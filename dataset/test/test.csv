bugid	patch	buggy	id	buglineNo	removeNo	filepath
0	if  (dataset  ==  null)  {  	[BUGGY]  if  (  dataset  !  =  null  )  {  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  ( "S1 "  ,  lic  .  get  (  0  )  .  getLabel  (  )  )  ;  [METHOD]  getLegendItems  [TYPE]  LegendItemCollection  [PARAMETER]  [CLASS]  AbstractCategoryItemRenderer  [TYPE]  LegendItemCollection  result  [TYPE]  CategoryURLGenerator  baseURLGenerator  [TYPE]  CategoryItemLabelGenerator  baseItemLabelGenerator  [TYPE]  long  serialVersionUID  [TYPE]  CategoryPlot  plot  [TYPE]  int  columnCount  i  index  rowCount  seriesCount  [TYPE]  boolean  false  true  [TYPE]  LegendItem  item  [TYPE]  CategorySeriesLabelGenerator  legendItemLabelGenerator  legendItemToolTipGenerator  legendItemURLGenerator  [TYPE]  CategoryToolTipGenerator  baseToolTipGenerator  [TYPE]  CategoryDataset  dataset  [TYPE]  ObjectList  itemLabelGeneratorList  toolTipGeneratorList  urlGeneratorList  [TYPE]  List  backgroundAnnotations  foregroundAnnotations  [CONTEXT]  public  LegendItemCollection  getLegendItems  (  )  {  LegendItemCollection  result  =  new  LegendItemCollection  (  )  ;  if  (  this  .  plot  =  =  null  )  {  return  result  ;  }  int  index  =  this  .  plot  .  getIndexOf  (  this  )  ;  CategoryDataset  dataset  =  this  .  plot  .  getDataset  (  index  )  ;  [BUGGY]  if  (  dataset  !  =  null  )  {  return  result  ;  }  int  seriesCount  =  dataset  .  getRowCount  (  )  ;  if  (  plot  .  getRowRenderingOrder  (  )  .  equals  (  SortOrder  .  ASCENDING  )  )  {  for  (  int  i  =  0  ;  i  <  seriesCount  ;  i++  )  {  	Chart_1_AbstractCategoryItemRenderer_1_1	1797	1	source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java
1	double  value  =  intervalXYData.getXValue(series,  item);  if  (!Double.isNaN(value))  {  minimum  =  Math.min(minimum,  value);  maximum  =  Math.max(maximum,  value);  }  maximum  =  Math.max(maximum,  lvalue);  minimum  =  Math.min(minimum,  uvalue);  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  1  .  5  ,  r  .  getUpperBound  (  )  ,  EPSILON  )  ;  [METHOD]  iterateDomainBounds  [TYPE]  Range  [PARAMETER]  XYDataset  dataset  boolean  includeInterval  [CLASS]  DatasetUtilities  [TYPE]  boolean  false  includeInterval  true  [TYPE]  double  lvalue  maximum  minimum  uvalue  [TYPE]  IntervalXYDataset  intervalXYData  [TYPE]  XYDataset  dataset  [TYPE]  int  item  itemCount  series  seriesCount  [CONTEXT]  public  static  Range  iterateDomainBounds  (  XYDataset  dataset  ,  boolean  includeInterval  )  {  if  (  dataset  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'dataset'  argument  . "  )  ;  }  double  minimum  =  Double  .  POSITIVE_INFINITY  ;  double  maximum  =  Double  .  NEGATIVE_INFINITY  ;  int  seriesCount  =  dataset  .  getSeriesCount  (  )  ;  double  lvalue  ;  double  uvalue  ;  if  (  includeInterval  &&  dataset  instanceof  IntervalXYDataset  )  {  IntervalXYDataset  intervalXYData  =  (  IntervalXYDataset  )  dataset  ;  for  (  int  series  =  0  ;  series  <  seriesCount  ;  series++  )  {  int  itemCount  =  dataset  .  getItemCount  (  series  )  ;  for  (  int  item  =  0  ;  item  <  itemCount  ;  item++  )  {  [BUGGY]  lvalue  =  intervalXYData  .  getStartXValue  (  series  ,  item  )  ;  uvalue  =  intervalXYData  .  getEndXValue  (  series  ,  item  )  ;  if  (  !Double  .  isNaN  (  lvalue  )  )  {  minimum  =  Math  .  min  (  minimum  ,  lvalue  )  ;  }  if  (  !Double  .  isNaN  (  uvalue  )  )  {  	Chart_2_DatasetUtilities_2_1	755	0	source/org/jfree/data/general/DatasetUtilities.java
2	double  value  =  ixyd.getYValue(series,  item);  if  (!Double.isNaN(value))  {  minimum  =  Math.min(minimum,  value);  maximum  =  Math.max(maximum,  value);  }  maximum  =  Math.max(maximum,  lvalue);  minimum  =  Math.min(minimum,  uvalue);  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  1  .  5  ,  r  .  getUpperBound  (  )  ,  EPSILON  )  ;  [METHOD]  iterateRangeBounds  [TYPE]  Range  [PARAMETER]  XYDataset  dataset  boolean  includeInterval  [CLASS]  DatasetUtilities  [TYPE]  OHLCDataset  ohlc  [TYPE]  boolean  false  includeInterval  true  [TYPE]  double  lvalue  maximum  minimum  uvalue  value  [TYPE]  IntervalXYDataset  ixyd  [TYPE]  XYDataset  dataset  [TYPE]  int  item  itemCount  series  seriesCount  [CONTEXT]  public  static  Range  iterateRangeBounds  (  XYDataset  dataset  ,  boolean  includeInterval  )  {  double  minimum  =  Double  .  POSITIVE_INFINITY  ;  double  maximum  =  Double  .  NEGATIVE_INFINITY  ;  int  seriesCount  =  dataset  .  getSeriesCount  (  )  ;  if  (  includeInterval  &&  dataset  instanceof  IntervalXYDataset  )  {  IntervalXYDataset  ixyd  =  (  IntervalXYDataset  )  dataset  ;  for  (  int  series  =  0  ;  series  <  seriesCount  ;  series++  )  {  int  itemCount  =  dataset  .  getItemCount  (  series  )  ;  for  (  int  item  =  0  ;  item  <  itemCount  ;  item++  )  {  [BUGGY]  double  lvalue  =  ixyd  .  getStartYValue  (  series  ,  item  )  ;  double  uvalue  =  ixyd  .  getEndYValue  (  series  ,  item  )  ;  if  (  !Double  .  isNaN  (  lvalue  )  )  {  minimum  =  Math  .  min  (  minimum  ,  lvalue  )  ;  }  if  (  !Double  .  isNaN  (  uvalue  )  )  {  	Chart_2_DatasetUtilities_2_2	1242	0	source/org/jfree/data/general/DatasetUtilities.java
3	copy.minY  =  Double.NaN;  copy.maxY  =  Double.NaN;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1010>  but  was:<1020>  assertEquals  (  102  .  0  ,  s3  .  getMaxY  (  )  ,  EPSILON  )  ;  [METHOD]  createCopy  [TYPE]  TimeSeries  [PARAMETER]  int  start  int  end  [CLASS]  TimeSeries  [TYPE]  TimeSeries  copy  [TYPE]  boolean  false  true  [TYPE]  double  maxY  minY  [TYPE]  TimeSeriesDataItem  clone  item  [TYPE]  Class  timePeriodClass  [TYPE]  List  data  [TYPE]  String  DEFAULT_DOMAIN_DESCRIPTION  DEFAULT_RANGE_DESCRIPTION  domain  range  [TYPE]  SeriesException  e  [TYPE]  long  maximumItemAge  serialVersionUID  [TYPE]  int  end  index  maximumItemCount  start  [CONTEXT]  public  TimeSeries  createCopy  (  int  start  ,  int  end  )  throws  CloneNotSupportedException  {  if  (  start  <  0  )  {  throw  new  IllegalArgumentException  ( "Requires  start  >  =  0  . "  )  ;  }  if  (  end  <  start  )  {  throw  new  IllegalArgumentException  ( "Requires  start  <  =  end  . "  )  ;  }  TimeSeries  copy  =  (  TimeSeries  )  super  .  clone  (  )  ;  [BUGGY]  copy  .  data  =  new  java  .  util  .  ArrayList  (  )  ;  if  (  this  .  data  .  size  (  )  >  0  )  {  for  (  int  index  =  start  ;  index  <  =  end  ;  index++  )  {  TimeSeriesDataItem  item  =  (  TimeSeriesDataItem  )  this  .  data  .  get  (  index  )  ;  TimeSeriesDataItem  clone  =  (  TimeSeriesDataItem  )  item  .  clone  (  )  ;  try  {  copy  .  add  (  clone  )  ;  }  catch  (  SeriesException  e  )  {  e  .  printStackTrace  (  )  ;  }  }  }  return  copy  ;  }  	Chart_3_TimeSeries_1_1	1057	0	source/org/jfree/data/time/TimeSeries.java
4	if  (r  !=  null)  {  	[BUGGY]  Collection c = r.getAnnotations();  [FE]  NullPointerException  assertEquals  (  3  .  1694019256486126  ,  axis  .  getUpperBound  (  )  ,  EPSILON  )  ;  [METHOD]  getDataRange  [TYPE]  Range  [PARAMETER]  ValueAxis  axis  [CLASS]  XYPlot  [TYPE]  PlotOrientation  orientation  [TYPE]  long  serialVersionUID  [TYPE]  Paint[]  quadrantPaint  [TYPE]  Point2D  quadrantOrigin  [TYPE]  ValueAxis  axis  [TYPE]  Iterator  i  it  iterator  [TYPE]  List  annotations  includedAnnotations  mappedDatasets  [TYPE]  AxisSpace  fixedDomainAxisSpace  fixedRangeAxisSpace  [TYPE]  XYItemRenderer  r  [TYPE]  Stroke  DEFAULT_CROSSHAIR_STROKE  DEFAULT_GRIDLINE_STROKE  domainCrosshairStroke  domainGridlineStroke  domainMinorGridlineStroke  domainZeroBaselineStroke  rangeCrosshairStroke  rangeGridlineStroke  rangeMinorGridlineStroke  rangeZeroBaselineStroke  [TYPE]  XYAnnotation  a  annotation  [TYPE]  double  domainCrosshairValue  rangeCrosshairValue  [TYPE]  LegendItemCollection  fixedLegendItems  [TYPE]  XYAnnotationBoundsInfo  xyabi  [TYPE]  Paint  DEFAULT_CROSSHAIR_PAINT  DEFAULT_GRIDLINE_PAINT  domainCrosshairPaint  domainGridlinePaint  domainMinorGridlinePaint  domainTickBandPaint  domainZeroBaselinePaint  rangeCrosshairPaint  rangeGridlinePaint  rangeMinorGridlinePaint  rangeTickBandPaint  rangeZeroBaselinePaint  [TYPE]  Range  result  [TYPE]  int  domainIndex  rangeIndex  weight  [TYPE]  DatasetRenderingOrder  datasetRenderingOrder  [TYPE]  boolean  DEFAULT_CROSSHAIR_VISIBLE  domainCrosshairLockedOnData  domainCrosshairVisible  domainGridlinesVisible  domainMinorGridlinesVisible  domainPannable  domainZeroBaselineVisible  false  isDomainAxis  rangeCrosshairLockedOnData  rangeCrosshairVisible  rangeGridlinesVisible  rangeMinorGridlinesVisible  rangePannable  rangeZeroBaselineVisible  true  [TYPE]  RectangleInsets  axisOffset  [TYPE]  ObjectList  datasets  domainAxes  domainAxisLocations  rangeAxes  rangeAxisLocations  renderers  [TYPE]  Collection  c  [TYPE]  ResourceBundle  localizationResources  [TYPE]  XYDataset  d  [TYPE]  SeriesRenderingOrder  seriesRenderingOrder  [TYPE]  Map  backgroundDomainMarkers  backgroundRangeMarkers  datasetToDomainAxesMap  datasetToRangeAxesMap  foregroundDomainMarkers  foregroundRangeMarkers  [CONTEXT]  Iterator  iterator  =  mappedDatasets  .  iterator  (  )  ;  while  (  iterator  .  hasNext  (  )  )  {  XYDataset  d  =  (  XYDataset  )  iterator  .  next  (  )  ;  if  (  d  !  =  null  )  {  XYItemRenderer  r  =  getRendererForDataset  (  d  )  ;  if  (  isDomainAxis  )  {  if  (  r  !  =  null  )  {  result  =  Range  .  combine  (  result  ,  r  .  findDomainBounds  (  d  )  )  ;  }  else  {  result  =  Range  .  combine  (  result  ,  DatasetUtilities  .  findDomainBounds  (  d  )  )  ;  }  }  else  {  if  (  r  !  =  null  )  {  result  =  Range  .  combine  (  result  ,  r  .  findRangeBounds  (  d  )  )  ;  }  else  {  result  =  Range  .  combine  (  result  ,  DatasetUtilities  .  findRangeBounds  (  d  )  )  ;  }  }  [BUGGY]  Collection  c  =  r  .  getAnnotations  (  )  ;  Iterator  i  =  c  .  iterator  (  )  ;  while  (  i  .  hasNext  (  )  )  {  XYAnnotation  a  =  (  XYAnnotation  )  i  .  next  (  )  ;  if  (  a  instanceof  XYAnnotationBoundsInfo  )  {  includedAnnotations  .  add  (  a  )  ;  	Chart_4_XYPlot_1_1	4493	0	source/org/jfree/chart/plot/XYPlot.java
6	if  (this.allowDuplicateXValues)  {  add(x,  y);  return  null;  }  	[BUGGY]  [FE]  IndexOutOfBoundsException:  Index:  -1  ,  Size:  1  assertEquals  (  2  ,  series  .  getItemCount  (  )  )  ;  [METHOD]  addOrUpdate  [TYPE]  XYDataItem  [PARAMETER]  Number  x  Number  y  [CLASS]  XYSeries  [TYPE]  boolean  allowDuplicateXValues  autoSort  false  true  [TYPE]  Number  x  y  [TYPE]  List  data  [TYPE]  long  serialVersionUID  [TYPE]  int  index  maximumItemCount  [TYPE]  XYDataItem  existing  overwritten  [TYPE]  CloneNotSupportedException  e  [CONTEXT]  public  XYDataItem  addOrUpdate  (  Number  x  ,  Number  y  )  {  if  (  x  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'x'  argument  . "  )  ;  }  [BUGGY]  XYDataItem  overwritten  =  null  ;  int  index  =  indexOf  (  x  )  ;  if  (  index  >  =  0  &&  !this  .  allowDuplicateXValues  )  {  XYDataItem  existing  =  (  XYDataItem  )  this  .  data  .  get  (  index  )  ;  	Chart_5_XYSeries_2_1	544	0	source/org/jfree/data/xy/XYSeries.java
7	if  (index  >=  0)  {  	[BUGGY]  if  (  index  >  =  0  &&  !this  .  allowDuplicateXValues  )  {  [FE]  IndexOutOfBoundsException:  Index:  -1  ,  Size:  1  assertEquals  (  2  ,  series  .  getItemCount  (  )  )  ;  [METHOD]  addOrUpdate  [TYPE]  XYDataItem  [PARAMETER]  Number  x  Number  y  [CLASS]  XYSeries  [TYPE]  boolean  allowDuplicateXValues  autoSort  false  true  [TYPE]  Number  x  y  [TYPE]  List  data  [TYPE]  long  serialVersionUID  [TYPE]  int  index  maximumItemCount  [TYPE]  XYDataItem  existing  overwritten  [TYPE]  CloneNotSupportedException  e  [CONTEXT]  public  XYDataItem  addOrUpdate  (  Number  x  ,  Number  y  )  {  if  (  x  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'x'  argument  . "  )  ;  }  XYDataItem  overwritten  =  null  ;  int  index  =  indexOf  (  x  )  ;  [BUGGY]  if  (  index  >  =  0  &&  !this  .  allowDuplicateXValues  )  {  XYDataItem  existing  =  (  XYDataItem  )  this  .  data  .  get  (  index  )  ;  try  {  overwritten  =  (  XYDataItem  )  existing  .  clone  (  )  ;  }  catch  (  CloneNotSupportedException  e  )  {  	Chart_5_XYSeries_2_2	548	1	source/org/jfree/data/xy/XYSeries.java
8	ShapeList  that  =  (ShapeList)  obj;  int  listSize  =  size();  for  (int  i  =  0;  i  <  listSize;  i++)  {  if  (!ShapeUtilities.equal((Shape)  get(i),  (Shape)  that.get(i)))  {  return  false;  }  }  return  true;  	[BUGGY]  return  super  .  equals  (  obj  )  ;  [FE]  AssertionFailedError:  expected:<orgjfreechartutilShapeList@cef18a3f>  but  was:<orgjfreechartutilShapeList@e657ea8d>  assertEquals  (  l1  ,  l2  )  ;  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  ShapeList  [TYPE]  boolean  false  true  [TYPE]  Object  obj  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  obj  =  =  this  )  {  return  true  ;  }  if  (  !  (  obj  instanceof  ShapeList  )  )  {  return  false  ;  }  [BUGGY]  return  super  .  equals  (  obj  )  ;  }  	Chart_6_ShapeList_1_1	111	1	source/org/jfree/chart/util/ShapeList.java
9	long  s  =  getDataItem(this.maxMiddleIndex).getPeriod().getStart() .  getTime  (  )  ;   	[BUGGY]  long  s  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getStart  (  )  .  getTime  (  )  ;  [FE]  AssertionFailedError:  expected:<1>  but  was:<3>  assertEquals  (  1  ,  s  .  getMaxMiddleIndex  (  )  )  ;  [METHOD]  updateBounds  [TYPE]  void  [PARAMETER]  TimePeriod  period  int  index  [CLASS]  TimePeriodValues  [TYPE]  List  data  [TYPE]  String  DEFAULT_DOMAIN_DESCRIPTION  DEFAULT_RANGE_DESCRIPTION  domain  range  [TYPE]  boolean  false  true  [TYPE]  long  e  end  maxEnd  maxMiddle  maxStart  middle  minEnd  minMiddle  minStart  s  serialVersionUID  start  [TYPE]  int  index  maxEndIndex  maxMiddleIndex  maxStartIndex  minEndIndex  minMiddleIndex  minStartIndex  [TYPE]  TimePeriod  period  [CONTEXT]  long  maxStart  =  getDataItem  (  this  .  maxStartIndex  )  .  getPeriod  (  )  .  getStart  (  )  .  getTime  (  )  ;  if  (  start  >  maxStart  )  {  this  .  maxStartIndex  =  index  ;  }  }  else  {  this  .  maxStartIndex  =  index  ;  }  if  (  this  .  minMiddleIndex  >  =  0  )  {  long  s  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getStart  (  )  .  getTime  (  )  ;  long  e  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getEnd  (  )  .  getTime  (  )  ;  long  minMiddle  =  s  +  (  e  -  s  )  /  2  ;  if  (  middle  <  minMiddle  )  {  this  .  minMiddleIndex  =  index  ;  }  }  else  {  this  .  minMiddleIndex  =  index  ;  }  if  (  this  .  maxMiddleIndex  >  =  0  )  {  [BUGGY]  long  s  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getStart  (  )  .  getTime  (  )  ;  long  e  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getEnd  (  )  .  getTime  (  )  ;  long  maxMiddle  =  s  +  (  e  -  s  )  /  2  ;  if  (  middle  >  maxMiddle  )  {  	Chart_7_TimePeriodValues_2_1	300	2	source/org/jfree/data/time/TimePeriodValues.java
5	 long  e  =  getDataItem(this.maxMiddleIndex).getPeriod().getEnd() .getTime();  	[BUGGY]   long  e  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getEnd  (  ) .getTime(); [FE]  AssertionFailedError:  expected:<1>  but  was:<3>  assertEquals  (  1  ,  s  .  getMaxMiddleIndex  (  )  )  ;  [METHOD]  updateBounds  [TYPE]  void  [PARAMETER]  TimePeriod  period  int  index  [CLASS]  TimePeriodValues  [TYPE]  List  data  [TYPE]  String  DEFAULT_DOMAIN_DESCRIPTION  DEFAULT_RANGE_DESCRIPTION  domain  range  [TYPE]  boolean  false  true  [TYPE]  long  e  end  maxEnd  maxMiddle  maxStart  middle  minEnd  minMiddle  minStart  s  serialVersionUID  start  [TYPE]  int  index  maxEndIndex  maxMiddleIndex  maxStartIndex  minEndIndex  minMiddleIndex  minStartIndex  [TYPE]  TimePeriod  period  [CONTEXT]  long  maxStart  =  getDataItem  (  this  .  maxStartIndex  )  .  getPeriod  (  )  .  getStart  (  )  .  getTime  (  )  ;  if  (  start  >  maxStart  )  {  this  .  maxStartIndex  =  index  ;  }  }  else  {  this  .  maxStartIndex  =  index  ;  }  if  (  this  .  minMiddleIndex  >  =  0  )  {  long  s  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getStart  (  )  .  getTime  (  )  ;  long  e  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getEnd  (  )  .  getTime  (  )  ;  long  minMiddle  =  s  +  (  e  -  s  )  /  2  ;  if  (  middle  <  minMiddle  )  {  this  .  minMiddleIndex  =  index  ;  }  }  else  {  this  .  minMiddleIndex  =  index  ;  }  if  (  this  .  maxMiddleIndex  >  =  0  )  {  [BUGGY]  long  s  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getStart  (  )  .  getTime  (  )  ;  long  e  =  getDataItem  (  this  .  minMiddleIndex  )  .  getPeriod  (  )  .  getEnd  (  )  .  getTime  (  )  ;  long  maxMiddle  =  s  +  (  e  -  s  )  /  2  ;  if  (  middle  >  maxMiddle  )  {  	Chart_7_TimePeriodValues_2_2	302	2	source/org/jfree/data/time/TimePeriodValues.java
10	this(time,  zone,  Locale.getDefault());  	[BUGGY] this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; [FE] AssertionFailedError: expected:<35> but was:<34> assertEquals ( 34 , w . getWeek ( ) ) ; [CONTEXT]     public Week ( Date time , TimeZone zone ) { [BUGGY] this ( time , RegularTimePeriod . DEFAULT_TIME_ZONE , Locale . getDefault ( ) ) ; }  	Chart_8_Week_1_1	175	1	source/org/jfree/data/time/Week.java
11	if  ((endIndex  <  0)  ||  (endIndex  <  startIndex))  {  	[BUGGY]  if  (  endIndex  <  0  )  {  [FE]  IllegalArgumentException:  Requires  start  <  =  end  assertTrue  (  pass  )  ;  [METHOD]  createCopy  [TYPE]  TimeSeries  [PARAMETER]  RegularTimePeriod  start  RegularTimePeriod  end  [CLASS]  TimeSeries  [TYPE]  boolean  emptyRange  false  true  [TYPE]  TimeSeries  copy  [TYPE]  Class  timePeriodClass  [TYPE]  List  data  [TYPE]  String  DEFAULT_DOMAIN_DESCRIPTION  DEFAULT_RANGE_DESCRIPTION  domain  range  [TYPE]  RegularTimePeriod  end  start  [TYPE]  long  maximumItemAge  serialVersionUID  [TYPE]  int  endIndex  maximumItemCount  startIndex  [CONTEXT]  throws  CloneNotSupportedException  {  if  (  start  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'start'  argument  . "  )  ;  }  if  (  end  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'end'  argument  . "  )  ;  }  if  (  start  .  compareTo  (  end  )  >  0  )  {  throw  new  IllegalArgumentException  ( "Requires  start  on  or  before  end  . "  )  ;  }  boolean  emptyRange  =  false  ;  int  startIndex  =  getIndex  (  start  )  ;  if  (  startIndex  <  0  )  {  startIndex  =  -  (  startIndex  +  1  )  ;  if  (  startIndex  ==  this  .  data  .  size  (  )  )  {  emptyRange  =  true  ;    }  }  int  endIndex  =  getIndex  (  end  )  ;  if  (  endIndex  <  0  )  {    endIndex  =  -  (  endIndex  +  1  )  ;   endIndex  =  endIndex  -  1  ;   }  [BUGGY]  if  (  endIndex  <  0  )  {  emptyRange  =  true  ;  }  if  (  emptyRange  )  {  TimeSeries  copy  =  (  TimeSeries  )  super  .  clone  (  )  ;  copy  .  data  =  new  java  .  util  .  ArrayList  (  )  ;  	Chart_9_TimeSeries_1_1	944	1	source/org/jfree/data/time/TimeSeries.java
12	return "  title=\\ " "  +  ImageMapUtilities.htmlEscape(toolTipText)  	[BUGGY]  return "  title  =  \\ " "  +  toolTipText  [FE]  ComparisonFailure:  expected:<  title  = "Series  [&quot  ;  A&quot  ;  ]  ,  1000 "  alt  = " ">  but  was:<  title  = "Series  [ "A "]  ,  1000 "  alt  = " ">  assertEquals  ( "  title  =  \ "Series  &quot  ;  A&quot  ;  ,  100  .  0\ "  alt  =  \ "\ " "  ,  [METHOD]  generateToolTipFragment  [TYPE]  String  [PARAMETER]  String  toolTipText  [CLASS]  StandardToolTipTagFragmentGenerator  [TYPE]  boolean  false  true  [TYPE]  String  toolTipText  [CONTEXT]  public  String  generateToolTipFragment  (  String  toolTipText  )  {  [BUGGY]  return "  title  =  \ " "  +  toolTipText  + "\ "  alt  =  \ "\ " "  ;  }  	Chart_10_StandardToolTipTagFragmentGenerator_1_1	65	1	source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java
13	PathIterator  iterator2  =  p2.getPathIterator(null);  	[BUGGY]  PathIterator  iterator2  =  p1  .  getPathIterator  (  null  )  ;  [FE]  AssertionFailedError  assertFalse  (  ShapeUtilities  .  equal  (  g1  ,  g2  )  )  ;  [METHOD]  equal  [TYPE]  boolean  [PARAMETER]  GeneralPath  p1  GeneralPath  p2  [CLASS]  ShapeUtilities  [TYPE]  boolean  done  false  true  [TYPE]  float  SQRT2  [TYPE]  GeneralPath  p1  p2  [TYPE]  double[]  d1  d2  [TYPE]  PathIterator  iterator1  iterator2  [TYPE]  int  seg1  seg2  [CONTEXT]  public  static  boolean  equal  (  GeneralPath  p1  ,  GeneralPath  p2  )  {  if  (  p1  =  =  null  )  {  return  (  p2  =  =  null  )  ;  }  if  (  p2  =  =  null  )  {  return  false  ;  }  if  (  p1  .  getWindingRule  (  )  !  =  p2  .  getWindingRule  (  )  )  {  return  false  ;  }  PathIterator  iterator1  =  p1  .  getPathIterator  (  null  )  ;  [BUGGY]  PathIterator  iterator2  =  p1  .  getPathIterator  (  null  )  ;  double[]  d1  =  new  double[6]  ;  double[]  d2  =  new  double[6]  ;  boolean  done  =  iterator1  .  isDone  (  )  &&  iterator2  .  isDone  (  )  ;  while  (  !done  )  {  if  (  iterator1  .  isDone  (  )  !  =  iterator2  .  isDone  (  )  )  {  	Chart_11_ShapeUtilities_1_1	275	1	source/org/jfree/chart/util/ShapeUtilities.java
14	setDataset(dataset);  	[BUGGY]  this  .  dataset  =  dataset  ;  [FE]  AssertionFailedError  assertTrue  (  dataset  .  hasListener  (  plot  )  )  ;  [CLASS]  [CONTEXT]  	Chart_12_MultiplePiePlot_1_1	145	1	source/org/jfree/chart/plot/MultiplePiePlot.java
15	new  Range(0.0,  Math.max(constraint.getWidth()  -  w[2],  0.0)),  	[BUGGY]  new  Range  (  0  .  0  ,  constraint  .  getWidth  (  )  -  w[2]  )  ,  [FE]  IllegalArgumentException:  Range  (  double  ,  double  )  :  require  lower  (  00  )  <  =  upper  (  -23000000000000007  )  assertEquals  (  0  .  0  ,  size  .  height  ,  EPSILON  )  ;  [METHOD]  arrangeFF  [TYPE]  Size2D  [PARAMETER]  BlockContainer  container  Graphics2D  g2  RectangleConstraint  constraint  [CLASS]  BorderArrangement  [TYPE]  Size2D  size  [TYPE]  boolean  false  true  [TYPE]  double[]  h  w  [TYPE]  BlockContainer  container  [TYPE]  Block  bottomBlock  centerBlock  leftBlock  rightBlock  topBlock  [TYPE]  RectangleConstraint  c1  c2  c3  c4  c5  constraint  [TYPE]  long  serialVersionUID  [TYPE]  Graphics2D  g2  [CONTEXT]  new  Range  (  0  .  0  ,  constraint  .  getHeight  (  )  )  ,  LengthConstraintType  .  RANGE  )  ;  Size2D  size  =  this  .  topBlock  .  arrange  (  g2  ,  c1  )  ;  h[0]  =  size  .  height  ;  }  w[1]  =  w[0]  ;  if  (  this  .  bottomBlock  !  =  null  )  {  RectangleConstraint  c2  =  new  RectangleConstraint  (  w[0]  ,  null  ,  LengthConstraintType  .  FIXED  ,  0  .  0  ,  new  Range  (  0  .  0  ,  constraint  .  getHeight  (  )  -  h[0]  )  ,  LengthConstraintType  .  RANGE  )  ;  Size2D  size  =  this  .  bottomBlock  .  arrange  (  g2  ,  c2  )  ;  h[1]  =  size  .  height  ;  }  h[2]  =  constraint  .  getHeight  (  )  -  h[1]  -  h[0]  ;  if  (  this  .  leftBlock  !  =  null  )  {  RectangleConstraint  c3  =  new  RectangleConstraint  (  0  .  0  ,  new  Range  (  0  .  0  ,  constraint  .  getWidth  (  )  )  ,  LengthConstraintType  .  RANGE  ,  h[2]  ,  null  ,  LengthConstraintType  .  FIXED  )  ;  Size2D  size  =  this  .  leftBlock  .  arrange  (  g2  ,  c3  )  ;  w[2]  =  size  .  width  ;  }  h[3]  =  h[2]  ;  if  (  this  .  rightBlock  !  =  null  )  {  RectangleConstraint  c4  =  new  RectangleConstraint  (  0  .  0  ,  [BUGGY]  new  Range  (  0  .  0  ,  constraint  .  getWidth  (  )  -  w[2]  )  ,  LengthConstraintType  .  RANGE  ,  h[2]  ,  null  ,  LengthConstraintType  .  FIXED  )  ;  Size2D  size  =  this  .  rightBlock  .  arrange  (  g2  ,  c4  )  ;  w[3]  =  size  .  width  ;  }  	Chart_13_BorderArrangement_1_1	455	1	source/org/jfree/chart/block/BorderArrangement.java
16	if  (markers  ==  null)  {  return  false;  }  	[BUGGY]  [FE]  NullPointerException  assertFalse  (  plot  .  removeRangeMarker  (  new  ValueMarker  (  0  .  5  )  )  )  ;  [METHOD]  removeDomainMarker  [TYPE]  boolean  [PARAMETER]  int  index  Marker  marker  Layer  layer  boolean  notify  [CLASS]  CategoryPlot  [TYPE]  Stroke  DEFAULT_CROSSHAIR_STROKE  DEFAULT_GRIDLINE_STROKE  domainGridlineStroke  rangeCrosshairStroke  rangeGridlineStroke  [TYPE]  PlotOrientation  orientation  [TYPE]  double  anchorValue  rangeCrosshairValue  [TYPE]  LegendItemCollection  fixedLegendItems  [TYPE]  ArrayList  markers  [TYPE]  SortOrder  columnRenderingOrder  rowRenderingOrder  [TYPE]  Paint  DEFAULT_CROSSHAIR_PAINT  DEFAULT_GRIDLINE_PAINT  domainGridlinePaint  rangeCrosshairPaint  rangeGridlinePaint  [TYPE]  Marker  marker  [TYPE]  Layer  layer  [TYPE]  long  serialVersionUID  [TYPE]  Font  DEFAULT_VALUE_LABEL_FONT  [TYPE]  int  index  weight  [TYPE]  DatasetRenderingOrder  renderingOrder  [TYPE]  CategoryAnchor  domainGridlinePosition  [TYPE]  boolean  DEFAULT_CROSSHAIR_VISIBLE  DEFAULT_DOMAIN_GRIDLINES_VISIBLE  DEFAULT_RANGE_GRIDLINES_VISIBLE  domainGridlinesVisible  drawSharedDomainAxis  false  notify  rangeCrosshairLockedOnData  rangeCrosshairVisible  rangeGridlinesVisible  removed  true  [TYPE]  RectangleInsets  axisOffset  [TYPE]  ObjectList  datasetToDomainAxisMap  datasetToRangeAxisMap  datasets  domainAxes  domainAxisLocations  rangeAxes  rangeAxisLocations  renderers  [TYPE]  ResourceBundle  localizationResources  [TYPE]  List  annotations  [TYPE]  AxisSpace  fixedDomainAxisSpace  fixedRangeAxisSpace  [TYPE]  Map  backgroundDomainMarkers  backgroundRangeMarkers  foregroundDomainMarkers  foregroundRangeMarkers  [CONTEXT]  public  boolean  removeDomainMarker  (  int  index  ,  Marker  marker  ,  Layer  layer  ,  boolean  notify  )  {  ArrayList  markers  ;  if  (  layer  =  =  Layer  .  FOREGROUND  )  {  markers  =  (  ArrayList  )  this  .  foregroundDomainMarkers  .  get  (  new  Integer  (  index  )  )  ;  }  else  {  markers  =  (  ArrayList  )  this  .  backgroundDomainMarkers  .  get  (  new  Integer  (  index  )  )  ;  }  [BUGGY]  boolean  removed  =  markers  .  remove  (  marker  )  ;  if  (  removed  &&  notify  )  {  fireChangeEvent  (  )  ;  }  return  removed  ;  }  	Chart_14_CategoryPlot_2_1	2166	0	source/org/jfree/chart/plot/CategoryPlot.java
17	if  (markers  ==  null)  {  return  false;  }  	[BUGGY]  [FE]  NullPointerException  assertFalse  (  plot  .  removeRangeMarker  (  new  ValueMarker  (  0  .  5  )  )  )  ;  [METHOD]  removeRangeMarker  [TYPE]  boolean  [PARAMETER]  int  index  Marker  marker  Layer  layer  boolean  notify  [CLASS]  CategoryPlot  [TYPE]  Stroke  DEFAULT_CROSSHAIR_STROKE  DEFAULT_GRIDLINE_STROKE  domainGridlineStroke  rangeCrosshairStroke  rangeGridlineStroke  [TYPE]  PlotOrientation  orientation  [TYPE]  double  anchorValue  rangeCrosshairValue  [TYPE]  LegendItemCollection  fixedLegendItems  [TYPE]  ArrayList  markers  [TYPE]  SortOrder  columnRenderingOrder  rowRenderingOrder  [TYPE]  Paint  DEFAULT_CROSSHAIR_PAINT  DEFAULT_GRIDLINE_PAINT  domainGridlinePaint  rangeCrosshairPaint  rangeGridlinePaint  [TYPE]  Marker  marker  [TYPE]  Layer  layer  [TYPE]  long  serialVersionUID  [TYPE]  Font  DEFAULT_VALUE_LABEL_FONT  [TYPE]  int  index  weight  [TYPE]  DatasetRenderingOrder  renderingOrder  [TYPE]  CategoryAnchor  domainGridlinePosition  [TYPE]  boolean  DEFAULT_CROSSHAIR_VISIBLE  DEFAULT_DOMAIN_GRIDLINES_VISIBLE  DEFAULT_RANGE_GRIDLINES_VISIBLE  domainGridlinesVisible  drawSharedDomainAxis  false  notify  rangeCrosshairLockedOnData  rangeCrosshairVisible  rangeGridlinesVisible  removed  true  [TYPE]  RectangleInsets  axisOffset  [TYPE]  ObjectList  datasetToDomainAxisMap  datasetToRangeAxisMap  datasets  domainAxes  domainAxisLocations  rangeAxes  rangeAxisLocations  renderers  [TYPE]  ResourceBundle  localizationResources  [TYPE]  List  annotations  [TYPE]  AxisSpace  fixedDomainAxisSpace  fixedRangeAxisSpace  [TYPE]  Map  backgroundDomainMarkers  backgroundRangeMarkers  foregroundDomainMarkers  foregroundRangeMarkers  [CONTEXT]  public  boolean  removeRangeMarker  (  int  index  ,  Marker  marker  ,  Layer  layer  ,  boolean  notify  )  {  if  (  marker  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'marker'  argument  . "  )  ;  }  ArrayList  markers  ;  if  (  layer  =  =  Layer  .  FOREGROUND  )  {  markers  =  (  ArrayList  )  this  .  foregroundRangeMarkers  .  get  (  new  Integer  (  index  )  )  ;  }  else  {  markers  =  (  ArrayList  )  this  .  backgroundRangeMarkers  .  get  (  new  Integer  (  index  )  )  ;  }  [BUGGY]  boolean  removed  =  markers  .  remove  (  marker  )  ;  if  (  removed  &&  notify  )  {  fireChangeEvent  (  )  ;  }  return  removed  ;  }  	Chart_14_CategoryPlot_2_2	2448	0	source/org/jfree/chart/plot/CategoryPlot.java
18	if  (markers  ==  null)  {  return  false;  }  	[BUGGY]  [FE]  NullPointerException  assertFalse  (  plot  .  removeRangeMarker  (  new  ValueMarker  (  0  .  5  )  )  )  ;  [METHOD]  removeDomainMarker  [TYPE]  boolean  [PARAMETER]  int  index  Marker  marker  Layer  layer  boolean  notify  [CLASS]  XYPlot  [TYPE]  Stroke  DEFAULT_CROSSHAIR_STROKE  DEFAULT_GRIDLINE_STROKE  domainCrosshairStroke  domainGridlineStroke  domainZeroBaselineStroke  rangeCrosshairStroke  rangeGridlineStroke  rangeZeroBaselineStroke  [TYPE]  PlotOrientation  orientation  [TYPE]  double  domainCrosshairValue  rangeCrosshairValue  [TYPE]  LegendItemCollection  fixedLegendItems  [TYPE]  ArrayList  markers  [TYPE]  Paint  DEFAULT_CROSSHAIR_PAINT  DEFAULT_GRIDLINE_PAINT  domainCrosshairPaint  domainGridlinePaint  domainTickBandPaint  domainZeroBaselinePaint  rangeCrosshairPaint  rangeGridlinePaint  rangeTickBandPaint  rangeZeroBaselinePaint  [TYPE]  Marker  marker  [TYPE]  Layer  layer  [TYPE]  long  serialVersionUID  [TYPE]  int  index  weight  [TYPE]  DatasetRenderingOrder  datasetRenderingOrder  [TYPE]  boolean  DEFAULT_CROSSHAIR_VISIBLE  domainCrosshairLockedOnData  domainCrosshairVisible  domainGridlinesVisible  domainZeroBaselineVisible  false  notify  rangeCrosshairLockedOnData  rangeCrosshairVisible  rangeGridlinesVisible  rangeZeroBaselineVisible  removed  true  [TYPE]  Paint[]  quadrantPaint  [TYPE]  Point2D  quadrantOrigin  [TYPE]  RectangleInsets  axisOffset  [TYPE]  ObjectList  datasets  domainAxes  domainAxisLocations  rangeAxes  rangeAxisLocations  renderers  [TYPE]  ResourceBundle  localizationResources  [TYPE]  List  annotations  [TYPE]  AxisSpace  fixedDomainAxisSpace  fixedRangeAxisSpace  [TYPE]  SeriesRenderingOrder  seriesRenderingOrder  [TYPE]  Map  backgroundDomainMarkers  backgroundRangeMarkers  datasetToDomainAxisMap  datasetToRangeAxisMap  foregroundDomainMarkers  foregroundRangeMarkers  [CONTEXT]  public  boolean  removeDomainMarker  (  int  index  ,  Marker  marker  ,  Layer  layer  ,  boolean  notify  )  {  ArrayList  markers  ;  if  (  layer  =  =  Layer  .  FOREGROUND  )  {  markers  =  (  ArrayList  )  this  .  foregroundDomainMarkers  .  get  (  new  Integer  (  index  )  )  ;  }  else  {  markers  =  (  ArrayList  )  this  .  backgroundDomainMarkers  .  get  (  new  Integer  (  index  )  )  ;  }  [BUGGY]  boolean  removed  =  markers  .  remove  (  marker  )  ;  if  (  removed  &&  notify  )  {  fireChangeEvent  (  )  ;  }  return  removed  ;  }  	Chart_14_XYPlot_2_1	2293	0	source/org/jfree/chart/plot/XYPlot.java
19	if  (markers  ==  null)  {  return  false;  }  	[BUGGY]  [FE]  NullPointerException  assertFalse  (  plot  .  removeRangeMarker  (  new  ValueMarker  (  0  .  5  )  )  )  ;  [METHOD]  removeRangeMarker  [TYPE]  boolean  [PARAMETER]  int  index  Marker  marker  Layer  layer  boolean  notify  [CLASS]  XYPlot  [TYPE]  Stroke  DEFAULT_CROSSHAIR_STROKE  DEFAULT_GRIDLINE_STROKE  domainCrosshairStroke  domainGridlineStroke  domainZeroBaselineStroke  rangeCrosshairStroke  rangeGridlineStroke  rangeZeroBaselineStroke  [TYPE]  PlotOrientation  orientation  [TYPE]  double  domainCrosshairValue  rangeCrosshairValue  [TYPE]  LegendItemCollection  fixedLegendItems  [TYPE]  ArrayList  markers  [TYPE]  Paint  DEFAULT_CROSSHAIR_PAINT  DEFAULT_GRIDLINE_PAINT  domainCrosshairPaint  domainGridlinePaint  domainTickBandPaint  domainZeroBaselinePaint  rangeCrosshairPaint  rangeGridlinePaint  rangeTickBandPaint  rangeZeroBaselinePaint  [TYPE]  Marker  marker  [TYPE]  Layer  layer  [TYPE]  long  serialVersionUID  [TYPE]  int  index  weight  [TYPE]  DatasetRenderingOrder  datasetRenderingOrder  [TYPE]  boolean  DEFAULT_CROSSHAIR_VISIBLE  domainCrosshairLockedOnData  domainCrosshairVisible  domainGridlinesVisible  domainZeroBaselineVisible  false  notify  rangeCrosshairLockedOnData  rangeCrosshairVisible  rangeGridlinesVisible  rangeZeroBaselineVisible  removed  true  [TYPE]  Paint[]  quadrantPaint  [TYPE]  Point2D  quadrantOrigin  [TYPE]  RectangleInsets  axisOffset  [TYPE]  ObjectList  datasets  domainAxes  domainAxisLocations  rangeAxes  rangeAxisLocations  renderers  [TYPE]  ResourceBundle  localizationResources  [TYPE]  List  annotations  [TYPE]  AxisSpace  fixedDomainAxisSpace  fixedRangeAxisSpace  [TYPE]  SeriesRenderingOrder  seriesRenderingOrder  [TYPE]  Map  backgroundDomainMarkers  backgroundRangeMarkers  datasetToDomainAxisMap  datasetToRangeAxisMap  foregroundDomainMarkers  foregroundRangeMarkers  [CONTEXT]  public  boolean  removeRangeMarker  (  int  index  ,  Marker  marker  ,  Layer  layer  ,  boolean  notify  )  {  if  (  marker  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'marker'  argument  . "  )  ;  }  ArrayList  markers  ;  if  (  layer  =  =  Layer  .  FOREGROUND  )  {  markers  =  (  ArrayList  )  this  .  foregroundRangeMarkers  .  get  (  new  Integer  (  index  )  )  ;  }  else  {  markers  =  (  ArrayList  )  this  .  backgroundRangeMarkers  .  get  (  new  Integer  (  index  )  )  ;  }  [BUGGY]  boolean  removed  =  markers  .  remove  (  marker  )  ;  if  (  removed  &&  notify  )  {  fireChangeEvent  (  )  ;  }  return  removed  ;  }  	Chart_14_XYPlot_2_2	2529	0	source/org/jfree/chart/plot/XYPlot.java
20	if  (this.dataset  ==  null)  {  return  0.0;  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  success  )  ;  [METHOD]  getMaximumExplodePercent  [TYPE]  double  [PARAMETER]  [CLASS]  PiePlot  [TYPE]  PieURLGenerator  legendLabelURLGenerator  urlGenerator  [TYPE]  Stroke  DEFAULT_LABEL_OUTLINE_STROKE  baseSectionOutlineStroke  labelLinkStroke  labelOutlineStroke  [TYPE]  Comparable  key  [TYPE]  PieSectionLabelGenerator  labelGenerator  legendLabelGenerator  legendLabelToolTipGenerator  [TYPE]  Shape  legendItemShape  [TYPE]  double  DEFAULT_INTERIOR_GAP  DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW  DEFAULT_START_ANGLE  MAX_INTERIOR_GAP  interiorGap  labelGap  labelLinkMargin  maximumLabelWidth  minimumArcAngleToDraw  result  shadowXOffset  shadowYOffset  startAngle  [TYPE]  AbstractPieLabelDistributor  labelDistributor  [TYPE]  Paint  DEFAULT_LABEL_BACKGROUND_PAINT  DEFAULT_LABEL_OUTLINE_PAINT  DEFAULT_LABEL_PAINT  DEFAULT_LABEL_SHADOW_PAINT  baseSectionOutlinePaint  baseSectionPaint  labelBackgroundPaint  labelLinkPaint  labelOutlinePaint  labelPaint  labelShadowPaint  shadowPaint  [TYPE]  Rotation  direction  [TYPE]  long  serialVersionUID  [TYPE]  Font  DEFAULT_LABEL_FONT  labelFont  [TYPE]  int  pieIndex  [TYPE]  boolean  DEBUG_DRAW_INTERIOR  DEBUG_DRAW_LINK_AREA  DEBUG_DRAW_PIE_AREA  circular  false  ignoreNullValues  ignoreZeroValues  labelLinksVisible  sectionOutlinesVisible  simpleLabels  true  [TYPE]  PieToolTipGenerator  toolTipGenerator  [TYPE]  Number  explode  [TYPE]  PieDataset  dataset  [TYPE]  PaintMap  sectionOutlinePaintMap  sectionPaintMap  [TYPE]  Iterator  iterator  [TYPE]  RectangleInsets  labelPadding  simpleLabelOffset  [TYPE]  ResourceBundle  localizationResources  [TYPE]  Map  explodePercentages  [TYPE]  StrokeMap  sectionOutlineStrokeMap  [CONTEXT]  public  double  getMaximumExplodePercent  (  )  {  [BUGGY]  double  result  =  0  .  0  ;  Iterator  iterator  =  this  .  dataset  .  getKeys  (  )  .  iterator  (  )  ;  while  (  iterator  .  hasNext  (  )  )  {  Comparable  key  =  (  Comparable  )  iterator  .  next  (  )  ;  Number  explode  =  (  Number  )  this  .  explodePercentages  .  get  (  key  )  ;  if  (  explode  !  =  null  )  {  result  =  Math  .  max  (  result  ,  explode  .  doubleValue  (  )  )  ;  }  }  return  result  ;  }  	Chart_15_PiePlot_2_1	1378	0	source/org/jfree/chart/plot/PiePlot.java
21	if  (this.dataset  !=  null)  {  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  success  )  ;  [METHOD]  initialise  [TYPE]  PiePlotState  [PARAMETER]  Graphics2D  g2  Rectangle2D  plotArea  PiePlot  plot  Integer  index  PlotRenderingInfo  info  [CLASS]  PiePlot  [TYPE]  PieSectionLabelGenerator  labelGenerator  legendLabelGenerator  legendLabelToolTipGenerator  [TYPE]  Shape  legendItemShape  [TYPE]  long  serialVersionUID  [TYPE]  Font  DEFAULT_LABEL_FONT  labelFont  [TYPE]  PiePlotState  state  [TYPE]  StrokeMap  sectionOutlineStrokeMap  [TYPE]  PieURLGenerator  legendLabelURLGenerator  urlGenerator  [TYPE]  Stroke  DEFAULT_LABEL_OUTLINE_STROKE  baseSectionOutlineStroke  labelLinkStroke  labelOutlineStroke  [TYPE]  PlotRenderingInfo  info  [TYPE]  double  DEFAULT_INTERIOR_GAP  DEFAULT_MINIMUM_ARC_ANGLE_TO_DRAW  DEFAULT_START_ANGLE  MAX_INTERIOR_GAP  interiorGap  labelGap  labelLinkMargin  maximumLabelWidth  minimumArcAngleToDraw  shadowXOffset  shadowYOffset  startAngle  [TYPE]  AbstractPieLabelDistributor  labelDistributor  [TYPE]  Rectangle2D  plotArea  [TYPE]  Paint  DEFAULT_LABEL_BACKGROUND_PAINT  DEFAULT_LABEL_OUTLINE_PAINT  DEFAULT_LABEL_PAINT  DEFAULT_LABEL_SHADOW_PAINT  baseSectionOutlinePaint  baseSectionPaint  labelBackgroundPaint  labelLinkPaint  labelOutlinePaint  labelPaint  labelShadowPaint  shadowPaint  [TYPE]  Rotation  direction  [TYPE]  int  pieIndex  [TYPE]  Graphics2D  g2  [TYPE]  Integer  index  [TYPE]  boolean  DEBUG_DRAW_INTERIOR  DEBUG_DRAW_LINK_AREA  DEBUG_DRAW_PIE_AREA  circular  false  ignoreNullValues  ignoreZeroValues  labelLinksVisible  sectionOutlinesVisible  simpleLabels  true  [TYPE]  PieToolTipGenerator  toolTipGenerator  [TYPE]  PieDataset  dataset  [TYPE]  PaintMap  sectionOutlinePaintMap  sectionPaintMap  [TYPE]  RectangleInsets  labelPadding  simpleLabelOffset  [TYPE]  PiePlot  plot  [TYPE]  ResourceBundle  localizationResources  [TYPE]  Map  explodePercentages  [CONTEXT]  public  PiePlotState  initialise  (  Graphics2D  g2  ,  Rectangle2D  plotArea  ,  PiePlot  plot  ,  Integer  index  ,  PlotRenderingInfo  info  )  {  PiePlotState  state  =  new  PiePlotState  (  info  )  ;  state  .  setPassesRequired  (  2  )  ;  [BUGGY]  state  .  setTotal  (  DatasetUtilities  .  calculatePieDatasetTotal  (  plot  .  getDataset  (  )  )  )  ;  state  .  setLatestAngle  (  plot  .  getStartAngle  (  )  )  ;  return  state  ;  }  	Chart_15_PiePlot_2_2	2051	0	source/org/jfree/chart/plot/PiePlot.java
22	this.seriesKeys  =  new  Comparable[0];  this.categoryKeys  =  new  Comparable[0];  	[BUGGY]  this  .  seriesKeys  =  null  ;  this  .  categoryKeys  =  null  ;  [FE]  NullPointerException  assertEquals  (  -1  ,  empty  .  getCategoryIndex  ( "ABC "  )  )  ;  [CLASS]  [CONTEXT]  	Chart_16_DefaultIntervalCategoryDataset_2_1	207	2	source/org/jfree/data/category/DefaultIntervalCategoryDataset.java
23	if  (categoryKeys.length  !=  getCategoryCount())  {  	[BUGGY]  if  (  categoryKeys  .  length  !  =  this  .  startData[0]  .  length  )  {  [FE]  NullPointerException  assertEquals  (  -1  ,  empty  .  getCategoryIndex  ( "ABC "  )  )  ;  [METHOD]  setCategoryKeys  [TYPE]  void  [PARAMETER]  Comparable[]  categoryKeys  [CLASS]  DefaultIntervalCategoryDataset  [TYPE]  Number[][]  endData  startData  [TYPE]  boolean  false  true  [TYPE]  int  i  [TYPE]  Comparable[]  categoryKeys  seriesKeys  [CONTEXT]  public  void  setCategoryKeys  (  Comparable[]  categoryKeys  )  {  if  (  categoryKeys  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'categoryKeys'  argument  . "  )  ;  }  [BUGGY]  if  (  categoryKeys  .  length  !  =  this  .  startData[0]  .  length  )  {  throw  new  IllegalArgumentException  ( "The  number  of  categories  does  not  match  the  data  . "  )  ;  }  for  (  int  i  =  0  ;  i  <  categoryKeys  .  length  ;  i++  )  {  if  (  categoryKeys[i]  =  =  null  )  {  throw  new  IllegalArgumentException  ( "DefaultIntervalCategoryDataset  .  setCategoryKeys  (  )  : "  + "null  category  not  permitted  . "  )  ;  }  }  this  .  categoryKeys  =  categoryKeys  ;  fireDatasetChanged  (  )  ;  }  	Chart_16_DefaultIntervalCategoryDataset_2_2	338	1	source/org/jfree/data/category/DefaultIntervalCategoryDataset.java
24	TimeSeries  clone  =  (TimeSeries)  super.clone();  clone.data  =  (List)  ObjectUtilities.deepClone(this.data);  	[BUGGY]  Object  clone  =  createCopy  (  0  ,  getItemCount  (  )  -  1  )  ;  [FE]  IllegalArgumentException:  Requires  start  <  =  end  assertFalse  (  s1  .  equals  (  s2  )  )  ;  [METHOD]  clone  [TYPE]  Object  [PARAMETER]  [CLASS]  TimeSeries  [TYPE]  boolean  false  true  [TYPE]  Class  timePeriodClass  [TYPE]  List  data  [TYPE]  Object  clone  [TYPE]  String  DEFAULT_DOMAIN_DESCRIPTION  DEFAULT_RANGE_DESCRIPTION  domain  range  [TYPE]  long  maximumItemAge  serialVersionUID  [TYPE]  int  maximumItemCount  [CONTEXT]  public  Object  clone  (  )  throws  CloneNotSupportedException  {  [BUGGY]  Object  clone  =  createCopy  (  0  ,  getItemCount  (  )  -  1  )  ;  return  clone  ;  }  	Chart_17_TimeSeries_1_1	857	1	source/org/jfree/data/time/TimeSeries.java
25		[BUGGY]  if  (  index  <  this  .  keys  .  size  (  )  )  {  }  [FE]  IndexOutOfBoundsException:  Index:  0  ,  Size:  0  assertEquals  (  3  .  0  ,  d  .  getValue  ( "R2 "  , "C2 "  )  .  doubleValue  (  )  ,  EPSILON  )  ;  [METHOD]  removeValue  [TYPE]  void  [PARAMETER]  int  index  [CLASS]  DefaultKeyedValues  [TYPE]  ArrayList  keys  values  [TYPE]  boolean  false  true  [TYPE]  HashMap  indexMap  [TYPE]  long  serialVersionUID  [TYPE]  int  index  [CONTEXT]  public  void  removeValue  (  int  index  )  {  this  .  keys  .  remove  (  index  )  ;  this  .  values  .  remove  (  index  )  ;  [BUGGY]  if  (  index  <  this  .  keys  .  size  (  )  )  {  rebuildIndex  (  )  ;  }  }  	Chart_18_DefaultKeyedValues_2_1	318	2	source/org/jfree/data/DefaultKeyedValues.java
26	throw  new  UnknownKeyException( "The  key  ( "  +  key  + ")  is  not  recognised. ");  	[BUGGY]  \t\t\treturn  ;  [FE]  IndexOutOfBoundsException:  Index:  0  ,  Size:  0  assertEquals  (  3  .  0  ,  d  .  getValue  ( "R2 "  , "C2 "  )  .  doubleValue  (  )  ,  EPSILON  )  ;  [METHOD]  removeValue  [TYPE]  void  [PARAMETER]  Comparable  key  [CLASS]  DefaultKeyedValues  [TYPE]  ArrayList  keys  values  [TYPE]  Comparable  key  [TYPE]  boolean  false  true  [TYPE]  HashMap  indexMap  [TYPE]  long  serialVersionUID  [TYPE]  int  index  [CONTEXT]  public  void  removeValue  (  Comparable  key  )  {  int  index  =  getIndex  (  key  )  ;  if  (  index  <  0  )  {  [BUGGY]  return  ;  }  removeValue  (  index  )  ;  }  	Chart_18_DefaultKeyedValues_2_2	335	1	source/org/jfree/data/DefaultKeyedValues.java
27	\tif  (columnKey  ==  null)  {  \t\tthrow  new  IllegalArgumentException( "Null  \'columnKey\'  argument. ");  \t}  \tif  (!this.columnKeys.contains(columnKey))  {  \t\tthrow  new  UnknownKeyException( "Unknown  key: "  +  columnKey);  \t}  	[BUGGY]  [FE]  IndexOutOfBoundsException:  Index:  0  ,  Size:  0  assertEquals  (  3  .  0  ,  d  .  getValue  ( "R2 "  , "C2 "  )  .  doubleValue  (  )  ,  EPSILON  )  ;  [METHOD]  removeColumn  [TYPE]  void  [PARAMETER]  Comparable  columnKey  [CLASS]  DefaultKeyedValues2D  [TYPE]  Iterator  iterator  [TYPE]  List  columnKeys  rowKeys  rows  [TYPE]  Comparable  columnKey  [TYPE]  boolean  false  sortRowKeys  true  [TYPE]  DefaultKeyedValues  rowData  [TYPE]  long  serialVersionUID  [CONTEXT]  public  void  removeColumn  (  Comparable  columnKey  )  {  [BUGGY]  Iterator  iterator  =  this  .  rows  .  iterator  (  )  ;  while  (  iterator  .  hasNext  (  )  )  {  DefaultKeyedValues  rowData  =  (  DefaultKeyedValues  )  iterator  .  next  (  )  ;  rowData  .  removeValue  (  columnKey  )  ;  }  this  .  columnKeys  .  remove  (  columnKey  )  ;  }  	Chart_18_DefaultKeyedValues2D_2_1	455	0	source/org/jfree/data/DefaultKeyedValues2D.java
28	int  index  =  rowData.getIndex(columnKey);  if  (index  >=  0)  {  }  	[BUGGY]  [FE]  IndexOutOfBoundsException:  Index:  0  ,  Size:  0  assertEquals  (  3  .  0  ,  d  .  getValue  ( "R2 "  , "C2 "  )  .  doubleValue  (  )  ,  EPSILON  )  ;  [METHOD]  removeColumn  [TYPE]  void  [PARAMETER]  Comparable  columnKey  [CLASS]  DefaultKeyedValues2D  [TYPE]  Iterator  iterator  [TYPE]  List  columnKeys  rowKeys  rows  [TYPE]  Comparable  columnKey  [TYPE]  boolean  false  sortRowKeys  true  [TYPE]  DefaultKeyedValues  rowData  [TYPE]  long  serialVersionUID  [CONTEXT]  public  void  removeColumn  (  Comparable  columnKey  )  {  Iterator  iterator  =  this  .  rows  .  iterator  (  )  ;  while  (  iterator  .  hasNext  (  )  )  {  DefaultKeyedValues  rowData  =  (  DefaultKeyedValues  )  iterator  .  next  (  )  ;  [BUGGY]  rowData  .  removeValue  (  columnKey  )  ;  }  this  .  columnKeys  .  remove  (  columnKey  )  ;  }  	Chart_18_DefaultKeyedValues2D_2_2	458	0	source/org/jfree/data/DefaultKeyedValues2D.java
29	if  (axis  ==  null)  {  throw  new  IllegalArgumentException( "Null  \'axis\'  argument. ");  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  pass  )  ;  [METHOD]  getDomainAxisIndex  [TYPE]  int  [PARAMETER]  CategoryAxis  axis  [CLASS]  CategoryPlot  [TYPE]  Stroke  DEFAULT_CROSSHAIR_STROKE  DEFAULT_GRIDLINE_STROKE  domainGridlineStroke  rangeCrosshairStroke  rangeGridlineStroke  [TYPE]  PlotOrientation  orientation  [TYPE]  double  anchorValue  rangeCrosshairValue  [TYPE]  LegendItemCollection  fixedLegendItems  [TYPE]  SortOrder  columnRenderingOrder  rowRenderingOrder  [TYPE]  Paint  DEFAULT_CROSSHAIR_PAINT  DEFAULT_GRIDLINE_PAINT  domainGridlinePaint  rangeCrosshairPaint  rangeGridlinePaint  [TYPE]  long  serialVersionUID  [TYPE]  Font  DEFAULT_VALUE_LABEL_FONT  [TYPE]  int  weight  [TYPE]  DatasetRenderingOrder  renderingOrder  [TYPE]  CategoryAnchor  domainGridlinePosition  [TYPE]  boolean  DEFAULT_CROSSHAIR_VISIBLE  DEFAULT_DOMAIN_GRIDLINES_VISIBLE  DEFAULT_RANGE_GRIDLINES_VISIBLE  domainGridlinesVisible  drawSharedDomainAxis  false  rangeCrosshairLockedOnData  rangeCrosshairVisible  rangeGridlinesVisible  true  [TYPE]  CategoryAxis  axis  [TYPE]  RectangleInsets  axisOffset  [TYPE]  ObjectList  datasetToDomainAxisMap  datasetToRangeAxisMap  datasets  domainAxes  domainAxisLocations  rangeAxes  rangeAxisLocations  renderers  [TYPE]  ResourceBundle  localizationResources  [TYPE]  List  annotations  [TYPE]  AxisSpace  fixedDomainAxisSpace  fixedRangeAxisSpace  [TYPE]  Map  backgroundDomainMarkers  backgroundRangeMarkers  foregroundDomainMarkers  foregroundRangeMarkers  [CONTEXT]  public  int  getDomainAxisIndex  (  CategoryAxis  axis  )  {  [BUGGY]  return  this  .  domainAxes  .  indexOf  (  axis  )  ;  }  	Chart_19_CategoryPlot_2_1	698	0	source/org/jfree/chart/plot/CategoryPlot.java
30	if  (axis  ==  null)  {  throw  new  IllegalArgumentException( "Null  \'axis\'  argument. ");  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  pass  )  ;  [METHOD]  getRangeAxisIndex  [TYPE]  int  [PARAMETER]  ValueAxis  axis  [CLASS]  CategoryPlot  [TYPE]  Stroke  DEFAULT_CROSSHAIR_STROKE  DEFAULT_GRIDLINE_STROKE  domainGridlineStroke  rangeCrosshairStroke  rangeGridlineStroke  [TYPE]  PlotOrientation  orientation  [TYPE]  double  anchorValue  rangeCrosshairValue  [TYPE]  LegendItemCollection  fixedLegendItems  [TYPE]  Plot  parent  [TYPE]  SortOrder  columnRenderingOrder  rowRenderingOrder  [TYPE]  Paint  DEFAULT_CROSSHAIR_PAINT  DEFAULT_GRIDLINE_PAINT  domainGridlinePaint  rangeCrosshairPaint  rangeGridlinePaint  [TYPE]  long  serialVersionUID  [TYPE]  Font  DEFAULT_VALUE_LABEL_FONT  [TYPE]  int  result  weight  [TYPE]  CategoryPlot  p  [TYPE]  DatasetRenderingOrder  renderingOrder  [TYPE]  CategoryAnchor  domainGridlinePosition  [TYPE]  boolean  DEFAULT_CROSSHAIR_VISIBLE  DEFAULT_DOMAIN_GRIDLINES_VISIBLE  DEFAULT_RANGE_GRIDLINES_VISIBLE  domainGridlinesVisible  drawSharedDomainAxis  false  rangeCrosshairLockedOnData  rangeCrosshairVisible  rangeGridlinesVisible  true  [TYPE]  ValueAxis  axis  [TYPE]  RectangleInsets  axisOffset  [TYPE]  ObjectList  datasetToDomainAxisMap  datasetToRangeAxisMap  datasets  domainAxes  domainAxisLocations  rangeAxes  rangeAxisLocations  renderers  [TYPE]  ResourceBundle  localizationResources  [TYPE]  List  annotations  [TYPE]  AxisSpace  fixedDomainAxisSpace  fixedRangeAxisSpace  [TYPE]  Map  backgroundDomainMarkers  backgroundRangeMarkers  foregroundDomainMarkers  foregroundRangeMarkers  [CONTEXT]  public  int  getRangeAxisIndex  (  ValueAxis  axis  )  {  [BUGGY]  int  result  =  this  .  rangeAxes  .  indexOf  (  axis  )  ;  if  (  result  <  0  )  {  //  try  the  parent  plot  Plot  parent  =  getParent  (  )  ;  if  (  parent  instanceof  CategoryPlot  )  {  CategoryPlot  p  =  (  CategoryPlot  )  parent  ;  result  =  p  .  getRangeAxisIndex  (  axis  )  ;  }  }  return  result  ;  }  	Chart_19_CategoryPlot_2_2	973	0	source/org/jfree/chart/plot/CategoryPlot.java
31	super(paint,  stroke,  outlinePaint,  outlineStroke,  alpha);  	[BUGGY] super ( paint , stroke , paint , stroke , alpha ) ; [FE] AssertionFailedError: expected:<javaawtColor[r = 0 , g = 0 , b = 255]> but was:<javaawtColor[r = 255 , g = 0 , b = 0]> assertEquals ( 0 . 5f , m . getAlpha ( ) , EPSILON ) ; [CONTEXT]     public ValueMarker ( double value , Paint paint , Stroke stroke , Paint outlinePaint , Stroke outlineStroke , float alpha ) { [BUGGY] super ( paint , stroke , paint , stroke , alpha ) ; this . value = value ; }  	Chart_20_ValueMarker_1_1	95	1	source/org/jfree/chart/plot/ValueMarker.java
32	else  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Range[85  ,  96]>  but  was:<Range[86  ,  96]>  assertEquals  (  new  Range  (  8  .  5  ,  9  .  6  )  ,  d1  .  getRangeBounds  (  true  )  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  BoxAndWhiskerItem  item  Comparable  rowKey  Comparable  columnKey  [CLASS]  DefaultBoxAndWhiskerCategoryDataset  [TYPE]  Comparable  columnKey  rowKey  [TYPE]  boolean  false  true  [TYPE]  double  maximumRangeValue  maxval  minimumRangeValue  minval  [TYPE]  Range  rangeBounds  [TYPE]  KeyedObjects2D  data  [TYPE]  int  c  maximumRangeValueColumn  maximumRangeValueRow  minimumRangeValueColumn  minimumRangeValueRow  r  [TYPE]  BoxAndWhiskerItem  item  [CONTEXT]  public  void  add  (  BoxAndWhiskerItem  item  ,  Comparable  rowKey  ,  Comparable  columnKey  )  {  this  .  data  .  addObject  (  item  ,  rowKey  ,  columnKey  )  ;  int  r  =  this  .  data  .  getRowIndex  (  rowKey  )  ;  int  c  =  this  .  data  .  getColumnIndex  (  columnKey  )  ;  if  (  (  this  .  maximumRangeValueRow  =  =  r  &&  this  .  maximumRangeValueColumn  =  =  c  )  ||  (  this  .  minimumRangeValueRow  =  =  r  &&  this  .  minimumRangeValueColumn  =  =  c  )  )  {  updateBounds  (  )  ;  }  [BUGGY]  double  minval  =  Double  .  NaN  ;  if  (  item  .  getMinOutlier  (  )  !  =  null  )  {  minval  =  item  .  getMinOutlier  (  )  .  doubleValue  (  )  ;  }  double  maxval  =  Double  .  NaN  ;  	Chart_21_DefaultBoxAndWhiskerCategoryDataset_3_1	157	0	source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java
33	}  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Range[85  ,  96]>  but  was:<Range[86  ,  96]>  assertEquals  (  new  Range  (  8  .  5  ,  9  .  6  )  ,  d1  .  getRangeBounds  (  true  )  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  BoxAndWhiskerItem  item  Comparable  rowKey  Comparable  columnKey  [CLASS]  DefaultBoxAndWhiskerCategoryDataset  [TYPE]  Comparable  columnKey  rowKey  [TYPE]  boolean  false  true  [TYPE]  double  maximumRangeValue  maxval  minimumRangeValue  minval  [TYPE]  Range  rangeBounds  [TYPE]  KeyedObjects2D  data  [TYPE]  int  c  maximumRangeValueColumn  maximumRangeValueRow  minimumRangeValueColumn  minimumRangeValueRow  r  [TYPE]  BoxAndWhiskerItem  item  [CONTEXT]  if  (  item  .  getMaxOutlier  (  )  !  =  null  )  {  maxval  =  item  .  getMaxOutlier  (  )  .  doubleValue  (  )  ;  }  if  (  Double  .  isNaN  (  this  .  maximumRangeValue  )  )  {  this  .  maximumRangeValue  =  maxval  ;  this  .  maximumRangeValueRow  =  r  ;  this  .  maximumRangeValueColumn  =  c  ;  }  else  if  (  maxval  >  this  .  maximumRangeValue  )  {  this  .  maximumRangeValue  =  maxval  ;  this  .  maximumRangeValueRow  =  r  ;  this  .  maximumRangeValueColumn  =  c  ;  }  if  (  Double  .  isNaN  (  this  .  minimumRangeValue  )  )  {  this  .  minimumRangeValue  =  minval  ;  this  .  minimumRangeValueRow  =  r  ;  this  .  minimumRangeValueColumn  =  c  ;  }  else  if  (  minval  <  this  .  minimumRangeValue  )  {  this  .  minimumRangeValue  =  minval  ;  this  .  minimumRangeValueRow  =  r  ;  this  .  minimumRangeValueColumn  =  c  ;  }  [BUGGY]  this  .  rangeBounds  =  new  Range  (  this  .  minimumRangeValue  ,  this  .  maximumRangeValue  )  ;  fireDatasetChanged  (  )  ;  }  	Chart_21_DefaultBoxAndWhiskerCategoryDataset_3_2	188	0	source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java
34	this.minimumRangeValueRow  =  -1;  this.minimumRangeValueColumn  =  -1;  this.maximumRangeValueRow  =  -1;  this.maximumRangeValueColumn  =  -1;  int  rowCount  =  getRowCount();  int  columnCount  =  getColumnCount();  for  (int  r  =  0;  r  <  rowCount;  r++)  {  for  (int  c  =  0;  c  <  columnCount;  c++)  {  BoxAndWhiskerItem  item  =  getItem(r,  c);  if  (item  !=  null)  {  Number  min  =  item.getMinOutlier();  if  (min  !=  null)  {  double  minv  =  min.doubleValue();  if  (!Double.isNaN(minv))  {  if  (minv  <  this.minimumRangeValue  ||  Double.isNaN(  this.minimumRangeValue))  {  this.minimumRangeValue  =  minv;  this.minimumRangeValueRow  =  r;  this.minimumRangeValueColumn  =  c;  }  }  }  Number  max  =  item.getMaxOutlier();  if  (max  !=  null)  {  double  maxv  =  max.doubleValue();  if  (!Double.isNaN(maxv))  {  if  (maxv  >  this.maximumRangeValue  ||  Double.isNaN(  this.maximumRangeValue))  {  this.maximumRangeValue  =  maxv;  this.maximumRangeValueRow  =  r;  this.maximumRangeValueColumn  =  c;  }  }  }  }  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Range[85  ,  96]>  but  was:<Range[86  ,  96]>  assertEquals  (  new  Range  (  8  .  5  ,  9  .  6  )  ,  d1  .  getRangeBounds  (  true  )  )  ;  [METHOD]  updateBounds  [TYPE]  void  [PARAMETER]  [CLASS]  DefaultBoxAndWhiskerCategoryDataset  [TYPE]  boolean  false  true  [TYPE]  Range  rangeBounds  [TYPE]  double  maximumRangeValue  minimumRangeValue  [TYPE]  KeyedObjects2D  data  [TYPE]  int  maximumRangeValueColumn  maximumRangeValueRow  minimumRangeValueColumn  minimumRangeValueRow  [CONTEXT]  private  void  updateBounds  (  )  {  this  .  minimumRangeValue  =  Double  .  NaN  ;  [BUGGY]  this  .  maximumRangeValue  =  Double  .  NaN  ;  }  	Chart_21_DefaultBoxAndWhiskerCategoryDataset_3_3	741	0	source/org/jfree/data/statistics/DefaultBoxAndWhiskerCategoryDataset.java
35	int  index  =  rowData.getIndex(columnKey);  if  (index  >=  0)  {  return  rowData.getObject(index);  	[BUGGY]  if  (  row  >  =  0  )  {  return  rowData  .  getObject  (  columnKey  )  ;  [FE]  dataUnknownKeyException:  The  key  (  C2  )  is  not  recognised  assertTrue  (  pass  )  ;  [METHOD]  getObject  [TYPE]  Object  [PARAMETER]  Comparable  rowKey  Comparable  columnKey  [CLASS]  KeyedObjects2D  [TYPE]  KeyedObjects  rowData  [TYPE]  List  columnKeys  rowKeys  rows  [TYPE]  Comparable  columnKey  rowKey  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  column  row  [CONTEXT]  public  Object  getObject  (  Comparable  rowKey  ,  Comparable  columnKey  )  {  if  (  rowKey  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'rowKey'  argument  . "  )  ;  }  if  (  columnKey  =  =  null  )  {  throw  new  IllegalArgumentException  ( "Null  'columnKey'  argument  . "  )  ;  }  int  row  =  this  .  rowKeys  .  indexOf  (  rowKey  )  ;  if  (  row  <  0  )  {  throw  new  UnknownKeyException  ( "Row  key  ( "  +  rowKey  + "  )  not  recognised  . "  )  ;  }  int  column  =  this  .  columnKeys  .  indexOf  (  columnKey  )  ;  if  (  column  <  0  )  {  throw  new  UnknownKeyException  ( "Column  key  ( "  +  columnKey  + "  )  not  recognised  . "  )  ;  }  [BUGGY]  if  (  row  >  =  0  )  {  KeyedObjects  rowData  =  (  KeyedObjects  )  this  .  rows  .  get  (  row  )  ;  return  rowData  .  getObject  (  columnKey  )  ;  }  else  {  return  null  ;  }  }  	Chart_22_KeyedObjects2D_4_1	231	2	source/org/jfree/data/KeyedObjects2D.java
36	allNull  =  true;  for  (int  item  =  0,  itemCount  =  this.rows.size();  item  <  itemCount;  item++)  {  row  =  (KeyedObjects)  this.rows.get(item);  int  columnIndex  =  row.getIndex(columnKey);  if  (columnIndex  >=  0  &&  row.getObject(columnIndex)  !=  null)  {  allNull  =  false;  break;  }  }  if  (allNull)  {  for  (int  item  =  0,  itemCount  =  this.rows.size();  item  <  itemCount;  item++)  {  row  =  (KeyedObjects)  this.rows.get(item);  int  columnIndex  =  row.getIndex(columnKey);  if  (columnIndex  >=  0)  {  row.removeValue(columnIndex);  }  }  this.columnKeys.remove(columnKey);  }  	[BUGGY]  [FE]  dataUnknownKeyException:  The  key  (  C2  )  is  not  recognised  assertTrue  (  pass  )  ;  [METHOD]  removeObject  [TYPE]  void  [PARAMETER]  Comparable  rowKey  Comparable  columnKey  [CLASS]  KeyedObjects2D  [TYPE]  KeyedObjects  row  [TYPE]  List  columnKeys  rowKeys  rows  [TYPE]  Comparable  columnKey  rowKey  [TYPE]  boolean  allNull  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  item  itemCount  rowIndex  [CONTEXT]  public  void  removeObject  (  Comparable  rowKey  ,  Comparable  columnKey  )  {  setObject  (  null  ,  rowKey  ,  columnKey  )  ;  boolean  allNull  =  true  ;  int  rowIndex  =  getRowIndex  (  rowKey  )  ;  KeyedObjects  row  =  (  KeyedObjects  )  this  .  rows  .  get  (  rowIndex  )  ;  for  (  int  item  =  0  ,  itemCount  =  row  .  getItemCount  (  )  ;  item  <  itemCount  ;  item++  )  {  if  (  row  .  getObject  (  item  )  !  =  null  )  {  allNull  =  false  ;  break  ;  }  }  if  (  allNull  )  {  this  .  rowKeys  .  remove  (  rowIndex  )  ;  this  .  rows  .  remove  (  rowIndex  )  ;  }  [BUGGY]  }  	Chart_22_KeyedObjects2D_4_2	318	0	source/org/jfree/data/KeyedObjects2D.java
37	if  (index  <  0)  {  throw  new  UnknownKeyException( "Row  key  ( "  +  rowKey  + ")  not  recognised. ");  }  	[BUGGY]  [FE]  dataUnknownKeyException:  The  key  (  C2  )  is  not  recognised  assertTrue  (  pass  )  ;  [METHOD]  removeRow  [TYPE]  void  [PARAMETER]  Comparable  rowKey  [CLASS]  KeyedObjects2D  [TYPE]  List  columnKeys  rowKeys  rows  [TYPE]  Comparable  rowKey  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  index  [CONTEXT]  public  void  removeRow  (  Comparable  rowKey  )  {  int  index  =  getRowIndex  (  rowKey  )  ;  [BUGGY]  removeRow  (  index  )  ;  }  	Chart_22_KeyedObjects2D_4_3	345	0	source/org/jfree/data/KeyedObjects2D.java
38	int  i  =  rowData.getIndex(columnKey);  if  (i  >=  0)  {  rowData.removeValue(i);  }  	[BUGGY]  rowData  .  removeValue  (  columnKey  )  ;  [FE]  dataUnknownKeyException:  The  key  (  C2  )  is  not  recognised  assertTrue  (  pass  )  ;  [METHOD]  removeColumn  [TYPE]  void  [PARAMETER]  Comparable  columnKey  [CLASS]  KeyedObjects2D  [TYPE]  Comparable  columnKey  [TYPE]  boolean  false  true  [TYPE]  Iterator  iterator  [TYPE]  KeyedObjects  rowData  [TYPE]  List  columnKeys  rowKeys  rows  [TYPE]  long  serialVersionUID  [TYPE]  int  index  [CONTEXT]  public  void  removeColumn  (  Comparable  columnKey  )  {  int  index  =  getColumnIndex  (  columnKey  )  ;  if  (  index  <  0  )  {  throw  new  UnknownKeyException  ( "Column  key  ( "  +  columnKey  + "  )  not  recognised  . "  )  ;  }  Iterator  iterator  =  this  .  rows  .  iterator  (  )  ;  while  (  iterator  .  hasNext  (  )  )  {  KeyedObjects  rowData  =  (  KeyedObjects  )  iterator  .  next  (  )  ;  [BUGGY]  rowData  .  removeValue  (  columnKey  )  ;  }  this  .  columnKeys  .  remove  (  columnKey  )  ;  }  	Chart_22_KeyedObjects2D_4_4	378	1	source/org/jfree/data/KeyedObjects2D.java
39	public  boolean  equals(Object  obj)  {  if  (obj  ==  this)  {  return  true;  }  if  (!(obj  instanceof  MinMaxCategoryRenderer))  {  return  false;  }  MinMaxCategoryRenderer  that  =  (MinMaxCategoryRenderer)  obj;  if  (this.plotLines  !=  that.plotLines)  {  return  false;  }  if  (!PaintUtilities.equal(this.groupPaint,  that.groupPaint))  {  return  false;  }  if  (!this.groupStroke.equals(that.groupStroke))  {  return  false;  }  return  super.equals(obj);  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  r1  .  equals  (  r2  )  )  ;  [CLASS]  [CONTEXT]  	Chart_23_MinMaxCategoryRenderer_1_1	435	0	source/org/jfree/chart/renderer/category/MinMaxCategoryRenderer.java
40	int  g  =  (int)  ((v  -  this.lowerBound)  /  (this.upperBound  	[BUGGY]  int  g  =  (  int  )  (  (  value  -  this  .  lowerBound  )  /  (  this  .  upperBound  [FE]  IllegalArgumentException:  Color  parameter  outside  of  expected  range:  Red  Green  Blue  assertTrue  (  c  .  equals  (  Color  .  white  )  )  ;  [METHOD]  getPaint  [TYPE]  Paint  [PARAMETER]  double  value  [CLASS]  GrayPaintScale  [TYPE]  double  lowerBound  upperBound  v  value  [TYPE]  int  g  [TYPE]  boolean  false  true  [CONTEXT]  public  Paint  getPaint  (  double  value  )  {  double  v  =  Math  .  max  (  value  ,  this  .  lowerBound  )  ;  v  =  Math  .  min  (  v  ,  this  .  upperBound  )  ;  [BUGGY]  int  g  =  (  int  )  (  (  value  -  this  .  lowerBound  )  /  (  this  .  upperBound  -  this  .  lowerBound  )  *  255  .  0  )  ;  return  new  Color  (  g  ,  g  ,  g  )  ;  }  	Chart_24_GrayPaintScale_1_1	126	1	source/org/jfree/chart/renderer/GrayPaintScale.java
41	if  (meanValue  ==  null)  {  return;  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  success  )  ;  [METHOD]  drawHorizontalItem  [TYPE]  void  [PARAMETER]  Graphics2D  g2  CategoryItemRendererState  state  Rectangle2D  dataArea  CategoryPlot  plot  CategoryAxis  domainAxis  ValueAxis  rangeAxis  StatisticalCategoryDataset  dataset  int  row  int  column  [CLASS]  StatisticalBarRenderer  [TYPE]  Stroke  errorIndicatorStroke  [TYPE]  CategoryItemRendererState  state  [TYPE]  double  base  highVal  lclip  lowVal  rectHeight  rectWidth  rectX  rectY  seriesGap  transY1  transY2  uclip  value  valueDelta  [TYPE]  Rectangle2D  bar  dataArea  [TYPE]  CategoryItemLabelGenerator  generator  [TYPE]  Paint  errorIndicatorPaint  seriesPaint  [TYPE]  Line2D  line  [TYPE]  long  serialVersionUID  [TYPE]  CategoryPlot  plot  [TYPE]  int  categoryCount  column  row  seriesCount  [TYPE]  Graphics2D  g2  [TYPE]  StatisticalCategoryDataset  dataset  [TYPE]  boolean  false  true  [TYPE]  Number  meanValue  [TYPE]  CategoryAxis  domainAxis  [TYPE]  EntityCollection  entities  [TYPE]  ValueAxis  rangeAxis  [TYPE]  RectangleEdge  xAxisLocation  yAxisLocation  [CONTEXT]  CategoryAxis  domainAxis  ,  ValueAxis  rangeAxis  ,  StatisticalCategoryDataset  dataset  ,  int  row  ,  int  column  )  {  RectangleEdge  xAxisLocation  =  plot  .  getDomainAxisEdge  (  )  ;  double  rectY  =  domainAxis  .  getCategoryStart  (  column  ,  getColumnCount  (  )  ,  dataArea  ,  xAxisLocation  )  ;  int  seriesCount  =  getRowCount  (  )  ;  int  categoryCount  =  getColumnCount  (  )  ;  if  (  seriesCount  >  1  )  {  double  seriesGap  =  dataArea  .  getHeight  (  )  *  getItemMargin  (  )  rectY  =  rectY  +  row  *  (  state  .  getBarWidth  (  )  +  seriesGap  )  ;  }  else  {  rectY  =  rectY  +  row  *  state  .  getBarWidth  (  )  ;  }  Number  meanValue  =  dataset  .  getMeanValue  (  row  ,  column  )  ;  [BUGGY]  double  value  =  meanValue  .  doubleValue  (  )  ;  double  base  =  0  .  0  ;  double  lclip  =  getLowerClip  (  )  ;  double  uclip  =  getUpperClip  (  )  ;  	Chart_25_StatisticalBarRenderer_6_1	259	0	source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java
42	Number  n  =  dataset.getStdDevValue(row,  column);  if  (n  !=  null)  {  double  valueDelta  =  n.doubleValue();  	[BUGGY]  double  valueDelta  =  dataset  .  getStdDevValue  (  row  ,  column  )  .  doubleValue  (  )  ;  [FE]  AssertionFailedError  assertTrue  (  success  )  ;  [METHOD]  drawHorizontalItem  [TYPE]  void  [PARAMETER]  Graphics2D  g2  CategoryItemRendererState  state  Rectangle2D  dataArea  CategoryPlot  plot  CategoryAxis  domainAxis  ValueAxis  rangeAxis  StatisticalCategoryDataset  dataset  int  row  int  column  [CLASS]  StatisticalBarRenderer  [TYPE]  Stroke  errorIndicatorStroke  [TYPE]  CategoryItemRendererState  state  [TYPE]  double  base  highVal  lclip  lowVal  rectHeight  rectWidth  rectX  rectY  seriesGap  transY1  transY2  uclip  value  valueDelta  [TYPE]  Rectangle2D  bar  dataArea  [TYPE]  CategoryItemLabelGenerator  generator  [TYPE]  Paint  errorIndicatorPaint  seriesPaint  [TYPE]  Line2D  line  [TYPE]  long  serialVersionUID  [TYPE]  CategoryPlot  plot  [TYPE]  int  categoryCount  column  row  seriesCount  [TYPE]  Graphics2D  g2  [TYPE]  StatisticalCategoryDataset  dataset  [TYPE]  boolean  false  true  [TYPE]  Number  meanValue  [TYPE]  CategoryAxis  domainAxis  [TYPE]  EntityCollection  entities  [TYPE]  ValueAxis  rangeAxis  [TYPE]  RectangleEdge  xAxisLocation  yAxisLocation  [CONTEXT]  value  =  uclip  ;  }  }  RectangleEdge  yAxisLocation  =  plot  .  getRangeAxisEdge  (  )  ;  double  transY1  =  rangeAxis  .  valueToJava2D  (  base  ,  dataArea  ,  yAxisLocation  )  ;  double  transY2  =  rangeAxis  .  valueToJava2D  (  value  ,  dataArea  ,  yAxisLocation  )  ;  double  rectX  =  Math  .  min  (  transY2  ,  transY1  )  ;  double  rectHeight  =  state  .  getBarWidth  (  )  ;  double  rectWidth  =  Math  .  abs  (  transY2  -  transY1  )  ;  Rectangle2D  bar  =  new  Rectangle2D  .  Double  (  rectX  ,  rectY  ,  rectWidth  ,  rectHeight  )  ;  Paint  seriesPaint  =  getItemPaint  (  row  ,  column  )  ;  g2  .  setPaint  (  seriesPaint  )  ;  g2  .  fill  (  bar  )  ;  if  (  isDrawBarOutline  (  )  &&  state  .  getBarWidth  (  )  >  3  )  {  g2  .  setStroke  (  getItemStroke  (  row  ,  column  )  )  ;  g2  .  setPaint  (  getItemOutlinePaint  (  row  ,  column  )  )  ;  g2  .  draw  (  bar  )  ;  }  [BUGGY]  double  valueDelta  =  dataset  .  getStdDevValue  (  row  ,  column  )  .  doubleValue  (  )  ;  double  highVal  =  rangeAxis  .  valueToJava2D  (  meanValue  .  doubleValue  (  )  +  valueDelta  ,  dataArea  ,  yAxisLocation  )  ;  double  lowVal  =  rangeAxis  .  valueToJava2D  (  meanValue  .  doubleValue  (  )  -  valueDelta  ,  dataArea  ,  yAxisLocation  )  ;  	Chart_25_StatisticalBarRenderer_6_2	315	1	source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java
43	}  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  success  )  ;  [METHOD]  drawHorizontalItem  [TYPE]  void  [PARAMETER]  Graphics2D  g2  CategoryItemRendererState  state  Rectangle2D  dataArea  CategoryPlot  plot  CategoryAxis  domainAxis  ValueAxis  rangeAxis  StatisticalCategoryDataset  dataset  int  row  int  column  [CLASS]  StatisticalBarRenderer  [TYPE]  Stroke  errorIndicatorStroke  [TYPE]  CategoryItemRendererState  state  [TYPE]  double  base  highVal  lclip  lowVal  rectHeight  rectWidth  rectX  rectY  seriesGap  transY1  transY2  uclip  value  valueDelta  [TYPE]  Rectangle2D  bar  dataArea  [TYPE]  CategoryItemLabelGenerator  generator  [TYPE]  Paint  errorIndicatorPaint  seriesPaint  [TYPE]  Line2D  line  [TYPE]  long  serialVersionUID  [TYPE]  CategoryPlot  plot  [TYPE]  int  categoryCount  column  row  seriesCount  [TYPE]  Graphics2D  g2  [TYPE]  StatisticalCategoryDataset  dataset  [TYPE]  boolean  false  true  [TYPE]  Number  meanValue  [TYPE]  CategoryAxis  domainAxis  [TYPE]  EntityCollection  entities  [TYPE]  ValueAxis  rangeAxis  [TYPE]  RectangleEdge  xAxisLocation  yAxisLocation  [CONTEXT]  -  valueDelta  ,  dataArea  ,  yAxisLocation  )  ;  if  (  this  .  errorIndicatorStroke  !  =  null  )  {  g2  .  setStroke  (  this  .  errorIndicatorStroke  )  ;  }  else  {  g2  .  setStroke  (  getItemOutlineStroke  (  row  ,  column  )  )  ;  }  if  (  this  .  errorIndicatorPaint  !  =  null  )  {  g2  .  setPaint  (  this  .  errorIndicatorPaint  )  ;  }  else  {  g2  .  setPaint  (  getItemOutlinePaint  (  row  ,  column  )  )  ;  }  Line2D  line  =  null  ;  line  =  new  Line2D  .  Double  (  lowVal  ,  rectY  +  rectHeight  /  2  .  0d  ,  highVal  ,  rectY  +  rectHeight  /  2  .  0d  )  ;  g2  .  draw  (  line  )  ;  line  =  new  Line2D  .  Double  (  highVal  ,  rectY  +  rectHeight  *  0  .  25  ,  highVal  ,  rectY  +  rectHeight  *  0  .  75  )  ;  g2  .  draw  (  line  )  ;  line  =  new  Line2D  .  Double  (  lowVal  ,  rectY  +  rectHeight  *  0  .  25  ,  lowVal  ,  rectY  +  rectHeight  *  0  .  75  )  ;  g2  .  draw  (  line  )  ;  [BUGGY]  CategoryItemLabelGenerator  generator  =  getItemLabelGenerator  (  row  ,  column  )  ;  if  (  generator  !  =  null  &&  isItemLabelVisible  (  row  ,  column  )  )  {  drawItemLabel  (  g2  ,  dataset  ,  row  ,  column  ,  plot  ,  generator  ,  bar  ,  (  value  <  0  .  0  )  )  ;  	Chart_25_StatisticalBarRenderer_6_3	344	0	source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java
44	if  (meanValue  ==  null)  {  return;  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  success  )  ;  [METHOD]  drawVerticalItem  [TYPE]  void  [PARAMETER]  Graphics2D  g2  CategoryItemRendererState  state  Rectangle2D  dataArea  CategoryPlot  plot  CategoryAxis  domainAxis  ValueAxis  rangeAxis  StatisticalCategoryDataset  dataset  int  row  int  column  [CLASS]  StatisticalBarRenderer  [TYPE]  Stroke  errorIndicatorStroke  [TYPE]  CategoryItemRendererState  state  [TYPE]  double  base  highVal  lclip  lowVal  rectHeight  rectWidth  rectX  rectY  seriesGap  transY1  transY2  uclip  value  valueDelta  [TYPE]  Rectangle2D  bar  dataArea  [TYPE]  CategoryItemLabelGenerator  generator  [TYPE]  Paint  errorIndicatorPaint  seriesPaint  [TYPE]  Line2D  line  [TYPE]  long  serialVersionUID  [TYPE]  CategoryPlot  plot  [TYPE]  int  categoryCount  column  row  seriesCount  [TYPE]  Graphics2D  g2  [TYPE]  StatisticalCategoryDataset  dataset  [TYPE]  boolean  false  true  [TYPE]  Number  meanValue  [TYPE]  CategoryAxis  domainAxis  [TYPE]  EntityCollection  entities  [TYPE]  ValueAxis  rangeAxis  [TYPE]  RectangleEdge  xAxisLocation  yAxisLocation  [CONTEXT]  ValueAxis  rangeAxis  ,  StatisticalCategoryDataset  dataset  ,  int  row  ,  int  column  )  {  RectangleEdge  xAxisLocation  =  plot  .  getDomainAxisEdge  (  )  ;  double  rectX  =  domainAxis  .  getCategoryStart  (  column  ,  getColumnCount  (  )  ,  dataArea  ,  xAxisLocation  )  ;  int  seriesCount  =  getRowCount  (  )  ;  int  categoryCount  =  getColumnCount  (  )  ;  if  (  seriesCount  >  1  )  {  double  seriesGap  =  dataArea  .  getWidth  (  )  *  getItemMargin  (  )  rectX  =  rectX  +  row  *  (  state  .  getBarWidth  (  )  +  seriesGap  )  ;  }  else  {  rectX  =  rectX  +  row  *  state  .  getBarWidth  (  )  ;  }  Number  meanValue  =  dataset  .  getMeanValue  (  row  ,  column  )  ;  [BUGGY]  double  value  =  meanValue  .  doubleValue  (  )  ;  double  base  =  0  .  0  ;  double  lclip  =  getLowerClip  (  )  ;  double  uclip  =  getUpperClip  (  )  ;  	Chart_25_StatisticalBarRenderer_6_4	403	0	source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java
45	Number  n  =  dataset.getStdDevValue(row,  column);  if  (n  !=  null)  {  double  valueDelta  =  n.doubleValue();  	[BUGGY]  double  valueDelta  =  dataset  .  getStdDevValue  (  row  ,  column  )  .  doubleValue  (  )  ;  [FE]  AssertionFailedError  assertTrue  (  success  )  ;  [METHOD]  drawVerticalItem  [TYPE]  void  [PARAMETER]  Graphics2D  g2  CategoryItemRendererState  state  Rectangle2D  dataArea  CategoryPlot  plot  CategoryAxis  domainAxis  ValueAxis  rangeAxis  StatisticalCategoryDataset  dataset  int  row  int  column  [CLASS]  StatisticalBarRenderer  [TYPE]  Stroke  errorIndicatorStroke  [TYPE]  CategoryItemRendererState  state  [TYPE]  double  base  highVal  lclip  lowVal  rectHeight  rectWidth  rectX  rectY  seriesGap  transY1  transY2  uclip  value  valueDelta  [TYPE]  Rectangle2D  bar  dataArea  [TYPE]  CategoryItemLabelGenerator  generator  [TYPE]  Paint  errorIndicatorPaint  seriesPaint  [TYPE]  Line2D  line  [TYPE]  long  serialVersionUID  [TYPE]  CategoryPlot  plot  [TYPE]  int  categoryCount  column  row  seriesCount  [TYPE]  Graphics2D  g2  [TYPE]  StatisticalCategoryDataset  dataset  [TYPE]  boolean  false  true  [TYPE]  Number  meanValue  [TYPE]  CategoryAxis  domainAxis  [TYPE]  EntityCollection  entities  [TYPE]  ValueAxis  rangeAxis  [TYPE]  RectangleEdge  xAxisLocation  yAxisLocation  [CONTEXT]  value  =  uclip  ;  }  }  RectangleEdge  yAxisLocation  =  plot  .  getRangeAxisEdge  (  )  ;  double  transY1  =  rangeAxis  .  valueToJava2D  (  base  ,  dataArea  ,  yAxisLocation  )  ;  double  transY2  =  rangeAxis  .  valueToJava2D  (  value  ,  dataArea  ,  yAxisLocation  )  ;  double  rectY  =  Math  .  min  (  transY2  ,  transY1  )  ;  double  rectWidth  =  state  .  getBarWidth  (  )  ;  double  rectHeight  =  Math  .  abs  (  transY2  -  transY1  )  ;  Rectangle2D  bar  =  new  Rectangle2D  .  Double  (  rectX  ,  rectY  ,  rectWidth  ,  rectHeight  )  ;  Paint  seriesPaint  =  getItemPaint  (  row  ,  column  )  ;  g2  .  setPaint  (  seriesPaint  )  ;  g2  .  fill  (  bar  )  ;  if  (  isDrawBarOutline  (  )  &&  state  .  getBarWidth  (  )  >  3  )  {  g2  .  setStroke  (  getItemStroke  (  row  ,  column  )  )  ;  g2  .  setPaint  (  getItemOutlinePaint  (  row  ,  column  )  )  ;  g2  .  draw  (  bar  )  ;  }  [BUGGY]  double  valueDelta  =  dataset  .  getStdDevValue  (  row  ,  column  )  .  doubleValue  (  )  ;  double  highVal  =  rangeAxis  .  valueToJava2D  (  meanValue  .  doubleValue  (  )  +  valueDelta  ,  dataArea  ,  yAxisLocation  )  ;  double  lowVal  =  rangeAxis  .  valueToJava2D  (  meanValue  .  doubleValue  (  )  -  valueDelta  ,  dataArea  ,  yAxisLocation  )  ;  	Chart_25_StatisticalBarRenderer_6_5	459	1	source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java
46	}  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  success  )  ;  [METHOD]  drawVerticalItem  [TYPE]  void  [PARAMETER]  Graphics2D  g2  CategoryItemRendererState  state  Rectangle2D  dataArea  CategoryPlot  plot  CategoryAxis  domainAxis  ValueAxis  rangeAxis  StatisticalCategoryDataset  dataset  int  row  int  column  [CLASS]  StatisticalBarRenderer  [TYPE]  Stroke  errorIndicatorStroke  [TYPE]  CategoryItemRendererState  state  [TYPE]  double  base  highVal  lclip  lowVal  rectHeight  rectWidth  rectX  rectY  seriesGap  transY1  transY2  uclip  value  valueDelta  [TYPE]  Rectangle2D  bar  dataArea  [TYPE]  CategoryItemLabelGenerator  generator  [TYPE]  Paint  errorIndicatorPaint  seriesPaint  [TYPE]  Line2D  line  [TYPE]  long  serialVersionUID  [TYPE]  CategoryPlot  plot  [TYPE]  int  categoryCount  column  row  seriesCount  [TYPE]  Graphics2D  g2  [TYPE]  StatisticalCategoryDataset  dataset  [TYPE]  boolean  false  true  [TYPE]  Number  meanValue  [TYPE]  CategoryAxis  domainAxis  [TYPE]  EntityCollection  entities  [TYPE]  ValueAxis  rangeAxis  [TYPE]  RectangleEdge  xAxisLocation  yAxisLocation  [CONTEXT]  double  lowVal  =  rangeAxis  .  valueToJava2D  (  meanValue  .  doubleValue  (  )  -  valueDelta  ,  dataArea  ,  yAxisLocation  )  ;  if  (  this  .  errorIndicatorStroke  !  =  null  )  {  g2  .  setStroke  (  this  .  errorIndicatorStroke  )  ;  }  else  {  g2  .  setStroke  (  getItemOutlineStroke  (  row  ,  column  )  )  ;  }  if  (  this  .  errorIndicatorPaint  !  =  null  )  {  g2  .  setPaint  (  this  .  errorIndicatorPaint  )  ;  }  else  {  g2  .  setPaint  (  getItemOutlinePaint  (  row  ,  column  )  )  ;  }  Line2D  line  =  null  ;  line  =  new  Line2D  .  Double  (  rectX  +  rectWidth  /  2  .  0d  ,  lowVal  ,  rectX  +  rectWidth  /  2  .  0d  ,  highVal  )  ;  g2  .  draw  (  line  )  ;  line  =  new  Line2D  .  Double  (  rectX  +  rectWidth  /  2  .  0d  -  5  .  0d  ,  highVal  ,  rectX  +  rectWidth  /  2  .  0d  +  5  .  0d  ,  highVal  )  ;  g2  .  draw  (  line  )  ;  line  =  new  Line2D  .  Double  (  rectX  +  rectWidth  /  2  .  0d  -  5  .  0d  ,  lowVal  ,  rectX  +  rectWidth  /  2  .  0d  +  5  .  0d  ,  lowVal  )  ;  g2  .  draw  (  line  )  ;  [BUGGY]  CategoryItemLabelGenerator  generator  =  getItemLabelGenerator  (  row  ,  column  )  ;  if  (  generator  !  =  null  &&  isItemLabelVisible  (  row  ,  column  )  )  {  drawItemLabel  (  g2  ,  dataset  ,  row  ,  column  ,  plot  ,  generator  ,  bar  ,  (  value  <  0  .  0  )  )  ;  	Chart_25_StatisticalBarRenderer_6_6	487	0	source/org/jfree/chart/renderer/category/StatisticalBarRenderer.java
47	if  (epsilon  ==  0.0  &&  FastMath.abs(q1)  <  maxDenominator)  {  break;  }  	[BUGGY] [FE] commonsmath3fractionFractionConversionException: illegal state: Overflow trying to convert 05 to fraction ( 2 , 499 , 999 , 794/4 , 999 , 999 , 587 ) assertFraction ( 1 , 2 , new BigFraction ( 0 . 5000000001 , 10 ) ) ; [CONTEXT] boolean stop = false ; do { ++n ; final double r1 = 1 . 0 / ( r0 - a0 ) ; final long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( p2 > overflow ) || ( q2 > overflow ) ) {  [BUGGY] throw new FractionConversionException ( value , p2 , q2 ) ; } final double convergent = ( double ) p2 / ( double ) q2 ; if ( ( n < maxIterations ) && ( FastMath . abs ( convergent - value ) > epsilon ) && ( q2 < maxDenominator ) ) { p0 = p1 ; p1 = p2 ; q0 = q1 ; q1 = q2 ;  	Math_1_BigFraction_1_1	306	0	src/main/java/org/apache/commons/math3/fraction/BigFraction.java
48	if  (epsilon  ==  0.0  &&  FastMath.abs(q1)  <  maxDenominator)  {  break;  }  	[BUGGY] [FE] commonsmath3fractionFractionConversionException: illegal state: Overflow trying to convert 05 to fraction ( 2 , 499 , 999 , 794/4 , 999 , 999 , 587 ) assertFraction ( 1 , 2 , new BigFraction ( 0 . 5000000001 , 10 ) ) ; [CONTEXT] do { ++n ; double r1 = 1 . 0 / ( r0 - a0 ) ; long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; if ( ( FastMath . abs ( p2 ) > overflow ) || ( FastMath . abs ( q2 ) > overflow ) ) {  [BUGGY] throw new FractionConversionException ( value , p2 , q2 ) ; } double convergent = ( double ) p2 / ( double ) q2 ; if ( n < maxIterations && FastMath . abs ( convergent - value ) > epsilon && q2 < maxDenominator ) { p0 = p1 ; p1 = p2 ; q0 = q1 ; q1 = q2 ; a0 = a1 ; r0 = r1 ; 	Math_1_Fraction_1_1	215	0	src/main/java/org/apache/commons/math3/fraction/Fraction.java
49	return  getSampleSize()  *  (getNumberOfSuccesses()  /  (double)  getPopulationSize());  	[BUGGY]  return  (  double  )  (  getSampleSize  (  )  *  getNumberOfSuccesses  (  )  )  /  (  double  )  getPopulationSize  (  )  ;  [FE]  AssertionFailedError:  sample  =  -50  Assert  .  assertTrue  ( "sample  = "  +  sample  ,  sample  <  =  n  )  ;  [METHOD]  getNumericalMean  [TYPE]  double  [PARAMETER]  [CLASS]  HypergeometricDistribution  [TYPE]  boolean  false  numericalVarianceIsCalculated  true  [TYPE]  double  numericalVariance  [TYPE]  long  serialVersionUID  [TYPE]  int  numberOfSuccesses  populationSize  sampleSize  [CONTEXT]  public  double  getNumericalMean  (  )  {  [BUGGY]  return  (  double  )  (  getSampleSize  (  )  *  getNumberOfSuccesses  (  )  )  /  (  double  )  getPopulationSize  (  )  ;  }  	Math_2_HypergeometricDistribution_1_1	268	1	src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java
50	if  (len  ==  1)  {  return  a[0]  *  b[0];  }  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  1  Assert  .  assertEquals  (  a[0]  *  b[0]  ,  MathArrays  .  linearCombination  (  a  ,  b  )  ,  0d  )  ;  [METHOD]  linearCombination  [TYPE]  double  [PARAMETER]  final  double[]  a  final  double[]  b  [CLASS]  MathArrays  [TYPE]  boolean  false  true  [TYPE]  double[]  a  b  prodHigh  [TYPE]  int  SPLIT_FACTOR  i  len  lenMinusOne  [TYPE]  OrderDirection  DECREASING  INCREASING  [TYPE]  double  aHigh  aLow  ai  bHigh  bLow  bi  ca  cb  prodHighCur  prodHighNext  prodLow  prodLowSum  result  sHighCur  sHighPrev  sLowSum  sPrime  [CONTEXT]  public  static  double  linearCombination  (  final  double[]  a  ,  final  double[]  b  )  throws  DimensionMismatchException  {  final  int  len  =  a  .  length  ;  if  (  len  !  =  b  .  length  )  {  throw  new  DimensionMismatchException  (  len  ,  b  .  length  )  ;  }  [BUGGY]  final  double[]  prodHigh  =  new  double[len]  ;  double  prodLowSum  =  0  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  	Math_3_MathArrays_1_1	821	0	src/main/java/org/apache/commons/math3/util/MathArrays.java
51	if  (v2D  ==  null)  {  return  null;  }  	[BUGGY]  [FE]  NullPointerException  Assert  .  assertNull  (  sub1  .  intersection  (  sub2  ,  false  )  )  ;  [METHOD]  intersection  [TYPE]  Vector3D  [PARAMETER]  SubLine  subLine  final  boolean  includeEndPoints  [CLASS]  SubLine  [TYPE]  Line  line  [TYPE]  SubLine  subLine  [TYPE]  IntervalsSet  remainingRegion  [TYPE]  boolean  false  includeEndPoints  true  [TYPE]  Vector3D  v1D  [TYPE]  Location  loc1  loc2  [CONTEXT]  public  Vector3D  intersection  (  final  SubLine  subLine  ,  final  boolean  includeEndPoints  )  {  Vector3D  v1D  =  line  .  intersection  (  subLine  .  line  )  ;  Location  loc1  =  remainingRegion  .  checkPoint  (  line  .  toSubSpace  (  v1D  )  )  ;  [BUGGY]  Location  loc2  =  subLine  .  remainingRegion  .  checkPoint  (  subLine  .  line  .  toSubSpace  (  v1D  )  )  ;  if  (  includeEndPoints  )  {  return  (  (  loc1  !  =  Location  .  OUTSIDE  )  &&  (  loc2  !  =  Location  .  OUTSIDE  )  )  ?  v1D  :  null  ;  }  else  {  return  (  (  loc1  =  =  Location  .  INSIDE  )  &&  (  loc2  =  =  Location  .  INSIDE  )  )  ?  v1D  :  null  ;  }  }  	Math_4_SubLine_1_1	118	0	src/main/java/org/apache/commons/math3/geometry/euclidean/threed/SubLine.java
52	return  INF;  	[BUGGY]  return  NaN  ;  [FE]  AssertionFailedError:  expected:<  (  NaN  ,  NaN  )  >  but  was:<  (  Infinity  ,  Infinity  )  >  Assert  .  assertEquals  (  Complex  .  ZERO  .  reciprocal  (  )  ,  Complex  .  INF  )  ;  [METHOD]  reciprocal  [TYPE]  Complex  [PARAMETER]  [CLASS]  Complex  [TYPE]  boolean  false  isInfinite  isNaN  true  [TYPE]  double  imaginary  q  real  scale  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  [CONTEXT]  public  Complex  reciprocal  (  )  {  if  (  isNaN  )  {  return  NaN  ;  }  if  (  real  =  =  0  .  0  &&  imaginary  =  =  0  .  0  )  {  [BUGGY]  return  NaN  ;  }  if  (  isInfinite  )  {  return  ZERO  ;  }  if  (  FastMath  .  abs  (  real  )  <  FastMath  .  abs  (  imaginary  )  )  {  double  q  =  real  /  imaginary  ;  double  scale  =  1  .  /  (  real  *  q  +  imaginary  )  ;  return  createComplex  (  scale  *  q  ,  -scale  )  ;  }  else  {  double  q  =  imaginary  /  real  ;  double  scale  =  1  .  /  (  imaginary  *  q  +  real  )  ;  return  createComplex  (  scale  ,  -scale  *  q  )  ;  }  }  	Math_5_Complex_1_1	305	1	src/main/java/org/apache/commons/math3/complex/Complex.java
53	iterations  =  new  Incrementor(Integer.MAX_VALUE,  new  MaxIterCallback());  	[BUGGY]  iterations  =  new  Incrementor  (  0  ,  new  MaxIterCallback  (  )  )  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [CLASS]  [CONTEXT]  	Math_6_BaseOptimizer_1_1	51	1	src/main/java/org/apache/commons/math3/optim/BaseOptimizer.java
54	incrementIterationCount();  	[BUGGY]  int  iter  =  0  ;  ++iter  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointValuePair  [PARAMETER]  [CLASS]  NonLinearConjugateGradientOptimizer  [TYPE]  Formula  FLETCHER_REEVES  POLAK_RIBIERE  updateFormula  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  false  true  [TYPE]  double[]  currentPoint  newSteepestDescent  point  r  searchDirection  steepestDescent  [TYPE]  UnivariateFunction  lsf  [TYPE]  Preconditioner  preconditioner  [TYPE]  UnivariateSolver  solver  [TYPE]  double  beta  delta  deltaMid  deltaOld  initialStep  objective  step  uB  [TYPE]  GoalType  goal  [TYPE]  int  i  iter  maxEval  n  [TYPE]  PointValuePair  current  previous  [CONTEXT]  protected  PointValuePair  doOptimize  (  )  {  final  ConvergenceChecker<PointValuePair>  checker  =  getConvergenceChecker  (  )  ;  final  double[]  point  =  getStartPoint  (  )  ;  final  GoalType  goal  =  getGoalType  (  )  ;  final  int  n  =  point  .  length  ;  double[]  r  =  computeObjectiveGradient  (  point  )  ;  if  (  goal  =  =  GoalType  .  MINIMIZE  )  {  for  (  int  i  =  0  ;  i  <  n  ;  i++  )  {  r[i]  =  -r[i]  ;  }  }  double[]  steepestDescent  =  preconditioner  .  precondition  (  point  ,  r  )  ;  double[]  searchDirection  =  steepestDescent  .  clone  (  )  ;  double  delta  =  0  ;  for  (  int  i  =  0  ;  i  <  n  ;  ++i  )  {  delta  +  =  r[i]  *  searchDirection[i]  ;  }  PointValuePair  current  =  null  ;  [BUGGY]  int  iter  =  0  ;  int  maxEval  =  getMaxEvaluations  (  )  ;  while  (  true  )  {  ++iter  ;  final  double  objective  =  computeObjectiveValue  (  point  )  ;  	Math_6_NonLinearConjugateGradientOptimizer_3_1	214	2	src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
55	if  (checker.converged(getIterations(),  previous,  current))  {  	[BUGGY]  if  (  checker  .  converged  (  iter  ,  previous  ,  current  )  )  {  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointValuePair  [PARAMETER]  [CLASS]  NonLinearConjugateGradientOptimizer  [TYPE]  Formula  FLETCHER_REEVES  POLAK_RIBIERE  updateFormula  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  false  true  [TYPE]  double[]  currentPoint  newSteepestDescent  point  r  searchDirection  steepestDescent  [TYPE]  UnivariateFunction  lsf  [TYPE]  Preconditioner  preconditioner  [TYPE]  UnivariateSolver  solver  [TYPE]  double  beta  delta  deltaMid  deltaOld  initialStep  objective  step  uB  [TYPE]  GoalType  goal  [TYPE]  int  i  iter  maxEval  n  [TYPE]  PointValuePair  current  previous  [CONTEXT]  if  (  goal  =  =  GoalType  .  MINIMIZE  )  {  for  (  int  i  =  0  ;  i  <  n  ;  i++  )  {  r[i]  =  -r[i]  ;  }  }  double[]  steepestDescent  =  preconditioner  .  precondition  (  point  ,  r  )  ;  double[]  searchDirection  =  steepestDescent  .  clone  (  )  ;  double  delta  =  0  ;  for  (  int  i  =  0  ;  i  <  n  ;  ++i  )  {  delta  +  =  r[i]  *  searchDirection[i]  ;  }  PointValuePair  current  =  null  ;  int  iter  =  0  ;  int  maxEval  =  getMaxEvaluations  (  )  ;  while  (  true  )  {  ++iter  ;  final  double  objective  =  computeObjectiveValue  (  point  )  ;  PointValuePair  previous  =  current  ;  current  =  new  PointValuePair  (  point  ,  objective  )  ;  if  (  previous  !  =  null  )  {  [BUGGY]  if  (  checker  .  converged  (  iter  ,  previous  ,  current  )  )  {  return  current  ;  }  }  	Math_6_NonLinearConjugateGradientOptimizer_3_2	223	1	src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
56	if  (getIterations()  %  n  ==  0  ||  	[BUGGY]  if  (  iter  %  n  =  =  0  ||  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointValuePair  [PARAMETER]  [CLASS]  NonLinearConjugateGradientOptimizer  [TYPE]  Formula  FLETCHER_REEVES  POLAK_RIBIERE  updateFormula  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  false  true  [TYPE]  double[]  currentPoint  newSteepestDescent  point  r  searchDirection  steepestDescent  [TYPE]  UnivariateFunction  lsf  [TYPE]  Preconditioner  preconditioner  [TYPE]  UnivariateSolver  solver  [TYPE]  double  beta  delta  deltaMid  deltaOld  initialStep  objective  step  uB  [TYPE]  GoalType  goal  [TYPE]  int  i  iter  maxEval  n  [TYPE]  PointValuePair  current  previous  [CONTEXT]  final  double[]  newSteepestDescent  =  preconditioner  .  precondition  (  point  ,  r  )  ;  delta  =  0  ;  for  (  int  i  =  0  ;  i  <  n  ;  ++i  )  {  delta  +  =  r[i]  *  newSteepestDescent[i]  ;  }  final  double  beta  ;  switch  (  updateFormula  )  {  case  FLETCHER_REEVES:  beta  =  delta  /  deltaOld  ;  break  ;  case  POLAK_RIBIERE:  double  deltaMid  =  0  ;  for  (  int  i  =  0  ;  i  <  r  .  length  ;  ++i  )  {  deltaMid  +  =  r[i]  *  steepestDescent[i]  ;  }  beta  =  (  delta  -  deltaMid  )  /  deltaOld  ;  break  ;  default:  throw  new  MathInternalError  (  )  ;  }  steepestDescent  =  newSteepestDescent  ;  [BUGGY]  if  (  iter  %  n  =  =  0  ||  beta  <  0  )  {  searchDirection  =  steepestDescent  .  clone  (  )  ;  }  else  {  	Math_6_NonLinearConjugateGradientOptimizer_3_3	277	1	src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer.java
57	incrementIterationCount();  	[BUGGY]  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointValuePair  [PARAMETER]  [CLASS]  CMAESOptimizer  [TYPE]  TooManyEvaluationsException  e  [TYPE]  boolean  false  generateStatistics  hsig  isActiveCMA  isMinimize  isRepairMode  true  [TYPE]  double[]  fitness  fitnessHistory  guess  inputSigma  pcCol  sigma  sqrtDiagC  [TYPE]  RealMatrix  B  BD  C  D  arx  arxk  arz  bestArx  bestArz  diagC  diagD  pc  ps  weights  xmean  xold  zmean  [TYPE]  double  bestFitness  bestValue  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  historyBest  historyWorst  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  worstFitness  [TYPE]  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  [TYPE]  FitnessFunction  fitfun  [TYPE]  int[]  arindex  [TYPE]  int  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  k  lambda  maxIterations  mu  [TYPE]  RandomGenerator  random  [TYPE]  PointValuePair  current  lastResult  optimum  [CONTEXT]  protected  PointValuePair  doOptimize  (  )  {  isMinimize  =  getGoalType  (  )  .  equals  (  GoalType  .  MINIMIZE  )  ;  final  FitnessFunction  fitfun  =  new  FitnessFunction  (  )  ;  final  double[]  guess  =  getStartPoint  (  )  ;  dimension  =  guess  .  length  ;  initializeCMA  (  guess  )  ;  iterations  =  0  ;  double  bestValue  =  fitfun  .  value  (  guess  )  ;  push  (  fitnessHistory  ,  bestValue  )  ;  PointValuePair  optimum  =  new  PointValuePair  (  getStartPoint  (  )  ,  isMinimize  ?  bestValue  :  -bestValue  )  ;  PointValuePair  lastResult  =  null  ;  generationLoop:  for  (  iterations  =  1  ;  iterations  <  =  maxIterations  ;  iterations++  )  {  [BUGGY]  final  RealMatrix  arz  =  randn1  (  dimension  ,  lambda  )  ;  final  RealMatrix  arx  =  zeros  (  dimension  ,  lambda  )  ;  final  double[]  fitness  =  new  double[lambda]  ;  	Math_6_CMAESOptimizer_1_1	388	0	src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/CMAESOptimizer.java
58	incrementIterationCount();  	[BUGGY]  int  iter  =  0  ;  ++iter  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointValuePair  [PARAMETER]  [CLASS]  PowellOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  false  stop  true  [TYPE]  double[]  d  guess  x  x1  x2  [TYPE]  double  ABS_TOL_UNUSED  MIN_RELATIVE_TOLERANCE  REL_TOL_UNUSED  absoluteThreshold  alphaMin  delta  fVal  fX  fX2  relativeThreshold  t  temp  [TYPE]  double[][]  direc  result  [TYPE]  LineSearch  line  [TYPE]  BracketFinder  bracket  [TYPE]  GoalType  goal  [TYPE]  UnivariatePointValuePair  optimum  [TYPE]  int  bigInd  i  iter  lastInd  n  [TYPE]  PointValuePair  current  previous  [CONTEXT]  protected  PointValuePair  doOptimize  (  )  {  checkParameters  (  )  ;  final  GoalType  goal  =  getGoalType  (  )  ;  final  double[]  guess  =  getStartPoint  (  )  ;  final  int  n  =  guess  .  length  ;  final  double[][]  direc  =  new  double[n][n]  ;  for  (  int  i  =  0  ;  i  <  n  ;  i++  )  {  direc[i][i]  =  1  ;  }  final  ConvergenceChecker<PointValuePair>  checker  =  getConvergenceChecker  (  )  ;  double[]  x  =  guess  ;  double  fVal  =  computeObjectiveValue  (  x  )  ;  double[]  x1  =  x  .  clone  (  )  ;  [BUGGY]  int  iter  =  0  ;  while  (  true  )  {  ++iter  ;  double  fX  =  fVal  ;  double  fX2  =  0  ;  	Math_6_PowellOptimizer_2_1	191	2	src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
59	stop  =  checker.converged(getIterations(),  previous,  current);  	[BUGGY]  stop  =  checker  .  converged  (  iter  ,  previous  ,  current  )  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointValuePair  [PARAMETER]  [CLASS]  PowellOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  false  stop  true  [TYPE]  double[]  d  guess  x  x1  x2  [TYPE]  double  ABS_TOL_UNUSED  MIN_RELATIVE_TOLERANCE  REL_TOL_UNUSED  absoluteThreshold  alphaMin  delta  fVal  fX  fX2  relativeThreshold  t  temp  [TYPE]  double[][]  direc  result  [TYPE]  LineSearch  line  [TYPE]  BracketFinder  bracket  [TYPE]  GoalType  goal  [TYPE]  UnivariatePointValuePair  optimum  [TYPE]  int  bigInd  i  iter  lastInd  n  [TYPE]  PointValuePair  current  previous  [CONTEXT]  final  double[]  d  =  MathArrays  .  copyOf  (  direc[i]  )  ;  fX2  =  fVal  ;  final  UnivariatePointValuePair  optimum  =  line  .  search  (  x  ,  d  )  ;  fVal  =  optimum  .  getValue  (  )  ;  alphaMin  =  optimum  .  getPoint  (  )  ;  final  double[][]  result  =  newPointAndDirection  (  x  ,  d  ,  alphaMin  )  ;  x  =  result[0]  ;  if  (  (  fX2  -  fVal  )  >  delta  )  {  delta  =  fX2  -  fVal  ;  bigInd  =  i  ;  }  }  boolean  stop  =  2  *  (  fX  -  fVal  )  <  =  (  relativeThreshold  *  (  FastMath  .  abs  (  fX  )  +  FastMath  .  abs  (  fVal  )  )  +  absoluteThreshold  )  ;  final  PointValuePair  previous  =  new  PointValuePair  (  x1  ,  fX  )  ;  final  PointValuePair  current  =  new  PointValuePair  (  x  ,  fVal  )  ;  if  (  !stop  )  {  //  User-defined  stopping  criteria  .  if  (  checker  !  =  null  )  {  [BUGGY]  stop  =  checker  .  converged  (  iter  ,  previous  ,  current  )  ;  }  }  if  (  stop  )  {  if  (  goal  =  =  GoalType  .  MINIMIZE  )  {  return  (  fVal  <  fX  )  ?  current  :  previous  ;  	Math_6_PowellOptimizer_2_2	227	1	src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/PowellOptimizer.java
60	if  (getIterations()  >  0)  {  	[BUGGY]  if  (  iteration  >  0  )  {  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointValuePair  [PARAMETER]  [CLASS]  SimplexOptimizer  [TYPE]  PointValuePair[]  previous  [TYPE]  MultivariateFunction  evalFunc  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  converged  false  isMinim  true  [TYPE]  double[]  point  [TYPE]  double  v1  v2  [TYPE]  AbstractSimplex  simplex  [TYPE]  int  i  iteration  [TYPE]  Comparator  comparator  [TYPE]  PointValuePair  o1  o2  prev  [CONTEXT]  =  new  MultivariateFunction  (  )  {  public  double  value  (  double[]  point  )  {  return  computeObjectiveValue  (  point  )  ;  }  }  ;  final  boolean  isMinim  =  getGoalType  (  )  =  =  GoalType  .  MINIMIZE  ;  final  Comparator<PointValuePair>  comparator  =  new  Comparator<PointValuePair>  (  )  {  public  int  compare  (  final  PointValuePair  o1  ,  final  PointValuePair  o2  )  {  final  double  v1  =  o1  .  getValue  (  )  ;  final  double  v2  =  o2  .  getValue  (  )  ;  return  isMinim  ?  Double  .  compare  (  v1  ,  v2  )  :  Double  .  compare  (  v2  ,  v1  )  ;  }  }  ;  simplex  .  build  (  getStartPoint  (  )  )  ;  simplex  .  evaluate  (  evalFunc  ,  comparator  )  ;  PointValuePair[]  previous  =  null  ;  int  iteration  =  0  ;  final  ConvergenceChecker<PointValuePair>  checker  =  getConvergenceChecker  (  )  ;  while  (  true  )  {  [BUGGY]  if  (  iteration  >  0  )  {  boolean  converged  =  true  ;  for  (  int  i  =  0  ;  i  <  simplex  .  getSize  (  )  ;  i++  )  {  PointValuePair  prev  =  previous[i]  ;  converged  =  converged  &&  checker  .  converged  (  iteration  ,  prev  ,  simplex  .  getPoint  (  i  )  )  ;  	Math_6_SimplexOptimizer_2_1	158	1	src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
61	incrementIterationCount();  	[BUGGY]  \t\t\t++iteration  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointValuePair  [PARAMETER]  [CLASS]  SimplexOptimizer  [TYPE]  PointValuePair[]  previous  [TYPE]  MultivariateFunction  evalFunc  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  converged  false  isMinim  true  [TYPE]  double[]  point  [TYPE]  double  v1  v2  [TYPE]  AbstractSimplex  simplex  [TYPE]  int  i  iteration  [TYPE]  Comparator  comparator  [TYPE]  PointValuePair  o1  o2  prev  [CONTEXT]  simplex  .  build  (  getStartPoint  (  )  )  ;  simplex  .  evaluate  (  evalFunc  ,  comparator  )  ;  PointValuePair[]  previous  =  null  ;  int  iteration  =  0  ;  final  ConvergenceChecker<PointValuePair>  checker  =  getConvergenceChecker  (  )  ;  while  (  true  )  {  if  (  iteration  >  0  )  {  boolean  converged  =  true  ;  for  (  int  i  =  0  ;  i  <  simplex  .  getSize  (  )  ;  i++  )  {  PointValuePair  prev  =  previous[i]  ;  converged  =  converged  &&  checker  .  converged  (  iteration  ,  prev  ,  simplex  .  getPoint  (  i  )  )  ;  }  if  (  converged  )  {  return  simplex  .  getPoint  (  0  )  ;  }  }  previous  =  simplex  .  getPoints  (  )  ;  simplex  .  iterate  (  evalFunc  ,  comparator  )  ;  [BUGGY]  ++iteration  ;  }  }  	Math_6_SimplexOptimizer_2_2	175	1	src/main/java/org/apache/commons/math3/optim/nonlinear/scalar/noderiv/SimplexOptimizer.java
62	incrementIterationCount();  	[BUGGY]  int  iter  =  0  ;  ++iter  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointVectorValuePair  [PARAMETER]  [CLASS]  GaussNewtonOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  PointVectorValuePair  current  previous  [TYPE]  boolean  converged  false  true  useLU  [TYPE]  double[]  ak  b  currentObjective  currentPoint  currentResiduals  dX  grad  residualsWeights  targetValues  [TYPE]  RealMatrix  mA  weightMatrix  weightedJacobian  [TYPE]  DecompositionSolver  solver  [TYPE]  double  residual  weight  wgk  wr  [TYPE]  SingularMatrixException  e  [TYPE]  double[][]  a  [TYPE]  int  i  iter  j  k  l  nC  nR  [CONTEXT]  checkParameters  (  )  ;  final  ConvergenceChecker<PointVectorValuePair>  checker  =  getConvergenceChecker  (  )  ;  if  (  checker  =  =  null  )  {  throw  new  NullArgumentException  (  )  ;  }  final  double[]  targetValues  =  getTarget  (  )  ;  final  int  nR  =  targetValues  .  length  ;  //  Number  of  observed  data  .  final  RealMatrix  weightMatrix  =  getWeight  (  )  ;  final  double[]  residualsWeights  =  new  double[nR]  ;  for  (  int  i  =  0  ;  i  <  nR  ;  i++  )  {  residualsWeights[i]  =  weightMatrix  .  getEntry  (  i  ,  i  )  ;  }  final  double[]  currentPoint  =  getStartPoint  (  )  ;  final  int  nC  =  currentPoint  .  length  ;  PointVectorValuePair  current  =  null  ;  [BUGGY]  int  iter  =  0  ;  for  (  boolean  converged  =  false  ;  !converged  ;  )  {  ++iter  ;  PointVectorValuePair  previous  =  current  ;  	Math_6_GaussNewtonOptimizer_2_1	106	2	src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
63	converged  =  checker.converged(getIterations(),  previous,  current);  	[BUGGY]  converged  =  checker  .  converged  (  iter  ,  previous  ,  current  )  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointVectorValuePair  [PARAMETER]  [CLASS]  GaussNewtonOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  PointVectorValuePair  current  previous  [TYPE]  boolean  converged  false  true  useLU  [TYPE]  double[]  ak  b  currentObjective  currentPoint  currentResiduals  dX  grad  residualsWeights  targetValues  [TYPE]  RealMatrix  mA  weightMatrix  weightedJacobian  [TYPE]  DecompositionSolver  solver  [TYPE]  double  residual  weight  wgk  wr  [TYPE]  SingularMatrixException  e  [TYPE]  double[][]  a  [TYPE]  int  i  iter  j  k  l  nC  nR  [CONTEXT]  double[]  ak  =  a[k]  ;  double  wgk  =  weight  *  grad[k]  ;  for  (  int  l  =  0  ;  l  <  nC  ;  ++l  )  {  ak[l]  +  =  wgk  *  grad[l]  ;  }  }  }  try  {  RealMatrix  mA  =  new  BlockRealMatrix  (  a  )  ;  DecompositionSolver  solver  =  useLU  ?  new  LUDecomposition  (  mA  )  .  getSolver  (  )  :  new  QRDecomposition  (  mA  )  .  getSolver  (  )  ;  final  double[]  dX  =  solver  .  solve  (  new  ArrayRealVector  (  b  ,  false  )  )  .  toArray  (  )  ;  for  (  int  i  =  0  ;  i  <  nC  ;  ++i  )  {  currentPoint[i]  +  =  dX[i]  ;  }  }  catch  (  SingularMatrixException  e  )  {  throw  new  ConvergenceException  (  LocalizedFormats  .  UNABLE_TO_SOLVE_SINGULAR_PROBLEM  )  ;  }  if  (  previous  !  =  null  )  {  [BUGGY]  converged  =  checker  .  converged  (  iter  ,  previous  ,  current  )  ;  if  (  converged  )  {  setCost  (  computeCost  (  currentResiduals  )  )  ;  return  current  ;  }  }  	Math_6_GaussNewtonOptimizer_2_2	160	1	src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/GaussNewtonOptimizer.java
64	incrementIterationCount();  	[BUGGY]  int  iter  =  0  ;  ++iter  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointVectorValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  PointVectorValuePair  current  previous  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  currentObjective  currentPoint  currentResiduals  diag  diagR  jacNorm  lmDir  oldObj  oldRes  oldX  qtf  tmpVec  weightedResidual  work1  work2  work3  [TYPE]  RealMatrix  weightMatrixSqrt  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  currentCost  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  double[][]  weightedJacobian  [TYPE]  int[]  permutation  [TYPE]  int  i  iter  j  k  nC  nR  pj  pk  rank  solvedCols  [CONTEXT]  lmDir  =  new  double[nC]  ;  double  delta  =  0  ;  double  xNorm  =  0  ;  double[]  diag  =  new  double[nC]  ;  double[]  oldX  =  new  double[nC]  ;  double[]  oldRes  =  new  double[nR]  ;  double[]  oldObj  =  new  double[nR]  ;  double[]  qtf  =  new  double[nR]  ;  double[]  work1  =  new  double[nC]  ;  double[]  work2  =  new  double[nC]  ;  double[]  work3  =  new  double[nC]  ;  final  RealMatrix  weightMatrixSqrt  =  getWeightSquareRoot  (  )  ;  double[]  currentObjective  =  computeObjectiveValue  (  currentPoint  )  ;  double[]  currentResiduals  =  computeResiduals  (  currentObjective  )  ;  PointVectorValuePair  current  =  new  PointVectorValuePair  (  currentPoint  ,  currentObjective  )  ;  double  currentCost  =  computeCost  (  currentResiduals  )  ;  lmPar  =  0  ;  boolean  firstIteration  =  true  ;  [BUGGY]  int  iter  =  0  ;  final  ConvergenceChecker<PointVectorValuePair>  checker  =  getConvergenceChecker  (  )  ;  while  (  true  )  {  ++iter  ;  final  PointVectorValuePair  previous  =  current  ;  	Math_6_LevenbergMarquardtOptimizer_2_1	322	2	src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
65	if  (checker.converged(getIterations(),  previous,  current))  {  	[BUGGY]  if  (  checker  .  converged  (  iter  ,  previous  ,  current  )  )  {  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getIterations  (  )  >  0  )  ;  [METHOD]  doOptimize  [TYPE]  PointVectorValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  PointVectorValuePair  current  previous  [TYPE]  ConvergenceChecker  checker  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  currentObjective  currentPoint  currentResiduals  diag  diagR  jacNorm  lmDir  oldObj  oldRes  oldX  qtf  tmpVec  weightedResidual  work1  work2  work3  [TYPE]  RealMatrix  weightMatrixSqrt  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  currentCost  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  double[][]  weightedJacobian  [TYPE]  int[]  permutation  [TYPE]  int  i  iter  j  k  nC  nR  pj  pk  rank  solvedCols  [CONTEXT]  (  actRed  <  0  )  ?  (  0  .  5  *  dirDer  /  (  dirDer  +  0  .  5  *  actRed  )  )  :  0  .  5  ;  if  (  (  0  .  1  *  currentCost  >  =  previousCost  )  ||  (  tmp  <  0  .  1  )  )  {  tmp  =  0  .  1  ;  }  delta  =  tmp  *  FastMath  .  min  (  delta  ,  10  .  0  *  lmNorm  )  ;  lmPar  /  =  tmp  ;  }  else  if  (  (  lmPar  =  =  0  )  ||  (  ratio  >  =  0  .  75  )  )  {  delta  =  2  *  lmNorm  ;  lmPar  *  =  0  .  5  ;  }  if  (  ratio  >  =  1  .  0e-4  )  {  firstIteration  =  false  ;  xNorm  =  0  ;  for  (  int  k  =  0  ;  k  <  nC  ;  ++k  )  {  double  xK  =  diag[k]  *  currentPoint[k]  ;  xNorm  +  =  xK  *  xK  ;  }  xNorm  =  FastMath  .  sqrt  (  xNorm  )  ;  if  (  checker  !  =  null  )  {  [BUGGY]  if  (  checker  .  converged  (  iter  ,  previous  ,  current  )  )  {  setCost  (  currentCost  )  ;  return  current  ;  }  }  }  else  {  	Math_6_LevenbergMarquardtOptimizer_2_2	489	1	src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/LevenbergMarquardtOptimizer.java
66	for  (final  EventState  state  :  eventsStates)  {  state.stepAccepted(eventT,  eventY);  isLastStep  =  isLastStep  ||  state.stop();  }  	[BUGGY]  currentEvent  .  stepAccepted  (  eventT  ,  eventY  )  ;  isLastStep  =  currentEvent  .  stop  (  )  ;  [FE]  AssertionFailedError  [METHOD]  acceptStep  [TYPE]  double  [PARAMETER]  AbstractStepInterpolator  interpolator  final  double[]  y  final  double[]  yDot  final  double  tEnd  [CLASS]  AbstractIntegrator  [TYPE]  ExpandableStatefulODE  expandable  [TYPE]  EventState  currentEvent  es0  es1  remaining  state  [TYPE]  double  currentT  eventT  previousT  stepSize  stepStart  tEnd  [TYPE]  Incrementor  evaluations  [TYPE]  StepHandler  handler  [TYPE]  String  name  [TYPE]  SortedSet  occuringEvents  [TYPE]  int  orderingSign  [TYPE]  boolean  false  isLastStep  needReset  resetOccurred  statesInitialized  true  [TYPE]  double[]  currentY  eventY  y  yDot  [TYPE]  Iterator  iterator  [TYPE]  Collection  eventsStates  stepHandlers  [TYPE]  AbstractStepInterpolator  interpolator  [CONTEXT]  for  (  final  EventState  state  :  eventsStates  )  {  if  (  state  .  evaluateStep  (  interpolator  )  )  {  occuringEvents  .  add  (  state  )  ;  }  }  while  (  !occuringEvents  .  isEmpty  (  )  )  {  final  Iterator<EventState>  iterator  =  occuringEvents  .  iterator  (  )  ;  final  EventState  currentEvent  =  iterator  .  next  (  )  ;  iterator  .  remove  (  )  ;  final  double  eventT  =  currentEvent  .  getEventTime  (  )  ;  interpolator  .  setSoftPreviousTime  (  previousT  )  ;  interpolator  .  setSoftCurrentTime  (  eventT  )  ;  interpolator  .  setInterpolatedTime  (  eventT  )  ;  final  double[]  eventY  =  interpolator  .  getInterpolatedState  (  )  .  clone  (  )  ;  [BUGGY]  currentEvent  .  stepAccepted  (  eventT  ,  eventY  )  ;  isLastStep  =  currentEvent  .  stop  (  )  ;  for  (  final  StepHandler  handler  :  stepHandlers  )  {  handler  .  handleStep  (  interpolator  ,  isLastStep  )  ;  	Math_7_AbstractIntegrator_4_1	346	2	src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java
67		[BUGGY]  for  (  final  EventState  remaining  :  occuringEvents  )  {  remaining  .  stepAccepted  (  eventT  ,  eventY  )  ;  }  [FE]  AssertionFailedError  [METHOD]  acceptStep  [TYPE]  double  [PARAMETER]  AbstractStepInterpolator  interpolator  final  double[]  y  final  double[]  yDot  final  double  tEnd  [CLASS]  AbstractIntegrator  [TYPE]  ExpandableStatefulODE  expandable  [TYPE]  EventState  currentEvent  es0  es1  remaining  state  [TYPE]  double  currentT  eventT  previousT  stepSize  stepStart  tEnd  [TYPE]  Incrementor  evaluations  [TYPE]  StepHandler  handler  [TYPE]  String  name  [TYPE]  SortedSet  occuringEvents  [TYPE]  int  orderingSign  [TYPE]  boolean  false  isLastStep  needReset  resetOccurred  statesInitialized  true  [TYPE]  double[]  currentY  eventY  y  yDot  [TYPE]  Iterator  iterator  [TYPE]  Collection  eventsStates  stepHandlers  [TYPE]  AbstractStepInterpolator  interpolator  [CONTEXT]  final  Iterator<EventState>  iterator  =  occuringEvents  .  iterator  (  )  ;  final  EventState  currentEvent  =  iterator  .  next  (  )  ;  iterator  .  remove  (  )  ;  final  double  eventT  =  currentEvent  .  getEventTime  (  )  ;  interpolator  .  setSoftPreviousTime  (  previousT  )  ;  interpolator  .  setSoftCurrentTime  (  eventT  )  ;  interpolator  .  setInterpolatedTime  (  eventT  )  ;  final  double[]  eventY  =  interpolator  .  getInterpolatedState  (  )  .  clone  (  )  ;  currentEvent  .  stepAccepted  (  eventT  ,  eventY  )  ;  isLastStep  =  currentEvent  .  stop  (  )  ;  for  (  final  StepHandler  handler  :  stepHandlers  )  {  handler  .  handleStep  (  interpolator  ,  isLastStep  )  ;  }  if  (  isLastStep  )  {  System  .  arraycopy  (  eventY  ,  0  ,  y  ,  0  ,  y  .  length  )  ;  [BUGGY]  for  (  final  EventState  remaining  :  occuringEvents  )  {  remaining  .  stepAccepted  (  eventT  ,  eventY  )  ;  }  return  eventT  ;  }  	Math_7_AbstractIntegrator_4_2	357	3	src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java
68	boolean  needReset  =  false;  for  (final  EventState  state  :  eventsStates)  {  needReset  =  needReset  ||  state.reset(eventT,  eventY);  }  	[BUGGY]  boolean  needReset  =  currentEvent  .  reset  (  eventT  ,  eventY  )  ;  [FE]  AssertionFailedError  [METHOD]  acceptStep  [TYPE]  double  [PARAMETER]  AbstractStepInterpolator  interpolator  final  double[]  y  final  double[]  yDot  final  double  tEnd  [CLASS]  AbstractIntegrator  [TYPE]  ExpandableStatefulODE  expandable  [TYPE]  EventState  currentEvent  es0  es1  remaining  state  [TYPE]  double  currentT  eventT  previousT  stepSize  stepStart  tEnd  [TYPE]  Incrementor  evaluations  [TYPE]  StepHandler  handler  [TYPE]  String  name  [TYPE]  SortedSet  occuringEvents  [TYPE]  int  orderingSign  [TYPE]  boolean  false  isLastStep  needReset  resetOccurred  statesInitialized  true  [TYPE]  double[]  currentY  eventY  y  yDot  [TYPE]  Iterator  iterator  [TYPE]  Collection  eventsStates  stepHandlers  [TYPE]  AbstractStepInterpolator  interpolator  [CONTEXT]  interpolator  .  setSoftPreviousTime  (  previousT  )  ;  interpolator  .  setSoftCurrentTime  (  eventT  )  ;  interpolator  .  setInterpolatedTime  (  eventT  )  ;  final  double[]  eventY  =  interpolator  .  getInterpolatedState  (  )  .  clone  (  )  ;  currentEvent  .  stepAccepted  (  eventT  ,  eventY  )  ;  isLastStep  =  currentEvent  .  stop  (  )  ;  for  (  final  StepHandler  handler  :  stepHandlers  )  {  handler  .  handleStep  (  interpolator  ,  isLastStep  )  ;  }  if  (  isLastStep  )  {  System  .  arraycopy  (  eventY  ,  0  ,  y  ,  0  ,  y  .  length  )  ;  for  (  final  EventState  remaining  :  occuringEvents  )  {  remaining  .  stepAccepted  (  eventT  ,  eventY  )  ;  }  return  eventT  ;  }  [BUGGY]  boolean  needReset  =  currentEvent  .  reset  (  eventT  ,  eventY  )  ;  if  (  needReset  )  {  System  .  arraycopy  (  eventY  ,  0  ,  y  ,  0  ,  y  .  length  )  ;  computeDerivatives  (  eventT  ,  y  ,  yDot  )  ;  	Math_7_AbstractIntegrator_4_3	363	1	src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java
69		[BUGGY]  for  (  final  EventState  remaining  :  occuringEvents  )  {  remaining  .  stepAccepted  (  eventT  ,  eventY  )  ;  }  [FE]  AssertionFailedError  [METHOD]  acceptStep  [TYPE]  double  [PARAMETER]  AbstractStepInterpolator  interpolator  final  double[]  y  final  double[]  yDot  final  double  tEnd  [CLASS]  AbstractIntegrator  [TYPE]  ExpandableStatefulODE  expandable  [TYPE]  EventState  currentEvent  es0  es1  remaining  state  [TYPE]  double  currentT  eventT  previousT  stepSize  stepStart  tEnd  [TYPE]  Incrementor  evaluations  [TYPE]  StepHandler  handler  [TYPE]  String  name  [TYPE]  SortedSet  occuringEvents  [TYPE]  int  orderingSign  [TYPE]  boolean  false  isLastStep  needReset  resetOccurred  statesInitialized  true  [TYPE]  double[]  currentY  eventY  y  yDot  [TYPE]  Iterator  iterator  [TYPE]  Collection  eventsStates  stepHandlers  [TYPE]  AbstractStepInterpolator  interpolator  [CONTEXT]  currentEvent  .  stepAccepted  (  eventT  ,  eventY  )  ;  isLastStep  =  currentEvent  .  stop  (  )  ;  for  (  final  StepHandler  handler  :  stepHandlers  )  {  handler  .  handleStep  (  interpolator  ,  isLastStep  )  ;  }  if  (  isLastStep  )  {  System  .  arraycopy  (  eventY  ,  0  ,  y  ,  0  ,  y  .  length  )  ;  for  (  final  EventState  remaining  :  occuringEvents  )  {  remaining  .  stepAccepted  (  eventT  ,  eventY  )  ;  }  return  eventT  ;  }  boolean  needReset  =  currentEvent  .  reset  (  eventT  ,  eventY  )  ;  if  (  needReset  )  {  System  .  arraycopy  (  eventY  ,  0  ,  y  ,  0  ,  y  .  length  )  ;  computeDerivatives  (  eventT  ,  y  ,  yDot  )  ;  resetOccurred  =  true  ;  [BUGGY]  for  (  final  EventState  remaining  :  occuringEvents  )  {  remaining  .  stepAccepted  (  eventT  ,  eventY  )  ;  }  return  eventT  ;  }  	Math_7_AbstractIntegrator_4_4	370	3	src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java
70	public  Object[]  sample(int  sampleSize)  throws  NotStrictlyPositiveException  {  	[BUGGY]  public  T[]  sample  (  int  sampleSize  )  throws  NotStrictlyPositiveException  {  [FE]  ArrayStoreException:  orgapachecommonsmath3distributionDiscreteRealDistributionTest$2  Assert  .  assertEquals  (  1  ,  new  DiscreteDistribution<Object>  (  list  )  .  sample  (  1  )  .  length  )  ;  [CLASS]  [CONTEXT]  	Math_8_DiscreteDistribution_2_1	181	1	src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java
71	final  Object[]  out  =  new  Object[sampleSize];  	[BUGGY]  final  T[]out  =  (  T[]  )  java  .  lang  .  reflect  .  Array  .  newInstance  (  singletons  .  get  (  0  )  .  getClass  (  )  ,  sampleSize  )  ;  [FE]  ArrayStoreException:  orgapachecommonsmath3distributionDiscreteRealDistributionTest$2  Assert  .  assertEquals  (  1  ,  new  DiscreteDistribution<Object>  (  list  )  .  sample  (  1  )  .  length  )  ;  [METHOD]  sample  [TYPE]  T[]  [PARAMETER]  int  sampleSize  [CLASS]  DiscreteDistribution  [TYPE]  List  singletons  [TYPE]  boolean  false  true  [TYPE]  double[]  probabilities  [TYPE]  RandomGenerator  random  [TYPE]  int  i  sampleSize  [TYPE]  T[]  out  [CONTEXT]  public  T[]  sample  (  int  sampleSize  )  throws  NotStrictlyPositiveException  {  if  (  sampleSize  <  =  0  )  {  throw  new  NotStrictlyPositiveException  (  LocalizedFormats  .  NUMBER_OF_SAMPLES  ,  sampleSize  )  ;  }  [BUGGY]  final  T[]out  =  (  T[]  )  java  .  lang  .  reflect  .  Array  .  newInstance  (  singletons  .  get  (  0  )  .  getClass  (  )  ,  sampleSize  )  ;  for  (  int  i  =  0  ;  i  <  sampleSize  ;  i++  )  {  out[i]  =  sample  (  )  ;  }  return  out  ;  }  	Math_8_DiscreteDistribution_2_2	187	1	src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java
72	final  Line  reverted  =  new  Line(this);  reverted.direction  =  reverted.direction.negate();  	[BUGGY]  final  Line  reverted  =  new  Line  (  zero  ,  zero  .  subtract  (  direction  )  )  ;  [FE]  AssertionFailedError:  arrays  first  differed  at  element  [0]  ;  expected:<0028581782127907646>  but  was:<0028581782243293483>  Assert  .  assertArrayEquals  (  expected  .  toArray  (  )  ,  reverted  .  getDirection  (  )  .  toArray  (  )  ,  0  )  ;  [METHOD]  revert  [TYPE]  Line  [PARAMETER]  [CLASS]  Line  [TYPE]  Line  reverted  [TYPE]  Vector3D  direction  zero  [TYPE]  boolean  false  true  [CONTEXT]  public  Line  revert  (  )  {  [BUGGY]  final  Line  reverted  =  new  Line  (  zero  ,  zero  .  subtract  (  direction  )  )  ;  return  reverted  ;  }  	Math_9_Line_1_1	87	1	src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java
73	result[resultOffset]  =  FastMath.atan2(y[yOffset],  x[xOffset]);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<00>  but  was:<NaN>  Assert  .  assertEquals  (  -FastMath  .  PI  ,  nn  .  getValue  (  )  ,  1  .  0e-15  )  ;  [METHOD]  atan2  [TYPE]  void  [PARAMETER]  final  double[]  y  final  int  yOffset  final  double[]  x  final  int  xOffset  final  double[]  result  final  int  resultOffset  [CLASS]  DSCompiler  [TYPE]  int[][][]  compIndirection  multIndirection  [TYPE]  int[][]  derivativesIndirection  sizes  [TYPE]  boolean  false  true  [TYPE]  double[]  result  tmp1  tmp2  x  y  [TYPE]  AtomicReference  compilers  [TYPE]  int[]  lowerIndirection  [TYPE]  int  i  order  parameters  resultOffset  xOffset  yOffset  [CONTEXT]  if  (  x[xOffset]  >  =  0  )  {  add  (  tmp1  ,  0  ,  x  ,  xOffset  ,  tmp2  ,  0  )  ;  //  r  +  x  divide  (  y  ,  yOffset  ,  tmp2  ,  0  ,  tmp1  ,  0  )  ;  //  y  /  (  r  +  x  )  atan  (  tmp1  ,  0  ,  tmp2  ,  0  )  ;  //  atan  (  y  /  (  r  +  x  )  )  for  (  int  i  =  0  ;  i  <  tmp2  .  length  ;  ++i  )  {  result[resultOffset  +  i]  =  2  *  tmp2[i]  ;  //  2  *  atan  (  y  /  (  r  +  x  )  )  }  }  else  {  subtract  (  tmp1  ,  0  ,  x  ,  xOffset  ,  tmp2  ,  0  )  ;  //  r  -  x  divide  (  y  ,  yOffset  ,  tmp2  ,  0  ,  tmp1  ,  0  )  ;  //  y  /  (  r  -  x  )  atan  (  tmp1  ,  0  ,  tmp2  ,  0  )  ;  //  atan  (  y  /  (  r  -  x  )  )  result[resultOffset]  =  (  (  tmp2[0]  <  =  0  )  ?  -FastMath  .  PI  :  FastMath  .  PI  )  -  2  *  tmp2[0]  ;  //  +/-pi  -  2  *  atan  (  y  /  (  r  -  x  )  )  for  (  int  i  =  1  ;  i  <  tmp2  .  length  ;  ++i  )  {  result[resultOffset  +  i]  =  -2  *  tmp2[i]  ;  //  +/-pi  -  2  *  atan  (  y  /  (  r  -  x  )  )  }  }  [BUGGY]  }  	Math_10_DSCompiler_1_1	1419	0	src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java
74	return  FastMath.pow(2  *  FastMath.PI,  -0.5  *  dim)  *  	[BUGGY]  return  FastMath  .  pow  (  2  *  FastMath  .  PI  ,  -dim  /  2  )  *  [FE]  AssertionFailedError:  expected:<023644016090654427>  but  was:<05926675925866471>  Assert  .  assertEquals  (  uni  .  density  (  v  )  ,  multi  .  density  (  new  double[]  {  v  }  )  ,  tol  )  ;  [METHOD]  density  [TYPE]  double  [PARAMETER]  final  double[]  vals  [CLASS]  MultivariateNormalDistribution  [TYPE]  boolean  false  true  [TYPE]  double[]  means  vals  [TYPE]  RealMatrix  covarianceMatrix  covarianceMatrixInverse  samplingMatrix  [TYPE]  double  covarianceMatrixDeterminant  [TYPE]  int  dim  [CONTEXT]  public  double  density  (  final  double[]  vals  )  throws  DimensionMismatchException  {  final  int  dim  =  getDimension  (  )  ;  if  (  vals  .  length  !  =  dim  )  {  throw  new  DimensionMismatchException  (  vals  .  length  ,  dim  )  ;  }  [BUGGY]  return  FastMath  .  pow  (  2  *  FastMath  .  PI  ,  -dim  /  2  )  *  FastMath  .  pow  (  covarianceMatrixDeterminant  ,  -0  .  5  )  *  getExponentTerm  (  vals  )  ;  }  	Math_11_MultivariateNormalDistribution_1_1	183	1	src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java
75		[BUGGY]  [FE]  AssertionFailedError:  expected:<10688186123440644>  but  was:<13675503685260901>  [CLASS]  [CONTEXT]  	Math_12_BitsStreamGenerator_2_1	19	0	src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java
76	implements  RandomGenerator,  Serializable  {  private  static  final  long  serialVersionUID  =  20130104L;  	[BUGGY]  implements  RandomGenerator  {  [FE]  AssertionFailedError:  expected:<10688186123440644>  but  was:<13675503685260901>  [CLASS]  [CONTEXT]  	Math_12_BitsStreamGenerator_2_2	29	1	src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java
77	if  (m  instanceof  DiagonalMatrix)  {  final  int  dim  =  m.getRowDimension();  final  RealMatrix  sqrtM  =  new  DiagonalMatrix(dim);  for  (int  i  =  0;  i  <  dim;  i++)  {  sqrtM.setEntry(i,  i,  FastMath.sqrt(m.getEntry(i,  i)));  }  return  sqrtM;  }  else  {  }  	[BUGGY]  [FE]  OutOfMemoryError:  Java  heap  space  Assert  .  assertTrue  (  (  !  solvable  )  &&  (  degree  >  0  )  )  ;  [METHOD]  squareRoot  [TYPE]  RealMatrix  [PARAMETER]  RealMatrix  m  [CLASS]  AbstractLeastSquaresOptimizer  [TYPE]  EigenDecomposition  dec  [TYPE]  boolean  false  true  [TYPE]  double[]  objective  point  weightedResiduals  [TYPE]  MultivariateDifferentiableVectorFunction  jF  [TYPE]  RealMatrix  m  weightMatrixSqrt  [TYPE]  double  DEFAULT_SINGULARITY_THRESHOLD  cost  [TYPE]  double[][]  weightedResidualJacobian  [TYPE]  int  cols  jacobianEvaluations  rows  [CONTEXT]  private  RealMatrix  squareRoot  (  RealMatrix  m  )  {  [BUGGY]  final  EigenDecomposition  dec  =  new  EigenDecomposition  (  m  )  ;  return  dec  .  getSquareRoot  (  )  ;  }  	Math_13_AbstractLeastSquaresOptimizer_1_1	562	0	src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java
78	if  (m  instanceof  DiagonalMatrix)  {  final  int  dim  =  m.getRowDimension();  final  RealMatrix  sqrtM  =  new  DiagonalMatrix(dim);  for  (int  i  =  0;  i  <  dim;  i++)  {  sqrtM.setEntry(i,  i,  FastMath.sqrt(m.getEntry(i,  i)));  }  return  sqrtM;  }  else  {  }  	[BUGGY]  [FE]  OutOfMemoryError:  Java  heap  space  Assert  .  assertTrue  (  (  !  solvable  )  &&  (  degree  >  0  )  )  ;  [METHOD]  squareRoot  [TYPE]  RealMatrix  [PARAMETER]  RealMatrix  m  [CLASS]  AbstractLeastSquaresOptimizer  [TYPE]  EigenDecomposition  dec  [TYPE]  boolean  false  true  [TYPE]  RealMatrix  m  weightMatrixSqrt  [TYPE]  double  cost  [CONTEXT]  private  RealMatrix  squareRoot  (  RealMatrix  m  )  {  [BUGGY]  final  EigenDecomposition  dec  =  new  EigenDecomposition  (  m  )  ;  return  dec  .  getSquareRoot  (  )  ;  }  	Math_14_AbstractLeastSquaresOptimizer_1_1	267	0	src/main/java/org/apache/commons/math3/optim/nonlinear/vector/jacobian/AbstractLeastSquaresOptimizer.java
79	weightMatrix  =  new  DiagonalMatrix(weight);  	[BUGGY]  weightMatrix  =  org  .  apache  .  commons  .  math3  .  linear  .  MatrixUtils  .  createRealMatrix  (  dim  ,  dim  )  ;  for  (  int  i  =  0  ;  i  <  dim  ;  i++  )  {  weightMatrix  .  setEntry  (  i  ,  i  ,  weight[i]  )  ;  }  [FE]  OutOfMemoryError:  Java  heap  space  Assert  .  assertTrue  (  (  !  solvable  )  &&  (  degree  >  0  )  )  ;  [CLASS]  [CONTEXT]  	Math_14_Weight_1_1	43	4	src/main/java/org/apache/commons/math3/optim/nonlinear/vector/Weight.java
81	if  (y  >=  TWO_POWER_53  ||  y  <=  -TWO_POWER_53)  {  	[BUGGY]  if  (  y  >  =  TWO_POWER_52  ||  y  <  =  -TWO_POWER_52  )  {  [FE]  AssertionFailedError:  expected:<-10>  but  was:<10>  Assert  .  assertEquals  (  Math  .  pow  (  x  ,  -y  )  ,  [METHOD]  pow  [TYPE]  double  [PARAMETER]  double  x  double  y  [CLASS]  FastMath  [TYPE]  boolean  RECOMPUTE_TABLES_AT_RUNTIME  false  true  [TYPE]  double[]  CBRTTWO  COSINE_TABLE_A  COSINE_TABLE_B  EIGHTHS  EXP_FRAC_TABLE_A  EXP_FRAC_TABLE_B  EXP_INT_TABLE_A  EXP_INT_TABLE_B  SINE_TABLE_A  SINE_TABLE_B  TANGENT_TABLE_A  TANGENT_TABLE_B  lns  [TYPE]  long[]  PI_O_4_BITS  RECIP_2PI  [TYPE]  double  E  F_11_12  F_13_14  F_15_16  F_1_11  F_1_13  F_1_15  F_1_17  F_1_2  F_1_3  F_1_4  F_1_5  F_1_7  F_1_9  F_3_4  F_5_6  F_7_8  F_9_10  LN_2_A  LN_2_B  LOG_MAX_VALUE  PI  TWO_POWER_52  aa  ab  finalRemA  finalRemB  lna  lnb  lores  result  tmp1  tmp2  x  y  ya  yb  z  [TYPE]  double[][]  LN_HI_PREC_COEF  LN_MANT  LN_QUICK_COEF  [TYPE]  int  EXP_FRAC_TABLE_LEN  EXP_INT_TABLE_LEN  EXP_INT_TABLE_MAX_INDEX  LN_MANT_LEN  SINE_TABLE_LEN  finalK  [TYPE]  long  HEX_40000000  MASK_30BITS  bits  yi  [CONTEXT]  long  yi  =  (  long  )  y  ;  if  (  y  =  =  yi  &&  (  yi  &  1  )  =  =  1  )  {  return  Double  .  NEGATIVE_INFINITY  ;  }  return  Double  .  POSITIVE_INFINITY  ;  }  }  if  (  y  =  =  Double  .  NEGATIVE_INFINITY  )  {  if  (  x  *  x  =  =  1  .  0  )  {  return  Double  .  NaN  ;  }  if  (  x  *  x  <  1  .  0  )  {  return  Double  .  POSITIVE_INFINITY  ;  }  else  {  return  0  .  0  ;  }  }  if  (  x  <  0  )  {  [BUGGY]  if  (  y  >  =  TWO_POWER_52  ||  y  <  =  -TWO_POWER_52  )  {  return  pow  (  -x  ,  y  )  ;  }  if  (  y  =  =  (  long  )  y  )  {  	Math_15_FastMath_1_1	1541	1	src/main/java/org/apache/commons/math3/util/FastMath.java
82	private  static  final  double  LOG_MAX_VALUE  =  StrictMath.log(Double.MAX_VALUE);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<00>  but  was:<Infinity>  Assert  .  assertEquals  (  0  ,  maxErr  ,  3  )  ;  [CLASS]  [CONTEXT]  	Math_16_FastMath_3_1	82	0	src/main/java/org/apache/commons/math3/util/FastMath.java
83	if  (x  >=  LOG_MAX_VALUE)  {  final  double  t  =  exp(0.5  *  x);  return  (0.5  *  t)  *  t;  }  else  {  }  else  if  (x  <  -20)  {  if  (x  <=  -LOG_MAX_VALUE)  {  final  double  t  =  exp(-0.5  *  x);  return  (0.5  *  t)  *  t;  }  else  {  }  	[BUGGY]  if  (  x  <  -20  )  {  [FE]  AssertionFailedError:  expected:<00>  but  was:<Infinity>  Assert  .  assertEquals  (  0  ,  maxErr  ,  3  )  ;  [METHOD]  cosh  [TYPE]  double  [PARAMETER]  double  x  [CLASS]  FastMath  [TYPE]  boolean  RECOMPUTE_TABLES_AT_RUNTIME  false  true  [TYPE]  double[]  CBRTTWO  COSINE_TABLE_A  COSINE_TABLE_B  EIGHTHS  EXP_FRAC_TABLE_A  EXP_FRAC_TABLE_B  EXP_INT_TABLE_A  EXP_INT_TABLE_B  SINE_TABLE_A  SINE_TABLE_B  TANGENT_TABLE_A  TANGENT_TABLE_B  hiPrec  [TYPE]  long[]  PI_O_4_BITS  RECIP_2PI  [TYPE]  double  E  F_11_12  F_13_14  F_15_16  F_1_11  F_1_13  F_1_15  F_1_17  F_1_2  F_1_3  F_1_4  F_1_5  F_1_7  F_1_9  F_3_4  F_5_6  F_7_8  F_9_10  LN_2_A  LN_2_B  PI  TWO_POWER_52  finalRemA  finalRemB  recip  recipa  recipb  result  temp  x  ya  yaa  yab  yb  [TYPE]  double[][]  LN_HI_PREC_COEF  LN_MANT  LN_QUICK_COEF  [TYPE]  int  EXP_FRAC_TABLE_LEN  EXP_INT_TABLE_LEN  EXP_INT_TABLE_MAX_INDEX  LN_MANT_LEN  SINE_TABLE_LEN  finalK  [TYPE]  long  HEX_40000000  MASK_30BITS  [CONTEXT]  public  static  double  cosh  (  double  x  )  {  if  (  x  !  =  x  )  {  return  x  ;  }  if  (  x  >  20  )  {  [BUGGY]  return  0  .  5  *  exp  (  x  )  ;  }  if  (  x  <  -20  )  {  return  0  .  5  *  exp  (  -x  )  ;  	Math_16_FastMath_3_2	394	1	src/main/java/org/apache/commons/math3/util/FastMath.java
84	if  (x  >=  LOG_MAX_VALUE)  {  final  double  t  =  exp(0.5  *  x);  return  (0.5  *  t)  *  t;  }  else  {  }  else  if  (x  <  -20)  {  if  (x  <=  -LOG_MAX_VALUE)  {  final  double  t  =  exp(-0.5  *  x);  return  (-0.5  *  t)  *  t;  }  else  {  }  	[BUGGY]  if  (  x  <  -20  )  {  [FE]  AssertionFailedError:  expected:<00>  but  was:<Infinity>  Assert  .  assertEquals  (  0  ,  maxErr  ,  3  )  ;  [METHOD]  sinh  [TYPE]  double  [PARAMETER]  double  x  [CLASS]  FastMath  [TYPE]  boolean  RECOMPUTE_TABLES_AT_RUNTIME  false  negate  true  [TYPE]  double[]  CBRTTWO  COSINE_TABLE_A  COSINE_TABLE_B  EIGHTHS  EXP_FRAC_TABLE_A  EXP_FRAC_TABLE_B  EXP_INT_TABLE_A  EXP_INT_TABLE_B  SINE_TABLE_A  SINE_TABLE_B  TANGENT_TABLE_A  TANGENT_TABLE_B  hiPrec  [TYPE]  long[]  PI_O_4_BITS  RECIP_2PI  [TYPE]  double  E  F_11_12  F_13_14  F_15_16  F_1_11  F_1_13  F_1_15  F_1_17  F_1_2  F_1_3  F_1_4  F_1_5  F_1_7  F_1_9  F_3_4  F_5_6  F_7_8  F_9_10  LN_2_A  LN_2_B  PI  TWO_POWER_52  denom  denomb  denomr  finalRemA  finalRemB  ra  ratio  rb  recip  recipa  recipb  result  temp  x  ya  yaa  yab  yb  za  zb  [TYPE]  double[][]  LN_HI_PREC_COEF  LN_MANT  LN_QUICK_COEF  [TYPE]  int  EXP_FRAC_TABLE_LEN  EXP_INT_TABLE_LEN  EXP_INT_TABLE_MAX_INDEX  LN_MANT_LEN  SINE_TABLE_LEN  finalK  [TYPE]  long  HEX_40000000  MASK_30BITS  [CONTEXT]  public  static  double  sinh  (  double  x  )  {  boolean  negate  =  false  ;  if  (  x  !  =  x  )  {  return  x  ;  }  if  (  x  >  20  )  {  [BUGGY]  return  0  .  5  *  exp  (  x  )  ;  }  if  (  x  <  -20  )  {  return  -0  .  5  *  exp  (  -x  )  ;  	Math_16_FastMath_3_3	455	1	src/main/java/org/apache/commons/math3/util/FastMath.java
85	if  (x  >=  0  &&  x  <  RADIX)  {  }  else  {  return  multiply(newInstance(x));  }  	[BUGGY]  [FE]  AssertionFailedError:  assersion  failed  Multiply  #37  x  =  NaN  flags  =  1  [METHOD]  multiply  [TYPE]  Dfp  [PARAMETER]  final  int  x  [CLASS]  Dfp  [TYPE]  DfpField  field  [TYPE]  int[]  mant  [TYPE]  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  [TYPE]  boolean  false  true  [TYPE]  byte  FINITE  INFINITE  QNAN  SNAN  nans  sign  [TYPE]  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  exp  x  [CONTEXT]  public  Dfp  multiply  (  final  int  x  )  {  [BUGGY]  return  multiplyFast  (  x  )  ;  }  	Math_17_Dfp_1_1	1603	0	src/main/java/org/apache/commons/math3/dfp/Dfp.java
86	res[i]  =  x[i]  /  diff;  	[BUGGY]  res[i]  =  (  x[i]  -  boundaries[0][i]  )  /  diff  ;  [FE]  AssertionFailedError:  expected:<11100000000388787>  but  was:<80>  Assert  .  assertEquals  (  expected  .  getPoint  (  )  [i]  ,  result  .  getPoint  (  )  [i]  ,  pointTol  )  ;  [METHOD]  encode  [TYPE]  double[]  [PARAMETER]  final  double[]  x  [CLASS]  FitnessFunction  [TYPE]  boolean  false  isRepairMode  true  [TYPE]  double[]  res  x  [TYPE]  double  diff  valueRange  [TYPE]  int  i  [CONTEXT]  public  double[]  encode  (  final  double[]  x  )  {  if  (  boundaries  =  =  null  )  {  return  x  ;  }  double[]  res  =  new  double[x  .  length]  ;  for  (  int  i  =  0  ;  i  <  x  .  length  ;  i++  )  {  double  diff  =  boundaries[1][i]  -  boundaries[0][i]  ;  [BUGGY]  res[i]  =  (  x[i]  -  boundaries[0][i]  )  /  diff  ;  }  return  res  ;  }  	Math_18_CMAESOptimizer_3_1	932	1	src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
87	res[i]  =  diff  *  x[i];  	[BUGGY]  res[i]  =  diff  *  x[i]  +  boundaries[0][i]  ;  [FE]  AssertionFailedError:  expected:<11100000000388787>  but  was:<80>  Assert  .  assertEquals  (  expected  .  getPoint  (  )  [i]  ,  result  .  getPoint  (  )  [i]  ,  pointTol  )  ;  [METHOD]  decode  [TYPE]  double[]  [PARAMETER]  final  double[]  x  [CLASS]  FitnessFunction  [TYPE]  boolean  false  isRepairMode  true  [TYPE]  double[]  res  x  [TYPE]  double  diff  valueRange  [TYPE]  int  i  [CONTEXT]  public  double[]  decode  (  final  double[]  x  )  {  if  (  boundaries  =  =  null  )  {  return  x  ;  }  double[]  res  =  new  double[x  .  length]  ;  for  (  int  i  =  0  ;  i  <  x  .  length  ;  i++  )  {  double  diff  =  boundaries[1][i]  -  boundaries[0][i]  ;  [BUGGY]  res[i]  =  diff  *  x[i]  +  boundaries[0][i]  ;  }  return  res  ;  }  	Math_18_CMAESOptimizer_3_2	958	1	src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
88	final  double[]  bLoEnc  =  encode(boundaries[0]);  final  double[]  bHiEnc  =  encode(boundaries[1]);  if  (x[i]  <  bLoEnc[i])  {  if  (x[i]  >  bHiEnc[i])  {  	[BUGGY]  if  (  x[i]  <  0  )  {  if  (  x[i]  >  1  .  0  )  {  [FE]  AssertionFailedError:  expected:<11100000000388787>  but  was:<80>  Assert  .  assertEquals  (  expected  .  getPoint  (  )  [i]  ,  result  .  getPoint  (  )  [i]  ,  pointTol  )  ;  [METHOD]  isFeasible  [TYPE]  boolean  [PARAMETER]  final  double[]  x  [CLASS]  FitnessFunction  [TYPE]  boolean  false  isRepairMode  true  [TYPE]  double[]  x  [TYPE]  double  valueRange  [TYPE]  int  i  [CONTEXT]  public  boolean  isFeasible  (  final  double[]  x  )  {  if  (  boundaries  =  =  null  )  {  return  true  ;  }  [BUGGY]  for  (  int  i  =  0  ;  i  <  x  .  length  ;  i++  )  {  if  (  x[i]  <  0  )  {  return  false  ;  }  if  (  x[i]  >  1  .  0  )  {  return  false  ;  }  }  return  true  ;  }  	Math_18_CMAESOptimizer_3_3	990	2	src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
89	for  (int  i  =  0;  i  <  lB.length;  i++)  {  if  (Double.isInfinite(boundaries[1][i]  -  boundaries[0][i]))  {  final  double  max  =  Double.MAX_VALUE  +  boundaries[0][i];  final  NumberIsTooLargeException  e  =  new  NumberIsTooLargeException(boundaries[1][i],  max,  true);  e.getContext().addMessage(LocalizedFormats.OVERFLOW);  e.getContext().addMessage(LocalizedFormats.INDEX,  i);  throw  e;  }  }  	[BUGGY]  [FE]  Exception:  Unexpected  exception  ,  expected<orgapachecommonsmath3exceptionNumberIsTooLargeException>  but  was<orgapachecommonsmath3exceptionMathIllegalStateException>  Assert  .  assertEquals  (  expected  .  getPoint  (  )  [i]  ,  [METHOD]  checkParameters  [TYPE]  void  [PARAMETER]  [CLASS]  CMAESOptimizer  [TYPE]  boolean  DEFAULT_ISACTIVECMA  false  generateStatistics  hasFiniteBounds  hasInfiniteBounds  isActiveCMA  isMinimize  isRepairMode  true  [TYPE]  double[]  fitnessHistory  init  inputSigma  lB  uB  [TYPE]  RealMatrix  B  BD  C  D  diagC  diagD  pc  ps  weights  xmean  [TYPE]  double  DEFAULT_STOPFITNESS  cc  ccov1  ccov1Sep  ccovmu  ccovmuSep  chiN  cs  damps  logMu2  mueff  normps  sigma  stopFitness  stopTolFun  stopTolHistFun  stopTolUpX  stopTolX  value  valueRange  [TYPE]  double[][]  boundaries  [TYPE]  List  statisticsDHistory  statisticsFitnessHistory  statisticsMeanHistory  statisticsSigmaHistory  [TYPE]  int  DEFAULT_CHECKFEASABLECOUNT  DEFAULT_DIAGONALONLY  DEFAULT_MAXITERATIONS  checkFeasableCount  diagonalOnly  dimension  historySize  i  index  iterations  lambda  maxIterations  mu  [TYPE]  RandomGenerator  DEFAULT_RANDOMGENERATOR  random  [CONTEXT]  break  ;  }  }  boolean  hasInfiniteBounds  =  false  ;  if  (  hasFiniteBounds  )  {  for  (  int  i  =  0  ;  i  <  lB  .  length  ;  i++  )  {  if  (  Double  .  isInfinite  (  lB[i]  )  ||  Double  .  isInfinite  (  uB[i]  )  )  {  hasInfiniteBounds  =  true  ;  break  ;  }  }  if  (  hasInfiniteBounds  )  {  throw  new  MathUnsupportedOperationException  (  )  ;  }  else  {  boundaries  =  new  double[2][]  ;  boundaries[0]  =  lB  ;  boundaries[1]  =  uB  ;  [BUGGY]  }  }  else  {  boundaries  =  null  ;  }  	Math_19_CMAESOptimizer_1_1	540	0	src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
90	return  boundaries  !=  null  &&  isRepairMode  ?  decode(repair(x))  :  decode(x); 	[BUGGY]  return   decode(x); [FE]  AssertionFailedError:  Out  of  bounds  (  05246031767455861  >  05  )  Assert  .  assertEquals  (  expected  .  getPoint  (  )  [i]  ,  [METHOD]  repairAndDecode  [TYPE]  double[]  [PARAMETER]  final  double[]  x  [CLASS]  FitnessFunction  [TYPE]  double[]  x  [TYPE]  double  valueRange  [TYPE]  boolean  false  isRepairMode  true  [CONTEXT]  public  double[]  repairAndDecode  (  final  double[]  x  )  {  [BUGGY]  return  decode  (  x  )  ;  }  	Math_20_CMAESOptimizer_1_1	921	2	src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java
91		[BUGGY]  int[]  swap  =  new  int[order]  ;  [FE]  AssertionFailedError:  expected:<00>  but  was:<00180652917341963>  Assert  .  assertEquals  (  0  .  0  ,  m3  .  subtract  (  rebuiltM3  )  .  getNorm  (  )  ,  1  .  0e-16  )  ;  [CLASS]  [CONTEXT]  	Math_21_RectangularCholeskyDecomposition_5_1	69	1	src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java
92	int  swapR  =  r;  int  isr  =  index[swapR];  if  (c[ii][ii]  >  c[isr][isr])  {  swapR  =  i;  	[BUGGY]  swap[r]  =  r  ;  int  isi  =  index[swap[i]]  ;  if  (  c[ii][ii]  >  c[isi][isi]  )  {  swap[r]  =  i  ;  [FE]  AssertionFailedError:  expected:<00>  but  was:<00180652917341963>  Assert  .  assertEquals  (  0  .  0  ,  m3  .  subtract  (  rebuiltM3  )  .  getNorm  (  )  ,  1  .  0e-16  )  ;  [CLASS]  [CONTEXT]  	Math_21_RectangularCholeskyDecomposition_5_2	79	4	src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java
93	if  (swapR  !=  r)  {  final  int  tmpIndex  =  index[r];  index[r]    =  index[swapR];  index[swapR]    =  tmpIndex;  final  double[]  tmpRow  =  b[r];  b[r]    =  b[swapR];  b[swapR]    =  tmpRow;  	[BUGGY]  if  (  swap[r]  !  =  r  )  {  int  tmp  =  index[r]  ;  index[r]  =  index[swap[r]]  ;  index[swap[r]]  =  tmp  ;  [FE]  AssertionFailedError:  expected:<00>  but  was:<00180652917341963>  Assert  .  assertEquals  (  0  .  0  ,  m3  .  subtract  (  rebuiltM3  )  .  getNorm  (  )  ,  1  .  0e-16  )  ;  [CLASS]  [CONTEXT]  	Math_21_RectangularCholeskyDecomposition_5_3	90	4	src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java
94	final  double  inverse2  =  1  /  c[ir][ir];  	[BUGGY]  [FE]  AssertionFailedError:  expected:<00>  but  was:<00180652917341963>  Assert  .  assertEquals  (  0  .  0  ,  m3  .  subtract  (  rebuiltM3  )  .  getNorm  (  )  ,  1  .  0e-16  )  ;  [CLASS]  [CONTEXT]  	Math_21_RectangularCholeskyDecomposition_5_4	124	0	src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java
95	c[ii][ii]  -=  c[ii][ir]  *  c[ii][ir]  *  inverse2;  	[BUGGY]  c[ii][ii]  -  =  e  *  e  ;  [FE]  AssertionFailedError:  expected:<00>  but  was:<00180652917341963>  Assert  .  assertEquals  (  0  .  0  ,  m3  .  subtract  (  rebuiltM3  )  .  getNorm  (  )  ,  1  .  0e-16  )  ;  [CLASS]  [CONTEXT]  	Math_21_RectangularCholeskyDecomposition_5_5	128	1	src/main/java/org/apache/commons/math3/linear/RectangularCholeskyDecomposition.java
96	return  false;  	[BUGGY]  return  true  ;  [FE]  AssertionFailedError:  expected:<false>  but  was:<true>  [METHOD]  isSupportLowerBoundInclusive  [TYPE]  boolean  [PARAMETER]  [CLASS]  FDistribution  [TYPE]  boolean  false  numericalVarianceIsCalculated  true  [TYPE]  double  DEFAULT_INVERSE_ABSOLUTE_ACCURACY  denominatorDegreesOfFreedom  numeratorDegreesOfFreedom  numericalVariance  solverAbsoluteAccuracy  [TYPE]  long  serialVersionUID  [CONTEXT]  public  boolean  isSupportLowerBoundInclusive  (  )  {  [BUGGY]  return  true  ;  }  	Math_22_FDistribution_1_1	275	1	src/main/java/org/apache/commons/math3/distribution/FDistribution.java
97	return  true;  	[BUGGY]  return  false  ;  [FE]  AssertionFailedError:  expected:<false>  but  was:<true>  [METHOD]  isSupportUpperBoundInclusive  [TYPE]  boolean  [PARAMETER]  [CLASS]  UniformRealDistribution  [TYPE]  double  DEFAULT_INVERSE_ABSOLUTE_ACCURACY  lower  solverAbsoluteAccuracy  upper  [TYPE]  long  serialVersionUID  [TYPE]  boolean  false  true  [CONTEXT]  public  boolean  isSupportUpperBoundInclusive  (  )  {  [BUGGY]  return  false  ;  }  	Math_22_UniformRealDistribution_1_1	184	1	src/main/java/org/apache/commons/math3/distribution/UniformRealDistribution.java
98	UnivariatePointValuePair  best  =  current;  	[BUGGY]  [FE]  AssertionFailedError:  Best  point  not  reported  Assert  .  assertTrue  ( "Best  point  not  reported "  ,  f  .  value  (  sol  )  <  =  f  .  value  (  expected  )  )  ;  [METHOD]  doOptimize  [TYPE]  UnivariatePointValuePair  [PARAMETER]  [CLASS]  BrentOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  UnivariatePointValuePair  current  previous  [TYPE]  boolean  false  isMinim  stop  true  [TYPE]  double  GOLDEN_SECTION  MIN_RELATIVE_TOLERANCE  a  absoluteThreshold  b  d  e  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  relativeThreshold  tol1  tol2  u  v  w  x  [TYPE]  int  iter  [CONTEXT]  double  b  ;  if  (  lo  <  hi  )  {  a  =  lo  ;  b  =  hi  ;  }  else  {  a  =  hi  ;  b  =  lo  ;  }  double  x  =  mid  ;  double  v  =  x  ;  double  w  =  x  ;  double  d  =  0  ;  double  e  =  0  ;  double  fx  =  computeObjectiveValue  (  x  )  ;  if  (  !isMinim  )  {  fx  =  -fx  ;  }  double  fv  =  fx  ;  double  fw  =  fx  ;  UnivariatePointValuePair  previous  =  null  ;  UnivariatePointValuePair  current  =  new  UnivariatePointValuePair  (  x  ,  isMinim  ?  fx  :  -fx  )  ;  [BUGGY]  int  iter  =  0  ;  while  (  true  )  {  final  double  m  =  0  .  5  *  (  a  +  b  )  ;  final  double  tol1  =  relativeThreshold  *  FastMath  .  abs  (  x  )  +  absoluteThreshold  ;  final  double  tol2  =  2  *  tol1  ;  	Math_23_BrentOptimizer_4_1	151	0	src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
99	best  =  best(best,  best(current,  previous,  isMinim),  isMinim);  	[BUGGY]  [FE]  AssertionFailedError:  Best  point  not  reported  Assert  .  assertTrue  ( "Best  point  not  reported "  ,  f  .  value  (  sol  )  <  =  f  .  value  (  expected  )  )  ;  [METHOD]  doOptimize  [TYPE]  UnivariatePointValuePair  [PARAMETER]  [CLASS]  BrentOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  UnivariatePointValuePair  current  previous  [TYPE]  boolean  false  isMinim  stop  true  [TYPE]  double  GOLDEN_SECTION  MIN_RELATIVE_TOLERANCE  a  absoluteThreshold  b  d  e  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  relativeThreshold  tol1  tol2  u  v  w  x  [TYPE]  int  iter  [CONTEXT]  }  else  {  e  =  a  -  x  ;  }  d  =  GOLDEN_SECTION  *  e  ;  }  if  (  FastMath  .  abs  (  d  )  <  tol1  )  {  if  (  d  >  =  0  )  {  u  =  x  +  tol1  ;  }  else  {  u  =  x  -  tol1  ;  }  }  else  {  u  =  x  +  d  ;  }  double  fu  =  computeObjectiveValue  (  u  )  ;  if  (  !isMinim  )  {  fu  =  -fu  ;  }  previous  =  current  ;  current  =  new  UnivariatePointValuePair  (  u  ,  isMinim  ?  fu  :  -fu  )  ;  [BUGGY]  if  (  checker  !  =  null  )  {  if  (  checker  .  converged  (  iter  ,  previous  ,  current  )  )  {  return  best  (  current  ,  previous  ,  isMinim  )  ;  }  }  	Math_23_BrentOptimizer_4_2	234	0	src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
100	return  best;  	[BUGGY]  return  best  (  current  ,  previous  ,  isMinim  )  ;  [FE]  AssertionFailedError:  Best  point  not  reported  Assert  .  assertTrue  ( "Best  point  not  reported "  ,  f  .  value  (  sol  )  <  =  f  .  value  (  expected  )  )  ;  [METHOD]  doOptimize  [TYPE]  UnivariatePointValuePair  [PARAMETER]  [CLASS]  BrentOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  UnivariatePointValuePair  current  previous  [TYPE]  boolean  false  isMinim  stop  true  [TYPE]  double  GOLDEN_SECTION  MIN_RELATIVE_TOLERANCE  a  absoluteThreshold  b  d  e  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  relativeThreshold  tol1  tol2  u  v  w  x  [TYPE]  int  iter  [CONTEXT]  d  =  GOLDEN_SECTION  *  e  ;  }  if  (  FastMath  .  abs  (  d  )  <  tol1  )  {  if  (  d  >  =  0  )  {  u  =  x  +  tol1  ;  }  else  {  u  =  x  -  tol1  ;  }  }  else  {  u  =  x  +  d  ;  }  double  fu  =  computeObjectiveValue  (  u  )  ;  if  (  !isMinim  )  {  fu  =  -fu  ;  }  previous  =  current  ;  current  =  new  UnivariatePointValuePair  (  u  ,  isMinim  ?  fu  :  -fu  )  ;  if  (  checker  !  =  null  )  {  if  (  checker  .  converged  (  iter  ,  previous  ,  current  )  )  {  [BUGGY]  return  best  (  current  ,  previous  ,  isMinim  )  ;  }  }  if  (  fu  <  =  fx  )  {  	Math_23_BrentOptimizer_4_3	237	1	src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
101	return  best(best,  isMinim),  	[BUGGY]  [FE]  AssertionFailedError:  Best  point  not  reported  Assert  .  assertTrue  ( "Best  point  not  reported "  ,  f  .  value  (  sol  )  <  =  f  .  value  (  expected  )  )  ;  [METHOD]  doOptimize  [TYPE]  UnivariatePointValuePair  [PARAMETER]  [CLASS]  BrentOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  UnivariatePointValuePair  current  previous  [TYPE]  boolean  false  isMinim  stop  true  [TYPE]  double  GOLDEN_SECTION  MIN_RELATIVE_TOLERANCE  a  absoluteThreshold  b  d  e  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  relativeThreshold  tol1  tol2  u  v  w  x  [TYPE]  int  iter  [CONTEXT]  fv  =  fw  ;  w  =  x  ;  fw  =  fx  ;  x  =  u  ;  fx  =  fu  ;  }  else  {  if  (  u  <  x  )  {  a  =  u  ;  }  else  {  b  =  u  ;  }  if  (  fu  <  =  fw  ||  Precision  .  equals  (  w  ,  x  )  )  {  v  =  w  ;  fv  =  fw  ;  w  =  u  ;  fw  =  fu  ;  }  else  if  (  fu  <  =  fv  ||  Precision  .  equals  (  v  ,  x  )  ||  Precision  .  equals  (  v  ,  w  )  )  {  v  =  u  ;  fv  =  fu  ;  }  }  }  else  {  //  Default  termination  (  Brent's  criterion  )  .  [BUGGY]  return  best  (  current  ,  previous  ,  isMinim  )  ;  }  ++iter  ;  	Math_23_BrentOptimizer_4_4	274	0	src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
102	return  best(current,  previous,  isMinim);  	[BUGGY]  return  current  ;  [FE]  AssertionFailedError:  Best  point  not  reported  Assert  .  assertTrue  ( "Best  point  not  reported "  ,  f  .  value  (  sol  )  <  =  f  .  value  (  expected  )  )  ;  [METHOD]  doOptimize  [TYPE]  UnivariatePointValuePair  [PARAMETER]  [CLASS]  BrentOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  UnivariatePointValuePair  current  previous  [TYPE]  boolean  false  isMinim  stop  true  [TYPE]  double  GOLDEN_SECTION  MIN_RELATIVE_TOLERANCE  a  absoluteThreshold  b  d  e  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  relativeThreshold  tol1  tol2  u  v  w  x  [TYPE]  int  iter  [CONTEXT]  d  =  GOLDEN_SECTION  *  e  ;  }  if  (  FastMath  .  abs  (  d  )  <  tol1  )  {  if  (  d  >  =  0  )  {  u  =  x  +  tol1  ;  }  else  {  u  =  x  -  tol1  ;  }  }  else  {  u  =  x  +  d  ;  }  double  fu  =  computeObjectiveValue  (  u  )  ;  if  (  !isMinim  )  {  fu  =  -fu  ;  }  previous  =  current  ;  current  =  new  UnivariatePointValuePair  (  u  ,  isMinim  ?  fu  :  -fu  )  ;  if  (  checker  !  =  null  )  {  if  (  checker  .  converged  (  iter  ,  previous  ,  current  )  )  {  [BUGGY]  return  current  ;  }  }  if  (  fu  <  =  fx  )  {  	Math_24_BrentOptimizer_2_1	230	1	src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
103	return  best(current,  previous,  isMinim);  	[BUGGY]  [FE]  AssertionFailedError:  Best  point  not  reported  Assert  .  assertTrue  ( "Best  point  not  reported "  ,  f  .  value  (  sol  )  <  =  f  .  value  (  expected  )  )  ;  [METHOD]  doOptimize  [TYPE]  UnivariatePointValuePair  [PARAMETER]  [CLASS]  BrentOptimizer  [TYPE]  ConvergenceChecker  checker  [TYPE]  UnivariatePointValuePair  current  previous  [TYPE]  boolean  false  isMinim  stop  true  [TYPE]  double  GOLDEN_SECTION  MIN_RELATIVE_TOLERANCE  a  absoluteThreshold  b  d  e  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  relativeThreshold  tol1  tol2  u  v  w  x  [TYPE]  int  iter  [CONTEXT]  fv  =  fw  ;  w  =  x  ;  fw  =  fx  ;  x  =  u  ;  fx  =  fu  ;  }  else  {  if  (  u  <  x  )  {  a  =  u  ;  }  else  {  b  =  u  ;  }  if  (  fu  <  =  fw  ||  Precision  .  equals  (  w  ,  x  )  )  {  v  =  w  ;  fv  =  fw  ;  w  =  u  ;  fw  =  fu  ;  }  else  if  (  fu  <  =  fv  ||  Precision  .  equals  (  v  ,  x  )  ||  Precision  .  equals  (  v  ,  w  )  )  {  v  =  u  ;  fv  =  fu  ;  }  }  }  else  {  //  Default  termination  (  Brent's  criterion  )  .  [BUGGY]  return  current  ;  }  ++iter  ;  }  }  	Math_24_BrentOptimizer_2_2	267	0	src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java
104	if  (c2  ==  0)  {  throw  new  MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exception:  MathIllegalStateException  [METHOD]  guessAOmega  [TYPE]  void  [PARAMETER]  [CLASS]  ParameterGuesser  [TYPE]  boolean  false  true  [TYPE]  WeightedObservedPoint[]  observations  [TYPE]  double  a  c1  c2  c3  currentX  currentY  dx  dy  f2Integral  f2StepIntegral  fPrime2Integral  fPrime2StepIntegral  omega  phi  previousX  previousY  startX  sx2  sxy  sxz  sy2  syz  x  xRange  y  yMax  yMin  [TYPE]  int  i  last  [CONTEXT]  double  c2  =  sxy  *  sxz  -  sx2  *  syz  ;  double  c3  =  sx2  *  sy2  -  sxy  *  sxy  ;  if  (  (  c1  /  c2  <  0  )  ||  (  c2  /  c3  <  0  )  )  {  final  int  last  =  observations  .  length  -  1  ;  final  double  xRange  =  observations[last]  .  getX  (  )  -  observations[0]  .  getX  (  )  ;  if  (  xRange  =  =  0  )  {  throw  new  ZeroException  (  )  ;  }  omega  =  2  *  Math  .  PI  /  xRange  ;  double  yMin  =  Double  .  POSITIVE_INFINITY  ;  double  yMax  =  Double  .  NEGATIVE_INFINITY  ;  for  (  int  i  =  1  ;  i  <  observations  .  length  ;  ++i  )  {  final  double  y  =  observations[i]  .  getY  (  )  ;  if  (  y  <  yMin  )  {  yMin  =  y  ;  }  if  (  y  >  yMax  )  {  yMax  =  y  ;  }  }  a  =  0  .  5  *  (  yMax  -  yMin  )  ;  }  else  {  [BUGGY]  a  =  FastMath  .  sqrt  (  c1  /  c2  )  ;  omega  =  FastMath  .  sqrt  (  c2  /  c3  )  ;  }  	Math_25_HarmonicFitter_1_1	323	0	src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java
105	if  (FastMath.abs(a0)  >  overflow)  {  	[BUGGY] if ( a0 > overflow ) { [FE] AssertionFailedError: an exception should have been thrown [CONTEXT]   private Fraction ( double value , double epsilon , int maxDenominator , int maxIterations ) throws FractionConversionException { long overflow = Integer . MAX_VALUE ; double r0 = value ; long a0 = ( long ) FastMath . floor ( r0 ) ; [BUGGY] if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , 1l ) ; }  if ( FastMath . abs ( a0 - value ) < epsilon ) { this . numerator = ( int ) a0 ; this . denominator = 1 ; return ; } 	Math_26_Fraction_2_1	181	1	src/main/java/org/apache/commons/math3/fraction/Fraction.java
106	if  ((FastMath.abs(p2)  >  overflow)  ||  (FastMath.abs(q2)  >  overflow))  {  	[BUGGY] if ( ( p2 > overflow ) || ( q2 > overflow ) ) { [FE] AssertionFailedError: an exception should have been thrown [CONTEXT] long q2 = 1 ; int n = 0 ; boolean stop = false ; do { ++n ; double r1 = 1 . 0 / ( r0 - a0 ) ; long a1 = ( long ) FastMath . floor ( r1 ) ; p2 = ( a1 * p1 ) + p0 ; q2 = ( a1 * q1 ) + q0 ; [BUGGY] if ( ( p2 > overflow ) || ( q2 > overflow ) ) { throw new FractionConversionException ( value , p2 , q2 ) ; } double convergent = ( double ) p2 / ( double ) q2 ; if ( n < maxIterations && FastMath . abs ( convergent - value ) > epsilon && q2 < maxDenominator ) { p0 = p1 ; p1 = p2 ; q0 = q1 ; q1 = q2 ; a0 = a1 ; 	Math_26_Fraction_2_2	209	1	src/main/java/org/apache/commons/math3/fraction/Fraction.java
107	return  100  *  doubleValue();  	[BUGGY]  return  multiply  (  100  )  .  doubleValue  (  )  ;  [FE]  AssertionFailedError:  expected:<21691754E9>  but  was:<-2125791896E9>  Assert  .  assertEquals  (  percentage  ,  frac  .  percentageValue  (  )  ,  Math  .  ulp  (  percentage  )  )  ;  [METHOD]  percentageValue  [TYPE]  double  [PARAMETER]  [CLASS]  Fraction  [TYPE]  Fraction  FOUR_FIFTHS  MINUS_ONE  ONE  ONE_FIFTH  ONE_HALF  ONE_QUARTER  ONE_THIRD  THREE_FIFTHS  THREE_QUARTERS  TWO  TWO_FIFTHS  TWO_QUARTERS  TWO_THIRDS  ZERO  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  denominator  numerator  [CONTEXT]  public  double  percentageValue  (  )  {  [BUGGY]  return  multiply  (  100  )  .  doubleValue  (  )  ;  }  	Math_27_Fraction_1_1	597	1	src/main/java/org/apache/commons/math3/fraction/Fraction.java
108		[BUGGY]  [FE]  commonsmath3exceptionMaxCountExceededException:  illegal  state:  maximal  count  (  100  )  exceeded  Assert  .  assertTrue  (  validSolution  (  solution  ,  constraints  ,  epsilon  )  )  ;  [METHOD]  getPivotRow  [TYPE]  Integer  [PARAMETER]  SimplexTableau  tableau  final  int  col  [CLASS]  SimplexSolver  [TYPE]  Integer  minRow  row  [TYPE]  List  minRatioPositions  [TYPE]  boolean  false  true  [TYPE]  SimplexTableau  tableau  [TYPE]  double  DEFAULT_EPSILON  entry  epsilon  minRatio  ratio  rhs  [TYPE]  int  DEFAULT_ULPS  cmp  col  column  i  maxUlps  minIndex  [CONTEXT]  for  (  int  i  =  tableau  .  getNumObjectiveFunctions  (  )  ;  i  <  tableau  .  getHeight  (  )  ;  i++  )  {  final  double  rhs  =  tableau  .  getEntry  (  i  ,  tableau  .  getWidth  (  )  -  1  )  ;  final  double  entry  =  tableau  .  getEntry  (  i  ,  col  )  ;  if  (  Precision  .  compareTo  (  entry  ,  0d  ,  maxUlps  )  >  0  )  {  final  double  ratio  =  rhs  /  entry  ;  final  int  cmp  =  Double  .  compare  (  ratio  ,  minRatio  )  ;  if  (  cmp  =  =  0  )  {  minRatioPositions  .  add  (  i  )  ;  }  else  if  (  cmp  <  0  )  {  minRatio  =  ratio  ;  minRatioPositions  =  new  ArrayList<Integer>  (  )  ;  minRatioPositions  .  add  (  i  )  ;  }  }  }  if  (  minRatioPositions  .  size  (  )  =  =  0  )  {  return  null  ;  }  else  if  (  minRatioPositions  .  size  (  )  >  1  )  {  [BUGGY]  for  (  Integer  row  :  minRatioPositions  )  {  for  (  int  i  =  0  ;  i  <  tableau  .  getNumArtificialVariables  (  )  ;  i++  )  {  int  column  =  i  +  tableau  .  getArtificialVariableOffset  (  )  ;  final  double  entry  =  tableau  .  getEntry  (  row  ,  column  )  ;  if  (  Precision  .  equals  (  entry  ,  1d  ,  maxUlps  )  &&  row  .  equals  (  tableau  .  getBasicRow  (  column  )  )  )  {  return  row  ;  	Math_28_SimplexSolver_4_1	119	0	src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java
109	}  	[BUGGY]  [FE]  commonsmath3exceptionMaxCountExceededException:  illegal  state:  maximal  count  (  100  )  exceeded  Assert  .  assertTrue  (  validSolution  (  solution  ,  constraints  ,  epsilon  )  )  ;  [METHOD]  getPivotRow  [TYPE]  Integer  [PARAMETER]  SimplexTableau  tableau  final  int  col  [CLASS]  SimplexSolver  [TYPE]  Integer  minRow  row  [TYPE]  List  minRatioPositions  [TYPE]  boolean  false  true  [TYPE]  SimplexTableau  tableau  [TYPE]  double  DEFAULT_EPSILON  entry  epsilon  minRatio  ratio  rhs  [TYPE]  int  DEFAULT_ULPS  cmp  col  column  i  maxUlps  minIndex  [CONTEXT]  if  (  cmp  =  =  0  )  {  minRatioPositions  .  add  (  i  )  ;  }  else  if  (  cmp  <  0  )  {  minRatio  =  ratio  ;  minRatioPositions  =  new  ArrayList<Integer>  (  )  ;  minRatioPositions  .  add  (  i  )  ;  }  }  }  if  (  minRatioPositions  .  size  (  )  =  =  0  )  {  return  null  ;  }  else  if  (  minRatioPositions  .  size  (  )  >  1  )  {  for  (  Integer  row  :  minRatioPositions  )  {  for  (  int  i  =  0  ;  i  <  tableau  .  getNumArtificialVariables  (  )  ;  i++  )  {  int  column  =  i  +  tableau  .  getArtificialVariableOffset  (  )  ;  final  double  entry  =  tableau  .  getEntry  (  row  ,  column  )  ;  if  (  Precision  .  equals  (  entry  ,  1d  ,  maxUlps  )  &&  row  .  equals  (  tableau  .  getBasicRow  (  column  )  )  )  {  return  row  ;  }  }  }  [BUGGY]  	Math_28_SimplexSolver_4_2	128	0	src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java
110	if  (getIterations()  <  getMaxIterations()  /  2)  {  	[BUGGY]  [FE]  commonsmath3exceptionMaxCountExceededException:  illegal  state:  maximal  count  (  100  )  exceeded  Assert  .  assertTrue  (  validSolution  (  solution  ,  constraints  ,  epsilon  )  )  ;  [METHOD]  getPivotRow  [TYPE]  Integer  [PARAMETER]  SimplexTableau  tableau  final  int  col  [CLASS]  SimplexSolver  [TYPE]  Integer  minRow  row  [TYPE]  List  minRatioPositions  [TYPE]  boolean  false  true  [TYPE]  SimplexTableau  tableau  [TYPE]  double  DEFAULT_EPSILON  entry  epsilon  minRatio  ratio  rhs  [TYPE]  int  DEFAULT_ULPS  cmp  col  column  i  maxUlps  minIndex  [CONTEXT]  if  (  minRatioPositions  .  size  (  )  =  =  0  )  {  return  null  ;  }  else  if  (  minRatioPositions  .  size  (  )  >  1  )  {  for  (  Integer  row  :  minRatioPositions  )  {  for  (  int  i  =  0  ;  i  <  tableau  .  getNumArtificialVariables  (  )  ;  i++  )  {  int  column  =  i  +  tableau  .  getArtificialVariableOffset  (  )  ;  final  double  entry  =  tableau  .  getEntry  (  row  ,  column  )  ;  if  (  Precision  .  equals  (  entry  ,  1d  ,  maxUlps  )  &&  row  .  equals  (  tableau  .  getBasicRow  (  column  )  )  )  {  return  row  ;  }  }  }  [BUGGY]  Integer  minRow  =  null  ;  int  minIndex  =  tableau  .  getWidth  (  )  ;  for  (  Integer  row  :  minRatioPositions  )  {  int  i  =  tableau  .  getNumObjectiveFunctions  (  )  ;  for  (  ;  i  <  tableau  .  getWidth  (  )  -  1  &&  minRow  !  =  row  ;  i++  )  {  if  (  row  =  =  tableau  .  getBasicRow  (  i  )  )  {  	Math_28_SimplexSolver_4_3	138	0	src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java
111	}  	[BUGGY]  [FE]  commonsmath3exceptionMaxCountExceededException:  illegal  state:  maximal  count  (  100  )  exceeded  Assert  .  assertTrue  (  validSolution  (  solution  ,  constraints  ,  epsilon  )  )  ;  [METHOD]  getPivotRow  [TYPE]  Integer  [PARAMETER]  SimplexTableau  tableau  final  int  col  [CLASS]  SimplexSolver  [TYPE]  Integer  minRow  row  [TYPE]  List  minRatioPositions  [TYPE]  boolean  false  true  [TYPE]  SimplexTableau  tableau  [TYPE]  double  DEFAULT_EPSILON  entry  epsilon  minRatio  ratio  rhs  [TYPE]  int  DEFAULT_ULPS  cmp  col  column  i  maxUlps  minIndex  [CONTEXT]  }  Integer  minRow  =  null  ;  int  minIndex  =  tableau  .  getWidth  (  )  ;  for  (  Integer  row  :  minRatioPositions  )  {  int  i  =  tableau  .  getNumObjectiveFunctions  (  )  ;  for  (  ;  i  <  tableau  .  getWidth  (  )  -  1  &&  minRow  !  =  row  ;  i++  )  {  if  (  row  =  =  tableau  .  getBasicRow  (  i  )  )  {  if  (  i  <  minIndex  )  {  minIndex  =  i  ;  minRow  =  row  ;  }  }  }  }  return  minRow  ;  [BUGGY]  }  return  minRatioPositions  .  get  (  0  )  ;  }  	Math_28_SimplexSolver_4_4	152	0	src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java
112	final  int  n  =  getDimension();  for  (int  i  =  0;  i  <  n;  i++)  {  res.setEntry(i,  this.getEntry(i)  /  v.getEntry(i));  	[BUGGY]  Iterator  iter  =  entries  .  iterator  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  iter  .  advance  (  )  ;  res  .  setEntry  (  iter  .  key  (  )  ,  iter  .  value  (  )  /  v  .  getEntry  (  iter  .  key  (  )  )  )  ;  [FE]  AssertionFailedError:  entry  #0  ,  left  =  00  ,  right  =  00  expected:<NaN>  but  was:<00>  [METHOD]  ebeDivide  [TYPE]  OpenMapRealVector  [PARAMETER]  RealVector  v  [CLASS]  OpenMapRealVector  [TYPE]  Entry  current  [TYPE]  boolean  false  true  [TYPE]  double  DEFAULT_ZERO_TOLERANCE  epsilon  [TYPE]  RealVector  v  [TYPE]  Iterator  iter  [TYPE]  OpenMapRealVector  res  [TYPE]  OpenIntToDoubleHashMap  entries  [TYPE]  long  serialVersionUID  [TYPE]  int  virtualSize  [CONTEXT]  public  OpenMapRealVector  ebeDivide  (  RealVector  v  )  {  checkVectorDimensions  (  v  .  getDimension  (  )  )  ;  OpenMapRealVector  res  =  new  OpenMapRealVector  (  this  )  ;  [BUGGY]  Iterator  iter  =  entries  .  iterator  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  iter  .  advance  (  )  ;  res  .  setEntry  (  iter  .  key  (  )  ,  iter  .  value  (  )  /  v  .  getEntry  (  iter  .  key  (  )  )  )  ;  }  return  res  ;  }  	Math_29_OpenMapRealVector_2_1	349	4	src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java
113	if  (v.isNaN()  ||  v.isInfinite())  {  final  int  n  =  getDimension();  for  (int  i  =  0;  i  <  n;  i++)  {  final  double  y  =  v.getEntry(i);  if  (Double.isNaN(y))  {  res.setEntry(i,  Double.NaN);  }  else  if  (Double.isInfinite(y))  {  final  double  x  =  this.getEntry(i);  res.setEntry(i,  x  *  y);  }  }  }  	[BUGGY]  [FE]  AssertionFailedError:  entry  #0  ,  left  =  00  ,  right  =  00  expected:<NaN>  but  was:<00>  [METHOD]  ebeMultiply  [TYPE]  OpenMapRealVector  [PARAMETER]  RealVector  v  [CLASS]  OpenMapRealVector  [TYPE]  Entry  current  [TYPE]  boolean  false  true  [TYPE]  double  DEFAULT_ZERO_TOLERANCE  epsilon  [TYPE]  RealVector  v  [TYPE]  Iterator  iter  [TYPE]  OpenMapRealVector  res  [TYPE]  OpenIntToDoubleHashMap  entries  [TYPE]  long  serialVersionUID  [TYPE]  int  virtualSize  [CONTEXT]  public  OpenMapRealVector  ebeMultiply  (  RealVector  v  )  {  checkVectorDimensions  (  v  .  getDimension  (  )  )  ;  OpenMapRealVector  res  =  new  OpenMapRealVector  (  this  )  ;  Iterator  iter  =  entries  .  iterator  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  iter  .  advance  (  )  ;  res  .  setEntry  (  iter  .  key  (  )  ,  iter  .  value  (  )  *  v  .  getEntry  (  iter  .  key  (  )  )  )  ;  }  [BUGGY]  return  res  ;  }  	Math_29_OpenMapRealVector_2_2	374	0	src/main/java/org/apache/commons/math3/linear/OpenMapRealVector.java
114	final  double  n1n2prod  =  n1  *  n2;  	[BUGGY]  final  int  n1n2prod  =  n1  *  n2  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  result  >  0  .  1  )  ;  [METHOD]  calculateAsymptoticPValue  [TYPE]  double  [PARAMETER]  final  double  Umin  final  int  n1  final  int  n2  [CLASS]  MannWhitneyUTest  [TYPE]  NaturalRanking  naturalRanking  [TYPE]  boolean  false  true  [TYPE]  NormalDistribution  standardNormal  [TYPE]  double  EU  Umin  VarU  z  [TYPE]  int  n1  n1n2prod  n2  [CONTEXT]  private  double  calculateAsymptoticPValue  (  final  double  Umin  ,  final  int  n1  ,  final  int  n2  )  throws  ConvergenceException  ,  MaxCountExceededException  {  [BUGGY]  final  int  n1n2prod  =  n1  *  n2  ;  final  double  EU  =  n1n2prod  /  2  .  0  ;  final  double  VarU  =  n1n2prod  *  (  n1  +  n2  +  1  )  /  12  .  0  ;  final  double  z  =  (  Umin  -  EU  )  /  FastMath  .  sqrt  (  VarU  )  ;  final  NormalDistribution  standardNormal  =  new  NormalDistribution  (  0  ,  1  )  ;  return  2  *  standardNormal  .  cumulativeProbability  (  z  )  ;  }  	Math_30_MannWhitneyUTest_1_1	173	1	src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java
115		[BUGGY]  double  p0  =  1  .  0  ;  double  q1  =  1  .  0  ;  [FE]  commonsmath3exceptionConvergenceException:  illegal  state:  Continued  fraction  diverged  to  NaN  for  value  05  Assert  .  assertEquals  (  trials  /  2  ,  p  )  ;  [METHOD]  evaluate  [TYPE]  double  [PARAMETER]  double  x  double  epsilon  int  maxIterations  [CLASS]  ContinuedFraction  [TYPE]  double  DEFAULT_EPSILON  a  b  cN  cPrev  dPrev  deltaN  epsilon  hN  hPrev  lastScaleFactor  p0  q1  q2  scale  scaleFactor  small  x  [TYPE]  int  i  maxIterations  maxPower  n  [TYPE]  boolean  false  true  [CONTEXT]  public  double  evaluate  (  double  x  ,  double  epsilon  ,  int  maxIterations  )  {  final  double  small  =  1e-50  ;  double  hPrev  =  getA  (  0  ,  x  )  ;  if  (  Precision  .  equals  (  hPrev  ,  0  .  0  ,  small  )  )  {  hPrev  =  small  ;  }  int  n  =  1  ;  double  dPrev  =  0  .  0  ;  [BUGGY]  double  p0  =  1  .  0  ;  double  q1  =  1  .  0  ;  double  cPrev  =  hPrev  ;  double  hN  =  hPrev  ;  while  (  n  <  maxIterations  )  {  	Math_31_ContinuedFraction_3_1	134	2	src/main/java/org/apache/commons/math3/util/ContinuedFraction.java
116	double  dN  =  a  +  b  *  dPrev;  if  (Precision.equals(dN,  0.0,  small))  {  dN  =  small;  }  double  cN  =  a  +  b  /  cPrev;  if  (Precision.equals(cN,  0.0,  small))  {  cN  =  small;  dN  =  1  /  dN;  final  double  deltaN  =  cN  *  dN;  hN  =  hPrev  *  deltaN;  	[BUGGY]  double  cN  =  a  *  hPrev  +  b  *  p0  ;  double  q2  =  a  *  q1  +  b  *  dPrev  ;  if  (  Double  .  isInfinite  (  cN  )  ||  Double  .  isInfinite  (  q2  )  )  {  double  scaleFactor  =  1d  ;  double  lastScaleFactor  =  1d  ;  final  int  maxPower  =  5  ;  final  double  scale  =  FastMath  .  max  (  a  ,  b  )  ;  \n'  , "-  if  (  scale  <  =  0  )  {  }  for  (  int  i  =  0  ;  i  <  maxPower  ;  i++  )  {  lastScaleFactor  =  scaleFactor  ;  scaleFactor  *  =  scale  ;  if  (  a  !  =  0  .  0  &&  a  >  b  )  {  cN  =  hPrev  /  lastScaleFactor  +  (  b  /  scaleFactor  *  p0  )  ;  q2  =  q1  /  lastScaleFactor  +  (  b  /  scaleFactor  *  dPrev  )  ;  }  else  if  (  b  !  =  0  )  {  cN  =  (  a  /  scaleFactor  *  hPrev  )  +  p0  /  lastScaleFactor  ;  q2  =  (  a  /  scaleFactor  *  q1  )  +  dPrev  /  lastScaleFactor  ;  }  if  (  !  (  Double  .  isInfinite  (  cN  )  ||  Double  .  isInfinite  (  q2  )  )  )  {  break  ;  }  }  final  double  deltaN  =  cN  /  q2  /  cPrev  ;  hN  =  cPrev  *  deltaN  ;  [FE]  commonsmath3exceptionConvergenceException:  illegal  state:  Continued  fraction  diverged  to  NaN  for  value  05  Assert  .  assertEquals  (  trials  /  2  ,  p  )  ;  [METHOD]  evaluate  [TYPE]  double  [PARAMETER]  double  x  double  epsilon  int  maxIterations  [CLASS]  ContinuedFraction  [TYPE]  double  DEFAULT_EPSILON  a  b  cN  cPrev  dPrev  deltaN  epsilon  hN  hPrev  lastScaleFactor  p0  q1  q2  scale  scaleFactor  small  x  [TYPE]  int  i  maxIterations  maxPower  n  [TYPE]  boolean  false  true  [CONTEXT]  public  double  evaluate  (  double  x  ,  double  epsilon  ,  int  maxIterations  )  {  final  double  small  =  1e-50  ;  double  hPrev  =  getA  (  0  ,  x  )  ;  if  (  Precision  .  equals  (  hPrev  ,  0  .  0  ,  small  )  )  {  hPrev  =  small  ;  }  int  n  =  1  ;  double  dPrev  =  0  .  0  ;  double  p0  =  1  .  0  ;  double  q1  =  1  .  0  ;  double  cPrev  =  hPrev  ;  double  hN  =  hPrev  ;  while  (  n  <  maxIterations  )  {  final  double  a  =  getA  (  n  ,  x  )  ;  final  double  b  =  getB  (  n  ,  x  )  ;  [BUGGY]  double  cN  =  a  *  hPrev  +  b  *  p0  ;  double  q2  =  a  *  q1  +  b  *  dPrev  ;  if  (  Double  .  isInfinite  (  cN  )  ||  Double  .  isInfinite  (  q2  )  )  {  double  scaleFactor  =  1d  ;  double  lastScaleFactor  =  1d  ;  final  int  maxPower  =  5  ;  	Math_31_ContinuedFraction_3_2	143	24	src/main/java/org/apache/commons/math3/util/ContinuedFraction.java
117	dPrev  =  dN;  cPrev  =  cN;  hPrev  =  hN;  	[BUGGY]  dPrev  =  q1  ;  cPrev  =  cN  /  q2  ;  p0  =  hPrev  ;  hPrev  =  cN  ;  q1  =  q2  ;  [FE]  commonsmath3exceptionConvergenceException:  illegal  state:  Continued  fraction  diverged  to  NaN  for  value  05  Assert  .  assertEquals  (  trials  /  2  ,  p  )  ;  [METHOD]  evaluate  [TYPE]  double  [PARAMETER]  double  x  double  epsilon  int  maxIterations  [CLASS]  ContinuedFraction  [TYPE]  double  DEFAULT_EPSILON  a  b  cN  cPrev  dPrev  deltaN  epsilon  hN  hPrev  lastScaleFactor  p0  q1  q2  scale  scaleFactor  small  x  [TYPE]  int  i  maxIterations  maxPower  n  [TYPE]  boolean  false  true  [CONTEXT]  cN  =  (  a  /  scaleFactor  *  hPrev  )  +  p0  /  lastScaleFactor  ;  q2  =  (  a  /  scaleFactor  *  q1  )  +  dPrev  /  lastScaleFactor  ;  }  if  (  !  (  Double  .  isInfinite  (  cN  )  ||  Double  .  isInfinite  (  q2  )  )  )  {  break  ;  }  }  }  final  double  deltaN  =  cN  /  q2  /  cPrev  ;  hN  =  cPrev  *  deltaN  ;  if  (  Double  .  isInfinite  (  hN  )  )  {  throw  new  ConvergenceException  (  LocalizedFormats  .  CONTINUED_FRACTION_INFINITY_DIVERGENCE  ,  x  )  ;  }  if  (  Double  .  isNaN  (  hN  )  )  {  throw  new  ConvergenceException  (  LocalizedFormats  .  CONTINUED_FRACTION_NAN_DIVERGENCE  ,  x  )  ;  }  if  (  FastMath  .  abs  (  deltaN  -  1  .  0  )  <  epsilon  )  {  break  ;  }  [BUGGY]  dPrev  =  q1  ;  cPrev  =  cN  /  q2  ;  p0  =  hPrev  ;  hPrev  =  cN  ;  q1  =  q2  ;  n++  ;  	Math_31_ContinuedFraction_3_3	185	5	src/main/java/org/apache/commons/math3/util/ContinuedFraction.java
118	if  (tree.getCut()  ==  null  &&  (Boolean)  tree.getAttribute())  {  	[BUGGY]  if  (  (  Boolean  )  tree  .  getAttribute  (  )  )  {  [FE]  ClassCastException:  orgapachecommonsmath3geometrypartitioningBoundaryAttribute  cannot  be  cast  to  javalangBoolean  Assert  .  assertEquals  (  expected  ,  tree  .  checkPoint  (  points[i]  )  )  ;  [METHOD]  computeGeometricalProperties  [TYPE]  void  [PARAMETER]  [CLASS]  PolygonsSet  [TYPE]  BSPTree  tree  [TYPE]  boolean  false  true  [TYPE]  Vector2D  point  [TYPE]  double  factor  sum  sumX  sumY  x0  x1  y0  y1  [TYPE]  AVLTree  sorted  [TYPE]  OrderedTuple  sortingKey  [TYPE]  Vector2D[][]  v  vertices  [TYPE]  Vector2D[]  loop  [CONTEXT]  protected  void  computeGeometricalProperties  (  )  {  final  Vector2D[][]  v  =  getVertices  (  )  ;  if  (  v  .  length  =  =  0  )  {  final  BSPTree<Euclidean2D>  tree  =  getTree  (  false  )  ;  [BUGGY]  if  (  (  Boolean  )  tree  .  getAttribute  (  )  )  {  setSize  (  Double  .  POSITIVE_INFINITY  )  ;  setBarycenter  (  Vector2D  .  NaN  )  ;  }  else  {  setSize  (  0  )  ;  	Math_32_PolygonsSet_1_1	136	1	src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java
119	if  (Precision.compareTo(entry,  0d,  epsilon)  >  0)  {  	[BUGGY]  if  (  Precision  .  compareTo  (  entry  ,  0d  ,  maxUlps  )  >  0  )  {  [FE]  AssertionFailedError  Assert  .  assertEquals  (  2  .  0d  ,  solution  .  getValue  (  )  ,  epsilon  )  ;  [METHOD]  dropPhase1Objective  [TYPE]  void  [PARAMETER]  [CLASS]  SimplexTableau  [TYPE]  boolean  false  restrictToNonNegative  true  [TYPE]  RealMatrix  tableau  [TYPE]  double  entry  epsilon  [TYPE]  LinearObjectiveFunction  f  [TYPE]  double[][]  matrix  [TYPE]  List  columnLabels  columnsToDrop  constraints  [TYPE]  String  NEGATIVE_VAR_COLUMN_LABEL  [TYPE]  int  DEFAULT_ULPS  col  i  j  maxUlps epsilon numArtificialVariables  numDecisionVariables  numSlackVariables  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  void  dropPhase1Objective  (  )  {  if  (  getNumObjectiveFunctions  (  )  =  =  1  )  {  return  ;  }  List<Integer>  columnsToDrop  =  new  ArrayList<Integer>  (  )  ;  columnsToDrop  .  add  (  0  )  ;  for  (  int  i  =  getNumObjectiveFunctions  (  )  ;  i  <  getArtificialVariableOffset  (  )  ;  i++  )  {  final  double  entry  =  tableau  .  getEntry  (  0  ,  i  )  ;  [BUGGY]  if  (  Precision  .  compareTo  (  entry  ,  0d  ,  maxUlps  )  >  0  )  {  columnsToDrop  .  add  (  i  )  ;  }  }  	Math_33_SimplexTableau_1_1	338	1	src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java
120	return  getChromosomes().iterator();  	[BUGGY]  return  chromosomes  .  iterator  (  )  ;  [FE]  AssertionFailedError:  Expected  exception:  javalangUnsupportedOperationException  [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  ListPopulation  [TYPE]  List  chromosomes  [TYPE]  int  populationLimit  [TYPE]  boolean  false  true  [CONTEXT]  public  Iterator<Chromosome>  iterator  (  )  {  [BUGGY]  return  chromosomes  .  iterator  (  )  ;  }  	Math_34_ListPopulation_1_1	209	1	src/main/java/org/apache/commons/math3/genetics/ListPopulation.java
121	setElitismRate(elitismRate);  	[BUGGY]  this  .  elitismRate  =  elitismRate  ;  [FE]  AssertionFailedError:  Expected  exception:  orgapachecommonsmath3exceptionOutOfRangeException  [CLASS]  [CONTEXT]  	Math_35_ElitisticListPopulation_2_1	51	1	src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java
122	setElitismRate(elitismRate);  	[BUGGY]  this  .  elitismRate  =  elitismRate  ;  [FE]  AssertionFailedError:  Expected  exception:  orgapachecommonsmath3exceptionOutOfRangeException  [CLASS]  [CONTEXT]  	Math_35_ElitisticListPopulation_2_2	65	1	src/main/java/org/apache/commons/math3/genetics/ElitisticListPopulation.java
123	if  (Double.isNaN(result))  {  int  shift  =  Math.max(numerator.bitLength(),  denominator.bitLength())  -  Double.MAX_EXPONENT;  result  =  numerator.shiftRight(shift).doubleValue()  /  denominator.shiftRight(shift).doubleValue();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<50>  but  was:<NaN>  Assert  .  assertEquals  (  5  ,  large  .  floatValue  (  )  ,  1e-15  )  ;  [METHOD]  doubleValue  [TYPE]  double  [PARAMETER]  [CLASS]  BigFraction  [TYPE]  BigInteger  ONE_HUNDRED  denominator  numerator  [TYPE]  boolean  false  true  [TYPE]  BigFraction  FOUR_FIFTHS  MINUS_ONE  ONE  ONE_FIFTH  ONE_HALF  ONE_QUARTER  ONE_THIRD  THREE_FIFTHS  THREE_QUARTERS  TWO  TWO_FIFTHS  TWO_QUARTERS  TWO_THIRDS  ZERO  [TYPE]  long  serialVersionUID  [TYPE]  double  result  [CONTEXT]  public  double  doubleValue  (  )  {  double  result  =  numerator  .  doubleValue  (  )  /  denominator  .  doubleValue  (  )  ;  [BUGGY]  return  result  ;  }  	Math_36_BigFraction_2_1	686	0	src/main/java/org/apache/commons/math/fraction/BigFraction.java
124	if  (Double.isNaN(result))  {  int  shift  =  Math.max(numerator.bitLength(),  denominator.bitLength())  -  Float.MAX_EXPONENT;  result  =  numerator.shiftRight(shift).floatValue()  /  denominator.shiftRight(shift).floatValue();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<50>  but  was:<NaN>  Assert  .  assertEquals  (  5  ,  large  .  floatValue  (  )  ,  1e-15  )  ;  [METHOD]  floatValue  [TYPE]  float  [PARAMETER]  [CLASS]  BigFraction  [TYPE]  BigInteger  ONE_HUNDRED  denominator  numerator  [TYPE]  boolean  false  true  [TYPE]  BigFraction  FOUR_FIFTHS  MINUS_ONE  ONE  ONE_FIFTH  ONE_HALF  ONE_QUARTER  ONE_THIRD  THREE_FIFTHS  THREE_QUARTERS  TWO  TWO_FIFTHS  TWO_QUARTERS  TWO_THIRDS  ZERO  [TYPE]  float  result  [TYPE]  long  serialVersionUID  [CONTEXT]  public  float  floatValue  (  )  {  float  result  =  numerator  .  floatValue  (  )  /  denominator  .  floatValue  (  )  ;  [BUGGY]  return  result  ;  }  	Math_36_BigFraction_2_2	733	0	src/main/java/org/apache/commons/math/fraction/BigFraction.java
125	if  (isNaN  ||  Double.isInfinite(real))  {  if  (imaginary  >  20.0)  {  return  createComplex(0.0,  1.0);  }  if  (imaginary  <  -20.0)  {  return  createComplex(0.0,  -1.0);  }  	[BUGGY]  if  (  isNaN  )  {  [FE]  AssertionFailedError:  expected:<10>  but  was:<NaN>  TestUtils  .  assertSame  (  Complex  .  NaN  ,  negInfNegInf  .  tanh  (  )  )  ;  [METHOD]  tan  [TYPE]  Complex  [PARAMETER]  [CLASS]  Complex  [TYPE]  boolean  false  isInfinite  isNaN  true  [TYPE]  double  d  imaginary  imaginary2  real  real2  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  [CONTEXT]  public  Complex  tan  (  )  {  [BUGGY]  if  (  isNaN  )  {  return  NaN  ;  }  double  real2  =  2  .  0  *  real  ;  double  imaginary2  =  2  .  0  *  imaginary  ;  double  d  =  FastMath  .  cos  (  real2  )  +  FastMath  .  cosh  (  imaginary2  )  ;  return  createComplex  (  FastMath  .  sin  (  real2  )  /  d  ,  FastMath  .  sinh  (  imaginary2  )  /  d  )  ;  }  	Math_37_Complex_2_1	1018	1	src/main/java/org/apache/commons/math/complex/Complex.java
126	if  (isNaN  ||  Double.isInfinite(imaginary))  {  if  (real  >  20.0)  {  return  createComplex(1.0,  0.0);  }  if  (real  <  -20.0)  {  return  createComplex(-1.0,  0.0);  }  	[BUGGY]  if  (  isNaN  )  {  [FE]  AssertionFailedError:  expected:<10>  but  was:<NaN>  TestUtils  .  assertSame  (  Complex  .  NaN  ,  negInfNegInf  .  tanh  (  )  )  ;  [METHOD]  tanh  [TYPE]  Complex  [PARAMETER]  [CLASS]  Complex  [TYPE]  boolean  false  isInfinite  isNaN  true  [TYPE]  double  d  imaginary  imaginary2  real  real2  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  [CONTEXT]  public  Complex  tanh  (  )  {  [BUGGY]  if  (  isNaN  )  {  return  NaN  ;  }  double  real2  =  2  .  0  *  real  ;  double  imaginary2  =  2  .  0  *  imaginary  ;  double  d  =  FastMath  .  cosh  (  real2  )  +  FastMath  .  cos  (  imaginary2  )  ;  return  createComplex  (  FastMath  .  sinh  (  real2  )  /  d  ,  FastMath  .  sin  (  imaginary2  )  /  d  )  ;  }  	Math_37_Complex_2_2	1063	1	src/main/java/org/apache/commons/math/complex/Complex.java
127	final  int  iptMinus1  =  ipt  -  1;  final  int  jptMinus1  =  jpt  -  1;  	[BUGGY]  throw  new  PathIsExploredException  (  )  ;  final  int  iptMinus1  =  ipt  ;  final  int  jptMinus1  =  jpt  ;  [FE]  commonsmathoptimizationdirectBOBYQAOptimizer$PathIsExploredException:  If  this  exception  is  thrown  ,  just  remove  it  from  the  code  prelim  (  at  line  1752  )  Assert  .  assertEquals  (  expected  .  getPoint  (  )  [i]  ,  [METHOD]  prelim  [TYPE]  void  [PARAMETER]  double[]  lowerBound  double[]  upperBound  [CLASS]  BOBYQAOptimizer  [TYPE]  boolean  false  isMinimize  true  [TYPE]  double[]  boundDifference  lowerBound  upperBound  [TYPE]  Array2DRowRealMatrix  bMatrix  interpolationPoints  zMatrix  [TYPE]  double  DEFAULT_INITIAL_RADIUS  DEFAULT_STOPPING_RADIUS  HALF  MINUS_ONE  ONE  ONE_OVER_A_THOUSAND  ONE_OVER_EIGHT  ONE_OVER_FOUR  ONE_OVER_TEN  SIXTEEN  TEN  TWO  TWO_HUNDRED_FIFTY  ZERO  diff  f  fbeg  initialTrustRegionRadius  objectiveValue  oneOverStepA  recip  rhosq  stepa  stepb  stoppingTrustRegionRadius  tmp  [TYPE]  ArrayRealVector  alternativeNewPoint  currentBest  fAtInterpolationPoints  gradientAtTrustRegionCenter  lagrangeValuesAtNewPoint  lowerDifference  modelSecondDerivativesParameters  modelSecondDerivativesValues  newPoint  originShift  trialStepPoint  trustRegionCenterOffset  upperDifference  [TYPE]  String  PATH_IS_EXPLORED  [TYPE]  int  MINIMUM_PROBLEM_DIMENSION  i  ih  ipt  iptMinus1  j  jpt  jptMinus1  k  max  n  ndim  nfm  nfmm  nfx  nfxm  np  npt  numEval  numberOfInterpolationPoints  tmp1  tmp2  trustRegionCenterInterpolationPointIndex  [TYPE]  long  serialVersionUID  [CONTEXT]  stepa  =  -stepa  ;  throw  new  PathIsExploredException  (  )  ;  //  XXX  }  interpolationPoints  .  setEntry  (  nfm  ,  nfmm  ,  stepa  )  ;  }  else  if  (  nfm  >  n  )  {  stepa  =  interpolationPoints  .  getEntry  (  nfx  ,  nfxm  )  ;  stepb  =  -initialTrustRegionRadius  ;  if  (  lowerDifference  .  getEntry  (  nfxm  )  =  =  ZERO  )  {  stepb  =  Math  .  min  (  TWO  *  initialTrustRegionRadius  ,  upperDifference  .  getEntry  (  nfxm  )  )  ;  throw  new  PathIsExploredException  (  )  ;  //  XXX  }  if  (  upperDifference  .  getEntry  (  nfxm  )  =  =  ZERO  )  {  stepb  =  Math  .  max  (  -TWO  *  initialTrustRegionRadius  ,  lowerDifference  .  getEntry  (  nfxm  )  )  ;  throw  new  PathIsExploredException  (  )  ;  //  XXX  }  interpolationPoints  .  setEntry  (  nfm  ,  nfxm  ,  stepb  )  ;  }  }  else  {  final  int  tmp1  =  (  nfm  -  np  )  /  n  ;  jpt  =  nfm  -  tmp1  *  n  -  n  ;  ipt  =  jpt  +  tmp1  ;  if  (  ipt  >  n  )  {  final  int  tmp2  =  jpt  ;  jpt  =  ipt  -  n  ;  ipt  =  tmp2  ;  [BUGGY]  throw  new  PathIsExploredException  (  )  ;  //  XXX  }  final  int  iptMinus1  =  ipt  ;  final  int  jptMinus1  =  jpt  ;  interpolationPoints  .  setEntry  (  nfm  ,  iptMinus1  ,  interpolationPoints  .  getEntry  (  ipt  ,  iptMinus1  )  )  ;  interpolationPoints  .  setEntry  (  nfm  ,  jptMinus1  ,  interpolationPoints  .  getEntry  (  jpt  ,  jptMinus1  )  )  ;  	Math_38_BOBYQAOptimizer_2_1	1660	3	src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java
128		[BUGGY]  throw  new  PathIsExploredException  (  )  ;  [FE]  commonsmathoptimizationdirectBOBYQAOptimizer$PathIsExploredException:  If  this  exception  is  thrown  ,  just  remove  it  from  the  code  prelim  (  at  line  1752  )  Assert  .  assertEquals  (  expected  .  getPoint  (  )  [i]  ,  [METHOD]  prelim  [TYPE]  void  [PARAMETER]  double[]  lowerBound  double[]  upperBound  [CLASS]  BOBYQAOptimizer  [TYPE]  boolean  false  isMinimize  true  [TYPE]  double[]  boundDifference  lowerBound  upperBound  [TYPE]  Array2DRowRealMatrix  bMatrix  interpolationPoints  zMatrix  [TYPE]  double  DEFAULT_INITIAL_RADIUS  DEFAULT_STOPPING_RADIUS  HALF  MINUS_ONE  ONE  ONE_OVER_A_THOUSAND  ONE_OVER_EIGHT  ONE_OVER_FOUR  ONE_OVER_TEN  SIXTEEN  TEN  TWO  TWO_HUNDRED_FIFTY  ZERO  diff  f  fbeg  initialTrustRegionRadius  objectiveValue  oneOverStepA  recip  rhosq  stepa  stepb  stoppingTrustRegionRadius  tmp  [TYPE]  ArrayRealVector  alternativeNewPoint  currentBest  fAtInterpolationPoints  gradientAtTrustRegionCenter  lagrangeValuesAtNewPoint  lowerDifference  modelSecondDerivativesParameters  modelSecondDerivativesValues  newPoint  originShift  trialStepPoint  trustRegionCenterOffset  upperDifference  [TYPE]  String  PATH_IS_EXPLORED  [TYPE]  int  MINIMUM_PROBLEM_DIMENSION  i  ih  ipt  iptMinus1  j  jpt  jptMinus1  k  max  n  ndim  nfm  nfmm  nfx  nfxm  np  npt  numEval  numberOfInterpolationPoints  tmp1  tmp2  trustRegionCenterInterpolationPointIndex  [TYPE]  long  serialVersionUID  [CONTEXT]  }  }  bMatrix  .  setEntry  (  0  ,  nfxm  ,  -  (  stepa  +  stepb  )  /  (  stepa  *  stepb  )  )  ;  bMatrix  .  setEntry  (  nfm  ,  nfxm  ,  -HALF  /  interpolationPoints  .  getEntry  (  nfm  -  n  ,  nfxm  )  )  ;  bMatrix  .  setEntry  (  nfm  -  n  ,  nfxm  ,  -bMatrix  .  getEntry  (  0  ,  nfxm  )  -  bMatrix  .  getEntry  (  nfm  ,  nfxm  )  )  ;  zMatrix  .  setEntry  (  0  ,  nfxm  ,  Math  .  sqrt  (  TWO  )  /  (  stepa  *  stepb  )  )  ;  zMatrix  .  setEntry  (  nfm  ,  nfxm  ,  Math  .  sqrt  (  HALF  )  /  rhosq  )  ;  zMatrix  .  setEntry  (  nfm  -  n  ,  nfxm  ,  -zMatrix  .  getEntry  (  0  ,  nfxm  )  -  zMatrix  .  getEntry  (  nfm  ,  nfxm  )  )  ;  }  }  else  {  zMatrix  .  setEntry  (  0  ,  nfxm  ,  recip  )  ;  zMatrix  .  setEntry  (  nfm  ,  nfxm  ,  recip  )  ;  zMatrix  .  setEntry  (  ipt  ,  nfxm  ,  -recip  )  ;  zMatrix  .  setEntry  (  jpt  ,  nfxm  ,  -recip  )  ;  final  int  ih  =  ipt  *  (  ipt  -  1  )  /  2  +  jpt  -  1  ;  final  double  tmp  =  interpolationPoints  .  getEntry  (  nfm  ,  ipt  -  1  )  *  interpolationPoints  .  getEntry  (  nfm  ,  jpt  -  1  )  ;  modelSecondDerivativesValues  .  setEntry  (  ih  ,  (  fbeg  -  fAtInterpolationPoints  .  getEntry  (  ipt  )  -  fAtInterpolationPoints  .  getEntry  (  jpt  )  +  f  )  /  tmp  )  ;  [BUGGY]  throw  new  PathIsExploredException  (  )  ;  //  XXX  }  }  while  (  getEvaluations  (  )  <  npt  )  ;  }  //  prelim  	Math_38_BOBYQAOptimizer_2_2	1752	1	src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java
129	if  (forward)  {  if  (stepStart  +  stepSize  >=  t)  {  stepSize  =  t  -  stepStart;  }  }  else  {  if  (stepStart  +  stepSize  <=  t)  {  stepSize  =  t  -  stepStart;  }  }  	[BUGGY]  [FE]  AssertionFailedError  [METHOD]  integrate  [TYPE]  void  [PARAMETER]  ExpandableStatefulODE  equations  final  double  t  [CLASS]  EmbeddedRungeKuttaIntegrator  [TYPE]  ExpandableStatefulODE  equations  [TYPE]  boolean  false  filteredNextIsLast  firstTime  forward  fsal  nextIsLast  true  [TYPE]  double[]  b  c  scale  y  y0  yDotTmp  yTmp  [TYPE]  double  error  exp  factor  filteredNextT  hNew  maxGrowth  minReduction  nextT  safety  scaledH  sum  t  [TYPE]  double[][]  a  yDotK  [TYPE]  RungeKuttaStepInterpolator  interpolator  prototype  [TYPE]  int  i  j  k  l  stages  [CONTEXT]  double  error  =  10  ;  while  (  error  >  =  1  .  0  )  {  if  (  firstTime  ||  !fsal  )  {  computeDerivatives  (  stepStart  ,  y  ,  yDotK[0]  )  ;  }  if  (  firstTime  )  {  final  double[]  scale  =  new  double[mainSetDimension]  ;  if  (  vecAbsoluteTolerance  =  =  null  )  {  for  (  int  i  =  0  ;  i  <  scale  .  length  ;  ++i  )  {  scale[i]  =  scalAbsoluteTolerance  +  scalRelativeTolerance  *  FastMath  .  abs  (  y[i]  )  ;  }  }  else  {  for  (  int  i  =  0  ;  i  <  scale  .  length  ;  ++i  )  {  scale[i]  =  vecAbsoluteTolerance[i]  +  vecRelativeTolerance[i]  *  FastMath  .  abs  (  y[i]  )  ;  }  }  hNew  =  initializeStep  (  forward  ,  getOrder  (  )  ,  scale  ,  stepStart  ,  y  ,  yDotK[0]  ,  yTmp  ,  yDotK[1]  )  ;  firstTime  =  false  ;  }  stepSize  =  hNew  ;  [BUGGY]  for  (  int  k  =  1  ;  k  <  stages  ;  ++k  )  {  for  (  int  j  =  0  ;  j  <  y0  .  length  ;  ++j  )  {  double  sum  =  a[k-1][0]  *  yDotK[0][j]  ;  	Math_39_EmbeddedRungeKuttaIntegrator_1_1	250	0	src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
130	final  int  p  =  agingA  -  MAXIMAL_AGING;  final  double  weightA  =  (1  <<  p)  -  1;  final  double  weightB  =  p  +  1;  targetY  =  (weightA  *  yA  -  weightB  *  REDUCTION_FACTOR  *  yB)  /  (weightA  +  weightB);  final  int  p  =  agingB  -  MAXIMAL_AGING;  final  double  weightA  =  p  +  1;  final  double  weightB  =  (1  <<  p)  -  1;  targetY  =  (weightB  *  yB  -  weightA  *  REDUCTION_FACTOR  *  yA)  /  (weightA  +  weightB);  	[BUGGY]  targetY  =  -REDUCTION_FACTOR  *  yB  ;  targetY  =  -REDUCTION_FACTOR  *  yA  ;  [FE]  commonsmathexceptionTooManyEvaluationsException:  illegal  state:  maximal  count  (  100  )  exceeded:  evaluations  Assert  .  assertEquals  (  -0  .  5  ,  result  ,  1  .  0e-10  )  ;  [METHOD]  doSolve  [TYPE]  double  [PARAMETER]  [CLASS]  BracketingNthOrderBrentSolver  [TYPE]  AllowedSolution  allowed  [TYPE]  boolean  false  true  [TYPE]  double[]  tmpX  x  y  [TYPE]  double  DEFAULT_ABSOLUTE_ACCURACY  REDUCTION_FACTOR  absYA  absYB  nextX  nextY  targetY  xA  xB  xTol  yA  yB  [TYPE]  int  DEFAULT_MAXIMAL_ORDER  MAXIMAL_AGING  agingA  agingB  end  maximalOrder  nbPoints  signChangeIndex  start  [CONTEXT]  final  double  xTol  =  getAbsoluteAccuracy  (  )  +  getRelativeAccuracy  (  )  *  FastMath  .  max  (  FastMath  .  abs  (  xA  )  ,  FastMath  .  abs  (  xB  )  )  ;  if  (  (  (  xB  -  xA  )  <  =  xTol  )  ||  (  FastMath  .  max  (  absYA  ,  absYB  )  <  getFunctionValueAccuracy  (  )  )  )  {  switch  (  allowed  )  {  case  ANY_SIDE  :  return  absYA  <  absYB  ?  xA  :  xB  ;  case  LEFT_SIDE  :  return  xA  ;  case  RIGHT_SIDE  :  return  xB  ;  case  BELOW_SIDE  :  return  (  yA  <  =  0  )  ?  xA  :  xB  ;  case  ABOVE_SIDE  :  return  (  yA  <0  )  ?  xB  :  xA  ;  default  :  throw  new  MathInternalError  (  null  )  ;  }  }  double  targetY  ;  if  (  agingA  >  =  MAXIMAL_AGING  )  {  [BUGGY]  targetY  =  -REDUCTION_FACTOR  *  yB  ;  }  else  if  (  agingB  >  =  MAXIMAL_AGING  )  {  targetY  =  -REDUCTION_FACTOR  *  yA  ;  }  else  {  	Math_40_BracketingNthOrderBrentSolver_1_1	235	2	src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java
131	for  (int  i  =  begin;  i  <  begin  +  length;  i++)  {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  weights  .  length  ;  i++  )  {  [FE]  AssertionFailedError:  expected:<16644508338125354>  but  was:<031909161062727365>  [METHOD]  evaluate  [TYPE]  double  [PARAMETER]  final  double[]  values  final  double[]  weights  final  double  mean  final  int  begin  final  int  length  [CLASS]  Variance  [TYPE]  boolean  false  incMoment  isBiasCorrected  true  [TYPE]  double[]  values  weights  [TYPE]  long  serialVersionUID  [TYPE]  SecondMoment  moment  [TYPE]  double  accum  accum2  dev  mean  sumWts  var  [TYPE]  int  begin  i  length  [CONTEXT]  public  double  evaluate  (  final  double[]  values  ,  final  double[]  weights  ,  final  double  mean  ,  final  int  begin  ,  final  int  length  )  {  double  var  =  Double  .  NaN  ;  if  (  test  (  values  ,  weights  ,  begin  ,  length  )  )  {  if  (  length  =  =  1  )  {  var  =  0  .  0  ;  }  else  if  (  length  >  1  )  {  double  accum  =  0  .  0  ;  double  dev  =  0  .  0  ;  double  accum2  =  0  .  0  ;  for  (  int  i  =  begin  ;  i  <  begin  +  length  ;  i++  )  {  dev  =  values[i]  -  mean  ;  accum  +  =  weights[i]  *  (  dev  *  dev  )  ;  accum2  +  =  weights[i]  *  dev  ;  }  double  sumWts  =  0  ;  [BUGGY]  for  (  int  i  =  0  ;  i  <  weights  .  length  ;  i++  )  {  sumWts  +  =  weights[i]  ;  }  if  (  isBiasCorrected  )  {  var  =  (  accum  -  (  accum2  *  accum2  /  sumWts  )  )  /  (  sumWts  -  1  .  0  )  ;  	Math_41_Variance_1_1	520	1	src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java
132	if  (basicRow  !=  null  &&  basicRow  ==  0)  {  	[BUGGY]  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Precision  .  compareTo  (  solution  .  getPoint  (  )  [1]  ,  0  .  0d  ,  epsilon  )  >  =  0  )  ;  [METHOD]  getSolution  [TYPE]  RealPointValuePair  [PARAMETER]  [CLASS]  SimplexTableau  [TYPE]  Integer  basicRow  negativeVarBasicRow  [TYPE]  boolean  false  restrictToNonNegative  true  [TYPE]  Set  basicRows  [TYPE]  RealMatrix  tableau  [TYPE]  double[]  coefficients  [TYPE]  double  epsilon  mostNegative  [TYPE]  LinearObjectiveFunction  f  [TYPE]  List  columnLabels  constraints  [TYPE]  String  NEGATIVE_VAR_COLUMN_LABEL  [TYPE]  int  DEFAULT_ULPS  colIndex  i  maxUlps  negativeVarColumn  numArtificialVariables  numDecisionVariables  numSlackVariables  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  RealPointValuePair  getSolution  (  )  {  int  negativeVarColumn  =  columnLabels  .  indexOf  (  NEGATIVE_VAR_COLUMN_LABEL  )  ;  Integer  negativeVarBasicRow  =  negativeVarColumn  >  0  ?  getBasicRow  (  negativeVarColumn  )  :  null  ;  double  mostNegative  =  negativeVarBasicRow  =  =  null  ?  0  :  getEntry  (  negativeVarBasicRow  ,  getRhsOffset  (  )  )  ;  Set<Integer>  basicRows  =  new  HashSet<Integer>  (  )  ;  double[]  coefficients  =  new  double[getOriginalNumDecisionVariables  (  )  ]  ;  for  (  int  i  =  0  ;  i  <  coefficients  .  length  ;  i++  )  {  int  colIndex  =  columnLabels  .  indexOf  ( "x "  +  i  )  ;  if  (  colIndex  <  0  )  {  coefficients[i]  =  0  ;  continue  ;  }  Integer  basicRow  =  getBasicRow  (  colIndex  )  ;  [BUGGY]  if  (  basicRows  .  contains  (  basicRow  )  )  {  coefficients[i]  =  0  -  (  restrictToNonNegative  ?  0  :  mostNegative  )  ;  }  else  {  basicRows  .  add  (  basicRow  )  ;  coefficients[i]  =  (  basicRow  =  =  null  ?  0  :  getEntry  (  basicRow  ,  getRhsOffset  (  )  )  )  -  (  restrictToNonNegative  ?  0  :  mostNegative  )  ;  }  }  return  new  RealPointValuePair  (  coefficients  ,  f  .  getValue  (  coefficients  )  )  ;  }  	Math_42_SimplexTableau_2_1	410	0	src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
133	coefficients[i]  =  0;  }  else  if  (basicRows.contains(basicRow))  {  	[BUGGY]  if  (  basicRows  .  contains  (  basicRow  )  )  {  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Precision  .  compareTo  (  solution  .  getPoint  (  )  [1]  ,  0  .  0d  ,  epsilon  )  >  =  0  )  ;  [METHOD]  getSolution  [TYPE]  RealPointValuePair  [PARAMETER]  [CLASS]  SimplexTableau  [TYPE]  Integer  basicRow  negativeVarBasicRow  [TYPE]  boolean  false  restrictToNonNegative  true  [TYPE]  Set  basicRows  [TYPE]  RealMatrix  tableau  [TYPE]  double[]  coefficients  [TYPE]  double  epsilon  mostNegative  [TYPE]  LinearObjectiveFunction  f  [TYPE]  List  columnLabels  constraints  [TYPE]  String  NEGATIVE_VAR_COLUMN_LABEL  [TYPE]  int  DEFAULT_ULPS  colIndex  i  maxUlps  negativeVarColumn  numArtificialVariables  numDecisionVariables  numSlackVariables  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  RealPointValuePair  getSolution  (  )  {  int  negativeVarColumn  =  columnLabels  .  indexOf  (  NEGATIVE_VAR_COLUMN_LABEL  )  ;  Integer  negativeVarBasicRow  =  negativeVarColumn  >  0  ?  getBasicRow  (  negativeVarColumn  )  :  null  ;  double  mostNegative  =  negativeVarBasicRow  =  =  null  ?  0  :  getEntry  (  negativeVarBasicRow  ,  getRhsOffset  (  )  )  ;  Set<Integer>  basicRows  =  new  HashSet<Integer>  (  )  ;  double[]  coefficients  =  new  double[getOriginalNumDecisionVariables  (  )  ]  ;  for  (  int  i  =  0  ;  i  <  coefficients  .  length  ;  i++  )  {  int  colIndex  =  columnLabels  .  indexOf  ( "x "  +  i  )  ;  if  (  colIndex  <  0  )  {  coefficients[i]  =  0  ;  continue  ;  }  Integer  basicRow  =  getBasicRow  (  colIndex  )  ;  [BUGGY]  if  (  basicRows  .  contains  (  basicRow  )  )  {  coefficients[i]  =  0  -  (  restrictToNonNegative  ?  0  :  mostNegative  )  ;  }  else  {  basicRows  .  add  (  basicRow  )  ;  coefficients[i]  =  (  basicRow  =  =  null  ?  0  :  getEntry  (  basicRow  ,  getRhsOffset  (  )  )  )  -  (  restrictToNonNegative  ?  0  :  mostNegative  )  ;  }  }  return  new  RealPointValuePair  (  coefficients  ,  f  .  getValue  (  coefficients  )  )  ;  }  	Math_42_SimplexTableau_2_2	413	1	src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
134	if  (meanImpl  !=  mean)  {  if  (varianceImpl  !=  variance)  {  if  (geoMeanImpl  !=  geoMean)  {  	[BUGGY]  if  (  !  (  meanImpl  instanceof  Mean  )  )  {  if  (  !  (  varianceImpl  instanceof  Variance  )  )  {  if  (  !  (  geoMeanImpl  instanceof  GeometricMean  )  )  {  [FE]  AssertionFailedError:  expected:<25>  but  was:<NaN>  Assert  .  assertEquals  (  (  new  Mean  (  )  )  .  evaluate  (  scores  )  ,  stats  .  getMean  (  )  ,  0  )  ;  [METHOD]  addValue  [TYPE]  void  [PARAMETER]  double  value  [CLASS]  SummaryStatistics  [TYPE]  SumOfLogs  sumLog  [TYPE]  Mean  mean  [TYPE]  SumOfSquares  sumsq  [TYPE]  StorelessUnivariateStatistic  geoMeanImpl  maxImpl  meanImpl  minImpl  sumImpl  sumLogImpl  sumsqImpl  varianceImpl  [TYPE]  Max  max  [TYPE]  double  value  [TYPE]  GeometricMean  geoMean  [TYPE]  Sum  sum  [TYPE]  long  n  serialVersionUID  [TYPE]  Variance  variance  [TYPE]  Min  min  [TYPE]  boolean  false  true  [TYPE]  SecondMoment  secondMoment  [CONTEXT]  public  void  addValue  (  double  value  )  {  sumImpl  .  increment  (  value  )  ;  sumsqImpl  .  increment  (  value  )  ;  minImpl  .  increment  (  value  )  ;  maxImpl  .  increment  (  value  )  ;  sumLogImpl  .  increment  (  value  )  ;  secondMoment  .  increment  (  value  )  ;  [BUGGY]  if  (  !  (  meanImpl  instanceof  Mean  )  )  {  meanImpl  .  increment  (  value  )  ;  }  if  (  !  (  varianceImpl  instanceof  Variance  )  )  {  varianceImpl  .  increment  (  value  )  ;  }  if  (  !  (  geoMeanImpl  instanceof  GeometricMean  )  )  {  geoMeanImpl  .  increment  (  value  )  ;  }  n++  ;  }  	Math_43_SummaryStatistics_1_1	158	3	src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java
135		[BUGGY]  resetOccurred  =  false  ;  [FE]  AssertionFailedError:  going  backard  in  time!  (  7796578226186635  <  1099  )  [METHOD]  acceptStep  [TYPE]  double  [PARAMETER]  AbstractStepInterpolator  interpolator  final  double[]  y  final  double[]  yDot  final  double  tEnd  [CLASS]  AbstractIntegrator  [TYPE]  ExpandableStatefulODE  expandable  [TYPE]  EventState  currentEvent  es0  es1  state  [TYPE]  double  currentT  eventT  previousT  stepSize  stepStart  tEnd  [TYPE]  Incrementor  evaluations  [TYPE]  StepHandler  handler  [TYPE]  String  name  [TYPE]  SortedSet  occuringEvents  [TYPE]  int  orderingSign  [TYPE]  boolean  false  isLastStep  resetOccurred  statesInitialized  true  [TYPE]  double[]  currentY  eventY  y  yDot  [TYPE]  Iterator  iterator  [TYPE]  Collection  eventsStates  stepHandlers  [TYPE]  AbstractStepInterpolator  interpolator  [CONTEXT]  protected  double  acceptStep  (  final  AbstractStepInterpolator  interpolator  ,  final  double[]  y  ,  final  double[]  yDot  ,  final  double  tEnd  )  throws  MathIllegalStateException  {  double  previousT  =  interpolator  .  getGlobalPreviousTime  (  )  ;  final  double  currentT  =  interpolator  .  getGlobalCurrentTime  (  )  ;  [BUGGY]  resetOccurred  =  false  ;  if  (  !  statesInitialized  )  {  for  (  EventState  state  :  eventsStates  )  {  state  .  reinitializeBegin  (  interpolator  )  ;  	Math_44_AbstractIntegrator_3_1	280	1	src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java
136	for  (final  EventState  remaining  :  occuringEvents)  {  remaining.stepAccepted(eventT,  eventY);  }  	[BUGGY]  [FE]  AssertionFailedError:  going  backard  in  time!  (  7796578226186635  <  1099  )  [METHOD]  acceptStep  [TYPE]  double  [PARAMETER]  AbstractStepInterpolator  interpolator  final  double[]  y  final  double[]  yDot  final  double  tEnd  [CLASS]  AbstractIntegrator  [TYPE]  ExpandableStatefulODE  expandable  [TYPE]  EventState  currentEvent  es0  es1  state  [TYPE]  double  currentT  eventT  previousT  stepSize  stepStart  tEnd  [TYPE]  Incrementor  evaluations  [TYPE]  StepHandler  handler  [TYPE]  String  name  [TYPE]  SortedSet  occuringEvents  [TYPE]  int  orderingSign  [TYPE]  boolean  false  isLastStep  resetOccurred  statesInitialized  true  [TYPE]  double[]  currentY  eventY  y  yDot  [TYPE]  Iterator  iterator  [TYPE]  Collection  eventsStates  stepHandlers  [TYPE]  AbstractStepInterpolator  interpolator  [CONTEXT]  final  Iterator<EventState>  iterator  =  occuringEvents  .  iterator  (  )  ;  final  EventState  currentEvent  =  iterator  .  next  (  )  ;  iterator  .  remove  (  )  ;  final  double  eventT  =  currentEvent  .  getEventTime  (  )  ;  interpolator  .  setSoftPreviousTime  (  previousT  )  ;  interpolator  .  setSoftCurrentTime  (  eventT  )  ;  interpolator  .  setInterpolatedTime  (  eventT  )  ;  final  double[]  eventY  =  interpolator  .  getInterpolatedState  (  )  ;  currentEvent  .  stepAccepted  (  eventT  ,  eventY  )  ;  isLastStep  =  currentEvent  .  stop  (  )  ;  for  (  final  StepHandler  handler  :  stepHandlers  )  {  handler  .  handleStep  (  interpolator  ,  isLastStep  )  ;  }  if  (  isLastStep  )  {  System  .  arraycopy  (  eventY  ,  0  ,  y  ,  0  ,  y  .  length  )  ;  [BUGGY]  return  eventT  ;  }  if  (  currentEvent  .  reset  (  eventT  ,  eventY  )  )  {  	Math_44_AbstractIntegrator_3_2	334	0	src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java
137	for  (final  EventState  remaining  :  occuringEvents)  {  remaining.stepAccepted(eventT,  eventY);  }  	[BUGGY]  [FE]  AssertionFailedError:  going  backard  in  time!  (  7796578226186635  <  1099  )  [METHOD]  acceptStep  [TYPE]  double  [PARAMETER]  AbstractStepInterpolator  interpolator  final  double[]  y  final  double[]  yDot  final  double  tEnd  [CLASS]  AbstractIntegrator  [TYPE]  ExpandableStatefulODE  expandable  [TYPE]  EventState  currentEvent  es0  es1  state  [TYPE]  double  currentT  eventT  previousT  stepSize  stepStart  tEnd  [TYPE]  Incrementor  evaluations  [TYPE]  StepHandler  handler  [TYPE]  String  name  [TYPE]  SortedSet  occuringEvents  [TYPE]  int  orderingSign  [TYPE]  boolean  false  isLastStep  resetOccurred  statesInitialized  true  [TYPE]  double[]  currentY  eventY  y  yDot  [TYPE]  Iterator  iterator  [TYPE]  Collection  eventsStates  stepHandlers  [TYPE]  AbstractStepInterpolator  interpolator  [CONTEXT]  interpolator  .  setSoftCurrentTime  (  eventT  )  ;  interpolator  .  setInterpolatedTime  (  eventT  )  ;  final  double[]  eventY  =  interpolator  .  getInterpolatedState  (  )  ;  currentEvent  .  stepAccepted  (  eventT  ,  eventY  )  ;  isLastStep  =  currentEvent  .  stop  (  )  ;  for  (  final  StepHandler  handler  :  stepHandlers  )  {  handler  .  handleStep  (  interpolator  ,  isLastStep  )  ;  }  if  (  isLastStep  )  {  System  .  arraycopy  (  eventY  ,  0  ,  y  ,  0  ,  y  .  length  )  ;  return  eventT  ;  }  if  (  currentEvent  .  reset  (  eventT  ,  eventY  )  )  {  System  .  arraycopy  (  eventY  ,  0  ,  y  ,  0  ,  y  .  length  )  ;  computeDerivatives  (  eventT  ,  y  ,  yDot  )  ;  resetOccurred  =  true  ;  [BUGGY]  return  eventT  ;  }  previousT  =  eventT  ;  interpolator  .  setSoftPreviousTime  (  eventT  )  ;  	Math_44_AbstractIntegrator_3_3	343	0	src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java
138	long  lRow  =  (long)  rowDimension;  long  lCol  =  (long)  columnDimension;  if  (lRow  *  lCol  >=  (long)  Integer.MAX_VALUE)  {  throw  new  NumberIsTooLargeException(lRow  *  lCol,  Integer.MAX_VALUE,  false);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exception:  orgapachecommonsmathexceptionNumberIsTooLargeException  [CLASS]  [CONTEXT]  	Math_45_OpenMapRealMatrix_1_1	50	0	src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java
139	return  NaN;  	[BUGGY]  return  isZero  ?  NaN  :  INF  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Complex  .  I  .  atan  (  )  .  isNaN  (  )  )  ;  [METHOD]  divide  [TYPE]  Complex  [PARAMETER]  Complex  divisor  [CLASS]  Complex  [TYPE]  boolean  false  isInfinite  isNaN  isZero  true  [TYPE]  double  c  d  denominator  imaginary  q  real  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  divisor  [CONTEXT]  public  Complex  divide  (  Complex  divisor  )  throws  NullArgumentException  {  MathUtils  .  checkNotNull  (  divisor  )  ;  if  (  isNaN  ||  divisor  .  isNaN  )  {  return  NaN  ;  }  if  (  divisor  .  isZero  )  {  [BUGGY]  return  isZero  ?  NaN  :  INF  ;  }  if  (  divisor  .  isInfinite  (  )  &&  !isInfinite  (  )  )  {  return  ZERO  ;  }  	Math_46_Complex_2_1	260	1	src/main/java/org/apache/commons/math/complex/Complex.java
140	return  NaN;  	[BUGGY]  return  isZero  ?  NaN  :  INF  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Complex  .  I  .  atan  (  )  .  isNaN  (  )  )  ;  [METHOD]  divide  [TYPE]  Complex  [PARAMETER]  double  divisor  [CLASS]  Complex  [TYPE]  boolean  false  isInfinite  isNaN  isZero  true  [TYPE]  double  divisor  imaginary  real  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  [CONTEXT]  public  Complex  divide  (  double  divisor  )  {  if  (  isNaN  ||  Double  .  isNaN  (  divisor  )  )  {  return  NaN  ;  }  if  (  divisor  =  =  0d  )  {  [BUGGY]  return  isZero  ?  NaN  :  INF  ;  }  if  (  Double  .  isInfinite  (  divisor  )  )  {  return  !isInfinite  (  )  ?  ZERO  :  NaN  ;  }  return  createComplex  (  real  /  divisor  ,  imaginary/  divisor  )  ;  }  	Math_46_Complex_2_2	297	1	src/main/java/org/apache/commons/math/complex/Complex.java
141	private  final  transient  boolean  isZero;  	[BUGGY]  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Complex  .  I  .  atan  (  )  .  isInfinite  (  )  )  ;  [CLASS]  [CONTEXT]  	Math_47_Complex_4_1	82	0	src/main/java/org/apache/commons/math/complex/Complex.java
142	isZero  =  real  ==  0  &&  imaginary  ==  0;  	[BUGGY]  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Complex  .  I  .  atan  (  )  .  isInfinite  (  )  )  ;  [CLASS]  [CONTEXT]  	Math_47_Complex_4_2	105	0	src/main/java/org/apache/commons/math/complex/Complex.java
143	if  (divisor.isZero)  {  return  isZero  ?  NaN  :  INF;  	[BUGGY]  if  (  divisor  .  getReal  (  )  =  =  0  .  0  &&  divisor  .  getImaginary  (  )  =  =  0  .  0  )  {  return  NaN  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Complex  .  I  .  atan  (  )  .  isInfinite  (  )  )  ;  [METHOD]  divide  [TYPE]  Complex  [PARAMETER]  Complex  divisor  [CLASS]  Complex  [TYPE]  boolean  false  isInfinite  isNaN  true  [TYPE]  double  c  d  denominator  imaginary  q  real  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  divisor  [CONTEXT]  public  Complex  divide  (  Complex  divisor  )  throws  NullArgumentException  {  MathUtils  .  checkNotNull  (  divisor  )  ;  if  (  isNaN  ||  divisor  .  isNaN  )  {  return  NaN  ;  }  [BUGGY]  if  (  divisor  .  getReal  (  )  =  =  0  .  0  &&  divisor  .  getImaginary  (  )  =  =  0  .  0  )  {  return  NaN  ;  }  if  (  divisor  .  isInfinite  (  )  &&  !isInfinite  (  )  )  {  return  ZERO  ;  }  final  double  c  =  divisor  .  getReal  (  )  ;  final  double  d  =  divisor  .  getImaginary  (  )  ;  if  (  FastMath  .  abs  (  c  )  <  FastMath  .  abs  (  d  )  )  {  double  q  =  c  /  d  ;  double  denominator  =  c  *  q  +  d  ;  return  createComplex  (  (  real  *  q  +  imaginary  )  /  denominator  ,  (  imaginary  *  q  -  real  )  /  denominator  )  ;  }  else  {  double  q  =  d  /  c  ;  double  denominator  =  d  *  q  +  c  ;  return  createComplex  (  (  imaginary  *  q  +  real  )  /  denominator  ,  (  imaginary  -  real  *  q  )  /  denominator  )  ;  }  }  	Math_47_Complex_4_3	256	2	src/main/java/org/apache/commons/math/complex/Complex.java
144	return  isZero  ?  NaN  :  INF;  	[BUGGY]  return  NaN  ;  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Complex  .  I  .  atan  (  )  .  isInfinite  (  )  )  ;  [METHOD]  divide  [TYPE]  Complex  [PARAMETER]  double  divisor  [CLASS]  Complex  [TYPE]  boolean  false  isInfinite  isNaN  true  [TYPE]  double  divisor  imaginary  real  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  [CONTEXT]  public  Complex  divide  (  double  divisor  )  {  if  (  isNaN  ||  Double  .  isNaN  (  divisor  )  )  {  return  NaN  ;  }  if  (  divisor  =  =  0d  )  {  [BUGGY]  return  NaN  ;  }  if  (  Double  .  isInfinite  (  divisor  )  )  {  return  !isInfinite  (  )  ?  ZERO  :  NaN  ;  }  return  createComplex  (  real  /  divisor  ,  imaginary/  divisor  )  ;  }  	Math_47_Complex_4_4	293	1	src/main/java/org/apache/commons/math/complex/Complex.java
145	if  (x  ==  x1)  {  throw  new  ConvergenceException();  }  	[BUGGY]  [FE]  Exception:  Unexpected  exception  ,  expected<ConvergenceException>  but  was<TooManyEvaluationsException>  Assert  .  assertEquals  (  3  .  4341896575482003  ,  root  ,  1e-15  )  ;  [METHOD]  doSolve  [TYPE]  double  [PARAMETER]  [CLASS]  BaseSecantSolver  [TYPE]  AllowedSolution  allowed  [TYPE]  Method  ILLINOIS  PEGASUS  REGULA_FALSI  method  [TYPE]  boolean  false  inverted  true  [TYPE]  double  DEFAULT_ABSOLUTE_ACCURACY  atol  f0  f1  ftol  fx  rtol  x  x0  x1  [CONTEXT]  if  (  fx  =  =  0  .  0  )  {  return  x  ;  }  if  (  f1  *  fx  <  0  )  {  x0  =  x1  ;  f0  =  f1  ;  inverted  =  !inverted  ;  }  else  {  switch  (  method  )  {  case  ILLINOIS:  f0  *  =  0  .  5  ;  break  ;  case  PEGASUS:  f0  *  =  f1  /  (  f1  +  fx  )  ;  break  ;  case  REGULA_FALSI:  [BUGGY]  break  ;  default:  throw  new  MathInternalError  (  )  ;  }  }  	Math_48_BaseSecantSolver_1_1	189	0	src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
146	Iterator  iter  =  entries.iterator();  	[BUGGY]  Iterator  iter  =  res  .  entries  .  iterator  (  )  ;  [FE]  commonsmathMathRuntimeException$6:  map  has  been  modified  while  iterating  [METHOD]  ebeDivide  [TYPE]  OpenMapRealVector  [PARAMETER]  RealVector  v  [CLASS]  OpenMapRealVector  [TYPE]  Entry  current  [TYPE]  boolean  false  true  [TYPE]  double  DEFAULT_ZERO_TOLERANCE  epsilon  [TYPE]  RealVector  v  [TYPE]  Iterator  iter  [TYPE]  OpenMapRealVector  res  [TYPE]  OpenIntToDoubleHashMap  entries  [TYPE]  long  serialVersionUID  [TYPE]  int  virtualSize  [CONTEXT]  public  OpenMapRealVector  ebeDivide  (  RealVector  v  )  {  checkVectorDimensions  (  v  .  getDimension  (  )  )  ;  OpenMapRealVector  res  =  new  OpenMapRealVector  (  this  )  ;  [BUGGY]  Iterator  iter  =  res  .  entries  .  iterator  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  iter  .  advance  (  )  ;  res  .  setEntry  (  iter  .  key  (  )  ,  iter  .  value  (  )  /  v  .  getEntry  (  iter  .  key  (  )  )  )  ;  }  return  res  ;  }  	Math_49_OpenMapRealVector_4_1	345	1	src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java
147	Iterator  iter  =  entries.iterator();  	[BUGGY]  Iterator  iter  =  res  .  entries  .  iterator  (  )  ;  [FE]  commonsmathMathRuntimeException$6:  map  has  been  modified  while  iterating  [METHOD]  ebeDivide  [TYPE]  OpenMapRealVector  [PARAMETER]  double[]  v  [CLASS]  OpenMapRealVector  [TYPE]  Entry  current  [TYPE]  boolean  false  true  [TYPE]  double[]  v  [TYPE]  double  DEFAULT_ZERO_TOLERANCE  epsilon  [TYPE]  Iterator  iter  [TYPE]  OpenMapRealVector  res  [TYPE]  OpenIntToDoubleHashMap  entries  [TYPE]  long  serialVersionUID  [TYPE]  int  virtualSize  [CONTEXT]  public  OpenMapRealVector  ebeDivide  (  double[]  v  )  {  checkVectorDimensions  (  v  .  length  )  ;  OpenMapRealVector  res  =  new  OpenMapRealVector  (  this  )  ;  [BUGGY]  Iterator  iter  =  res  .  entries  .  iterator  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  iter  .  advance  (  )  ;  res  .  setEntry  (  iter  .  key  (  )  ,  iter  .  value  (  )  /  v[iter  .  key  (  )  ]  )  ;  }  return  res  ;  }  	Math_49_OpenMapRealVector_4_2	358	1	src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java
148	Iterator  iter  =  entries.iterator();  	[BUGGY]  Iterator  iter  =  res  .  entries  .  iterator  (  )  ;  [FE]  commonsmathMathRuntimeException$6:  map  has  been  modified  while  iterating  [METHOD]  ebeMultiply  [TYPE]  OpenMapRealVector  [PARAMETER]  RealVector  v  [CLASS]  OpenMapRealVector  [TYPE]  Entry  current  [TYPE]  boolean  false  true  [TYPE]  double  DEFAULT_ZERO_TOLERANCE  epsilon  [TYPE]  RealVector  v  [TYPE]  Iterator  iter  [TYPE]  OpenMapRealVector  res  [TYPE]  OpenIntToDoubleHashMap  entries  [TYPE]  long  serialVersionUID  [TYPE]  int  virtualSize  [CONTEXT]  public  OpenMapRealVector  ebeMultiply  (  RealVector  v  )  {  checkVectorDimensions  (  v  .  getDimension  (  )  )  ;  OpenMapRealVector  res  =  new  OpenMapRealVector  (  this  )  ;  [BUGGY]  Iterator  iter  =  res  .  entries  .  iterator  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  iter  .  advance  (  )  ;  res  .  setEntry  (  iter  .  key  (  )  ,  iter  .  value  (  )  *  v  .  getEntry  (  iter  .  key  (  )  )  )  ;  }  return  res  ;  }  	Math_49_OpenMapRealVector_4_3	370	1	src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java
149	Iterator  iter  =  entries.iterator();  	[BUGGY]  Iterator  iter  =  res  .  entries  .  iterator  (  )  ;  [FE]  commonsmathMathRuntimeException$6:  map  has  been  modified  while  iterating  [METHOD]  ebeMultiply  [TYPE]  OpenMapRealVector  [PARAMETER]  double[]  v  [CLASS]  OpenMapRealVector  [TYPE]  Entry  current  [TYPE]  boolean  false  true  [TYPE]  double[]  v  [TYPE]  double  DEFAULT_ZERO_TOLERANCE  epsilon  [TYPE]  Iterator  iter  [TYPE]  OpenMapRealVector  res  [TYPE]  OpenIntToDoubleHashMap  entries  [TYPE]  long  serialVersionUID  [TYPE]  int  virtualSize  [CONTEXT]  public  OpenMapRealVector  ebeMultiply  (  double[]  v  )  {  checkVectorDimensions  (  v  .  length  )  ;  OpenMapRealVector  res  =  new  OpenMapRealVector  (  this  )  ;  [BUGGY]  Iterator  iter  =  res  .  entries  .  iterator  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  iter  .  advance  (  )  ;  res  .  setEntry  (  iter  .  key  (  )  ,  iter  .  value  (  )  *  v[iter  .  key  (  )  ]  )  ;  }  return  res  ;  }  	Math_49_OpenMapRealVector_4_4	383	1	src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java
150		[BUGGY]  if  (  x  =  =  x1  )  {  x0  =  0  .  5  *  (  x0  +  x1  -  FastMath  .  max  (  rtol  *  FastMath  .  abs  (  x1  )  ,  atol  )  )  ;  f0  =  computeObjectiveValue  (  x0  )  ;  }  [FE]  AssertionFailedError:  Expected  exception:  orgapachecommonsmathexceptionTooManyEvaluationsException  Assert  .  assertEquals  (  3  .  4341896575482003  ,  root  ,  1e-15  )  ;  [METHOD]  doSolve  [TYPE]  double  [PARAMETER]  [CLASS]  BaseSecantSolver  [TYPE]  AllowedSolution  allowed  [TYPE]  Method  ILLINOIS  PEGASUS  REGULA_FALSI  method  [TYPE]  boolean  false  inverted  true  [TYPE]  double  DEFAULT_ABSOLUTE_ACCURACY  atol  f0  f1  ftol  fx  rtol  x  x0  x1  [CONTEXT]  if  (  fx  =  =  0  .  0  )  {  return  x  ;  }  if  (  f1  *  fx  <  0  )  {  x0  =  x1  ;  f0  =  f1  ;  inverted  =  !inverted  ;  }  else  {  switch  (  method  )  {  case  ILLINOIS:  f0  *  =  0  .  5  ;  break  ;  case  PEGASUS:  f0  *  =  f1  /  (  f1  +  fx  )  ;  break  ;  case  REGULA_FALSI:  [BUGGY]  if  (  x  =  =  x1  )  {  x0  =  0  .  5  *  (  x0  +  x1  -  FastMath  .  max  (  rtol  *  FastMath  .  abs  (  x1  )  ,  atol  )  )  ;  f0  =  computeObjectiveValue  (  x0  )  ;  }  break  ;  default:  	Math_50_BaseSecantSolver_1_1	187	4	src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
151	case  REGULA_FALSI:  if  (x  ==  x1)  {  final  double  delta  =  FastMath.max(rtol  *  FastMath.abs(x1),  atol);  x0  =  0.5  *  (x0  +  x1  -  delta);  f0  =  computeObjectiveValue(x0);  }  break;  throw  new  MathInternalError();  	[BUGGY]  [FE]  commonsmathexceptionTooManyEvaluationsException:  illegal  state:  maximal  count  (  3  ,  624  )  exceeded:  evaluations  Assert  .  assertEquals  (  3  .  4341896575482003  ,  root  ,  1e-15  )  ;  [METHOD]  doSolve  [TYPE]  double  [PARAMETER]  [CLASS]  BaseSecantSolver  [TYPE]  AllowedSolution  allowed  [TYPE]  Method  ILLINOIS  PEGASUS  REGULA_FALSI  method  [TYPE]  boolean  false  inverted  true  [TYPE]  double  DEFAULT_ABSOLUTE_ACCURACY  atol  f0  f1  ftol  fx  rtol  x  x0  x1  [CONTEXT]  final  double  x  =  x1  -  (  (  f1  *  (  x1  -  x0  )  )  /  (  f1  -  f0  )  )  ;  final  double  fx  =  computeObjectiveValue  (  x  )  ;  if  (  fx  =  =  0  .  0  )  {  return  x  ;  }  if  (  f1  *  fx  <  0  )  {  x0  =  x1  ;  f0  =  f1  ;  inverted  =  !inverted  ;  }  else  {  switch  (  method  )  {  case  ILLINOIS:  f0  *  =  0  .  5  ;  break  ;  case  PEGASUS:  f0  *  =  f1  /  (  f1  +  fx  )  ;  break  ;  [BUGGY]  default:  }  }  	Math_51_BaseSecantSolver_1_1	185	0	src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java
152	final  double  inPlaneThreshold  =  0.001;  if  (c  <=  inPlaneThreshold  *  k.getNorm()  *  u3.getNorm())  {  	[BUGGY]  if  (  c  =  =  0  )  {  [FE]  AssertionFailedError:  expected:<06228370359608201>  but  was:<NaN>  Assert  .  assertEquals  (  0  ,  Rotation  .  distance  (  r  ,  new  Rotation  (  q0  ,  q1  ,  q2  ,  q3  ,  false  )  )  ,  1  .  0e-12  )  ;  [CLASS]  [CONTEXT]  	Math_52_Rotation_3_1	344	1	src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java
153	if  (c  <=  inPlaneThreshold  *  k.getNorm()  *  u2Prime.getNorm())  {  	[BUGGY]  if  (  c  =  =  0  )  {  [FE]  AssertionFailedError:  expected:<06228370359608201>  but  was:<NaN>  Assert  .  assertEquals  (  0  ,  Rotation  .  distance  (  r  ,  new  Rotation  (  q0  ,  q1  ,  q2  ,  q3  ,  false  )  )  ,  1  .  0e-12  )  ;  [CLASS]  [CONTEXT]  	Math_52_Rotation_3_2	353	1	src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java
154	if  (c  <=  0)  {  	[BUGGY]  if  (  c  =  =  0  )  {  [FE]  AssertionFailedError:  expected:<06228370359608201>  but  was:<NaN>  Assert  .  assertEquals  (  0  ,  Rotation  .  distance  (  r  ,  new  Rotation  (  q0  ,  q1  ,  q2  ,  q3  ,  false  )  )  ,  1  .  0e-12  )  ;  [CLASS]  [CONTEXT]  	Math_52_Rotation_3_3	359	1	src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java
155	if  (isNaN  ||  rhs.isNaN)  {  return  NaN;  }  	[BUGGY]  [FE]  AssertionFailedError  Assert  .  assertTrue  (  Double  .  isNaN  (  w  .  getImaginary  (  )  )  )  ;  [METHOD]  add  [TYPE]  Complex  [PARAMETER]  Complex  rhs  [CLASS]  Complex  [TYPE]  boolean  false  isInfinite  isNaN  true  [TYPE]  double  imaginary  real  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  rhs  [CONTEXT]  public  Complex  add  (  Complex  rhs  )  throws  NullArgumentException  {  MathUtils  .  checkNotNull  (  rhs  )  ;  [BUGGY]  return  createComplex  (  real  +  rhs  .  getReal  (  )  ,  imaginary  +  rhs  .  getImaginary  (  )  )  ;  }  	Math_53_Complex_1_1	153	0	src/main/java/org/apache/commons/math/complex/Complex.java
156	if  ((bits  &  0x8000000000000000L)  !=  0)  {  sign  =  -1;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<00>  but  was:<-Infinity>  Assert  .  assertEquals  (  +1  ,  FastMath  .  copySign  (  1  ,  field  .  newDfp  (  +0  .  0  )  .  toDouble  (  )  )  ,  MathUtils  .  EPSILON  )  ;  [CLASS]  [CONTEXT]  	Math_54_Dfp_2_1	273	0	src/main/java/org/apache/commons/math/dfp/Dfp.java
157	int  cmp0  =  compare(this,  getZero());  if  (cmp0  ==  0)  {  return  sign  <  0  ?  -0.0  :  +0.0;  }  else  if  (cmp0  <  0)  {  	[BUGGY]  if  (  lessThan  (  getZero  (  )  )  )  {  [FE]  AssertionFailedError:  expected:<00>  but  was:<-Infinity>  Assert  .  assertEquals  (  +1  ,  FastMath  .  copySign  (  1  ,  field  .  newDfp  (  +0  .  0  )  .  toDouble  (  )  )  ,  MathUtils  .  EPSILON  )  ;  [METHOD]  toDouble  [TYPE]  double  [PARAMETER]  [CLASS]  Dfp  [TYPE]  boolean  false  negate  true  [TYPE]  byte  FINITE  INFINITE  QNAN  SNAN  nans  sign  [TYPE]  double  x  [TYPE]  DfpField  field  [TYPE]  int[]  mant  [TYPE]  String  ADD_TRAP  ALIGN_TRAP  DIVIDE_TRAP  GREATER_THAN_TRAP  LESS_THAN_TRAP  MULTIPLY_TRAP  NAN_STRING  NEG_INFINITY_STRING  NEW_INSTANCE_TRAP  NEXT_AFTER_TRAP  POS_INFINITY_STRING  SQRT_TRAP  TRUNC_TRAP  str  [TYPE]  int  ERR_SCALE  MAX_EXP  MIN_EXP  RADIX  exp  exponent  [TYPE]  long  bits  mantissa  [TYPE]  Dfp  tempDfp  y  [CONTEXT]  public  double  toDouble  (  )  {  if  (  isInfinite  (  )  )  {  if  (  lessThan  (  getZero  (  )  )  )  {  return  Double  .  NEGATIVE_INFINITY  ;  }  else  {  return  Double  .  POSITIVE_INFINITY  ;  }  }  if  (  isNaN  (  )  )  {  return  Double  .  NaN  ;  }  Dfp  y  =  this  ;  boolean  negate  =  false  ;  [BUGGY]  if  (  lessThan  (  getZero  (  )  )  )  {  y  =  negate  (  )  ;  negate  =  true  ;  }  	Math_54_Dfp_2_2	2319	1	src/main/java/org/apache/commons/math/dfp/Dfp.java
158	final  double  n1  =  v1.getNormSq();  final  double  n2  =  v2.getNormSq();  if  ((n1  *  n2)  <  MathUtils.SAFE_MIN)  {  return  ZERO;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<10>  but  was:<00>  [METHOD]  crossProduct  [TYPE]  Vector3D  [PARAMETER]  Vector3D  v1  Vector3D  v2  [CLASS]  Vector3D  [TYPE]  Vector3DFormat  DEFAULT_FORMAT  [TYPE]  boolean  false  true  [TYPE]  Vector3D  MINUS_I  MINUS_J  MINUS_K  NEGATIVE_INFINITY  NaN  PLUS_I  PLUS_J  PLUS_K  POSITIVE_INFINITY  ZERO  v1  v2  [TYPE]  double  x  y  z  [TYPE]  long  serialVersionUID  [CONTEXT]  public  static  Vector3D  crossProduct  (  final  Vector3D  v1  ,  final  Vector3D  v2  )  {  [BUGGY]  return  new  Vector3D  (  v1  .  y  *  v2  .  z  -  v1  .  z  *  v2  .  y  ,  v1  .  z  *  v2  .  x  -  v1  .  x  *  v2  .  z  ,  v1  .  x  *  v2  .  y  -  v1  .  y  *  v2  .  x  )  ;  }  	Math_55_Vector3D_3_1	459	0	src/main/java/org/apache/commons/math/geometry/Vector3D.java
159	final  int  deltaExp  =  (FastMath.getExponent(n1)  -  FastMath.getExponent(n2))  /  4;  final  double  x1  =  FastMath.scalb(v1.x,  -deltaExp);  final  double  y1  =  FastMath.scalb(v1.y,  -deltaExp);  final  double  z1  =  FastMath.scalb(v1.z,  -deltaExp);  final  double  x2  =  FastMath.scalb(v2.x,  deltaExp);  final  double  y2  =  FastMath.scalb(v2.y,  deltaExp);  final  double  z2  =  FastMath.scalb(v2.z,  deltaExp);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<10>  but  was:<00>  [METHOD]  crossProduct  [TYPE]  Vector3D  [PARAMETER]  Vector3D  v1  Vector3D  v2  [CLASS]  Vector3D  [TYPE]  Vector3DFormat  DEFAULT_FORMAT  [TYPE]  boolean  false  true  [TYPE]  Vector3D  MINUS_I  MINUS_J  MINUS_K  NEGATIVE_INFINITY  NaN  PLUS_I  PLUS_J  PLUS_K  POSITIVE_INFINITY  ZERO  v1  v2  [TYPE]  double  x  y  z  [TYPE]  long  serialVersionUID  [CONTEXT]  public  static  Vector3D  crossProduct  (  final  Vector3D  v1  ,  final  Vector3D  v2  )  {  [BUGGY]  return  new  Vector3D  (  v1  .  y  *  v2  .  z  -  v1  .  z  *  v2  .  y  ,  v1  .  z  *  v2  .  x  -  v1  .  x  *  v2  .  z  ,  v1  .  x  *  v2  .  y  -  v1  .  y  *  v2  .  x  )  ;  }  	Math_55_Vector3D_3_2	462	0	src/main/java/org/apache/commons/math/geometry/Vector3D.java
160	final  double  ratio  =  (x1  *  x2  +  y1  *  y2  +  z1  *  z2)  /  FastMath.scalb(n2,  2  *  deltaExp);  final  double  rho  =  FastMath.rint(256  *  ratio)  /  256;  final  double  x3  =  x1  -  rho  *  x2;  final  double  y3  =  y1  -  rho  *  y2;  final  double  z3  =  z1  -  rho  *  z2;  return  new  Vector3D(y3  *  z2  -  z3  *  y2,  z3  *  x2  -  x3  *  z2,  x3  *  y2  -  y3  *  x2);  	[BUGGY]  return  new  Vector3D  (  v1  .  y  *  v2  .  z  -  v1  .  z  *  v2  .  y  ,  v1  .  z  *  v2  .  x  -  v1  .  x  *  v2  .  z  ,  v1  .  x  *  v2  .  y  -  v1  .  y  *  v2  .  x  )  ;  [FE]  AssertionFailedError:  expected:<10>  but  was:<00>  [METHOD]  crossProduct  [TYPE]  Vector3D  [PARAMETER]  Vector3D  v1  Vector3D  v2  [CLASS]  Vector3D  [TYPE]  Vector3DFormat  DEFAULT_FORMAT  [TYPE]  boolean  false  true  [TYPE]  Vector3D  MINUS_I  MINUS_J  MINUS_K  NEGATIVE_INFINITY  NaN  PLUS_I  PLUS_J  PLUS_K  POSITIVE_INFINITY  ZERO  v1  v2  [TYPE]  double  x  y  z  [TYPE]  long  serialVersionUID  [CONTEXT]  public  static  Vector3D  crossProduct  (  final  Vector3D  v1  ,  final  Vector3D  v2  )  {  [BUGGY]  return  new  Vector3D  (  v1  .  y  *  v2  .  z  -  v1  .  z  *  v2  .  y  ,  v1  .  z  *  v2  .  x  -  v1  .  x  *  v2  .  z  ,  v1  .  x  *  v2  .  y  -  v1  .  y  *  v2  .  x  )  ;  }  	Math_55_Vector3D_3_3	470	1	src/main/java/org/apache/commons/math/geometry/Vector3D.java
161	indices[last]  =  index  -  count;  	[BUGGY]  int  idx  =  1  ;  while  (  count  <  index  )  {  count  +  =  idx  ;  ++idx  ;  }  --idx  ;  indices[last]  =  idx  ;  [FE]  AssertionFailedError:  Wrong  multidimensional  index  for  [3][2]  expected:<3>  but  was:<2>  Assert  .  assertEquals  ( "Wrong  multidimensional  index  for  [ "  +  i  + "][ "  +  dimIndex  + "] "  ,  [METHOD]  getCounts  [TYPE]  int[]  [PARAMETER]  int  index  [CLASS]  MultidimensionalCounter  [TYPE]  int[]  counter  indices  size  uniCounterOffset  [TYPE]  int  count  dimension  i  idx  index  last  offset  totalSize  [TYPE]  boolean  false  true  [CONTEXT]  public  int[]  getCounts  (  int  index  )  {  if  (  index  <  0  ||  index  >  =  totalSize  )  {  throw  new  OutOfRangeException  (  index  ,  0  ,  totalSize  )  ;  }  final  int[]  indices  =  new  int[dimension]  ;  int  count  =  0  ;  for  (  int  i  =  0  ;  i  <  last  ;  i++  )  {  int  idx  =  0  ;  final  int  offset  =  uniCounterOffset[i]  ;  while  (  count  <  =  index  )  {  count  +  =  offset  ;  ++idx  ;  }  --idx  ;  count  -  =  offset  ;  indices[i]  =  idx  ;  }  [BUGGY]  int  idx  =  1  ;  while  (  count  <  index  )  {  count  +  =  idx  ;  ++idx  ;  }  --idx  ;  	Math_56_MultidimensionalCounter_1_1	237	7	src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java
162	double  sum  =  0;  	[BUGGY]  int  sum  =  0  ;  [FE]  AssertionFailedError  assertTrue  (  uniquePointIsCenter  )  ;  [CONTEXT]  final  List<Cluster<T>>  resultSet  =  new  ArrayList<Cluster<T>>  (  )  ;  final  T  firstPoint  =  pointSet  .  remove  (  random  .  nextInt  (  pointSet  .  size  (  )  )  )  ;  resultSet  .  add  (  new  Cluster<T>  (  firstPoint  )  )  ;  final  double[]  dx2  =  new  double[pointSet  .  size  (  )  ]  ;  while  (  resultSet  .  size  (  )  <  k  )  {  [BUGGY]  int  sum  =  0  ;  for  (  int  i  =  0  ;  i  <  pointSet  .  size  (  )  ;  i++  )  {  final  T  p  =  pointSet  .  get  (  i  )  ;  final  Cluster<T>  nearest  =  getNearestCluster  (  resultSet  ,  p  )  ;  final  double  d  =  p  .  distanceFrom  (  nearest  .  getCenter  (  )  )  ;  sum  +  =  d  *  d  ;  dx2[i]  =  sum  ;  }  	Math_57_KMeansPlusPlusClusterer_1_1	175	1	src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java
163	return  fit(guess);  	[BUGGY]  return  fit  (  new  Gaussian  .  Parametric  (  )  ,  guess  )  ;  [FE]  commonsmathexceptionNotStrictlyPositiveException:  -1277  is  smaller  than  ,  or  equal  to  ,  the  minimum  (  0  )  Assert  .  assertEquals  (  5  .  75214622  ,  p[2]  ,  1e-8  )  ;  [METHOD]  fit  [TYPE]  double[]  [PARAMETER]  [CLASS]  GaussianFitter  [TYPE]  ParametricUnivariateRealFunction  g  [TYPE]  boolean  false  true  [TYPE]  WeightedObservedPoint[]  observations  [TYPE]  double[]  guess  parameters  [CONTEXT]  public  double[]  fit  (  )  {  final  double[]  guess  =  (  new  ParameterGuesser  (  getObservations  (  )  )  )  .  guess  (  )  ;  [BUGGY]  return  fit  (  new  Gaussian  .  Parametric  (  )  ,  guess  )  ;  }  	Math_58_GaussianFitter_1_1	121	1	src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java
164	return  (a  <=  b)  ?  b  :  (Float.isNaN(a  +  b)  ?  Float.NaN  :  a);  	[BUGGY]  return  (  a  <  =  b  )  ?  b  :  (  Float  .  isNaN  (  a  +  b  )  ?  Float  .  NaN  :  b  )  ;  [FE]  AssertionFailedError:  max  (  500  ,  -500  )  expected:<500>  but  was:<-500>  Assert  .  assertEquals  ( "max  ( "  +  pair[1]  + "  , "  +  pair[0]  + "  ) "  ,  [METHOD]  max  [TYPE]  float  [PARAMETER]  final  float  a  final  float  b  [CLASS]  FastMath  [TYPE]  double[][]  LN_HI_PREC_COEF  LN_MANT  LN_QUICK_COEF  LN_SPLIT_COEF  [TYPE]  boolean  false  true  [TYPE]  double[]  CBRTTWO  COSINE_TABLE_A  COSINE_TABLE_B  EIGHTHES  EXP_FRAC_TABLE_A  EXP_FRAC_TABLE_B  EXP_INT_TABLE_A  EXP_INT_TABLE_B  FACT  SINE_TABLE_A  SINE_TABLE_B  TANGENT_TABLE_A  TANGENT_TABLE_B  [TYPE]  float  a  b  [TYPE]  long[]  PI_O_4_BITS  RECIP_2PI  [TYPE]  double  E  LN_2_A  LN_2_B  PI  [CONTEXT]  public  static  float  max  (  final  float  a  ,  final  float  b  )  {  [BUGGY]  return  (  a  <  =  b  )  ?  b  :  (  Float  .  isNaN  (  a  +  b  )  ?  Float  .  NaN  :  b  )  ;  }  	Math_59_FastMath_1_1	3482	1	src/main/java/org/apache/commons/math/util/FastMath.java
165	if  (FastMath.abs(dev)  >  40  *  standardDeviation)  {  return  dev  <  0  ?  0.0d  :  1.0d;  }  	[BUGGY]  try  {  }  catch  (  MaxIterationsExceededException  ex  )  {  if  (  x  <  (  mean  -  20  *  standardDeviation  )  )  {  return  0  ;  }  else  if  (  x  >  (  mean  +  20  *  standardDeviation  )  )  {  return  1  ;  }  else  {  throw  ex  ;  }  }  [FE]  commonsmathConvergenceException:  Continued  fraction  diverged  to  NaN  for  value  assertEquals  (  distribution  .  cumulativeProbability  (  Double  .  NEGATIVE_INFINITY  )  ,  0  ,  0  )  ;  [METHOD]  cumulativeProbability  [TYPE]  double  [PARAMETER]  double  x  [CLASS]  NormalDistributionImpl  [TYPE]  MaxIterationsExceededException  ex  [TYPE]  boolean  false  true  [TYPE]  double  DEFAULT_INVERSE_ABSOLUTE_ACCURACY  SQRT2PI  dev  mean  solverAbsoluteAccuracy  standardDeviation  x  [TYPE]  long  serialVersionUID  [CONTEXT]  public  double  cumulativeProbability  (  double  x  )  throws  MathException  {  final  double  dev  =  x  -  mean  ;  [BUGGY]  try  {  return  0  .  5  *  (  1  .  0  +  Erf  .  erf  (  (  dev  )  /  (  standardDeviation  *  FastMath  .  sqrt  (  2  .  0  )  )  )  )  ;  }  catch  (  MaxIterationsExceededException  ex  )  {  if  (  x  <  (  mean  -  20  *  standardDeviation  )  )  {  //  JDK  1  .  5  blows  at  38  return  0  ;  }  else  if  (  x  >  (  mean  +  20  *  standardDeviation  )  )  {  return  1  ;  }  else  {  throw  ex  ;  }  }  }  	Math_60_NormalDistributionImpl_1_1	126	10	src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java
166		[BUGGY]  [FE]  commonsmathMathRuntimeException$4:  the  Poisson  mean  must  be  positive  (  -1  )  assertEquals  (  10  .  0  ,  dist  .  getMean  (  )  ,  0  .  0  )  ;  [CLASS]  [CONTEXT]  	Math_61_PoissonDistributionImpl_2_1	22	0	src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java
167	throw  new  NotStrictlyPositiveException(LocalizedFormats.MEAN,  p);  	[BUGGY]  throw  MathRuntimeException  .  createIllegalArgumentException  (  LocalizedFormats  .  NOT_POSITIVE_POISSON_MEAN  ,  p  )  ;  [FE]  commonsmathMathRuntimeException$4:  the  Poisson  mean  must  be  positive  (  -1  )  assertEquals  (  10  .  0  ,  dist  .  getMean  (  )  ,  0  .  0  )  ;  [CLASS]  [CONTEXT]  	Math_61_PoissonDistributionImpl_2_2	94	1	src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java
168	return  optimize(f,  goal,  min,  max,  min  +  0.5  *  (max  -  min));  	[BUGGY]  return  optimize  (  f  ,  goal  ,  min  ,  max  ,  0  )  ;  [FE]  AssertionFailedError:  expected:<-02719561293>  but  was:<-02719561278056452>  assertTrue  (  optimizer  .  getEvaluations  (  )  <  =  100  )  ;  [METHOD]  optimize  [TYPE]  UnivariateRealPointValuePair  [PARAMETER]  final  FUNC  f  GoalType  goal  final  double  min  final  double  max  [CLASS]  MultiStartUnivariateRealOptimizer  [TYPE]  UnivariateRealPointValuePair[]  optima  [TYPE]  boolean  false  true  [TYPE]  FUNC  f  [TYPE]  double  max  min  [TYPE]  GoalType  goal  [TYPE]  BaseUnivariateRealOptimizer  optimizer  [TYPE]  int  maxEvaluations  starts  totalEvaluations  [TYPE]  RandomGenerator  generator  [CONTEXT]  public  UnivariateRealPointValuePair  optimize  (  final  FUNC  f  ,  final  GoalType  goal  ,  final  double  min  ,  final  double  max  )  throws  FunctionEvaluationException  {  [BUGGY]  return  optimize  (  f  ,  goal  ,  min  ,  max  ,  0  )  ;  }  	Math_62_MultiStartUnivariateRealOptimizer_2_1	146	1	src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java
169	final  double  s  =  (i  ==  0)  ?  startValue  :  min  +  generator.nextDouble()  *  (max  -  min);  optima[i]  =  optimizer.optimize(f,  goal,  min,  max,  s);  	[BUGGY]  final  double  bound1  =  (  i  =  =  0  )  ?  min  :  min  +  generator  .  nextDouble  (  )  *  (  max  -  min  )  ;  final  double  bound2  =  (  i  =  =  0  )  ?  max  :  min  +  generator  .  nextDouble  (  )  *  (  max  -  min  )  ;  optima[i]  =  optimizer  .  optimize  (  f  ,  goal  ,  FastMath  .  min  (  bound1  ,  bound2  )  ,  FastMath  .  max  (  bound1  ,  bound2  )  )  ;  [FE]  AssertionFailedError:  expected:<-02719561293>  but  was:<-02719561278056452>  assertTrue  (  optimizer  .  getEvaluations  (  )  <  =  100  )  ;  [METHOD]  optimize  [TYPE]  UnivariateRealPointValuePair  [PARAMETER]  final  FUNC  f  GoalType  goal  final  double  min  final  double  max  final  double  startValue  [CLASS]  MultiStartUnivariateRealOptimizer  [TYPE]  UnivariateRealPointValuePair[]  optima  [TYPE]  boolean  false  true  [TYPE]  FUNC  f  [TYPE]  double  bound1  bound2  max  min  startValue  [TYPE]  ConvergenceException  ce  [TYPE]  GoalType  goal  [TYPE]  FunctionEvaluationException  fee  [TYPE]  BaseUnivariateRealOptimizer  optimizer  [TYPE]  int  i  maxEvaluations  starts  totalEvaluations  usedEvaluations  [TYPE]  RandomGenerator  generator  [CONTEXT]  public  UnivariateRealPointValuePair  optimize  (  final  FUNC  f  ,  final  GoalType  goal  ,  final  double  min  ,  final  double  max  ,  final  double  startValue  )  throws  FunctionEvaluationException  {  optima  =  new  UnivariateRealPointValuePair[starts]  ;  totalEvaluations  =  0  ;  for  (  int  i  =  0  ;  i  <  starts  ;  ++i  )  {  try  {  [BUGGY]  final  double  bound1  =  (  i  =  =  0  )  ?  min  :  min  +  generator  .  nextDouble  (  )  *  (  max  -  min  )  ;  final  double  bound2  =  (  i  =  =  0  )  ?  max  :  min  +  generator  .  nextDouble  (  )  *  (  max  -  min  )  ;  optima[i]  =  optimizer  .  optimize  (  f  ,  goal  ,  FastMath  .  min  (  bound1  ,  bound2  )  ,  FastMath  .  max  (  bound1  ,  bound2  )  )  ;  }  catch  (  FunctionEvaluationException  fee  )  {  optima[i]  =  null  ;  }  catch  (  ConvergenceException  ce  )  {  	Math_62_MultiStartUnivariateRealOptimizer_2_2	160	3	src/main/java/org/apache/commons/math/optimization/univariate/MultiStartUnivariateRealOptimizer.java
170	return  equals(x,  y,  1);  	[BUGGY]  return  (  Double  .  isNaN  (  x  )  &&  Double  .  isNaN  (  y  )  )  ||  x  =  =  y  ;  [FE]  AssertionFailedError  assertFalse  (  MathUtils  .  equalsIncludingNaN  (  new  double[]  {  1d  }  ,  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  double  x  double  y  [CLASS]  MathUtils  [TYPE]  boolean  false  true  [TYPE]  long[]  FACTORIALS  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  x  y  [TYPE]  byte  NB  PB  ZB  [TYPE]  short  NS  PS  ZS  [TYPE]  int  NAN_GAP  [TYPE]  long  SGN_MASK  [TYPE]  OrderDirection  DECREASING  INCREASING  [CONTEXT]  public  static  boolean  equals  (  double  x  ,  double  y  )  {  [BUGGY]  return  (  Double  .  isNaN  (  x  )  &&  Double  .  isNaN  (  y  )  )  ||  x  =  =  y  ;  }  	Math_63_MathUtils_1_1	417	1	src/main/java/org/apache/commons/math/util/MathUtils.java
171	double[]  oldObj  =  new  double[rows];  double[]  qtf  =  new  double[rows];  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  protected  VectorialPointValuePair  doOptimize  (  )  throws  FunctionEvaluationException  ,  OptimizationException  ,  IllegalArgumentException  {  solvedCols  =  Math  .  min  (  rows  ,  cols  )  ;  diagR  =  new  double[cols]  ;  jacNorm  =  new  double[cols]  ;  beta  =  new  double[cols]  ;  permutation  =  new  int[cols]  ;  lmDir  =  new  double[cols]  ;  double  delta  =  0  ;  double  xNorm  =  0  ;  double[]  diag  =  new  double[cols]  ;  double[]  oldX  =  new  double[cols]  ;  double[]  oldRes  =  new  double[rows]  ;  [BUGGY]  double[]  work1  =  new  double[cols]  ;  double[]  work2  =  new  double[cols]  ;  double[]  work3  =  new  double[cols]  ;  updateResidualsAndCost  (  )  ;  	Math_64_LevenbergMarquardtOptimizer_10_1	258	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
172	for  (int  i=0;i<rows;i++)  {  qtf[i]=residuals[i];  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  solvedCols  =  Math  .  min  (  rows  ,  cols  )  ;  diagR  =  new  double[cols]  ;  jacNorm  =  new  double[cols]  ;  beta  =  new  double[cols]  ;  permutation  =  new  int[cols]  ;  lmDir  =  new  double[cols]  ;  double  delta  =  0  ;  double  xNorm  =  0  ;  double[]  diag  =  new  double[cols]  ;  double[]  oldX  =  new  double[cols]  ;  double[]  oldRes  =  new  double[rows]  ;  double[]  work1  =  new  double[cols]  ;  double[]  work2  =  new  double[cols]  ;  double[]  work3  =  new  double[cols]  ;  updateResidualsAndCost  (  )  ;  lmPar  =  0  ;  boolean  firstIteration  =  true  ;  VectorialPointValuePair  current  =  new  VectorialPointValuePair  (  point  ,  objective  )  ;  while  (  true  )  {  [BUGGY]  incrementIterationsCounter  (  )  ;  VectorialPointValuePair  previous  =  current  ;  updateJacobian  (  )  ;  qrDecomposition  (  )  ;  	Math_64_LevenbergMarquardtOptimizer_10_2	270	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
173	qTy(qtf);\n', "    	[BUGGY]  qTy  (  residuals  )  ;  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  double  delta  =  0  ;  double  xNorm  =  0  ;  double[]  diag  =  new  double[cols]  ;  double[]  oldX  =  new  double[cols]  ;  double[]  oldRes  =  new  double[rows]  ;  double[]  work1  =  new  double[cols]  ;  double[]  work2  =  new  double[cols]  ;  double[]  work3  =  new  double[cols]  ;  updateResidualsAndCost  (  )  ;  lmPar  =  0  ;  boolean  firstIteration  =  true  ;  VectorialPointValuePair  current  =  new  VectorialPointValuePair  (  point  ,  objective  )  ;  while  (  true  )  {  incrementIterationsCounter  (  )  ;  VectorialPointValuePair  previous  =  current  ;  updateJacobian  (  )  ;  qrDecomposition  (  )  ;  [BUGGY]  qTy  (  residuals  )  ;  for  (  int  k  =  0  ;  k  <  solvedCols  ;  ++k  )  {  int  pk  =  permutation[k]  ;  jacobian[k][pk]  =  diagR[pk]  ;  	Math_64_LevenbergMarquardtOptimizer_10_3	278	1	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
174	sum  +=  jacobian[i][pj]  *  qtf[i];  	[BUGGY]  sum  +  =  jacobian[i][pj]  *  residuals[i]  ;  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  for  (  int  k  =  0  ;  k  <  cols  ;  ++k  )  {  double  dk  =  jacNorm[k]  ;  if  (  dk  =  =  0  )  {  dk  =  1  .  0  ;  }  double  xk  =  dk  *  point[k]  ;  xNorm+  =  xk  *  xk  ;  diag[k]  =  dk  ;  }  xNorm  =  Math  .  sqrt  (  xNorm  )  ;  delta  =  (  xNorm  =  =  0  )  ?  initialStepBoundFactor  :  (  initialStepBoundFactor  *  xNorm  )  ;  }  double  maxCosine  =  0  ;  if  (  cost  !  =  0  )  {  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  intpj  =  permutation[j]  ;  double  s  =  jacNorm[pj]  ;  if  (  s  !  =  0  )  {  double  sum  =  0  ;  for  (  int  i  =  0  ;  i  <  =  j  ;  ++i  )  {  [BUGGY]  sum  +  =  jacobian[i][pj]  *  residuals[i]  ;  }  maxCosine  =  Math  .  max  (  maxCosine  ,  Math  .  abs  (  sum  )  /  (  s  *  cost  )  )  ;  }  }  }  	Math_64_LevenbergMarquardtOptimizer_10_4	316	1	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
175	\tupdateResidualsAndCost();  \tcurrent  =  new  VectorialPointValuePair(point,  objective);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  }  xNorm  =  Math  .  sqrt  (  xNorm  )  ;  delta  =  (  xNorm  =  =  0  )  ?  initialStepBoundFactor  :  (  initialStepBoundFactor  *  xNorm  )  ;  }  double  maxCosine  =  0  ;  if  (  cost  !  =  0  )  {  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  intpj  =  permutation[j]  ;  double  s  =  jacNorm[pj]  ;  if  (  s  !  =  0  )  {  double  sum  =  0  ;  for  (  int  i  =  0  ;  i  <  =  j  ;  ++i  )  {  sum  +  =  jacobian[i][pj]  *  residuals[i]  ;  }  maxCosine  =  Math  .  max  (  maxCosine  ,  Math  .  abs  (  sum  )  /  (  s  *  cost  )  )  ;  }  }  }  if  (  maxCosine  <  =  orthoTolerance  )  {  [BUGGY]  return  current  ;  }  for  (  int  j  =  0  ;  j  <  cols  ;  ++j  )  {  diag[j]  =  Math  .  max  (  diag[j]  ,  jacNorm[j]  )  ;  	Math_64_LevenbergMarquardtOptimizer_10_5	324	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
176	tmpVec  =  objective;  objective  =  oldObj;  oldObj  =  tmpVec;  determineLMParameter(qtf,  delta,  diag,  work1,  work2,  work3);  	[BUGGY]  determineLMParameter  (  oldRes  ,  delta  ,  diag  ,  work1  ,  work2  ,  work3  )  ;  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  }  }  }  if  (  maxCosine  <  =  orthoTolerance  )  {  return  current  ;  }  for  (  int  j  =  0  ;  j  <  cols  ;  ++j  )  {  diag[j]  =  Math  .  max  (  diag[j]  ,  jacNorm[j]  )  ;  }  for  (  double  ratio  =  0  ;  ratio  <  1  .  0e-4  ;  )  {  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  int  pj  =  permutation[j]  ;  oldX[pj]  =  point[pj]  ;  }  double  previousCost  =  cost  ;  double[]  tmpVec  =  residuals  ;  residuals  =  oldRes  ;  oldRes  =  tmpVec  ;  [BUGGY]  determineLMParameter  (  oldRes  ,  delta  ,  diag  ,  work1  ,  work2  ,  work3  )  ;  double  lmNorm  =  0  ;  	Math_64_LevenbergMarquardtOptimizer_10_6	344	1	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
177		[BUGGY]  current  =  new  VectorialPointValuePair  (  point  ,  objective  )  ;  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  double  previousCost  =  cost  ;  double[]  tmpVec  =  residuals  ;  residuals  =  oldRes  ;  oldRes  =  tmpVec  ;  determineLMParameter  (  oldRes  ,  delta  ,  diag  ,  work1  ,  work2  ,  work3  )  ;  double  lmNorm  =  0  ;  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  int  pj  =  permutation[j]  ;  lmDir[pj]  =  -lmDir[pj]  ;  point[pj]  =  oldX[pj]  +  lmDir[pj]  ;  double  s  =  diag[pj]  *  lmDir[pj]  ;  lmNorm+  =  s  *  s  ;  }  lmNorm  =  Math  .  sqrt  (  lmNorm  )  ;  if  (  firstIteration  )  {  delta  =  Math  .  min  (  delta  ,  lmNorm  )  ;  }  updateResidualsAndCost  (  )  ;  [BUGGY]  current  =  new  VectorialPointValuePair  (  point  ,  objective  )  ;  double  actRed  =  -1  .  0  ;  if  (  0  .  1  *  cost  <  previousCost  )  {  double  r  =  cost  /  previousCost  ;  	Math_64_LevenbergMarquardtOptimizer_10_7	365	1	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
178	current  =  new  VectorialPointValuePair(point,  objective);  if  (checker  !=  null)  {  \tif  (checker.converged(getIterations(),  previous,  current))  {  \t\treturn  current;  \t}  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  if  (  ratio  <  =  0  .  25  )  {  double  tmp  =  (  actRed  <  0  )  ?  (  0  .  5  *  dirDer  /  (  dirDer  +  0  .  5  *  actRed  )  )  :  0  .  5  ;  if  (  (  0  .  1  *  cost  >  =  previousCost  )  ||  (  tmp  <  0  .  1  )  )  {  tmp  =  0  .  1  ;  }  delta  =  tmp  *  Math  .  min  (  delta  ,  10  .  0  *  lmNorm  )  ;  lmPar  /  =  tmp  ;  }  else  if  (  (  lmPar  =  =  0  )  ||  (  ratio  >  =  0  .  75  )  )  {  delta  =  2  *  lmNorm  ;  lmPar  *  =  0  .  5  ;  }  if  (  ratio  >  =  1  .  0e-4  )  {  firstIteration  =  false  ;  xNorm  =  0  ;  for  (  int  k  =  0  ;  k  <  cols  ;  ++k  )  {  double  xK  =  diag[k]  *  point[k]  ;  xNorm+  =  xK  *  xK  ;  }  xNorm  =  Math  .  sqrt  (  xNorm  )  ;  [BUGGY]  }  else  {  cost  =  previousCost  ;  	Math_64_LevenbergMarquardtOptimizer_10_8	421	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
179	tmpVec  =  objective;  objective  =  oldObj;  oldObj  =  tmpVec;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  }  if  (  ratio  >  =  1  .  0e-4  )  {  firstIteration  =  false  ;  xNorm  =  0  ;  for  (  int  k  =  0  ;  k  <  cols  ;  ++k  )  {  double  xK  =  diag[k]  *  point[k]  ;  xNorm+  =  xK  *  xK  ;  }  xNorm  =  Math  .  sqrt  (  xNorm  )  ;  }  else  {  cost  =  previousCost  ;  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  int  pj  =  permutation[j]  ;  point[pj]  =  oldX[pj]  ;  }  tmpVec  =  residuals  ;  residuals  =  oldRes  ;  oldRes  =  tmpVec  ;  [BUGGY]  }  if  (  checker  =  =  null  )  {  if  (  (  (  Math  .  abs  (  actRed  )  <  =  costRelativeTolerance  )  &&  (  preRed  <  =  costRelativeTolerance  )  &&  (  ratio  <  =  2  .  0  )  )  ||  (  delta  <  =  parRelativeTolerance  *  xNorm  )  )  {  	Math_64_LevenbergMarquardtOptimizer_10_9	434	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
180		[BUGGY]  }  else  {  if  (  checker  .  converged  (  getIterations  (  )  ,  previous  ,  current  )  )  {  return  current  ;  }  [FE]  AssertionFailedError:  expected:<02578199266368004>  but  was:<02578330049004441>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  VectorialPointValuePair  current  previous  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  qrRankingThreshold  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  double  xK  =  diag[k]  *  point[k]  ;  xNorm+  =  xK  *  xK  ;  }  xNorm  =  Math  .  sqrt  (  xNorm  )  ;  }  else  {  cost  =  previousCost  ;  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  int  pj  =  permutation[j]  ;  point[pj]  =  oldX[pj]  ;  }  tmpVec  =  residuals  ;  residuals  =  oldRes  ;  oldRes  =  tmpVec  ;  }  if  (  checker  =  =  null  )  {  if  (  (  (  Math  .  abs  (  actRed  )  <  =  costRelativeTolerance  )  &&  (  preRed  <  =  costRelativeTolerance  )  &&  (  ratio  <  =  2  .  0  )  )  ||  (  delta  <  =  parRelativeTolerance  *  xNorm  )  )  {  return  current  ;  }  [BUGGY]  }  else  {  if  (  checker  .  converged  (  getIterations  (  )  ,  previous  ,  current  )  )  {  return  current  ;  }  }  	Math_64_LevenbergMarquardtOptimizer_10_10	442	4	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
181	return  Math.sqrt(getChiSquare()  /  rows);  	[BUGGY]  double  criterion  =  0  ;  for  (  int  i  =  0  ;  i  <  rows  ;  ++i  )  {  final  double  residual  =  residuals[i]  ;  criterion  +  =  residual  *  residual  *  residualsWeights[i]  ;  }  return  Math  .  sqrt  (  criterion  /  rows  )  ;  [FE]  AssertionFailedError:  expected:<0004>  but  was:<00019737107108948474>  assertEquals  (  0  .  2075001  ,  center  .  y  ,  1  .  0e-6  )  ;  [METHOD]  getRMS  [TYPE]  double  [PARAMETER]  [CLASS]  AbstractLeastSquaresOptimizer  [TYPE]  boolean  false  true  [TYPE]  VectorialConvergenceChecker  checker  [TYPE]  double[]  objective  point  residuals  residualsWeights  targetValues  [TYPE]  double  cost  criterion  residual  [TYPE]  double[][]  jacobian  [TYPE]  DifferentiableMultivariateVectorialFunction  function  [TYPE]  MultivariateMatrixFunction  jF  [TYPE]  int  DEFAULT_MAX_ITERATIONS  cols  i  iterations  jacobianEvaluations  maxEvaluations  maxIterations  objectiveEvaluations  rows  [CONTEXT]  public  double  getRMS  (  )  {  [BUGGY]  double  criterion  =  0  ;  for  (  int  i  =  0  ;  i  <  rows  ;  ++i  )  {  final  double  residual  =  residuals[i]  ;  criterion  +  =  residual  *  residual  *  residualsWeights[i]  ;  }  return  Math  .  sqrt  (  criterion  /  rows  )  ;  }  	Math_65_AbstractLeastSquaresOptimizer_2_1	240	6	src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java
182	chiSquare  +=  residual  *  residual  *  residualsWeights[i];  	[BUGGY]  chiSquare  +  =  residual  *  residual  /  residualsWeights[i]  ;  [FE]  AssertionFailedError:  expected:<0004>  but  was:<00019737107108948474>  assertEquals  (  0  .  2075001  ,  center  .  y  ,  1  .  0e-6  )  ;  [METHOD]  getChiSquare  [TYPE]  double  [PARAMETER]  [CLASS]  AbstractLeastSquaresOptimizer  [TYPE]  boolean  false  true  [TYPE]  VectorialConvergenceChecker  checker  [TYPE]  double[]  objective  point  residuals  residualsWeights  targetValues  [TYPE]  double  chiSquare  cost  residual  [TYPE]  double[][]  jacobian  [TYPE]  DifferentiableMultivariateVectorialFunction  function  [TYPE]  MultivariateMatrixFunction  jF  [TYPE]  int  DEFAULT_MAX_ITERATIONS  cols  i  iterations  jacobianEvaluations  maxEvaluations  maxIterations  objectiveEvaluations  rows  [CONTEXT]  public  double  getChiSquare  (  )  {  double  chiSquare  =  0  ;  for  (  int  i  =  0  ;  i  <  rows  ;  ++i  )  {  final  double  residual  =  residuals[i]  ;  [BUGGY]  chiSquare  +  =  residual  *  residual  /  residualsWeights[i]  ;  }  return  chiSquare  ;  }  	Math_65_AbstractLeastSquaresOptimizer_2_2	258	1	src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java
183	setMaxEvaluations(1000);  setAbsoluteAccuracy(1e-11);  setRelativeAccuracy(1e-9);  	[BUGGY]  setMaxEvaluations  (  Integer  .  MAX_VALUE  )  ;  setAbsoluteAccuracy  (  1E-10  )  ;  setRelativeAccuracy  (  1  .  0e-14  )  ;  [FE]  AssertionFailedError:  expected:<-02719561270319131>  but  was:<-02719561299044896>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [CLASS]  [CONTEXT]  	Math_66_BrentOptimizer_7_1	44	3	src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
184	getMin(),  getStartValue(),  getMax(),  	[BUGGY]  throw  new  UnsupportedOperationException  (  )  ;  }  public  double  optimize  (  final  UnivariateRealFunction  f  ,  final  GoalType  goalType  ,  final  double  min  ,  final  double  max  ,  final  double  startValue  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  clearResult  (  )  ;  f  ,  goalType  ,  min  ,  startValue  ,  max  ,  public  double  optimize  (  final  UnivariateRealFunction  f  ,  final  GoalType  goalType  ,  final  double  min  ,  final  double  max  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  return  optimize  (  f  ,  goalType  ,  min  ,  max  ,  min  +  GOLDEN_SECTION  *  (  max  -  min  )  )  ;  }  [FE]  AssertionFailedError:  expected:<-02719561270319131>  but  was:<-02719561299044896>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [METHOD]  doOptimize  [TYPE]  double  [PARAMETER]  [CLASS]  BrentOptimizer  [TYPE]  double  GOLDEN_SECTION  [TYPE]  boolean  false  true  [CONTEXT]  protected  double  doOptimize  (  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  [BUGGY]  throw  new  UnsupportedOperationException  (  )  ;  }  	Math_66_BrentOptimizer_7_2	57	8	src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
185		[BUGGY]  UnivariateRealFunction  f  ,  GoalType  goalType  ,  [FE]  AssertionFailedError:  expected:<-02719561270319131>  but  was:<-02719561299044896>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [METHOD]  localMin  [TYPE]  double  [PARAMETER]  boolean  isMinim  UnivariateRealFunction  f  GoalType  goalType  double  lo  double  mid  double  hi  double  eps  double  t  [CLASS]  BrentOptimizer  [TYPE]  UnivariateRealFunction  f  [TYPE]  GoalType  goalType  [TYPE]  boolean  false  isMinim  true  [TYPE]  double  GOLDEN_SECTION  a  b  d  e  eps  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  t  tol1  tol2  u  v  w  x  [TYPE]  int  count  [CONTEXT]  private  double  localMin  (  boolean  isMinim  ,  [BUGGY]  UnivariateRealFunction  f  ,  GoalType  goalType  ,  double  lo  ,  double  mid  ,  double  hi  ,  double  eps  ,  double  t  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  if  (  eps  <  =  0  )  {  	Math_66_BrentOptimizer_7_3	94	2	src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
186	double  fx  =  computeObjectiveValue(x);  if  (!isMinim)  {  	[BUGGY]  double  fx  =  computeObjectiveValue  (  f  ,  x  )  ;  if  (  goalType  =  =  GoalType  .  MAXIMIZE  )  {  [FE]  AssertionFailedError:  expected:<-02719561270319131>  but  was:<-02719561299044896>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [METHOD]  localMin  [TYPE]  double  [PARAMETER]  boolean  isMinim  UnivariateRealFunction  f  GoalType  goalType  double  lo  double  mid  double  hi  double  eps  double  t  [CLASS]  BrentOptimizer  [TYPE]  UnivariateRealFunction  f  [TYPE]  GoalType  goalType  [TYPE]  boolean  false  isMinim  true  [TYPE]  double  GOLDEN_SECTION  a  b  d  e  eps  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  t  tol1  tol2  u  v  w  x  [TYPE]  int  count  [CONTEXT]  UnivariateRealFunction  f  ,  GoalType  goalType  ,  double  lo  ,  double  mid  ,  double  hi  ,  double  eps  ,  double  t  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  if  (  eps  <  =  0  )  {  throw  new  NotStrictlyPositiveException  (  eps  )  ;  }  if  (  t  <  =  0  )  {  throw  new  NotStrictlyPositiveException  (  t  )  ;  }  double  a  ,  b  ;  if  (  lo  <  hi  )  {  a  =  lo  ;  b  =  hi  ;  }  else  {  a  =  hi  ;  b  =  lo  ;  }  double  x  =  mid  ;  double  v  =  x  ;  double  w  =  x  ;  double  d  =  0  ;  double  e  =  0  ;  [BUGGY]  double  fx  =  computeObjectiveValue  (  f  ,  x  )  ;  if  (  goalType  =  =  GoalType  .  MAXIMIZE  )  {  fx  =  -fx  ;  }  double  fv  =  fx  ;  double  fw  =  fx  ;  	Math_66_BrentOptimizer_7_4	119	2	src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
187	while  (true)  {  	[BUGGY]  int  count  =  0  ;  while  (  count  <  maximalIterationCount  )  {  [FE]  AssertionFailedError:  expected:<-02719561270319131>  but  was:<-02719561299044896>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [METHOD]  localMin  [TYPE]  double  [PARAMETER]  boolean  isMinim  UnivariateRealFunction  f  GoalType  goalType  double  lo  double  mid  double  hi  double  eps  double  t  [CLASS]  BrentOptimizer  [TYPE]  UnivariateRealFunction  f  [TYPE]  GoalType  goalType  [TYPE]  boolean  false  isMinim  true  [TYPE]  double  GOLDEN_SECTION  a  b  d  e  eps  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  t  tol1  tol2  u  v  w  x  [TYPE]  int  count  [CONTEXT]  }  if  (  t  <  =  0  )  {  throw  new  NotStrictlyPositiveException  (  t  )  ;  }  double  a  ,  b  ;  if  (  lo  <  hi  )  {  a  =  lo  ;  b  =  hi  ;  }  else  {  a  =  hi  ;  b  =  lo  ;  }  double  x  =  mid  ;  double  v  =  x  ;  double  w  =  x  ;  double  d  =  0  ;  double  e  =  0  ;  double  fx  =  computeObjectiveValue  (  f  ,  x  )  ;  if  (  goalType  =  =  GoalType  .  MAXIMIZE  )  {  fx  =  -fx  ;  }  double  fv  =  fx  ;  double  fw  =  fx  ;  [BUGGY]  int  count  =  0  ;  while  (  count  <  maximalIterationCount  )  {  double  m  =  0  .  5  *  (  a  +  b  )  ;  final  double  tol1  =  eps  *  Math  .  abs  (  x  )  +  t  ;  final  double  tol2  =  2  *  tol1  ;  	Math_66_BrentOptimizer_7_5	126	2	src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
188	double  fu  =  computeObjectiveValue(u);  if  (!isMinim)  {  	[BUGGY]  double  fu  =  computeObjectiveValue  (  f  ,  u  )  ;  if  (  goalType  =  =  GoalType  .  MAXIMIZE  )  {  [FE]  AssertionFailedError:  expected:<-02719561270319131>  but  was:<-02719561299044896>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [METHOD]  localMin  [TYPE]  double  [PARAMETER]  boolean  isMinim  UnivariateRealFunction  f  GoalType  goalType  double  lo  double  mid  double  hi  double  eps  double  t  [CLASS]  BrentOptimizer  [TYPE]  UnivariateRealFunction  f  [TYPE]  GoalType  goalType  [TYPE]  boolean  false  isMinim  true  [TYPE]  double  GOLDEN_SECTION  a  b  d  e  eps  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  t  tol1  tol2  u  v  w  x  [TYPE]  int  count  [CONTEXT]  e  =  a  -  x  ;  }  d  =  GOLDEN_SECTION  *  e  ;  }  }  else  {  if  (  x  <  m  )  {  e  =  b  -  x  ;  }  else  {  e  =  a  -  x  ;  }  d  =  GOLDEN_SECTION  *  e  ;  }  if  (  Math  .  abs  (  d  )  <  tol1  )  {  if  (  d  >  =  0  )  {  u  =  x  +  tol1  ;  }  else  {  u  =  x  -  tol1  ;  }  }  else  {  u  =  x  +  d  ;  }  [BUGGY]  double  fu  =  computeObjectiveValue  (  f  ,  u  )  ;  if  (  goalType  =  =  GoalType  .  MAXIMIZE  )  {  fu  =  -fu  ;  }  	Math_66_BrentOptimizer_7_6	200	2	src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
189	setFunctionValue(isMinim  ?  fx  :  -fx);  incrementIterationsCounter();  	[BUGGY]  setResult  (  x  ,  (  goalType  =  =  GoalType  .  MAXIMIZE  )  ?  -fx  :  fx  ,  count  )  ;  ++count  ;  throw  new  MaxIterationsExceededException  (  maximalIterationCount  )  ;  [FE]  AssertionFailedError:  expected:<-02719561270319131>  but  was:<-02719561299044896>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [METHOD]  localMin  [TYPE]  double  [PARAMETER]  boolean  isMinim  UnivariateRealFunction  f  GoalType  goalType  double  lo  double  mid  double  hi  double  eps  double  t  [CLASS]  BrentOptimizer  [TYPE]  UnivariateRealFunction  f  [TYPE]  GoalType  goalType  [TYPE]  boolean  false  isMinim  true  [TYPE]  double  GOLDEN_SECTION  a  b  d  e  eps  fu  fv  fw  fx  hi  lo  m  mid  p  q  r  t  tol1  tol2  u  v  w  x  [TYPE]  int  count  [CONTEXT]  fv  =  fw  ;  w  =  x  ;  fw  =  fx  ;  x  =  u  ;  fx  =  fu  ;  }  else  {  if  (  u  <  x  )  {  a  =  u  ;  }  else  {  b  =  u  ;  }  if  (  fu  <  =  fw  ||  w  =  =  x  )  {  v  =  w  ;  fv  =  fw  ;  w  =  u  ;  fw  =  fu  ;  }  else  if  (  fu  <  =  fv  ||  v  =  =  x  ||  v  =  =  w  )  {  v  =  u  ;  fv  =  fu  ;  }  }  }  else  {  //  termination  [BUGGY]  setResult  (  x  ,  (  goalType  =  =  GoalType  .  MAXIMIZE  )  ?  -fx  :  fx  ,  count  )  ;  return  x  ;  }  ++count  ;  }  throw  new  MaxIterationsExceededException  (  maximalIterationCount  )  ;  	Math_66_BrentOptimizer_7_7	238	3	src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java
190	return  optimaValues[0];  	[BUGGY]  return  optimizer  .  getFunctionValue  (  )  ;  [FE]  AssertionFailedError:  expected:<-027195612846834>  but  was:<-027194301946870036>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [METHOD]  getFunctionValue  [TYPE]  double  [PARAMETER]  [CLASS]  MultiStartUnivariateRealOptimizer  [TYPE]  UnivariateRealOptimizer  optimizer  [TYPE]  boolean  false  true  [TYPE]  double[]  optima  optimaValues  [TYPE]  long  serialVersionUID  [TYPE]  int  maxEvaluations  maxIterations  starts  totalEvaluations  totalIterations  [TYPE]  RandomGenerator  generator  [CONTEXT]  public  double  getFunctionValue  (  )  {  [BUGGY]  return  optimizer  .  getFunctionValue  (  )  ;  }  	Math_67_MultiStartUnivariateRealOptimizer_2_1	92	1	src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java
191	return  optima[0];  	[BUGGY]  return  optimizer  .  getResult  (  )  ;  [FE]  AssertionFailedError:  expected:<-027195612846834>  but  was:<-027194301946870036>  assertTrue  (  minimizer  .  getIterationCount  (  )  <  =  170  )  ;  [METHOD]  getResult  [TYPE]  double  [PARAMETER]  [CLASS]  MultiStartUnivariateRealOptimizer  [TYPE]  UnivariateRealOptimizer  optimizer  [TYPE]  boolean  false  true  [TYPE]  double[]  optima  optimaValues  [TYPE]  long  serialVersionUID  [TYPE]  int  maxEvaluations  maxIterations  starts  totalEvaluations  totalIterations  [TYPE]  RandomGenerator  generator  [CONTEXT]  public  double  getResult  (  )  {  [BUGGY]  return  optimizer  .  getResult  (  )  ;  }  	Math_67_MultiStartUnivariateRealOptimizer_2_2	97	1	src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java
192	setConvergenceChecker(null);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578330049>  but  was:<0257819926636807>  [CLASS]  [CONTEXT]  	Math_68_LevenbergMarquardtOptimizer_7_1	166	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
193	VectorialPointValuePair  current  =  new  VectorialPointValuePair(point,  objective);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578330049>  but  was:<0257819926636807>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  solvedCols  =  Math  .  min  (  rows  ,  cols  )  ;  diagR  =  new  double[cols]  ;  jacNorm  =  new  double[cols]  ;  beta  =  new  double[cols]  ;  permutation  =  new  int[cols]  ;  lmDir  =  new  double[cols]  ;  double  delta  =  0  ;  double  xNorm  =  0  ;  double[]  diag  =  new  double[cols]  ;  double[]  oldX  =  new  double[cols]  ;  double[]  oldRes  =  new  double[rows]  ;  double[]  work1  =  new  double[cols]  ;  double[]  work2  =  new  double[cols]  ;  double[]  work3  =  new  double[cols]  ;  updateResidualsAndCost  (  )  ;  lmPar  =  0  ;  boolean  firstIteration  =  true  ;  [BUGGY]  while  (  true  )  {  incrementIterationsCounter  (  )  ;  updateJacobian  (  )  ;  	Math_68_LevenbergMarquardtOptimizer_7_2	247	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
194	VectorialPointValuePair  previous  =  current;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578330049>  but  was:<0257819926636807>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  beta  =  new  double[cols]  ;  permutation  =  new  int[cols]  ;  lmDir  =  new  double[cols]  ;  double  delta  =  0  ;  double  xNorm  =  0  ;  double[]  diag  =  new  double[cols]  ;  double[]  oldX  =  new  double[cols]  ;  double[]  oldRes  =  new  double[rows]  ;  double[]  work1  =  new  double[cols]  ;  double[]  work2  =  new  double[cols]  ;  double[]  work3  =  new  double[cols]  ;  updateResidualsAndCost  (  )  ;  lmPar  =  0  ;  boolean  firstIteration  =  true  ;  while  (  true  )  {  incrementIterationsCounter  (  )  ;  [BUGGY]  updateJacobian  (  )  ;  qrDecomposition  (  )  ;  qTy  (  residuals  )  ;  	Math_68_LevenbergMarquardtOptimizer_7_3	252	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
195	return  current;  	[BUGGY]  return  new  VectorialPointValuePair  (  point  ,  objective  )  ;  [FE]  AssertionFailedError:  expected:<02578330049>  but  was:<0257819926636807>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  }  xNorm  =  Math  .  sqrt  (  xNorm  )  ;  delta  =  (  xNorm  =  =  0  )  ?  initialStepBoundFactor  :  (  initialStepBoundFactor  *  xNorm  )  ;  }  double  maxCosine  =  0  ;  if  (  cost  !  =  0  )  {  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  intpj  =  permutation[j]  ;  double  s  =  jacNorm[pj]  ;  if  (  s  !  =  0  )  {  double  sum  =  0  ;  for  (  int  i  =  0  ;  i  <  =  j  ;  ++i  )  {  sum  +  =  jacobian[i][pj]  *  residuals[i]  ;  }  maxCosine  =  Math  .  max  (  maxCosine  ,  Math  .  abs  (  sum  )  /  (  s  *  cost  )  )  ;  }  }  }  if  (  maxCosine  <  =  orthoTolerance  )  {  [BUGGY]  return  new  VectorialPointValuePair  (  point  ,  objective  )  ;  }  for  (  int  j  =  0  ;  j  <  cols  ;  ++j  )  {  diag[j]  =  Math  .  max  (  diag[j]  ,  jacNorm[j]  )  ;  	Math_68_LevenbergMarquardtOptimizer_7_4	303	1	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
196	current  =  new  VectorialPointValuePair(point,  objective);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578330049>  but  was:<0257819926636807>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  double[]  tmpVec  =  residuals  ;  residuals  =  oldRes  ;  oldRes  =  tmpVec  ;  determineLMParameter  (  oldRes  ,  delta  ,  diag  ,  work1  ,  work2  ,  work3  )  ;  double  lmNorm  =  0  ;  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  int  pj  =  permutation[j]  ;  lmDir[pj]  =  -lmDir[pj]  ;  point[pj]  =  oldX[pj]  +  lmDir[pj]  ;  double  s  =  diag[pj]  *  lmDir[pj]  ;  lmNorm+  =  s  *  s  ;  }  lmNorm  =  Math  .  sqrt  (  lmNorm  )  ;  if  (  firstIteration  )  {  delta  =  Math  .  min  (  delta  ,  lmNorm  )  ;  }  updateResidualsAndCost  (  )  ;  [BUGGY]  double  actRed  =  -1  .  0  ;  if  (  0  .  1  *  cost  <  previousCost  )  {  double  r  =  cost  /  previousCost  ;  actRed  =  1  .  0  -  r  *  r  ;  	Math_68_LevenbergMarquardtOptimizer_7_5	345	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
197	if  (checker  !=  null)  {  if  (checker.converged(getIterations(),  previous,  current))  {  return  current;  }  }  else  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<02578330049>  but  was:<0257819926636807>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  }  if  (  ratio  >  =  1  .  0e-4  )  {  firstIteration  =  false  ;  xNorm  =  0  ;  for  (  int  k  =  0  ;  k  <  cols  ;  ++k  )  {  double  xK  =  diag[k]  *  point[k]  ;  xNorm+  =  xK  *  xK  ;  }  xNorm  =  Math  .  sqrt  (  xNorm  )  ;  }  else  {  cost  =  previousCost  ;  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  int  pj  =  permutation[j]  ;  point[pj]  =  oldX[pj]  ;  }  tmpVec  =  residuals  ;  residuals  =  oldRes  ;  oldRes  =  tmpVec  ;  }  [BUGGY]  if  (  (  (  Math  .  abs  (  actRed  )  <  =  costRelativeTolerance  )  &&  (  preRed  <  =  costRelativeTolerance  )  &&  (  ratio  <  =  2  .  0  )  )  ||  (  delta  <  =  parRelativeTolerance  *  xNorm  )  )  {  	Math_68_LevenbergMarquardtOptimizer_7_6	413	0	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
198	return  current;  }  	[BUGGY]  return  new  VectorialPointValuePair  (  point  ,  objective  )  ;  [FE]  AssertionFailedError:  expected:<02578330049>  but  was:<0257819926636807>  [METHOD]  doOptimize  [TYPE]  VectorialPointValuePair  [PARAMETER]  [CLASS]  LevenbergMarquardtOptimizer  [TYPE]  int[]  permutation  [TYPE]  boolean  false  firstIteration  true  [TYPE]  double[]  beta  diag  diagR  jacNorm  lmDir  oldRes  oldX  tmpVec  work1  work2  work3  [TYPE]  double  actRed  coeff1  coeff2  costRelativeTolerance  delta  dirDer  dirJ  dk  initialStepBoundFactor  lmNorm  lmPar  maxCosine  orthoTolerance  parRelativeTolerance  pc2  preRed  previousCost  r  ratio  s  sum  tmp  xK  xNorm  xk  [TYPE]  int  i  j  k  pj  pk  rank  solvedCols  [CONTEXT]  xNorm  =  0  ;  for  (  int  k  =  0  ;  k  <  cols  ;  ++k  )  {  double  xK  =  diag[k]  *  point[k]  ;  xNorm+  =  xK  *  xK  ;  }  xNorm  =  Math  .  sqrt  (  xNorm  )  ;  }  else  {  cost  =  previousCost  ;  for  (  int  j  =  0  ;  j  <  solvedCols  ;  ++j  )  {  int  pj  =  permutation[j]  ;  point[pj]  =  oldX[pj]  ;  }  tmpVec  =  residuals  ;  residuals  =  oldRes  ;  oldRes  =  tmpVec  ;  }  if  (  (  (  Math  .  abs  (  actRed  )  <  =  costRelativeTolerance  )  &&  (  preRed  <  =  costRelativeTolerance  )  &&  (  ratio  <  =  2  .  0  )  )  ||  (  delta  <  =  parRelativeTolerance  *  xNorm  )  )  {  [BUGGY]  return  new  VectorialPointValuePair  (  point  ,  objective  )  ;  }  if  (  (  Math  .  abs  (  actRed  )  <  =  2  .  2204e-16  )  &&  (  preRed  <  =  2  .  2204e-16  )  &&  (  ratio  <  =  2  .  0  )  )  {  	Math_68_LevenbergMarquardtOptimizer_7_7	419	1	src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java
199	out[i][j]  =  2  *  tDistribution.cumulativeProbability(-t);  	[BUGGY]  out[i][j]  =  2  *  (  1  -  tDistribution  .  cumulativeProbability  (  t  )  )  ;  [FE]  AssertionFailedError  assertTrue  (  corrInstance  .  getCorrelationPValues  (  )  .  getEntry  (  0  ,  1  )  >  0  )  ;  [METHOD]  getCorrelationPValues  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  PearsonsCorrelation  [TYPE]  double[][]  out  [TYPE]  TDistribution  tDistribution  [TYPE]  boolean  false  true  [TYPE]  RealMatrix  correlationMatrix  [TYPE]  int  i  j  nObs  nVars  [TYPE]  double  r  t  [CONTEXT]  public  RealMatrix  getCorrelationPValues  (  )  throws  MathException  {  TDistribution  tDistribution  =  new  TDistributionImpl  (  nObs  -  2  )  ;  int  nVars  =  correlationMatrix  .  getColumnDimension  (  )  ;  double[][]  out  =  new  double[nVars][nVars]  ;  for  (  int  i  =  0  ;  i  <  nVars  ;  i++  )  {  for  (  int  j  =  0  ;  j  <  nVars  ;  j++  )  {  if  (  i  =  =  j  )  {  out[i][j]  =  0d  ;  }  else  {  double  r  =  correlationMatrix  .  getEntry  (  i  ,  j  )  ;  double  t  =  Math  .  abs  (  r  *  Math  .  sqrt  (  (  nObs  -  2  )  /  (  1  -  r  *  r  )  )  )  ;  [BUGGY]  out[i][j]  =  2  *  (  1  -  tDistribution  .  cumulativeProbability  (  t  )  )  ;  }  }  }  return  new  BlockRealMatrix  (  out  )  ;  }  	Math_69_PearsonsCorrelation_1_1	171	1	src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java
200	return  solve(f,  min,  max);  	[BUGGY]  return  solve  (  min  ,  max  )  ;  [FE]  NullPointerException  assertEquals  (  Math  .  PI  ,  solver  .  solve  (  f  ,  3  .  0  ,  3  .  2  ,  3  .  1  )  ,  solver  .  getAbsoluteAccuracy  (  )  )  ;  [METHOD]  solve  [TYPE]  double  [PARAMETER]  UnivariateRealFunction  f  double  min  double  max  double  initial  [CLASS]  BisectionSolver  [TYPE]  boolean  false  true  [TYPE]  double  initial  max  min  [TYPE]  UnivariateRealFunction  f  [CONTEXT]  public  double  solve  (  final  UnivariateRealFunction  f  ,  double  min  ,  double  max  ,  double  initial  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  [BUGGY]  return  solve  (  min  ,  max  )  ;  }  	Math_70_BisectionSolver_1_1	72	1	src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java
201	interpolator.storeTime(stepStart);  System.arraycopy(y,  0,  yTmp,  0,  y0.length);  hNew  =  0;  stepSize  =  0;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<18782503799999986E9>  but  was:<1878250439999994E9>  [METHOD]  integrate  [TYPE]  double  [PARAMETER]  FirstOrderDifferentialEquations  equations  final  double  t0  final  double[]  y0  final  double  t  final  double[]  y  [CLASS]  EmbeddedRungeKuttaIntegrator  [TYPE]  boolean  false  firstTime  forward  fsal  lastStep  loop  nextIsLast  true  [TYPE]  CombinedEventsManager  manager  [TYPE]  double[]  b  c  scale  y  y0  yTmp  [TYPE]  double  dt  error  exp  factor  hNew  maxGrowth  minReduction  nextStep  nextT  safety  scaledH  stopTime  sum  t  t0  [TYPE]  double[][]  a  yDotK  [TYPE]  AbstractStepInterpolator  interpolator  [TYPE]  StepHandler  handler  [TYPE]  RungeKuttaStepInterpolator  prototype  rki  [TYPE]  int  i  j  k  l  stages  [TYPE]  FirstOrderDifferentialEquations  equations  [CONTEXT]  }  for  (  int  j  =  0  ;  j  <  y0  .  length  ;  ++j  )  {  double  sum  =  b[0]  *  yDotK[0][j]  ;  for  (  int  l  =  1  ;  l  <  stages  ;  ++l  )  {  sum+  =  b[l]  *  yDotK[l][j]  ;  }  yTmp[j]  =  y[j]  +  stepSize  *  sum  ;  }  error  =  estimateError  (  yDotK  ,  y  ,  yTmp  ,  stepSize  )  ;  if  (  error  <  =  1  .  0  )  {  interpolator  .  storeTime  (  stepStart  +  stepSize  )  ;  if  (  manager  .  evaluateStep  (  interpolator  )  )  {  final  double  dt  =  manager  .  getEventTime  (  )  -  stepStart  ;  if  (  Math  .  abs  (  dt  )  <  =  Math  .  ulp  (  stepStart  )  )  {  [BUGGY]  loop  =  false  ;  }  else  {  hNew  =  dt  ;  }  }  else  {  	Math_71_EmbeddedRungeKuttaIntegrator_1_1	300	0	src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
202	interpolator.storeTime(stepStart);  System.arraycopy(y,  0,  yTmp,  0,  y0.length);  stepSize  =  0;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<18782503799999986E9>  but  was:<1878250439999994E9>  [METHOD]  integrate  [TYPE]  double  [PARAMETER]  FirstOrderDifferentialEquations  equations  final  double  t0  final  double[]  y0  final  double  t  final  double[]  y  [CLASS]  RungeKuttaIntegrator  [TYPE]  boolean  false  forward  lastStep  loop  true  [TYPE]  CombinedEventsManager  manager  [TYPE]  double[]  b  c  y  y0  yTmp  [TYPE]  double  dt  nextStep  step  stopTime  sum  t  t0  [TYPE]  double[][]  a  yDotK  [TYPE]  AbstractStepInterpolator  interpolator  [TYPE]  StepHandler  handler  [TYPE]  RungeKuttaStepInterpolator  prototype  rki  [TYPE]  int  i  j  k  l  stages  [TYPE]  FirstOrderDifferentialEquations  equations  [CONTEXT]  }  computeDerivatives  (  stepStart  +  c[k-1]  *  stepSize  ,  yTmp  ,  yDotK[k]  )  ;  }  for  (  int  j  =  0  ;  j  <  y0  .  length  ;  ++j  )  {  double  sum  =  b[0]  *  yDotK[0][j]  ;  for  (  int  l  =  1  ;  l  <  stages  ;  ++l  )  {  sum+  =  b[l]  *  yDotK[l][j]  ;  }  yTmp[j]  =  y[j]  +  stepSize  *  sum  ;  }  interpolator  .  storeTime  (  stepStart  +  stepSize  )  ;  if  (  manager  .  evaluateStep  (  interpolator  )  )  {  final  double  dt  =  manager  .  getEventTime  (  )  -  stepStart  ;  if  (  Math  .  abs  (  dt  )  <  =  Math  .  ulp  (  stepStart  )  )  {  [BUGGY]  loop  =  false  ;  }  else  {  stepSize  =  dt  ;  }  }  else  {  	Math_71_RungeKuttaIntegrator_1_1	180	0	src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java
203	setResult(min,  0);  	[BUGGY]  setResult  (  yMin  ,  0  )  ;  [FE]  AssertionFailedError:  expected:<3141592653589793>  but  was:<12246467991473532E-16>  assertEquals  (  Math  .  PI  ,  result  ,  solver  .  getAbsoluteAccuracy  (  )  )  ;  [METHOD]  solve  [TYPE]  double  [PARAMETER]  UnivariateRealFunction  f  final  double  min  final  double  max  final  double  initial  [CLASS]  BrentSolver  [TYPE]  UnivariateRealFunction  f  [TYPE]  String  NON_BRACKETING_MESSAGE  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  double  initial  max  min  yInitial  yMax  yMin  [CONTEXT]  public  double  solve  (  final  UnivariateRealFunction  f  ,  final  double  min  ,  final  double  max  ,  final  double  initial  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  clearResult  (  )  ;  verifySequence  (  min  ,  initial  ,  max  )  ;  double  yInitial  =  f  .  value  (  initial  )  ;  if  (  Math  .  abs  (  yInitial  )  <  =  functionValueAccuracy  )  {  setResult  (  initial  ,  0  )  ;  return  result  ;  }  double  yMin  =  f  .  value  (  min  )  ;  if  (  Math  .  abs  (  yMin  )  <  =  functionValueAccuracy  )  {  [BUGGY]  setResult  (  yMin  ,  0  )  ;  return  result  ;  }  if  (  yInitial  *  yMin  <  0  )  {  	Math_72_BrentSolver_2_1	115	1	src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java
204	setResult(max,  0);  	[BUGGY]  setResult  (  yMax  ,  0  )  ;  [FE]  AssertionFailedError:  expected:<3141592653589793>  but  was:<12246467991473532E-16>  assertEquals  (  Math  .  PI  ,  result  ,  solver  .  getAbsoluteAccuracy  (  )  )  ;  [METHOD]  solve  [TYPE]  double  [PARAMETER]  UnivariateRealFunction  f  final  double  min  final  double  max  final  double  initial  [CLASS]  BrentSolver  [TYPE]  UnivariateRealFunction  f  [TYPE]  String  NON_BRACKETING_MESSAGE  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  double  initial  max  min  yInitial  yMax  yMin  [CONTEXT]  clearResult  (  )  ;  verifySequence  (  min  ,  initial  ,  max  )  ;  double  yInitial  =  f  .  value  (  initial  )  ;  if  (  Math  .  abs  (  yInitial  )  <  =  functionValueAccuracy  )  {  setResult  (  initial  ,  0  )  ;  return  result  ;  }  double  yMin  =  f  .  value  (  min  )  ;  if  (  Math  .  abs  (  yMin  )  <  =  functionValueAccuracy  )  {  setResult  (  yMin  ,  0  )  ;  return  result  ;  }  if  (  yInitial  *  yMin  <  0  )  {  return  solve  (  f  ,  min  ,  yMin  ,  initial  ,  yInitial  ,  min  ,  yMin  )  ;  }  double  yMax  =  f  .  value  (  max  )  ;  if  (  Math  .  abs  (  yMax  )  <  =  functionValueAccuracy  )  {  [BUGGY]  setResult  (  yMax  ,  0  )  ;  return  result  ;  }  if  (  yInitial  *  yMax  <  0  )  {  	Math_72_BrentSolver_2_2	127	1	src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java
205	if  (yMin  *  yMax  >  0)  {  throw  MathRuntimeException.createIllegalArgumentException(  NON_BRACKETING_MESSAGE,  min,  max,  yMin,  yMax);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expecting  IllegalArgumentException  -  non-bracketing  [METHOD]  solve  [TYPE]  double  [PARAMETER]  UnivariateRealFunction  f  final  double  min  final  double  max  final  double  initial  [CLASS]  BrentSolver  [TYPE]  UnivariateRealFunction  f  [TYPE]  String  NON_BRACKETING_MESSAGE  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  double  initial  max  min  yInitial  yMax  yMin  [CONTEXT]  double  yMin  =  f  .  value  (  min  )  ;  if  (  Math  .  abs  (  yMin  )  <  =  functionValueAccuracy  )  {  setResult  (  yMin  ,  0  )  ;  return  result  ;  }  if  (  yInitial  *  yMin  <  0  )  {  return  solve  (  f  ,  min  ,  yMin  ,  initial  ,  yInitial  ,  min  ,  yMin  )  ;  }  double  yMax  =  f  .  value  (  max  )  ;  if  (  Math  .  abs  (  yMax  )  <  =  functionValueAccuracy  )  {  setResult  (  yMax  ,  0  )  ;  return  result  ;  }  if  (  yInitial  *  yMax  <  0  )  {  return  solve  (  f  ,  initial  ,  yInitial  ,  max  ,  yMax  ,  initial  ,  yInitial  )  ;  }  [BUGGY]  return  solve  (  f  ,  min  ,  yMin  ,  max  ,  yMax  ,  initial  ,  yInitial  )  ;  }  	Math_73_BrentSolver_1_1	136	0	src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java
206	final  double[]  scale  =  new  double[y0.length];  for  (int  i  =  0;  i  <  scale.length;  ++i)  {  scale[i]  =  scalAbsoluteTolerance  +  scalRelativeTolerance  *  Math.abs(y[i]);  }  for  (int  i  =  0;  i  <  scale.length;  ++i)  {  scale[i]  =  vecAbsoluteTolerance[i]  +  vecRelativeTolerance[i]  *  Math.abs(y[i]);  }  	[BUGGY]  final  double[]  scale  ;  scale  =  new  double[y0  .  length]  ;  java  .  util  .  Arrays  .  fill  (  scale  ,  scalAbsoluteTolerance  )  ;  scale  =  vecAbsoluteTolerance  ;  [FE]  AssertionFailedError  assertTrue  (  integ  .  getEvaluations  (  )  <  90  )  ;  [METHOD]  integrate  [TYPE]  double  [PARAMETER]  FirstOrderDifferentialEquations  equations  final  double  t0  final  double[]  y0  final  double  t  final  double[]  y  [CLASS]  EmbeddedRungeKuttaIntegrator  [TYPE]  boolean  false  firstTime  forward  fsal  lastStep  loop  nextIsLast  true  [TYPE]  CombinedEventsManager  manager  [TYPE]  double[]  b  c  scale  y  y0  yTmp  [TYPE]  double  dt  error  exp  factor  hNew  maxGrowth  minReduction  nextStep  nextT  safety  scaledH  stopTime  sum  t  t0  [TYPE]  double[][]  a  yDotK  [TYPE]  AbstractStepInterpolator  interpolator  [TYPE]  StepHandler  handler  [TYPE]  RungeKuttaStepInterpolator  prototype  rki  [TYPE]  int  j  k  l  stages  [TYPE]  FirstOrderDifferentialEquations  equations  [CONTEXT]  stepStart  =  t0  ;  doublehNew  =  0  ;  boolean  firstTime  =  true  ;  for  (  StepHandler  handler  :  stepHandlers  )  {  handler  .  reset  (  )  ;  }  CombinedEventsManager  manager  =  addEndTimeChecker  (  t0  ,  t  ,  eventsHandlersManager  )  ;  boolean  lastStep  =  false  ;  while  (  !lastStep  )  {  interpolator  .  shift  (  )  ;  double  error  =  0  ;  for  (  boolean  loop  =  true  ;  loop  ;  )  {  if  (  firstTime  ||  !fsal  )  {  computeDerivatives  (  stepStart  ,  y  ,  yDotK[0]  )  ;  }  if  (  firstTime  )  {  [BUGGY]  final  double[]  scale  ;  if  (  vecAbsoluteTolerance  =  =  null  )  {  scale  =  new  double[y0  .  length]  ;  java  .  util  .  Arrays  .  fill  (  scale  ,  scalAbsoluteTolerance  )  ;  }  else  {  scale  =  vecAbsoluteTolerance  ;  	Math_74_EmbeddedRungeKuttaIntegrator_1_1	245	4	src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java
207	return  getPct((Comparable<?>)  v);  	[BUGGY]  return  getCumPct  (  (  Comparable<?>  )  v  )  ;  [FE]  AssertionFailedError:  three  (  Object  )  pct  expected:<05>  but  was:<10>  assertEquals  ( "foo  cum  pct "  ,  0  ,  f  .  getCumPct  ( "foo "  )  ,  tolerance  )  ;  [METHOD]  getPct  [TYPE]  double  [PARAMETER]  Object  v  [CLASS]  Frequency  [TYPE]  Object  v  [TYPE]  boolean  false  true  [TYPE]  TreeMap  freqTable  [TYPE]  long  serialVersionUID  [CONTEXT]  public  double  getPct  (  Object  v  )  {  [BUGGY]  return  getCumPct  (  (  Comparable<?>  )  v  )  ;  }  	Math_75_Frequency_1_1	303	1	src/main/java/org/apache/commons/math/stat/Frequency.java
208	eigenDecomposition.getV().getSubMatrix(0,  n  -  1,  0,  p  -  1);  	[BUGGY]  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  [FE]  AssertionFailedError:  expected:<00>  but  was:<009336767546650937>  Assert  .  assertTrue  (  (  residual  (  rm  ,  x  ,  b  )  -  svdMinResidual  )  >  -epsilon  )  ;  [METHOD]  getU  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  SingularValueDecompositionImpl  [TYPE]  EigenDecomposition  eigenDecomposition  [TYPE]  boolean  false  nonSingular  true  [TYPE]  double[]  ei0  ei1  mainBidiagonal  mainTridiagonal  secondaryBidiagonal  secondaryTridiagonal  singularValues  wi  [TYPE]  RealMatrix  cachedS  cachedU  cachedUt  cachedV  cachedVt  e  pseudoInverse  [TYPE]  double  mi  si  [TYPE]  double[][]  eData  wData  [TYPE]  BiDiagonalTransformer  transformer  [TYPE]  int  i  j  m  n  p  [CONTEXT]  public  RealMatrix  getU  (  )  throws  InvalidMatrixException  {  if  (  cachedU  =  =  null  )  {  final  int  p  =  singularValues  .  length  ;  if  (  m  >  =  n  )  {  final  RealMatrix  e  =  [BUGGY]  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  final  double[][]  eData  =  e  .  getData  (  )  ;  final  double[][]  wData  =  new  double[m][p]  ;  double[]  ei1  =  eData[0]  ;  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  	Math_76_SingularValueDecompositionImpl_8_1	162	1	src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
209	for  (int  i  =  0;  i  <  p;  ++i)  {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  [FE]  AssertionFailedError:  expected:<00>  but  was:<009336767546650937>  Assert  .  assertTrue  (  (  residual  (  rm  ,  x  ,  b  )  -  svdMinResidual  )  >  -epsilon  )  ;  [METHOD]  getU  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  SingularValueDecompositionImpl  [TYPE]  EigenDecomposition  eigenDecomposition  [TYPE]  boolean  false  nonSingular  true  [TYPE]  double[]  ei0  ei1  mainBidiagonal  mainTridiagonal  secondaryBidiagonal  secondaryTridiagonal  singularValues  wi  [TYPE]  RealMatrix  cachedS  cachedU  cachedUt  cachedV  cachedVt  e  pseudoInverse  [TYPE]  double  mi  si  [TYPE]  double[][]  eData  wData  [TYPE]  BiDiagonalTransformer  transformer  [TYPE]  int  i  j  m  n  p  [CONTEXT]  public  RealMatrix  getU  (  )  throws  InvalidMatrixException  {  if  (  cachedU  =  =  null  )  {  final  int  p  =  singularValues  .  length  ;  if  (  m  >  =  n  )  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  final  double[][]  eData  =  e  .  getData  (  )  ;  final  double[][]  wData  =  new  double[m][p]  ;  double[]  ei1  =  eData[0]  ;  [BUGGY]  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  final  double  mi  =  mainBidiagonal[i]  ;  final  double[]  ei0  =  ei1  ;  final  double[]  wi  =  wData[i]  ;  ei1  =  eData[i  +  1]  ;  	Math_76_SingularValueDecompositionImpl_8_2	166	1	src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
210	if  (i  <  n  -  1)  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<00>  but  was:<009336767546650937>  Assert  .  assertTrue  (  (  residual  (  rm  ,  x  ,  b  )  -  svdMinResidual  )  >  -epsilon  )  ;  [METHOD]  getU  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  SingularValueDecompositionImpl  [TYPE]  EigenDecomposition  eigenDecomposition  [TYPE]  boolean  false  nonSingular  true  [TYPE]  double[]  ei0  ei1  mainBidiagonal  mainTridiagonal  secondaryBidiagonal  secondaryTridiagonal  singularValues  wi  [TYPE]  RealMatrix  cachedS  cachedU  cachedUt  cachedV  cachedVt  e  pseudoInverse  [TYPE]  double  mi  si  [TYPE]  double[][]  eData  wData  [TYPE]  BiDiagonalTransformer  transformer  [TYPE]  int  i  j  m  n  p  [CONTEXT]  public  RealMatrix  getU  (  )  throws  InvalidMatrixException  {  if  (  cachedU  =  =  null  )  {  final  int  p  =  singularValues  .  length  ;  if  (  m  >  =  n  )  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  final  double[][]  eData  =  e  .  getData  (  )  ;  final  double[][]  wData  =  new  double[m][p]  ;  double[]  ei1  =  eData[0]  ;  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  final  double  mi  =  mainBidiagonal[i]  ;  final  double[]  ei0  =  ei1  ;  final  double[]  wi  =  wData[i]  ;  [BUGGY]  ei1  =  eData[i  +  1]  ;  final  double  si  =  secondaryBidiagonal[i]  ;  for  (  int  j  =  0  ;  j  <  p  ;  ++j  )  {  wi[j]  =  (  mi  *  ei0[j]  +  si  *  ei1[j]  )  /  singularValues[j]  ;  }  }  	Math_76_SingularValueDecompositionImpl_8_3	171	0	src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
211	}  else  {  wi[j]  =  mi  *  ei0[j]  /  singularValues[j];  }  }  	[BUGGY]  }  wData[p  -  1][j]  =  ei1[j]  *  mainBidiagonal[p  -  1]  /  singularValues[j]  ;  [FE]  AssertionFailedError:  expected:<00>  but  was:<009336767546650937>  Assert  .  assertTrue  (  (  residual  (  rm  ,  x  ,  b  )  -  svdMinResidual  )  >  -epsilon  )  ;  [METHOD]  getU  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  SingularValueDecompositionImpl  [TYPE]  EigenDecomposition  eigenDecomposition  [TYPE]  boolean  false  nonSingular  true  [TYPE]  double[]  ei0  ei1  mainBidiagonal  mainTridiagonal  secondaryBidiagonal  secondaryTridiagonal  singularValues  wi  [TYPE]  RealMatrix  cachedS  cachedU  cachedUt  cachedV  cachedVt  e  pseudoInverse  [TYPE]  double  mi  si  [TYPE]  double[][]  eData  wData  [TYPE]  BiDiagonalTransformer  transformer  [TYPE]  int  i  j  m  n  p  [CONTEXT]  public  RealMatrix  getU  (  )  throws  InvalidMatrixException  {  if  (  cachedU  =  =  null  )  {  final  int  p  =  singularValues  .  length  ;  if  (  m  >  =  n  )  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  final  double[][]  eData  =  e  .  getData  (  )  ;  final  double[][]  wData  =  new  double[m][p]  ;  double[]  ei1  =  eData[0]  ;  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  final  double  mi  =  mainBidiagonal[i]  ;  final  double[]  ei0  =  ei1  ;  final  double[]  wi  =  wData[i]  ;  ei1  =  eData[i  +  1]  ;  final  double  si  =  secondaryBidiagonal[i]  ;  for  (  int  j  =  0  ;  j  <  p  ;  ++j  )  {  wi[j]  =  (  mi  *  ei0[j]  +  si  *  ei1[j]  )  /  singularValues[j]  ;  }  [BUGGY]  }  for  (  int  j  =  0  ;  j  <  p  ;  ++j  )  {  wData[p  -  1][j]  =  ei1[j]  *  mainBidiagonal[p  -  1]  /  singularValues[j]  ;  }  for  (  int  i  =  p  ;  i  <  m  ;  ++i  )  {  	Math_76_SingularValueDecompositionImpl_8_4	176	2	src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
212	eigenDecomposition.getV().getSubMatrix(0,  m  -  1,  0,  p  -  1);  	[BUGGY]  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  [FE]  AssertionFailedError:  expected:<00>  but  was:<009336767546650937>  Assert  .  assertTrue  (  (  residual  (  rm  ,  x  ,  b  )  -  svdMinResidual  )  >  -epsilon  )  ;  [METHOD]  getV  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  SingularValueDecompositionImpl  [TYPE]  EigenDecomposition  eigenDecomposition  [TYPE]  boolean  false  nonSingular  true  [TYPE]  double[]  ei0  ei1  mainBidiagonal  mainTridiagonal  secondaryBidiagonal  secondaryTridiagonal  singularValues  wi  [TYPE]  RealMatrix  cachedS  cachedU  cachedUt  cachedV  cachedVt  e  pseudoInverse  [TYPE]  double  mi  si  [TYPE]  double[][]  eData  wData  [TYPE]  BiDiagonalTransformer  transformer  [TYPE]  int  i  j  m  n  p  [CONTEXT]  public  RealMatrix  getV  (  )  throws  InvalidMatrixException  {  if  (  cachedV  =  =  null  )  {  final  int  p  =  singularValues  .  length  ;  if  (  m  >  =  n  )  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  n  -  1  ,  0  ,  p  -  1  )  ;  cachedV  =  transformer  .  getV  (  )  .  multiply  (  e  )  ;  }  else  {  final  RealMatrix  e  =  [BUGGY]  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  final  double[][]  eData  =  e  .  getData  (  )  ;  final  double[][]  wData  =  new  double[n][p]  ;  double[]  ei1  =  eData[0]  ;  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  final  double  mi  =  mainBidiagonal[i]  ;  	Math_76_SingularValueDecompositionImpl_8_5	248	1	src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
213	for  (int  i  =  0;  i  <  p;  ++i)  {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  [FE]  AssertionFailedError:  expected:<00>  but  was:<009336767546650937>  Assert  .  assertTrue  (  (  residual  (  rm  ,  x  ,  b  )  -  svdMinResidual  )  >  -epsilon  )  ;  [METHOD]  getV  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  SingularValueDecompositionImpl  [TYPE]  EigenDecomposition  eigenDecomposition  [TYPE]  boolean  false  nonSingular  true  [TYPE]  double[]  ei0  ei1  mainBidiagonal  mainTridiagonal  secondaryBidiagonal  secondaryTridiagonal  singularValues  wi  [TYPE]  RealMatrix  cachedS  cachedU  cachedUt  cachedV  cachedVt  e  pseudoInverse  [TYPE]  double  mi  si  [TYPE]  double[][]  eData  wData  [TYPE]  BiDiagonalTransformer  transformer  [TYPE]  int  i  j  m  n  p  [CONTEXT]  public  RealMatrix  getV  (  )  throws  InvalidMatrixException  {  if  (  cachedV  =  =  null  )  {  final  int  p  =  singularValues  .  length  ;  if  (  m  >  =  n  )  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  n  -  1  ,  0  ,  p  -  1  )  ;  cachedV  =  transformer  .  getV  (  )  .  multiply  (  e  )  ;  }  else  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  final  double[][]  eData  =  e  .  getData  (  )  ;  final  double[][]  wData  =  new  double[n][p]  ;  double[]  ei1  =  eData[0]  ;  [BUGGY]  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  final  double  mi  =  mainBidiagonal[i]  ;  final  double[]  ei0  =  ei1  ;  final  double[]  wi  =  wData[i]  ;  ei1  =  eData[i  +  1]  ;  final  double  si  =  secondaryBidiagonal[i]  ;  	Math_76_SingularValueDecompositionImpl_8_6	252	1	src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
214	if  (i  <  m  -  1)  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<00>  but  was:<009336767546650937>  Assert  .  assertTrue  (  (  residual  (  rm  ,  x  ,  b  )  -  svdMinResidual  )  >  -epsilon  )  ;  [METHOD]  getV  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  SingularValueDecompositionImpl  [TYPE]  EigenDecomposition  eigenDecomposition  [TYPE]  boolean  false  nonSingular  true  [TYPE]  double[]  ei0  ei1  mainBidiagonal  mainTridiagonal  secondaryBidiagonal  secondaryTridiagonal  singularValues  wi  [TYPE]  RealMatrix  cachedS  cachedU  cachedUt  cachedV  cachedVt  e  pseudoInverse  [TYPE]  double  mi  si  [TYPE]  double[][]  eData  wData  [TYPE]  BiDiagonalTransformer  transformer  [TYPE]  int  i  j  m  n  p  [CONTEXT]  public  RealMatrix  getV  (  )  throws  InvalidMatrixException  {  if  (  cachedV  =  =  null  )  {  final  int  p  =  singularValues  .  length  ;  if  (  m  >  =  n  )  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  n  -  1  ,  0  ,  p  -  1  )  ;  cachedV  =  transformer  .  getV  (  )  .  multiply  (  e  )  ;  }  else  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  final  double[][]  eData  =  e  .  getData  (  )  ;  final  double[][]  wData  =  new  double[n][p]  ;  double[]  ei1  =  eData[0]  ;  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  final  double  mi  =  mainBidiagonal[i]  ;  final  double[]  ei0  =  ei1  ;  final  double[]  wi  =  wData[i]  ;  [BUGGY]  ei1  =  eData[i  +  1]  ;  final  double  si  =  secondaryBidiagonal[i]  ;  for  (  int  j  =  0  ;  j  <  p  ;  ++j  )  {  wi[j]  =  (  mi  *  ei0[j]  +  si  *  ei1[j]  )  /  singularValues[j]  ;  }  }  	Math_76_SingularValueDecompositionImpl_8_7	256	0	src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
215	}  else  {  wi[j]  =  mi  *  ei0[j]  /  singularValues[j];  }  }  	[BUGGY]  }  wData[p  -  1][j]  =  ei1[j]  *  mainBidiagonal[p  -  1]  /  singularValues[j]  ;  [FE]  AssertionFailedError:  expected:<00>  but  was:<009336767546650937>  Assert  .  assertTrue  (  (  residual  (  rm  ,  x  ,  b  )  -  svdMinResidual  )  >  -epsilon  )  ;  [METHOD]  getV  [TYPE]  RealMatrix  [PARAMETER]  [CLASS]  SingularValueDecompositionImpl  [TYPE]  EigenDecomposition  eigenDecomposition  [TYPE]  boolean  false  nonSingular  true  [TYPE]  double[]  ei0  ei1  mainBidiagonal  mainTridiagonal  secondaryBidiagonal  secondaryTridiagonal  singularValues  wi  [TYPE]  RealMatrix  cachedS  cachedU  cachedUt  cachedV  cachedVt  e  pseudoInverse  [TYPE]  double  mi  si  [TYPE]  double[][]  eData  wData  [TYPE]  BiDiagonalTransformer  transformer  [TYPE]  int  i  j  m  n  p  [CONTEXT]  if  (  cachedV  =  =  null  )  {  final  int  p  =  singularValues  .  length  ;  if  (  m  >  =  n  )  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  n  -  1  ,  0  ,  p  -  1  )  ;  cachedV  =  transformer  .  getV  (  )  .  multiply  (  e  )  ;  }  else  {  final  RealMatrix  e  =  eigenDecomposition  .  getV  (  )  .  getSubMatrix  (  0  ,  p  -  1  ,  0  ,  p  -  1  )  ;  final  double[][]  eData  =  e  .  getData  (  )  ;  final  double[][]  wData  =  new  double[n][p]  ;  double[]  ei1  =  eData[0]  ;  for  (  int  i  =  0  ;  i  <  p  -  1  ;  ++i  )  {  final  double  mi  =  mainBidiagonal[i]  ;  final  double[]  ei0  =  ei1  ;  final  double[]  wi  =  wData[i]  ;  ei1  =  eData[i  +  1]  ;  final  double  si  =  secondaryBidiagonal[i]  ;  for  (  int  j  =  0  ;  j  <  p  ;  ++j  )  {  wi[j]  =  (  mi  *  ei0[j]  +  si  *  ei1[j]  )  /  singularValues[j]  ;  }  [BUGGY]  }  for  (  int  j  =  0  ;  j  <  p  ;  ++j  )  {  wData[p  -  1][j]  =  ei1[j]  *  mainBidiagonal[p  -  1]  /  singularValues[j]  ;  }  for  (  int  i  =  p  ;  i  <  n  ;  ++i  )  {  wData[i]  =  new  double[p]  ;  	Math_76_SingularValueDecompositionImpl_8_8	261	2	src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java
216	max  =  Math.max(max,  Math.abs(a));  	[BUGGY]  max  +  =  Math  .  max  (  max  ,  Math  .  abs  (  a  )  )  ;  [FE]  AssertionFailedError:  compare  values  expected:<60>  but  was:<1280>  assertClose  ( "compare  vect "  ,  v_projection_3  .  getData  (  )  ,  result_projection_3  ,  normTolerance  )  ;  [METHOD]  getLInfNorm  [TYPE]  double  [PARAMETER]  [CLASS]  ArrayRealVector  [TYPE]  RealVectorFormat  DEFAULT_FORMAT  [TYPE]  String  NON_FITTING_POSITION_AND_SIZE_MESSAGE  [TYPE]  boolean  false  true  [TYPE]  double[]  data  [TYPE]  long  serialVersionUID  [TYPE]  double  a  max  [CONTEXT]  public  double  getLInfNorm  (  )  {  double  max  =  0  ;  for  (  double  a  :  data  )  {  [BUGGY]  max  +  =  Math  .  max  (  max  ,  Math  .  abs  (  a  )  )  ;  }  return  max  ;  }  	Math_77_ArrayRealVector_1_1	721	1	src/main/java/org/apache/commons/math/linear/ArrayRealVector.java
217		[BUGGY]  public  double  getLInfNorm  (  )  {  double  max  =  0  ;  Iterator  iter  =  entries  .  iterator  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  iter  .  advance  (  )  ;  max  +  =  iter  .  value  (  )  ;  }  return  max  ;  }  [FE]  AssertionFailedError:  compare  values  expected:<60>  but  was:<1280>  assertClose  ( "compare  vect "  ,  v_projection_3  .  getData  (  )  ,  result_projection_3  ,  normTolerance  )  ;  [CLASS]  [CONTEXT]  	Math_77_OpenMapRealVector_1_1	498	9	src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java
218	if  (ga  *  gb  >  0)  {  	[BUGGY]  [FE]  commonsmathMathRuntimeException$4:  function  values  at  endpoints  do  not  have  different  signs  Endpoints:  [89999  ,  1531]  ,  Values:  [-0066  ,  -1  ,  14211]  [METHOD]  evaluateStep  [TYPE]  boolean  [PARAMETER]  StepInterpolator  interpolator  [CLASS]  EventState  [TYPE]  BrentSolver  solver  [TYPE]  boolean  false  forward  g0Positive  increasing  pendingEvent  true  [TYPE]  EventException  e  [TYPE]  double  convergence  g0  ga  gb  h  maxCheckInterval  pendingEventTime  previousEventTime  root  t  t0  t1  ta  tb  [TYPE]  EventHandler  handler  [TYPE]  Throwable  cause  [TYPE]  UnivariateRealFunction  f  [TYPE]  StepInterpolator  interpolator  [TYPE]  FunctionEvaluationException  e  [TYPE]  int  i  maxIterationCount  n  nextAction  [TYPE]  DerivativeException  e  [CONTEXT]  public  boolean  evaluateStep  (  final  StepInterpolator  interpolator  )  throws  DerivativeException  ,  EventException  ,  ConvergenceException  {  try  {  forward  =  interpolator  .  isForward  (  )  ;  final  double  t1  =  interpolator  .  getCurrentTime  (  )  ;  final  intn  =  Math  .  max  (  1  ,  (  int  )  Math  .  ceil  (  Math  .  abs  (  t1  -  t0  )  /  maxCheckInterval  )  )  ;  final  double  h  =  (  t1  -  t0  )  /  n  ;  double  ta  =  t0  ;  double  ga  =  g0  ;  double  tb  =  t0  +  (  interpolator  .  isForward  (  )  ?  convergence  :  -convergence  )  ;  for  (  int  i  =  0  ;  i  <  n  ;  ++i  )  {  tb  +  =  h  ;  interpolator  .  setInterpolatedTime  (  tb  )  ;  final  double  gb  =  handler  .  g  (  tb  ,  interpolator  .  getInterpolatedState  (  )  )  ;  if  (  g0Positive  ^  (  gb  >  =  0  )  )  {  [BUGGY]  	Math_78_EventState_2_1	191	0	src/main/java/org/apache/commons/math/ode/events/EventState.java
219	final  double  epsilon  =  (forward  ?  0.25  :  -0.25)  *  convergence;  for  (int  k  =  0;  (k  <  4)  &&  (ga  *  gb  >  0);  ++k)  {  ta  +=  epsilon;  interpolator.setInterpolatedTime(ta);  ga  =  handler.g(ta,  interpolator.getInterpolatedState());  }  if  (ga  *  gb  >  0)  {  throw  MathRuntimeException.createInternalError(null);  }  }  	[BUGGY]  [FE]  commonsmathMathRuntimeException$4:  function  values  at  endpoints  do  not  have  different  signs  Endpoints:  [89999  ,  1531]  ,  Values:  [-0066  ,  -1  ,  14211]  [METHOD]  evaluateStep  [TYPE]  boolean  [PARAMETER]  StepInterpolator  interpolator  [CLASS]  EventState  [TYPE]  BrentSolver  solver  [TYPE]  boolean  false  forward  g0Positive  increasing  pendingEvent  true  [TYPE]  EventException  e  [TYPE]  double  convergence  g0  ga  gb  h  maxCheckInterval  pendingEventTime  previousEventTime  root  t  t0  t1  ta  tb  [TYPE]  EventHandler  handler  [TYPE]  Throwable  cause  [TYPE]  UnivariateRealFunction  f  [TYPE]  StepInterpolator  interpolator  [TYPE]  FunctionEvaluationException  e  [TYPE]  int  i  maxIterationCount  n  nextAction  [TYPE]  DerivativeException  e  [CONTEXT]  final  double  t1  =  interpolator  .  getCurrentTime  (  )  ;  final  intn  =  Math  .  max  (  1  ,  (  int  )  Math  .  ceil  (  Math  .  abs  (  t1  -  t0  )  /  maxCheckInterval  )  )  ;  final  double  h  =  (  t1  -  t0  )  /  n  ;  double  ta  =  t0  ;  double  ga  =  g0  ;  double  tb  =  t0  +  (  interpolator  .  isForward  (  )  ?  convergence  :  -convergence  )  ;  for  (  int  i  =  0  ;  i  <  n  ;  ++i  )  {  tb  +  =  h  ;  interpolator  .  setInterpolatedTime  (  tb  )  ;  final  double  gb  =  handler  .  g  (  tb  ,  interpolator  .  getInterpolatedState  (  )  )  ;  if  (  g0Positive  ^  (  gb  >  =  0  )  )  {  [BUGGY]  increasing  =  gb  >  =  ga  ;  final  UnivariateRealFunction  f  =  new  UnivariateRealFunction  (  )  {  	Math_78_EventState_2_2	198	0	src/main/java/org/apache/commons/math/ode/events/EventState.java
220	double  sum  =  0;   	[BUGGY]  int  sum  =  0  ;   [FE]  NullPointerException  assertTrue  (  clusters  .  get  (  0  )  .  getPoints  (  )  .  contains  (  pt2  )  )  ;  [METHOD]  distance  [TYPE]  double  [PARAMETER]  int[]  p1  int[]  p2  [CLASS]  MathUtils  [TYPE]  boolean  false  true  [TYPE]  long[]  FACTORIALS  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  short  NS  PS  ZS  [TYPE]  int[]  p1  p2  [TYPE]  int  NAN_GAP  dp  i  sum  [TYPE]  long  SGN_MASK  [CONTEXT]  public  static  double  distance  (  int[]  p1  ,  int[]  p2  )  {  [BUGGY]  int  sum  =  0  ;  for  (  int  i  =  0  ;  i  <  p1  .  length  ;  i++  )  {  final  int  dp  =  p1[i]  -  p2[i]  ;  sum  +  =  dp  *  dp  ;  }  return  Math  .  sqrt  (  sum  )  ;  }  	Math_79_MathUtils_1_1	1624	1	src/main/java/org/apache/commons/math/util/MathUtils.java
2141	final  double  dp  =  p1[i]  -  p2[i];  	[BUGGY]   final  int  dp  =  p1[i]  -  p2[i]  ;  [FE]  NullPointerException  assertTrue  (  clusters  .  get  (  0  )  .  getPoints  (  )  .  contains  (  pt2  )  )  ;  [METHOD]  distance  [TYPE]  double  [PARAMETER]  int[]  p1  int[]  p2  [CLASS]  MathUtils  [TYPE]  boolean  false  true  [TYPE]  long[]  FACTORIALS  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  short  NS  PS  ZS  [TYPE]  int[]  p1  p2  [TYPE]  int  NAN_GAP  dp  i  sum  [TYPE]  long  SGN_MASK  [CONTEXT]  public  static  double  distance  (  int[]  p1  ,  int[]  p2  )  {  [BUGGY]  int  sum  =  0  ;  for  (  int  i  =  0  ;  i  <  p1  .  length  ;  i++  )  {  final  int  dp  =  p1[i]  -  p2[i]  ;  sum  +  =  dp  *  dp  ;  }  return  Math  .  sqrt  (  sum  )  ;  }  	Math_79_MathUtils_1_1	1626	1	src/main/java/org/apache/commons/math/util/MathUtils.java
221	int  j  =  4  *  (n  -  1);  	[BUGGY]  int  j  =  4  *  n  -  1  ;  [FE]  AssertionFailedError:  expected:<16828208208485466>  but  was:<2065474511575945>  assertEquals  (  0  ,  refEigenVectors[i]  .  subtract  (  decomposition  .  getEigenvector  (  i  )  )  .  getNorm  (  )  ,  1  .  0e-5  )  ;  [METHOD]  flipIfWarranted  [TYPE]  boolean  [PARAMETER]  final  int  n  final  int  step  [CLASS]  EigenDecompositionImpl  [TYPE]  boolean  false  true  [TYPE]  double[]  imagEigenvalues  main  realEigenvalues  secondary  squaredSecondary  work  [TYPE]  ArrayRealVector[]  eigenvectors  [TYPE]  RealMatrix  cachedD  cachedV  cachedVt  [TYPE]  double  TOLERANCE  TOLERANCE_2  dMin  dMin1  dMin2  dN  dN1  dN2  eMin  g  lowerSpectra  minPivot  qMax  sigma  sigmaLow  splitTolerance  tau  tmp  upperSpectra  [TYPE]  int  i  j  k  n  pingPong  step  tType  [TYPE]  TriDiagonalTransformer  transformer  [CONTEXT]  private  boolean  flipIfWarranted  (  final  int  n  ,  final  int  step  )  {  if  (  1  .  5  *  work[pingPong]  <  work[4  *  (  n  -  1  )  +  pingPong]  )  {  [BUGGY]  int  j  =  4  *  n  -  1  ;  for  (  int  i  =  0  ;  i  <  j  ;  i  +  =  4  )  {  for  (  int  k  =  0  ;  k  <  4  ;  k  +  =  step  )  {  final  double  tmp  =  work[i  +  k]  ;  work[i  +  k]  =  work[j  -  k]  ;  work[j  -  k]  =  tmp  ;  }  j  -  =  4  ;  }  return  true  ;  }  return  false  ;  }  	Math_80_EigenDecompositionImpl_1_1	1135	1	src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
222	upperSpectra  =  Math.max(upperSpectra,  upper);  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  -1  assertEquals  (  0  ,  refEigenVectors[i]  .  subtract  (  decomposition  .  getEigenvector  (  i  )  )  .  getNorm  (  )  ,  2  .  0e-7  )  ;  [METHOD]  computeGershgorinCircles  [TYPE]  void  [PARAMETER]  [CLASS]  EigenDecompositionImpl  [TYPE]  boolean  false  true  [TYPE]  double[]  imagEigenvalues  main  realEigenvalues  secondary  squaredSecondary  work  [TYPE]  ArrayRealVector[]  eigenvectors  [TYPE]  RealMatrix  cachedD  cachedV  cachedVt  [TYPE]  double  TOLERANCE  TOLERANCE_2  dCurrent  dMin  dMin1  dMin2  dN  dN1  dN2  eCurrent  eMax  eMin  ePrevious  g  lower  lowerSpectra  minPivot  qMax  radius  sigma  sigmaLow  splitTolerance  tau  upper  upperSpectra  [TYPE]  int  i  lowerStart  m  pingPong  tType  upperStart  [TYPE]  TriDiagonalTransformer  transformer  [CONTEXT]  double  eCurrent  =  0  ;  for  (  int  i  =  0  ;  i  <  m  -  1  ;  ++i  )  {  final  double  dCurrent  =  main[i]  ;  final  double  ePrevious  =  eCurrent  ;  eCurrent  =  Math  .  abs  (  secondary[i]  )  ;  eMax  =  Math  .  max  (  eMax  ,  eCurrent  )  ;  final  double  radius  =  ePrevious  +  eCurrent  ;  final  double  lower  =  dCurrent  -  radius  ;  work[lowerStart  +  i]  =  lower  ;  lowerSpectra  =  Math  .  min  (  lowerSpectra  ,  lower  )  ;  final  double  upper  =  dCurrent  +  radius  ;  work[upperStart  +  i]  =  upper  ;  upperSpectra  =  Math  .  max  (  upperSpectra  ,  upper  )  ;  }  final  double  dCurrent  =  main[m  -  1]  ;  final  double  lower  =  dCurrent  -  eCurrent  ;  work[lowerStart  +  m  -  1]  =  lower  ;  lowerSpectra  =  Math  .  min  (  lowerSpectra  ,  lower  )  ;  final  double  upper  =  dCurrent  +  eCurrent  ;  work[upperStart  +  m  -  1]  =  upper  ;  [BUGGY]  minPivot  =  MathUtils  .  SAFE_MIN  *  Math  .  max  (  1  .  0  ,  eMax  *  eMax  )  ;  }  	Math_81_EigenDecompositionImpl_3_1	603	0	src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
223	for  (int  i  =  4  *  i0;  i  <  4  *  n0  -  16;  i  +=  4)  {  if  ((work[i  +  3]  <=  TOLERANCE_2  *  work[i])  ||  	[BUGGY]  for  (  int  i  =  4  *  i0  ;  i  <  4  *  n0  -  11  ;  i  +  =  4  )  {  if  (  (  work[i  +  3]  <  =  TOLERANCE_2  *  work[i]  )  &&  [FE]  ArrayIndexOutOfBoundsException:  -1  assertEquals  (  0  ,  refEigenVectors[i]  .  subtract  (  decomposition  .  getEigenvector  (  i  )  )  .  getNorm  (  )  ,  2  .  0e-7  )  ;  [METHOD]  processGeneralBlock  [TYPE]  void  [PARAMETER]  final  int  n  [CLASS]  EigenDecompositionImpl  [TYPE]  boolean  false  true  [TYPE]  double[]  imagEigenvalues  main  realEigenvalues  secondary  squaredSecondary  work  [TYPE]  ArrayRealVector[]  eigenvectors  [TYPE]  RealMatrix  cachedD  cachedV  cachedVt  [TYPE]  double  TOLERANCE  TOLERANCE_2  dMin  dMin1  dMin2  dN  dN1  dN2  diagMax  diagMin  eMin  ei  g  lowerSpectra  minPivot  offDiagMax  offDiagMin  previousEMin  qMax  sigma  sigmaLow  splitTolerance  sumOffDiag  tau  upperSpectra  [TYPE]  int  fourI  i  i0  k  maxIter  n  n0  pingPong  split  tType  [TYPE]  TriDiagonalTransformer  transformer  [CONTEXT]  work[4  *  n0  -  2]  =  offDiagMin  ;  dMin  =  -Math  .  max  (  0  ,  diagMin  -  2  *  Math  .  sqrt  (  diagMin  *  offDiagMax  )  )  ;  pingPong  =  0  ;  int  maxIter  =  30  *  (  n0  -  i0  )  ;  for  (  int  k  =  0  ;  i0  <  n0  ;  ++k  )  {  if  (  k  >  =  maxIter  )  {  throw  new  InvalidMatrixException  (  new  MaxIterationsExceededException  (  maxIter  )  )  ;  }  n0  =  goodStep  (  i0  ,  n0  )  ;  pingPong  =  1  -  pingPong  ;  if  (  (  pingPong  =  =  0  )  &&  (  n0  -  i0  >  3  )  &&  (  work[4  *  n0  -  1]  <  =  TOLERANCE_2  *  diagMax  )  &&  (  work[4  *  n0  -  2]  <  =  TOLERANCE_2  *  sigma  )  )  {  int  split  =  i0  -  1  ;  diagMax  =  work[4  *  i0]  ;  offDiagMin  =  work[4  *  i0  +  2]  ;  double  previousEMin  =  work[4  *  i0  +  3]  ;  [BUGGY]  for  (  int  i  =  4  *  i0  ;  i  <  4  *  n0  -  11  ;  i  +  =  4  )  {  if  (  (  work[i  +  3]  <  =  TOLERANCE_2  *  work[i]  )  &&  (  work[i  +  2]  <  =  TOLERANCE_2  *  sigma  )  )  {  work[i  +  2]  =  -sigma  ;  split  =  i  /  4  ;  	Math_81_EigenDecompositionImpl_3_2	905	2	src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
224	if  (end  -  start  >  3)  {  	[BUGGY]  if  (  end  -  start  >  2  )  {  [FE]  ArrayIndexOutOfBoundsException:  -1  assertEquals  (  0  ,  refEigenVectors[i]  .  subtract  (  decomposition  .  getEigenvector  (  i  )  )  .  getNorm  (  )  ,  2  .  0e-7  )  ;  [METHOD]  computeShiftIncrement  [TYPE]  void  [PARAMETER]  final  int  start  final  int  end  final  int  deflated  [CLASS]  EigenDecompositionImpl  [TYPE]  boolean  false  true  [TYPE]  double[]  imagEigenvalues  main  realEigenvalues  secondary  squaredSecondary  work  [TYPE]  ArrayRealVector[]  eigenvectors  [TYPE]  RealMatrix  cachedD  cachedV  cachedVt  [TYPE]  double  TOLERANCE  TOLERANCE_2  a2  b1  b2  cnst1  cnst2  cnst3  dMin  dMin1  dMin2  dN  dN1  dN2  eMin  g  gam  gap1  gap2  lowerSpectra  minPivot  oldB1  qMax  s  sigma  sigmaLow  splitTolerance  tau  upperSpectra  [TYPE]  int  deflated  end  i4  nn  np  pingPong  start  tType  [TYPE]  TriDiagonalTransformer  transformer  [CONTEXT]  if  (  a2  <  cnst1  )  {  s  =  gam  *  (  1  -  Math  .  sqrt  (  a2  )  )  /  (  1  +  a2  )  ;  }  tau  =  s  ;  }  }  else  if  (  dMin  =  =  dN2  )  {  tType  =  -5  ;  double  s  =  0  .  25  *  dMin  ;  final  int  np  =  nn  -  2  *  pingPong  ;  double  b1  =  work[np  -  2]  ;  double  b2  =  work[np  -  6]  ;  final  double  gam  =  dN2  ;  if  (  work[np  -  8]  >  b2  ||  work[np  -  4]  >  b1  )  {  return  ;  }  double  a2  =  (  work[np  -  8]  /  b2  )  *  (  1  +  work[np  -  4]  /  b1  )  ;  [BUGGY]  if  (  end  -  start  >  2  )  {  b2  =  work[nn  -  13]  /  work[nn  -  15]  ;  a2  =  a2  +  b2  ;  for  (  int  i4  =  nn  -  17  ;  i4  >  =  4  *  start  +  2  +  pingPong  ;  i4  -  =  4  )  {  if  (  b2  =  =  0  .  0  )  {  break  ;  	Math_81_EigenDecompositionImpl_3_3	1543	1	src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java
225	if  (MathUtils.compareTo(entry,  0,  epsilon)  >  0)  {  	[BUGGY]  if  (  MathUtils  .  compareTo  (  entry  ,  0  ,  epsilon  )  >  =  0  )  {  [FE]  AssertionFailedError:  expected:<100>  but  was:<115>  assertEquals  (  10  .  0  ,  solution  .  getValue  (  )  ,  .  0000001  )  ;  [METHOD]  getPivotRow  [TYPE]  Integer  [PARAMETER]  final  int  col  SimplexTableau  tableau  [CLASS]  SimplexSolver  [TYPE]  Integer  minRatioPos  [TYPE]  boolean  false  true  [TYPE]  SimplexTableau  tableau  [TYPE]  double  DEFAULT_EPSILON  entry  epsilon  minRatio  ratio  rhs  [TYPE]  int  col  i  [CONTEXT]  private  Integer  getPivotRow  (  final  int  col  ,  final  SimplexTableau  tableau  )  {  double  minRatio  =  Double  .  MAX_VALUE  ;  Integer  minRatioPos  =  null  ;  for  (  int  i  =  tableau  .  getNumObjectiveFunctions  (  )  ;  i  <  tableau  .  getHeight  (  )  ;  i++  )  {  final  double  rhs  =  tableau  .  getEntry  (  i  ,  tableau  .  getWidth  (  )  -  1  )  ;  final  double  entry  =  tableau  .  getEntry  (  i  ,  col  )  ;  [BUGGY]  if  (  MathUtils  .  compareTo  (  entry  ,  0  ,  epsilon  )  >  =  0  )  {  final  double  ratio  =  rhs  /  entry  ;  if  (  ratio  <  minRatio  )  {  minRatio  =  ratio  ;  minRatioPos  =  i  ;  }  }  }  return  minRatioPos  ;  }  	Math_82_SimplexSolver_1_1	82	1	src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java
226	int  start  =  ignoreObjectiveRows  ?  getNumObjectiveFunctions()  :  0;  	[BUGGY]  int  start  =  getNumObjectiveFunctions  (  )  ;  [FE]  AssertionFailedError:  expected:<69>  but  was:<46000000000000005>  assertEquals  (  6  .  9  ,  solution  .  getValue  (  )  ,  .  0000001  )  ;  [METHOD]  getBasicRow  [TYPE]  Integer  [PARAMETER]  final  int  col  boolean  ignoreObjectiveRows  [CLASS]  SimplexTableau  [TYPE]  Integer  row  [TYPE]  boolean  false  ignoreObjectiveRows  restrictToNonNegative  true  [TYPE]  RealMatrix  tableau  [TYPE]  double  epsilon  [TYPE]  LinearObjectiveFunction  f  [TYPE]  Collection  constraints  [TYPE]  long  serialVersionUID  [TYPE]  int  col  i  numArtificialVariables  numDecisionVariables  numSlackVariables  start  [CONTEXT]  private  Integer  getBasicRow  (  final  int  col  ,  boolean  ignoreObjectiveRows  )  {  Integer  row  =  null  ;  [BUGGY]  int  start  =  getNumObjectiveFunctions  (  )  ;  for  (  int  i  =  start  ;  i  <  getHeight  (  )  ;  i++  )  {  if  (  MathUtils  .  equals  (  getEntry  (  i  ,  col  )  ,  1  .  0  ,  epsilon  )  &&  (  row  =  =  null  )  )  {  row  =  i  ;  }  else  if  (  !MathUtils  .  equals  (  getEntry  (  i  ,  col  )  ,  0  .  0  ,  epsilon  )  )  {  return  null  ;  }  }  return  row  ;  }  	Math_83_SimplexTableau_3_1	292	1	src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
227	Integer  negativeVarBasicRow  =  getBasicRowForSolution(getNegativeDecisionVariableOffset());  	[BUGGY]  Integer  negativeVarBasicRow  =  getBasicRow  (  getNegativeDecisionVariableOffset  (  )  )  ;  [FE]  AssertionFailedError:  expected:<69>  but  was:<46000000000000005>  assertEquals  (  6  .  9  ,  solution  .  getValue  (  )  ,  .  0000001  )  ;  [METHOD]  getSolution  [TYPE]  RealPointValuePair  [PARAMETER]  [CLASS]  SimplexTableau  [TYPE]  Integer  basicRow  negativeVarBasicRow  [TYPE]  boolean  false  restrictToNonNegative  true  [TYPE]  Set  basicRows  [TYPE]  RealMatrix  tableau  [TYPE]  double[]  coefficients  [TYPE]  double  epsilon  mostNegative  [TYPE]  LinearObjectiveFunction  f  [TYPE]  Collection  constraints  [TYPE]  long  serialVersionUID  [TYPE]  int  i  numArtificialVariables  numDecisionVariables  numSlackVariables  [CONTEXT]  protected  RealPointValuePair  getSolution  (  )  {  double[]  coefficients  =  new  double[getOriginalNumDecisionVariables  (  )  ]  ;  [BUGGY]  Integer  negativeVarBasicRow  =  getBasicRow  (  getNegativeDecisionVariableOffset  (  )  )  ;  double  mostNegative  =  negativeVarBasicRow  =  =  null  ?  0  :  getEntry  (  negativeVarBasicRow  ,  getRhsOffset  (  )  )  ;  Set<Integer>  basicRows  =  new  HashSet<Integer>  (  )  ;  for  (  int  i  =  0  ;  i  <  coefficients  .  length  ;  i++  )  {  Integer  basicRow  =  getBasicRow  (  getNumObjectiveFunctions  (  )  +  i  )  ;  if  (  basicRows  .  contains  (  basicRow  )  )  {  coefficients[i]  =  0  ;  }  else  {  basicRows  .  add  (  basicRow  )  ;  coefficients[i]  =  (  basicRow  =  =  null  ?  0  :  getEntry  (  basicRow  ,  getRhsOffset  (  )  )  )  -  (  restrictToNonNegative  ?  0  :  mostNegative  )  ;  }  }  return  new  RealPointValuePair  (  coefficients  ,  f  .  getValue  (  coefficients  )  )  ;  }  	Math_83_SimplexTableau_3_2	341	1	src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
228	Integer  basicRow  =  getBasicRowForSolution(getNumObjectiveFunctions()  +  i);  	[BUGGY]  Integer  basicRow  =  getBasicRow  (  getNumObjectiveFunctions  (  )  +  i  )  ;  [FE]  AssertionFailedError:  expected:<69>  but  was:<46000000000000005>  assertEquals  (  6  .  9  ,  solution  .  getValue  (  )  ,  .  0000001  )  ;  [METHOD]  getSolution  [TYPE]  RealPointValuePair  [PARAMETER]  [CLASS]  SimplexTableau  [TYPE]  Integer  basicRow  negativeVarBasicRow  [TYPE]  boolean  false  restrictToNonNegative  true  [TYPE]  Set  basicRows  [TYPE]  RealMatrix  tableau  [TYPE]  double[]  coefficients  [TYPE]  double  epsilon  mostNegative  [TYPE]  LinearObjectiveFunction  f  [TYPE]  Collection  constraints  [TYPE]  long  serialVersionUID  [TYPE]  int  i  numArtificialVariables  numDecisionVariables  numSlackVariables  [CONTEXT]  protected  RealPointValuePair  getSolution  (  )  {  double[]  coefficients  =  new  double[getOriginalNumDecisionVariables  (  )  ]  ;  Integer  negativeVarBasicRow  =  getBasicRow  (  getNegativeDecisionVariableOffset  (  )  )  ;  double  mostNegative  =  negativeVarBasicRow  =  =  null  ?  0  :  getEntry  (  negativeVarBasicRow  ,  getRhsOffset  (  )  )  ;  Set<Integer>  basicRows  =  new  HashSet<Integer>  (  )  ;  for  (  int  i  =  0  ;  i  <  coefficients  .  length  ;  i++  )  {  [BUGGY]  Integer  basicRow  =  getBasicRow  (  getNumObjectiveFunctions  (  )  +  i  )  ;  if  (  basicRows  .  contains  (  basicRow  )  )  {  coefficients[i]  =  0  ;  }  else  {  basicRows  .  add  (  basicRow  )  ;  coefficients[i]  =  (  basicRow  =  =  null  ?  0  :  getEntry  (  basicRow  ,  getRhsOffset  (  )  )  )  -  (  restrictToNonNegative  ?  0  :  mostNegative  )  ;  }  }  return  new  RealPointValuePair  (  coefficients  ,  f  .  getValue  (  coefficients  )  )  ;  }  	Math_83_SimplexTableau_3_3	345	1	src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
229	final  RealConvergenceChecker  checker  =  getConvergenceChecker();  	[BUGGY]  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getEvaluations  (  )  <  220  )  ;  [METHOD]  iterateSimplex  [TYPE]  void  [PARAMETER]  RealPointValuePair>  comparator  [CLASS]  MultiDirectional  [TYPE]  RealPointValuePair  best  contracted  expanded  reflected  [TYPE]  boolean  false  true  [TYPE]  double  gamma  khi  [TYPE]  RealPointValuePair[]  original  reflectedSimplex  [TYPE]  Comparator  comparator  [CONTEXT]  protected  void  iterateSimplex  (  final  Comparator<RealPointValuePair>  comparator  )  throws  FunctionEvaluationException  ,  OptimizationException  ,  IllegalArgumentException  {  [BUGGY]  while  (  true  )  {  incrementIterationsCounter  (  )  ;  final  RealPointValuePair[]  original  =  simplex  ;  	Math_84_MultiDirectional_2_1	64	0	src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java
230	return;  }  final  int  iter  =  getIterations();  boolean  converged  =  true;  for  (int  i  =  0;  i  <  simplex.length;  ++i)  {  converged  &=  checker.converged(iter,  original[i],  simplex[i]);  }  if  (converged)  {  	[BUGGY]  [FE]  AssertionFailedError  Assert  .  assertTrue  (  optimizer  .  getEvaluations  (  )  <  220  )  ;  [METHOD]  iterateSimplex  [TYPE]  void  [PARAMETER]  RealPointValuePair>  comparator  [CLASS]  MultiDirectional  [TYPE]  RealPointValuePair  best  contracted  expanded  reflected  [TYPE]  boolean  false  true  [TYPE]  double  gamma  khi  [TYPE]  RealPointValuePair[]  original  reflectedSimplex  [TYPE]  Comparator  comparator  [CONTEXT]  final  RealPointValuePair[]  original  =  simplex  ;  final  RealPointValuePair  best  =  original[0]  ;  final  RealPointValuePair  reflected  =  evaluateNewSimplex  (  original  ,  1  .  0  ,  comparator  )  ;  if  (  comparator  .  compare  (  reflected  ,  best  )  <  0  )  {  final  RealPointValuePair[]  reflectedSimplex  =  simplex  ;  final  RealPointValuePair  expanded  =  evaluateNewSimplex  (  original  ,  khi  ,  comparator  )  ;  if  (  comparator  .  compare  (  reflected  ,  expanded  )  <  =  0  )  {  simplex  =  reflectedSimplex  ;  }  return  ;  }  final  RealPointValuePair  contracted  =  evaluateNewSimplex  (  original  ,  gamma  ,  comparator  )  ;  if  (  comparator  .  compare  (  contracted  ,  best  )  <  0  )  {  [BUGGY]  return  ;  }  }  	Math_84_MultiDirectional_2_2	92	0	src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java
231	if  (fa  *  fb  >  0.0  )  {  	[BUGGY]  if  (  fa  *  fb  >  =  0  .  0  )  {  [FE]  MathException:  ConvergenceException:  number  of  iterations  =  1  ,  maximum  iterations  =  2  assertEquals  (  2  .  0  ,  result  ,  1  .  0e-12  )  ;  [METHOD]  bracket  [TYPE]  double[]  [PARAMETER]  UnivariateRealFunction  function  double  initial  double  lowerBound  double  upperBound  int  maximumIterations  [CLASS]  UnivariateRealSolverUtils  [TYPE]  UnivariateRealSolverFactory  FACTORY  [TYPE]  UnivariateRealFunction  function  [TYPE]  boolean  false  true  [TYPE]  double  a  b  fa  fb  initial  lowerBound  upperBound  [TYPE]  int  maximumIterations  numIterations  [CONTEXT]  if  (  maximumIterations  <  =  0  )  {  throw  MathRuntimeException  .  createIllegalArgumentException  ( "bad  value  for  maximum  iterations  number:  {0} "  ,  maximumIterations  )  ;  }  if  (  initial  <  lowerBound  ||  initial  >  upperBound  ||  lowerBound  >  =  upperBound  )  {  throw  MathRuntimeException  .  createIllegalArgumentException  ( "invalid  bracketing  parameters:lower  bound  =  {0}  ,  initial  =  {1}  ,  upper  bound  =  {2} "  ,  lowerBound  ,  initial  ,  upperBound  )  ;  }  double  a  =  initial  ;  double  b  =  initial  ;  double  fa  ;  double  fb  ;  int  numIterations  =  0  ;  do  {  a  =  Math  .  max  (  a  -  1  .  0  ,  lowerBound  )  ;  b  =  Math  .  min  (  b  +  1  .  0  ,  upperBound  )  ;  fa  =  function  .  value  (  a  )  ;  fb  =  function  .  value  (  b  )  ;  numIterations++  ;  }  while  (  (  fa  *  fb  >  0  .  0  )  &&  (  numIterations  <  maximumIterations  )  &&  (  (  a  >  lowerBound  )  ||  (  b  <  upperBound  )  )  )  ;  [BUGGY]  if  (  fa  *  fb  >  =  0  .  0  )  {  throw  new  ConvergenceException  ( "number  of  iterations  =  {0}  ,  maximum  iterations  =  {1}  , "  + "initial  =  {2}  ,  lower  bound  =  {3}  ,  upper  bound  =  {4}  ,  final  a  value  =  {5}  , "  + "final  b  value  =  {6}  ,  f  (  a  )  =  {7}  ,  f  (  b  )  =  {8} "  ,  numIterations  ,  maximumIterations  ,  initial  ,  	Math_85_UnivariateRealSolverUtils_1_1	198	1	src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java
232		[BUGGY]  if  (  lTData[i][i]  <  absolutePositivityThreshold  )  {  throw  new  NotPositiveDefiniteMatrixException  (  )  ;  }  [FE]  AssertionFailedError:  Expected  exception:  orgapachecommonsmathlinearNotPositiveDefiniteMatrixException  [CLASS]  [CONTEXT]  	Math_86_CholeskyDecompositionImpl_2_1	114	3	src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java
233	if  (ltI[i]  <  absolutePositivityThreshold)  {  throw  new  NotPositiveDefiniteMatrixException();  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exception:  orgapachecommonsmathlinearNotPositiveDefiniteMatrixException  [CLASS]  [CONTEXT]  	Math_86_CholeskyDecompositionImpl_2_2	137	0	src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java
234	if  (MathUtils.equals(getEntry(i,  col),  1.0,  epsilon)  &&  (row  ==  null))  {  }  else  if  (!MathUtils.equals(getEntry(i,  col),  0.0,  epsilon))  {  	[BUGGY]  if  (  !MathUtils  .  equals  (  getEntry  (  i  ,  col  )  ,  0  .  0  ,  epsilon  )  )  {  if  (  row  =  =  null  )  {  }  else  {  }  [FE]  AssertionFailedError:  expected:<100>  but  was:<00>  assertEquals  (  30  .  0  ,  solution  .  getValue  (  )  ,  0  .  0  )  ;  [METHOD]  getBasicRow  [TYPE]  Integer  [PARAMETER]  final  int  col  [CLASS]  SimplexTableau  [TYPE]  Integer  row  [TYPE]  boolean  false  restrictToNonNegative  true  [TYPE]  RealMatrix  tableau  [TYPE]  double  epsilon  [TYPE]  LinearObjectiveFunction  f  [TYPE]  Collection  constraints  [TYPE]  long  serialVersionUID  [TYPE]  int  col  i  numArtificialVariables  numDecisionVariables  numSlackVariables  [CONTEXT]  private  Integer  getBasicRow  (  final  int  col  )  {  Integer  row  =  null  ;  for  (  int  i  =  getNumObjectiveFunctions  (  )  ;  i  <  getHeight  (  )  ;  i++  )  {  [BUGGY]  if  (  !MathUtils  .  equals  (  getEntry  (  i  ,  col  )  ,  0  .  0  ,  epsilon  )  )  {  if  (  row  =  =  null  )  {  row  =  i  ;  }  else  {  return  null  ;  }  }  }  return  row  ;  }  	Math_87_SimplexTableau_1_1	275	4	src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
235	Set<Integer>  basicRows  =  new  HashSet<Integer>();  if  (basicRows.contains(basicRow))  {  coefficients[i]  =  0;  }  else  {  basicRows.add(basicRow);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<10>  but  was:<00>  assertEquals  (  3  .  0  ,  solution  .  getValue  (  )  ,  .  0000001  )  ;  [METHOD]  getSolution  [TYPE]  RealPointValuePair  [PARAMETER]  [CLASS]  SimplexTableau  [TYPE]  Integer  basicRow  [TYPE]  boolean  false  restrictToNonNegative  true  [TYPE]  RealMatrix  tableau  [TYPE]  double[]  coefficients  [TYPE]  double  epsilon  mostNegative  [TYPE]  LinearObjectiveFunction  f  [TYPE]  Collection  constraints  [TYPE]  long  serialVersionUID  [TYPE]  int  i  j  numArtificialVariables  numDecisionVariables  numSlackVariables  [CONTEXT]  protected  RealPointValuePair  getSolution  (  )  {  double[]  coefficients  =  new  double[getOriginalNumDecisionVariables  (  )  ]  ;  Integer  basicRow  =  getBasicRow  (  getNumObjectiveFunctions  (  )  +  getOriginalNumDecisionVariables  (  )  )  ;  double  mostNegative  =  basicRow  =  =  null  ?  0  :  getEntry  (  basicRow  ,  getRhsOffset  (  )  )  ;  [BUGGY]  for  (  int  i  =  0  ;  i  <  coefficients  .  length  ;  i++  )  {  basicRow  =  getBasicRow  (  getNumObjectiveFunctions  (  )  +  i  )  ;  coefficients[i]  =  (  basicRow  =  =  null  ?  0  :  getEntry  (  basicRow  ,  getRhsOffset  (  )  )  )  -  (  restrictToNonNegative  ?  0  :  mostNegative  )  ;  if  (  basicRow  !  =  null  )  {  for  (  int  j  =  getNumObjectiveFunctions  (  )  ;  j  <  getNumObjectiveFunctions  (  )  +  i  ;  j++  )  {  if  (  tableau  .  getEntry  (  basicRow  ,  j  )  =  =  1  )  {  coefficients[i]  =  0  ;  }  }  }  }  return  new  RealPointValuePair  (  coefficients  ,  f  .  getValue  (  coefficients  )  )  ;  }  	Math_88_SimplexTableau_2_1	329	0	src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
236		[BUGGY]  if  (  basicRow  !  =  null  )  {  for  (  int  j  =  getNumObjectiveFunctions  (  )  ;  j  <  getNumObjectiveFunctions  (  )  +  i  ;  j++  )  {  if  (  tableau  .  getEntry  (  basicRow  ,  j  )  =  =  1  )  {  coefficients[i]  =  0  ;  }  }  [FE]  AssertionFailedError:  expected:<10>  but  was:<00>  assertEquals  (  3  .  0  ,  solution  .  getValue  (  )  ,  .  0000001  )  ;  [METHOD]  getSolution  [TYPE]  RealPointValuePair  [PARAMETER]  [CLASS]  SimplexTableau  [TYPE]  Integer  basicRow  [TYPE]  boolean  false  restrictToNonNegative  true  [TYPE]  RealMatrix  tableau  [TYPE]  double[]  coefficients  [TYPE]  double  epsilon  mostNegative  [TYPE]  LinearObjectiveFunction  f  [TYPE]  Collection  constraints  [TYPE]  long  serialVersionUID  [TYPE]  int  i  j  numArtificialVariables  numDecisionVariables  numSlackVariables  [CONTEXT]  protected  RealPointValuePair  getSolution  (  )  {  double[]  coefficients  =  new  double[getOriginalNumDecisionVariables  (  )  ]  ;  Integer  basicRow  =  getBasicRow  (  getNumObjectiveFunctions  (  )  +  getOriginalNumDecisionVariables  (  )  )  ;  double  mostNegative  =  basicRow  =  =  null  ?  0  :  getEntry  (  basicRow  ,  getRhsOffset  (  )  )  ;  for  (  int  i  =  0  ;  i  <  coefficients  .  length  ;  i++  )  {  basicRow  =  getBasicRow  (  getNumObjectiveFunctions  (  )  +  i  )  ;  coefficients[i]  =  (  basicRow  =  =  null  ?  0  :  getEntry  (  basicRow  ,  getRhsOffset  (  )  )  )  -  (  restrictToNonNegative  ?  0  :  mostNegative  )  ;  [BUGGY]  if  (  basicRow  !  =  null  )  {  for  (  int  j  =  getNumObjectiveFunctions  (  )  ;  j  <  getNumObjectiveFunctions  (  )  +  i  ;  j++  )  {  if  (  tableau  .  getEntry  (  basicRow  ,  j  )  =  =  1  )  {  coefficients[i]  =  0  ;  }  }  }  }  return  new  RealPointValuePair  (  coefficients  ,  f  .  getValue  (  coefficients  )  )  ;  }  	Math_88_SimplexTableau_2_2	336	6	src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java
237	if  (v  instanceof  Comparable<?>){  }  else  {  throw  new  IllegalArgumentException( "Object  must  implement  Comparable ");  }  	[BUGGY]  [FE]  ClassCastException:  javalangObject  cannot  be  cast  to  javalangComparable  [METHOD]  addValue  [TYPE]  void  [PARAMETER]  Object  v  [CLASS]  Frequency  [TYPE]  Object  v  [TYPE]  boolean  false  true  [TYPE]  TreeMap  freqTable  [TYPE]  long  serialVersionUID  [CONTEXT]  public  void  addValue  (  Object  v  )  {  [BUGGY]  addValue  (  (  Comparable<?>  )  v  )  ;  }  	Math_89_Frequency_1_1	110	0	src/java/org/apache/commons/math/stat/Frequency.java
238	addValue((Comparable<?>)  v);  }  	[BUGGY]  [FE]  IllegalArgumentException:  Value  not  comparable  to  existing  values  [METHOD]  addValue  [TYPE]  void  [PARAMETER]  Object  v  [CLASS]  Frequency  [TYPE]  Long  count  [TYPE]  Object  obj  v  [TYPE]  boolean  false  true  [TYPE]  TreeMap  freqTable  [TYPE]  long  serialVersionUID  [TYPE]  ClassCastException  ex  [CONTEXT]  public  void  addValue  (  Object  v  )  {  [BUGGY]  Object  obj  =  v  ;  if  (  v  instanceof  Integer  )  {  obj  =  Long  .  valueOf  (  (  (  Integer  )  v  )  .  longValue  (  )  )  ;  }  try  {  Long  count  =  (  Long  )  freqTable  .  get  (  obj  )  ;  if  (  count  =  =  null  )  {  freqTable  .  put  (  obj  ,  Long  .  valueOf  (  1  )  )  ;  }  else  {  freqTable  .  put  (  obj  ,  Long  .  valueOf  (  count  .  longValue  (  )  +  1  )  )  ;  }  }  catch  (  ClassCastException  ex  )  {  throw  new  IllegalArgumentException  ( "Value  not  comparable  to  existing  values  . "  )  ;  }  }  	Math_90_Frequency_2_1	110	0	src/java/org/apache/commons/math/stat/Frequency.java
239	public  void  addValue(Comparable<?>v){  	[BUGGY]  [FE]  IllegalArgumentException:  Value  not  comparable  to  existing  values  [METHOD]  addValue  [TYPE]  void  [PARAMETER]  Object  v  [CLASS]  Frequency  [TYPE]  Long  count  [TYPE]  Object  obj  v  [TYPE]  boolean  false  true  [TYPE]  TreeMap  freqTable  [TYPE]  long  serialVersionUID  [TYPE]  ClassCastException  ex  [CONTEXT]  public  void  addValue  (  Object  v  )  {  [BUGGY]  Object  obj  =  v  ;  if  (  v  instanceof  Integer  )  {  obj  =  Long  .  valueOf  (  (  (  Integer  )  v  )  .  longValue  (  )  )  ;  }  try  {  Long  count  =  (  Long  )  freqTable  .  get  (  obj  )  ;  if  (  count  =  =  null  )  {  freqTable  .  put  (  obj  ,  Long  .  valueOf  (  1  )  )  ;  }  else  {  freqTable  .  put  (  obj  ,  Long  .  valueOf  (  count  .  longValue  (  )  +  1  )  )  ;  }  }  catch  (  ClassCastException  ex  )  {  throw  new  IllegalArgumentException  ( "Value  not  comparable  to  existing  values  . "  )  ;  }  }  	Math_90_Frequency_2_2	121	0	src/java/org/apache/commons/math/stat/Frequency.java
240	long  nOd  =  ((long)  numerator)  *  object.denominator;  long  dOn  =  ((long)  denominator)  *  object.numerator;  	[BUGGY]  double  nOd  =  doubleValue  (  )  ;  double  dOn  =  object  .  doubleValue  (  )  ;  [FE]  AssertionFailedError:  expected:<-1>  but  was:<0>  assertEquals  (  0  .  0  ,  pi1  .  doubleValue  (  )  -  pi2  .  doubleValue  (  )  ,  1  .  0e-20  )  ;  [METHOD]  compareTo  [TYPE]  int  [PARAMETER]  Fraction  object  [CLASS]  Fraction  [TYPE]  Fraction  MINUS_ONE  ONE  TWO  ZERO  object  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  denominator  numerator  [TYPE]  double  dOn  nOd  [CONTEXT]  public  int  compareTo  (  Fraction  object  )  {  [BUGGY]  double  nOd  =  doubleValue  (  )  ;  double  dOn  =  object  .  doubleValue  (  )  ;  return  (  nOd  <  dOn  )  ?  -1  :  (  (  nOd  >  dOn  )  ?  +1  :  0  )  ;  }  	Math_91_Fraction_1_1	259	2	src/java/org/apache/commons/math/fraction/Fraction.java
241	if  (k  >  n  /  2)  return  binomialCoefficient(n,  n  -  k);  	[BUGGY]  long  result  =  Math  .  round  (  binomialCoefficientDouble  (  n  ,  k  )  )  ;  if  (  result  =  =  Long  .  MAX_VALUE  )  {  throw  new  ArithmeticException  ( "result  too  large  to  represent  in  a  long  integer "  )  ;  }  [FE]  AssertionFailedError:  48  ,  22  expected:<27385657281648>  but  was:<27385657281647>  assertEquals  (  exactResult  ,  ourResult  )  ;  [METHOD]  binomialCoefficient  [TYPE]  long  [PARAMETER]  final  int  n  final  int  k  [CLASS]  MathUtils  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  short  NS  PS  ZS  [TYPE]  int  k  n  [TYPE]  long  result  [CONTEXT]  public  static  long  binomialCoefficient  (  final  int  n  ,  final  int  k  )  {  if  (  n  <  k  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  =  k  for  binomial  coefficient  (  n  ,  k  ) "  )  ;  }  if  (  n  <  0  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  =  0  for  binomial  coefficient  (  n  ,  k  ) "  )  ;  }  if  (  (  n  =  =  k  )  ||  (  k  =  =  0  )  )  {  return  1  ;  }  if  (  (  k  =  =  1  )  ||  (  k  =  =  n  -  1  )  )  {  return  n  ;  }  [BUGGY]  long  result  =  Math  .  round  (  binomialCoefficientDouble  (  n  ,  k  )  )  ;  if  (  result  =  =  Long  .  MAX_VALUE  )  {  throw  new  ArithmeticException  ( "result  too  large  to  represent  in  a  long  integer "  )  ;  }  	Math_92_MathUtils_7_1	184	5	src/java/org/apache/commons/math/util/MathUtils.java
242	long  result  =  1;  if  (n  <=  61)  {  for  (int  j  =  1,  i  =  n  -  k  +  1;  j  <=  k;  i++,  j++)  {  result  =  result  *  i  /  j;  }  }  else  if  (n  <=  66)  {  for  (int  j  =  1,  i  =  n  -  k  +  1;  j  <=  k;  i++,  j++)  {  	[BUGGY]  [FE]  AssertionFailedError:  48  ,  22  expected:<27385657281648>  but  was:<27385657281647>  assertEquals  (  exactResult  ,  ourResult  )  ;  [METHOD]  binomialCoefficient  [TYPE]  long  [PARAMETER]  final  int  n  final  int  k  [CLASS]  MathUtils  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  short  NS  PS  ZS  [TYPE]  int  k  n  [TYPE]  long  result  [CONTEXT]  throw  new  IllegalArgumentException  ( "must  have  n  >  =  k  for  binomial  coefficient  (  n  ,  k  ) "  )  ;  }  if  (  n  <  0  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  =  0  for  binomial  coefficient  (  n  ,  k  ) "  )  ;  }  if  (  (  n  =  =  k  )  ||  (  k  =  =  0  )  )  {  return  1  ;  }  if  (  (  k  =  =  1  )  ||  (  k  =  =  n  -  1  )  )  {  return  n  ;  }  long  result  =  Math  .  round  (  binomialCoefficientDouble  (  n  ,  k  )  )  ;  if  (  result  =  =  Long  .  MAX_VALUE  )  {  throw  new  ArithmeticException  ( "result  too  large  to  represent  in  a  long  integer "  )  ;  }  [BUGGY]  	Math_92_MathUtils_7_2	196	0	src/java/org/apache/commons/math/util/MathUtils.java
243	long  d  =  gcd(i,  j);  result  =  (result  /  (j  /  d))  *  (i  /  d);  }  }  else  {  	[BUGGY]  [FE]  AssertionFailedError:  48  ,  22  expected:<27385657281648>  but  was:<27385657281647>  assertEquals  (  exactResult  ,  ourResult  )  ;  [METHOD]  binomialCoefficient  [TYPE]  long  [PARAMETER]  final  int  n  final  int  k  [CLASS]  MathUtils  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  short  NS  PS  ZS  [TYPE]  int  k  n  [TYPE]  long  result  [CONTEXT]  }  if  (  (  k  =  =  1  )  ||  (  k  =  =  n  -  1  )  )  {  return  n  ;  }  long  result  =  Math  .  round  (  binomialCoefficientDouble  (  n  ,  k  )  )  ;  if  (  result  =  =  Long  .  MAX_VALUE  )  {  throw  new  ArithmeticException  ( "result  too  large  to  represent  in  a  long  integer "  )  ;  }  [BUGGY]  return  result  ;  }  	Math_92_MathUtils_7_3	205	0	src/java/org/apache/commons/math/util/MathUtils.java
244	for  (int  j  =  1,  i  =  n  -  k  +  1;  j  <=  k;  i++,  j++)  {  long  d  =  gcd(i,  j);  result  =  mulAndCheck((result  /  (j  /  d)),  (i  /  d));  }  }  	[BUGGY]  [FE]  AssertionFailedError:  48  ,  22  expected:<27385657281648>  but  was:<27385657281647>  assertEquals  (  exactResult  ,  ourResult  )  ;  [METHOD]  binomialCoefficient  [TYPE]  long  [PARAMETER]  final  int  n  final  int  k  [CLASS]  MathUtils  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  short  NS  PS  ZS  [TYPE]  int  k  n  [TYPE]  long  result  [CONTEXT]  }  long  result  =  Math  .  round  (  binomialCoefficientDouble  (  n  ,  k  )  )  ;  if  (  result  =  =  Long  .  MAX_VALUE  )  {  throw  new  ArithmeticException  ( "result  too  large  to  represent  in  a  long  integer "  )  ;  }    [BUGGY]  return  result  ;  }  	Math_92_MathUtils_7_4	208	0	src/java/org/apache/commons/math/util/MathUtils.java
245	if  (n  <  k)  {  throw  new  IllegalArgumentException( "must  have  n  >=  k  for  binomial  coefficient  (n,k) ");  }  if  (n  <  0)  {  throw  new  IllegalArgumentException( "must  have  n  >=  0  for  binomial  coefficient  (n,k) ");  }  if  ((n  ==  k)  ||  (k  ==  0))  {  return  1d;  }  if  ((k  ==  1)  ||  (k  ==  n  -  1))  {  return  n;  }  if  (k  >  n/2)  {  return  binomialCoefficientDouble(n,  n  -  k);  }  if  (n  <  67)  {  return  binomialCoefficient(n,k);  }  double  result  =  1d;  for  (int  i  =  1;  i  <=  k;  i++)  {  result  *=  (double)(n  -  k  +  i)  /  (double)i;  }  return  Math.floor(result  +  0.5);  	[BUGGY]  return  Math  .  floor  (  Math  .  exp  (  binomialCoefficientLog  (  n  ,  k  )  )  +  0  .  5  )  ;  [FE]  AssertionFailedError:  48  ,  22  expected:<27385657281648>  but  was:<27385657281647>  assertEquals  (  exactResult  ,  ourResult  )  ;  [METHOD]  binomialCoefficientDouble  [TYPE]  double  [PARAMETER]  final  int  n  final  int  k  [CLASS]  MathUtils  [TYPE]  short  NS  PS  ZS  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  int  k  n  [CONTEXT]  public  static  double  binomialCoefficientDouble  (  final  int  n  ,  final  int  k  )  {  [BUGGY]  return  Math  .  floor  (  Math  .  exp  (  binomialCoefficientLog  (  n  ,  k  )  )  +  0  .  5  )  ;  }  	Math_92_MathUtils_7_5	234	1	src/java/org/apache/commons/math/util/MathUtils.java
246	if  (n  <  67)  {  return  Math.log(binomialCoefficient(n,k));  }  	[BUGGY]  [FE]  AssertionFailedError:  48  ,  22  expected:<27385657281648>  but  was:<27385657281647>  assertEquals  (  exactResult  ,  ourResult  )  ;  [METHOD]  binomialCoefficientLog  [TYPE]  double  [PARAMETER]  final  int  n  final  int  k  [CLASS]  MathUtils  [TYPE]  short  NS  PS  ZS  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  logSum  [TYPE]  byte  NB  PB  ZB  [TYPE]  int  i  k  n  [CONTEXT]  public  static  double  binomialCoefficientLog  (  final  int  n  ,  final  int  k  )  {  if  (  n  <  k  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  =  k  for  binomial  coefficient  (  n  ,  k  ) "  )  ;  }  if  (  n  <  0  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  =  0  for  binomial  coefficient  (  n  ,  k  ) "  )  ;  }  if  (  (  n  =  =  k  )  ||  (  k  =  =  0  )  )  {  return  0  ;  }  if  (  (  k  =  =  1  )  ||  (  k  =  =  n  -  1  )  )  {  return  Math  .  log  (  (  double  )  n  )  ;  }  [BUGGY]  	Math_92_MathUtils_7_6	277	0	src/java/org/apache/commons/math/util/MathUtils.java
247	if  (n  <  1030)  {  return  Math.log(binomialCoefficientDouble(n,  k));  }  	[BUGGY]  [FE]  AssertionFailedError:  48  ,  22  expected:<27385657281648>  but  was:<27385657281647>  assertEquals  (  exactResult  ,  ourResult  )  ;  [METHOD]  binomialCoefficientLog  [TYPE]  double  [PARAMETER]  final  int  n  final  int  k  [CLASS]  MathUtils  [TYPE]  short  NS  PS  ZS  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  logSum  [TYPE]  byte  NB  PB  ZB  [TYPE]  int  i  k  n  [CONTEXT]  public  static  double  binomialCoefficientLog  (  final  int  n  ,  final  int  k  )  {  if  (  n  <  k  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  =  k  for  binomial  coefficient  (  n  ,  k  ) "  )  ;  }  if  (  n  <  0  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  =  0  for  binomial  coefficient  (  n  ,  k  ) "  )  ;  }  if  (  (  n  =  =  k  )  ||  (  k  =  =  0  )  )  {  return  0  ;  }  if  (  (  k  =  =  1  )  ||  (  k  =  =  n  -  1  )  )  {  return  Math  .  log  (  (  double  )  n  )  ;  }  [BUGGY]  double  logSum  =  0  ;  	Math_92_MathUtils_7_7	282	0	src/java/org/apache/commons/math/util/MathUtils.java
248	if  (n  <  0)  {  throw  new  IllegalArgumentException( "must  have  n  >=  0  for  n! ");  }  if  (n  >  20)  {  	[BUGGY]  long  result  =  Math  .  round  (  factorialDouble  (  n  )  )  ;  if  (  result  =  =  Long  .  MAX_VALUE  )  {  [FE]  AssertionFailedError:  17!  expected:<355687428096E14>  but  was:<355687428096001E14>  assertTrue  ( "expecting  infinite  factorial  value "  ,  Double  .  isInfinite  (  MathUtils  .  factorialDouble  (  171  )  )  )  ;  [METHOD]  factorial  [TYPE]  long  [PARAMETER]  final  int  n  [CLASS]  MathUtils  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  short  NS  PS  ZS  [TYPE]  int  n  [TYPE]  long  result  [CONTEXT]  public  static  long  factorial  (  final  int  n  )  {  [BUGGY]  long  result  =  Math  .  round  (  factorialDouble  (  n  )  )  ;  if  (  result  =  =  Long  .  MAX_VALUE  )  {  throw  new  ArithmeticException  ( "factorial  value  is  too  large  to  fit  in  a  long "  )  ;  }  return  factorials[n]  ;  }  	Math_93_MathUtils_3_1	345	2	src/java/org/apache/commons/math/util/MathUtils.java
249	if  (n  <  21)  {  return  factorial(n);  }  	[BUGGY]  [FE]  AssertionFailedError:  17!  expected:<355687428096E14>  but  was:<355687428096001E14>  assertTrue  ( "expecting  infinite  factorial  value "  ,  Double  .  isInfinite  (  MathUtils  .  factorialDouble  (  171  )  )  )  ;  [METHOD]  factorialDouble  [TYPE]  double  [PARAMETER]  final  int  n  [CLASS]  MathUtils  [TYPE]  short  NS  PS  ZS  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  int  n  [CONTEXT]  public  static  double  factorialDouble  (  final  int  n  )  {  if  (  n  <  0  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  =  0  for  n! "  )  ;  }  [BUGGY]  return  Math  .  floor  (  Math  .  exp  (  factorialLog  (  n  )  )  +  0  .  5  )  ;  }  	Math_93_MathUtils_3_2	377	0	src/java/org/apache/commons/math/util/MathUtils.java
250	if  (n  <  21)  {  return  Math.log(factorial(n));  }  	[BUGGY]  [FE]  AssertionFailedError:  17!  expected:<355687428096E14>  but  was:<355687428096001E14>  assertTrue  ( "expecting  infinite  factorial  value "  ,  Double  .  isInfinite  (  MathUtils  .  factorialDouble  (  171  )  )  )  ;  [METHOD]  factorialLog  [TYPE]  double  [PARAMETER]  final  int  n  [CLASS]  MathUtils  [TYPE]  short  NS  PS  ZS  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  logSum  [TYPE]  byte  NB  PB  ZB  [TYPE]  int  i  n  [CONTEXT]  public  static  double  factorialLog  (  final  int  n  )  {  if  (  n  <  0  )  {  throw  new  IllegalArgumentException  ( "must  have  n  >  0  for  n! "  )  ;  }  [BUGGY]  double  logSum  =  0  ;  for  (  int  i  =  2  ;  i  <  =  n  ;  i++  )  {  logSum  +  =  Math  .  log  (  (  double  )  i  )  ;  }  return  logSum  ;  }  	Math_93_MathUtils_3_3	397	0	src/java/org/apache/commons/math/util/MathUtils.java
251	if  ((u  ==  0)  ||  (v  ==  0))  {  	[BUGGY]  if  (  u  *  v  =  =  0  )  {  [FE]  AssertionFailedError:  expected:<98304>  but  was:<3440640>  assertEquals  (  3  *  (  1<<15  )  ,  MathUtils  .  gcd  (  3  *  (  1<<20  )  ,  9  *  (  1<<15  )  )  )  ;  [METHOD]  gcd  [TYPE]  int  [PARAMETER]  int  u  int  v  [CLASS]  MathUtils  [TYPE]  short  NS  PS  ZS  [TYPE]  boolean  false  true  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  int  k  t  u  v  [CONTEXT]  public  static  int  gcd  (  int  u  ,  int  v  )  {  [BUGGY]  if  (  u  *  v  =  =  0  )  {  return  (  Math  .  abs  (  u  )  +  Math  .  abs  (  v  )  )  ;  }  	Math_94_MathUtils_1_1	412	1	src/java/org/apache/commons/math/util/MathUtils.java
252	double  ret  =  1.0;  if  (d  >  2.0)  {  }  	[BUGGY]  double  ret  ;  [FE]  IllegalArgumentException:  Invalid  endpoint  parameters:  lowerBound  =  00  initial  =  -10  upperBound  =  17976931348623157E308  assertEquals  (  0  .  975  ,  x  ,  1  .  0e-5  )  ;  [METHOD]  getInitialDomain  [TYPE]  double  [PARAMETER]  double  p  [CLASS]  FDistributionImpl  [TYPE]  double  d  denominatorDegreesOfFreedom  numeratorDegreesOfFreedom  p  ret  [TYPE]  long  serialVersionUID  [TYPE]  boolean  false  true  [CONTEXT]  protected  double  getInitialDomain  (  double  p  )  {  [BUGGY]  double  ret  ;  double  d  =  getDenominatorDegreesOfFreedom  (  )  ;  ret  =  d  /  (  d  -  2  .  0  )  ;  return  ret  ;  }  	Math_95_FDistributionImpl_1_1	144	1	src/java/org/apache/commons/math/distribution/FDistributionImpl.java
253	ret  =  (real  ==  rhs.real)  &&  (imaginary  ==  rhs.imaginary);  	[BUGGY]  ret  =  (  Double  .  doubleToRawLongBits  (  real  )  =  =  Double  .  doubleToRawLongBits  (  rhs  .  getReal  (  )  )  )  &&  (  Double  .  doubleToRawLongBits  (  imaginary  )  =  =  Double  .  doubleToRawLongBits  (  rhs  .  getImaginary  (  )  )  )  ;  [FE]  AssertionFailedError:  expected:<orgapachecommonsmathcomplexComplex@98b00000>  but  was:<orgapachecommonsmathcomplexComplex@18b00000>  assertEquals  (  new  Complex  (  0  ,  -1  )  ,  new  Complex  (  0  ,  1  )  .  multiply  (  new  Complex  (  -1  ,  0  )  )  )  ;  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  other  [CLASS]  Complex  [TYPE]  Object  other  [TYPE]  boolean  false  ret  true  [TYPE]  double  imaginary  real  [TYPE]  long  serialVersionUID  [TYPE]  Complex  I  INF  NaN  ONE  ZERO  rhs  [TYPE]  ClassCastException  ex  [CONTEXT]  public  boolean  equals  (  Object  other  )  {  boolean  ret  ;  if  (  this  =  =  other  )  {  ret  =  true  ;  }  else  if  (  other  =  =  null  )  {  ret  =  false  ;  }  else{  try  {  Complex  rhs  =  (  Complex  )  other  ;  if  (  rhs  .  isNaN  (  )  )  {  ret  =  this  .  isNaN  (  )  ;  }  else  {  [BUGGY]  ret  =  (  Double  .  doubleToRawLongBits  (  real  )  =  =  Double  .  doubleToRawLongBits  (  rhs  .  getReal  (  )  )  )  &&  (  Double  .  doubleToRawLongBits  (  imaginary  )  =  =  Double  .  doubleToRawLongBits  (  rhs  .  getImaginary  (  )  )  )  ;  }  }  catch  (  ClassCastException  ex  )  {  ret  =  false  ;  }  }  return  ret  ;  }  	Math_96_Complex_1_1	258	1	src/java/org/apache/commons/math/complex/Complex.java
254	if  (sign  >  0)  {  if  (Math.abs(yMin)  <=  functionValueAccuracy)  {  setResult(min,  0);  ret  =  min;  }  else  if  (Math.abs(yMax)  <=  functionValueAccuracy)  {  setResult(max,  0);  ret  =  max;  }  else  {  	[BUGGY]  if  (  sign  >  =  0  )  {  [FE]  IllegalArgumentException:  Function  values  at  endpoints  do  not  have  different  signs  Endpoints:  [30  ,  3141592653589793]  Values:  [01411200080598672  ,  12246467991473532E-16]  assertEquals  (  result  ,  Math  .  PI  ,  solver  .  getAbsoluteAccuracy  (  )  )  ;  [METHOD]  solve  [TYPE]  double  [PARAMETER]  double  min  double  max  [CLASS]  BrentSolver  [TYPE]  long  serialVersionUID  [TYPE]  double  max  min  ret  sign  yMax  yMin  [TYPE]  boolean  false  true  [CONTEXT]  public  double  solve  (  double  min  ,  double  max  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  clearResult  (  )  ;  verifyInterval  (  min  ,  max  )  ;  double  ret  =  Double  .  NaN  ;  double  yMin  =  f  .  value  (  min  )  ;  double  yMax  =  f  .  value  (  max  )  ;  double  sign  =  yMin  *  yMax  ;  [BUGGY]  if  (  sign  >  =  0  )  {  throw  new  IllegalArgumentException  ( "Function  values  at  endpoints  do  not  have  different  signs  . "  + "Endpoints:  [ "  +  min  + "  , "  +  max  + "] "  + "Values:  [ "  +  yMin  + "  , "  +  yMax  + "] "  )  ;  }  else  {  ret  =  solve  (  min  ,  yMin  ,  max  ,  yMax  ,  min  ,  yMin  )  ;  }  return  ret  ;  }  	Math_97_BrentSolver_2_1	138	1	src/java/org/apache/commons/math/analysis/BrentSolver.java
255	}  }  else  if  (sign  <  0){  }  else  {  if  (yMin  ==  0.0)  {  ret  =  min;  }  else  {  ret  =  max;  }  	[BUGGY]  }  else  {  [FE]  IllegalArgumentException:  Function  values  at  endpoints  do  not  have  different  signs  Endpoints:  [30  ,  3141592653589793]  Values:  [01411200080598672  ,  12246467991473532E-16]  assertEquals  (  result  ,  Math  .  PI  ,  solver  .  getAbsoluteAccuracy  (  )  )  ;  [METHOD]  solve  [TYPE]  double  [PARAMETER]  double  min  double  max  [CLASS]  BrentSolver  [TYPE]  long  serialVersionUID  [TYPE]  double  max  min  ret  sign  yMax  yMin  [TYPE]  boolean  false  true  [CONTEXT]  public  double  solve  (  double  min  ,  double  max  )  throws  MaxIterationsExceededException  ,  FunctionEvaluationException  {  clearResult  (  )  ;  verifyInterval  (  min  ,  max  )  ;  double  ret  =  Double  .  NaN  ;  double  yMin  =  f  .  value  (  min  )  ;  double  yMax  =  f  .  value  (  max  )  ;  double  sign  =  yMin  *  yMax  ;  if  (  sign  >  =  0  )  {  throw  new  IllegalArgumentException  ( "Function  values  at  endpoints  do  not  have  different  signs  . "  + "Endpoints:  [ "  +  min  + "  , "  +  max  + "] "  + "Values:  [ "  +  yMin  + "  , "  +  yMax  + "] "  )  ;  [BUGGY]  }  else  {  ret  =  solve  (  min  ,  yMin  ,  max  ,  yMax  ,  min  ,  yMin  )  ;  }  return  ret  ;  }  	Math_97_BrentSolver_2_2	145	1	src/java/org/apache/commons/math/analysis/BrentSolver.java
256	final  BigDecimal[]  out  =  new  BigDecimal[nRows];  	[BUGGY]  final  BigDecimal[]  out  =  new  BigDecimal[v  .  length]  ;  [FE]  ArrayIndexOutOfBoundsException:  2  assertEquals  (  11  .  0  ,  b[2]  .  doubleValue  (  )  ,  1  .  0e-12  )  ;  [METHOD]  operate  [TYPE]  BigDecimal[]  [PARAMETER]  BigDecimal[]  v  [CLASS]  BigMatrixImpl  [TYPE]  boolean  false  true  [TYPE]  int[]  permutation  [TYPE]  BigDecimal[]  out  v  [TYPE]  long  serialVersionUID  [TYPE]  int  i  nCols  nRows  parity  roundingMode  row  scale  [TYPE]  BigDecimal  ONE  TOO_SMALL  ZERO  sum  [TYPE]  BigDecimal[][]  data  lu  [CONTEXT]  public  BigDecimal[]  operate  (  BigDecimal[]  v  )  throws  IllegalArgumentException  {  if  (  v  .  length  !  =  this  .  getColumnDimension  (  )  )  {  throw  new  IllegalArgumentException  ( "vector  has  wrong  length "  )  ;  }  final  int  nRows  =  this  .  getRowDimension  (  )  ;  final  int  nCols  =  this  .  getColumnDimension  (  )  ;  [BUGGY]  final  BigDecimal[]  out  =  new  BigDecimal[v  .  length]  ;  for  (  int  row  =  0  ;  row  <  nRows  ;  row++  )  {  BigDecimal  sum  =  ZERO  ;  for  (  int  i  =  0  ;  i  <  nCols  ;  i++  )  {  sum  =  sum  .  add  (  data[row][i]  .  multiply  (  v[i]  )  )  ;  }  out[row]  =  sum  ;  }  return  out  ;  }  	Math_98_BigMatrixImpl_1_1	991	1	src/java/org/apache/commons/math/linear/BigMatrixImpl.java
257	final  double[]  out  =  new  double[nRows];  	[BUGGY]  final  double[]  out  =  new  double[v  .  length]  ;  [FE]  ArrayIndexOutOfBoundsException:  2  assertEquals  (  11  .  0  ,  b[2]  .  doubleValue  (  )  ,  1  .  0e-12  )  ;  [METHOD]  operate  [TYPE]  double[]  [PARAMETER]  double[]  v  [CLASS]  RealMatrixImpl  [TYPE]  boolean  false  true  [TYPE]  double[]  dataRow  out  v  [TYPE]  double  TOO_SMALL  sum  [TYPE]  double[][]  data  lu  [TYPE]  int[]  permutation  [TYPE]  long  serialVersionUID  [TYPE]  int  i  nCols  nRows  parity  row  [CONTEXT]  public  double[]  operate  (  double[]  v  )  throws  IllegalArgumentException  {  final  int  nRows  =  this  .  getRowDimension  (  )  ;  final  int  nCols  =  this  .  getColumnDimension  (  )  ;  if  (  v  .  length  !  =  nCols  )  {  throw  new  IllegalArgumentException  ( "vector  has  wrong  length "  )  ;  }  [BUGGY]  final  double[]  out  =  new  double[v  .  length]  ;  for  (  int  row  =  0  ;  row  <  nRows  ;  row++  )  {  final  double[]  dataRow  =  data[row]  ;  double  sum  =  0  ;  for  (  int  i  =  0  ;  i  <  nCols  ;  i++  )  {  sum  +  =  dataRow[i]  *  v[i]  ;  }  out[row]  =  sum  ;  }  return  out  ;  }  	Math_98_RealMatrixImpl_1_1	779	1	src/java/org/apache/commons/math/linear/RealMatrixImpl.java
258	if  ((u  ==  Integer.MIN_VALUE)  ||  (v  ==  Integer.MIN_VALUE))  {  throw  MathRuntimeException.createArithmeticException( "overflow:  gcd({0},  {1})  is  2^31 ",  new  Object[]  {  p,  q  });  }  	[BUGGY]  [FE]  AssertionFailedError:  expecting  ArithmeticException  assertEquals  (  1<<30  ,  MathUtils  .  gcd  (  1<<30  ,  -Integer  .  MIN_VALUE  )  )  ;  [METHOD]  gcd  [TYPE]  int  [PARAMETER]  final  int  p  final  int  q  [CLASS]  MathUtils  [TYPE]  short  NS  PS  ZS  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  int  k  p  q  t  u  v  [CONTEXT]  public  static  int  gcd  (  final  int  p  ,  final  int  q  )  {  int  u  =  p  ;  int  v  =  q  ;  if  (  (  u  =  =  0  )  ||  (  v  =  =  0  )  )  {  [BUGGY]  return  (  Math  .  abs  (  u  )  +  Math  .  abs  (  v  )  )  ;  }  	Math_99_MathUtils_2_1	543	0	src/java/org/apache/commons/math/util/MathUtils.java
259	if  (lcm  ==  Integer.MIN_VALUE){  throw  new  ArithmeticException( "overflow:  lcm  is  2^31 ");  }  	[BUGGY]  [FE]  AssertionFailedError:  expecting  ArithmeticException  assertEquals  (  1<<30  ,  MathUtils  .  gcd  (  1<<30  ,  -Integer  .  MIN_VALUE  )  )  ;  [METHOD]  lcm  [TYPE]  int  [PARAMETER]  int  a  int  b  [CLASS]  MathUtils  [TYPE]  short  NS  PS  ZS  [TYPE]  boolean  false  true  [TYPE]  long[]  factorials  [TYPE]  double  EPSILON  SAFE_MIN  TWO_PI  [TYPE]  byte  NB  PB  ZB  [TYPE]  int  a  b  lcm  [CONTEXT]  public  static  int  lcm  (  int  a  ,  int  b  )  {  if  (  a  =  =  0  ||  b  =  =  0  )  {  return  0  ;  }  int  lcm  =  Math  .  abs  (  mulAndCheck  (  a  /  gcd  (  a  ,  b  )  ,  b  )  )  ;  [BUGGY]  return  lcm  ;  }  	Math_99_MathUtils_2_2	714	0	src/java/org/apache/commons/math/util/MathUtils.java
260	final  int  cols  =  problem.getUnboundParameters().length;  	[BUGGY]  final  int  cols  =  problem  .  getAllParameters  (  )  .  length  ;  [FE]  ArrayIndexOutOfBoundsException:  6  assertEquals  (  0  ,  errors[i1]  ,  1  .  0e-10  )  ;  [METHOD]  getCovariances  [TYPE]  double[][]  [PARAMETER]  EstimationProblem  problem  [CLASS]  AbstractEstimator  [TYPE]  EstimatedParameter[]  parameters  [TYPE]  InvalidMatrixException  ime  [TYPE]  boolean  false  true  [TYPE]  double[]  jacobian  residuals  [TYPE]  WeightedMeasurement[]  measurements  [TYPE]  double  cost  sum  [TYPE]  double[][]  jTj  [TYPE]  EstimationProblem  problem  [TYPE]  int  cols  costEvaluations  i  j  jacobianEvaluations  k  max  maxCostEval  rows  [CONTEXT]  public  double[][]  getCovariances  (  EstimationProblem  problem  )  throws  EstimationException  {  updateJacobian  (  )  ;  final  int  rows  =  problem  .  getMeasurements  (  )  .  length  ;  [BUGGY]  final  int  cols  =  problem  .  getAllParameters  (  )  .  length  ;  final  int  max  =  cols  *  rows  ;  double[][]  jTj  =  new  double[cols][cols]  ;  for  (  int  i  =  0  ;  i  <  cols  ;  ++i  )  {  for  (  int  j  =  i  ;  j  <  cols  ;  ++j  )  {  double  sum  =  0  ;  	Math_100_AbstractEstimator_3_1	166	1	src/java/org/apache/commons/math/estimation/AbstractEstimator.java
261	int  p  =  problem.getUnboundParameters().length;  	[BUGGY]  int  p  =  problem  .  getAllParameters  (  )  .  length  ;  [FE]  ArrayIndexOutOfBoundsException:  6  assertEquals  (  0  ,  errors[i1]  ,  1  .  0e-10  )  ;  [METHOD]  guessParametersErrors  [TYPE]  double[]  [PARAMETER]  EstimationProblem  problem  [CLASS]  AbstractEstimator  [TYPE]  EstimatedParameter[]  parameters  [TYPE]  boolean  false  true  [TYPE]  double[]  errors  jacobian  residuals  [TYPE]  WeightedMeasurement[]  measurements  [TYPE]  double  c  cost  [TYPE]  double[][]  covar  [TYPE]  EstimationProblem  problem  [TYPE]  int  cols  costEvaluations  i  jacobianEvaluations  m  maxCostEval  p  rows  [CONTEXT]  public  double[]  guessParametersErrors  (  EstimationProblem  problem  )  throws  EstimationException  {  int  m  =  problem  .  getMeasurements  (  )  .  length  ;  [BUGGY]  int  p  =  problem  .  getAllParameters  (  )  .  length  ;  if  (  m  <  =  p  )  {  throw  new  EstimationException  ( "no  degrees  of  freedom  (  {0}  measurements  ,  {1}  parameters  ) "  ,  new  Object[]  {  new  Integer  (  m  )  ,  new  Integer  (  p  )  }  )  ;  }  double[]  errors  =  new  double[problem  .  getAllParameters  (  )  .  length]  ;  final  double  c  =  Math  .  sqrt  (  getChiSquare  (  problem  )  /  (  m  -  p  )  )  ;  double[][]  covar  =  getCovariances  (  problem  )  ;  for  (  int  i  =  0  ;  i  <  errors  .  length  ;  ++i  )  {  errors[i]  =  Math  .  sqrt  (  covar[i][i]  )  *  c  ;  }  return  errors  ;  }  	Math_100_AbstractEstimator_3_2	202	1	src/java/org/apache/commons/math/estimation/AbstractEstimator.java
262	double[]  errors  =  new  double[problem.getUnboundParameters().length];  	[BUGGY]  double[]  errors  =  new  double[problem  .  getAllParameters  (  )  .  length]  ;  [FE]  ArrayIndexOutOfBoundsException:  6  assertEquals  (  0  ,  errors[i1]  ,  1  .  0e-10  )  ;  [METHOD]  guessParametersErrors  [TYPE]  double[]  [PARAMETER]  EstimationProblem  problem  [CLASS]  AbstractEstimator  [TYPE]  EstimatedParameter[]  parameters  [TYPE]  boolean  false  true  [TYPE]  double[]  errors  jacobian  residuals  [TYPE]  WeightedMeasurement[]  measurements  [TYPE]  double  c  cost  [TYPE]  double[][]  covar  [TYPE]  EstimationProblem  problem  [TYPE]  int  cols  costEvaluations  i  jacobianEvaluations  m  maxCostEval  p  rows  [CONTEXT]  public  double[]  guessParametersErrors  (  EstimationProblem  problem  )  throws  EstimationException  {  int  m  =  problem  .  getMeasurements  (  )  .  length  ;  int  p  =  problem  .  getAllParameters  (  )  .  length  ;  if  (  m  <  =  p  )  {  throw  new  EstimationException  ( "no  degrees  of  freedom  (  {0}  measurements  ,  {1}  parameters  ) "  ,  new  Object[]  {  new  Integer  (  m  )  ,  new  Integer  (  p  )  }  )  ;  }  [BUGGY]  double[]  errors  =  new  double[problem  .  getAllParameters  (  )  .  length]  ;  final  double  c  =  Math  .  sqrt  (  getChiSquare  (  problem  )  /  (  m  -  p  )  )  ;  double[][]  covar  =  getCovariances  (  problem  )  ;  for  (  int  i  =  0  ;  i  <  errors  .  length  ;  ++i  )  {  errors[i]  =  Math  .  sqrt  (  covar[i][i]  )  *  c  ;  }  return  errors  ;  }  	Math_100_AbstractEstimator_3_3	207	1	src/java/org/apache/commons/math/estimation/AbstractEstimator.java
263	if  ((startIndex  >=  source.length())  ||  (endIndex  >  source.length())  ||  	[BUGGY]    [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  6  [METHOD]  parse  [TYPE]  Complex  [PARAMETER]  String  source  ParsePosition  pos  [CLASS]  ComplexFormat  [TYPE]  boolean  false  true  [TYPE]  Number  im  re  [TYPE]  char  c  [TYPE]  String  DEFAULT_IMAGINARY_CHARACTER  imaginaryCharacter  source  [TYPE]  long  serialVersionUID  [TYPE]  int  endIndex  initialIndex  n  sign  startIndex  [TYPE]  NumberFormat  imaginaryFormat  realFormat  [TYPE]  ParsePosition  pos  [CONTEXT]  pos  .  setIndex  (  initialIndex  )  ;  pos  .  setErrorIndex  (  startIndex  )  ;  return  null  ;  }  parseAndIgnoreWhitespace  (  source  ,  pos  )  ;  Number  im  =  parseNumber  (  source  ,  getRealFormat  (  )  ,  pos  )  ;  if  (  im  =  =  null  )  {  pos  .  setIndex  (  initialIndex  )  ;  return  null  ;  }  int  n  =  getImaginaryCharacter  (  )  .  length  (  )  ;  startIndex  =  pos  .  getIndex  (  )  ;  int  endIndex  =  startIndex  +  n  ;  [BUGGY]  if  (  source  .  substring  (  startIndex  ,  endIndex  )  .  compareTo  (  getImaginaryCharacter  (  )  )  !  =  0  )  {  pos  .  setIndex  (  initialIndex  )  ;  	Math_101_ComplexFormat_1_1	377	0	src/java/org/apache/commons/math/complex/ComplexFormat.java
264	double  sumExpected  =  0d;  double  sumObserved  =  0d;  for  (int  i  =  0;  i  <  observed.length;  i++)  {  sumExpected  +=  expected[i];  sumObserved  +=  observed[i];  }  double  ratio  =  1.0d;  boolean  rescale  =  false;  if  (Math.abs(sumExpected  -  sumObserved)  >  10E-6)  {  ratio  =  sumObserved  /  sumExpected;  rescale  =  true;  }  	[BUGGY]  [FE]  AssertionFailedError:  chi-square  test  statistic  expected:<11487590421929007>  but  was:<36248833429077636>  [METHOD]  chiSquare  [TYPE]  double  [PARAMETER]  double[]  expected  long[]  observed  [CLASS]  ChiSquareTestImpl  [TYPE]  ChiSquaredDistribution  distribution  [TYPE]  boolean  false  true  [TYPE]  double[]  expected  [TYPE]  long[]  observed  [TYPE]  double  dev  sumSq  [TYPE]  int  i  [CONTEXT]  public  double  chiSquare  (  double[]  expected  ,  long[]  observed  )  throws  IllegalArgumentException  {  if  (  (  expected  .  length  <  2  )  ||  (  expected  .  length  !  =  observed  .  length  )  )  {  throw  new  IllegalArgumentException  ( "observed  ,  expected  array  lengths  incorrect "  )  ;  }  if  (  !isPositive  (  expected  )  ||  !isNonNegative  (  observed  )  )  {  throw  new  IllegalArgumentException  ( "observed  counts  must  be  non-negative  and  expected  counts  must  be  postive "  )  ;  }  [BUGGY]  double  sumSq  =  0  .  0d  ;  double  dev  =  0  .  0d  ;  for  (  int  i  =  0  ;  i  <  observed  .  length  ;  i++  )  {  dev  =  (  (  double  )  observed[i]  -  expected[i]  )  ;  sumSq  +  =  dev  *  dev  /  expected[i]  ;  }  return  sumSq  ;  }  	Math_102_ChiSquareTestImpl_2_1	74	0	src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java
265	if  (rescale)  {  dev  =  ((double)  observed[i]  -  ratio  *  expected[i]);  sumSq  +=  dev  *  dev  /  (ratio  *  expected[i]);  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError:  chi-square  test  statistic  expected:<11487590421929007>  but  was:<36248833429077636>  [METHOD]  chiSquare  [TYPE]  double  [PARAMETER]  double[]  expected  long[]  observed  [CLASS]  ChiSquareTestImpl  [TYPE]  ChiSquaredDistribution  distribution  [TYPE]  boolean  false  true  [TYPE]  double[]  expected  [TYPE]  long[]  observed  [TYPE]  double  dev  sumSq  [TYPE]  int  i  [CONTEXT]  public  double  chiSquare  (  double[]  expected  ,  long[]  observed  )  throws  IllegalArgumentException  {  if  (  (  expected  .  length  <  2  )  ||  (  expected  .  length  !  =  observed  .  length  )  )  {  throw  new  IllegalArgumentException  ( "observed  ,  expected  array  lengths  incorrect "  )  ;  }  if  (  !isPositive  (  expected  )  ||  !isNonNegative  (  observed  )  )  {  throw  new  IllegalArgumentException  ( "observed  counts  must  be  non-negative  and  expected  counts  must  be  postive "  )  ;  }  double  sumSq  =  0  .  0d  ;  double  dev  =  0  .  0d  ;  for  (  int  i  =  0  ;  i  <  observed  .  length  ;  i++  )  {  [BUGGY]  dev  =  (  (  double  )  observed[i]  -  expected[i]  )  ;  sumSq  +  =  dev  *  dev  /  expected[i]  ;  }  return  sumSq  ;  }  	Math_102_ChiSquareTestImpl_2_2	77	0	src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java
266	try  {  }  catch  (MaxIterationsExceededException  ex)  {  if  (x  <  (mean  -  20  *  standardDeviation))  {  return  0.0d;  }  else  if  (x  >  (mean  +  20  *  standardDeviation))  {  return  1.0d;  }  else  {  throw  ex;  }  }  	[BUGGY]  [FE]  commonsmathMaxIterationsExceededException:  Maximal  number  of  iterations  (  10  ,  000  )  exceeded  assertTrue  (  upperTail  >  0  .  99999  )  ;  [METHOD]  cumulativeProbability  [TYPE]  double  [PARAMETER]  double  x  [CLASS]  NormalDistributionImpl  [TYPE]  double  mean  standardDeviation  x  [TYPE]  long  serialVersionUID  [TYPE]  boolean  false  true  [CONTEXT]  public  double  cumulativeProbability  (  double  x  )  throws  MathException  {  [BUGGY]  return  0  .  5  *  (  1  .  0  +  Erf  .  erf  (  (  x  -  mean  )  /  (  standardDeviation  *  Math  .  sqrt  (  2  .  0  )  )  )  )  ;  }  	Math_103_NormalDistributionImpl_1_1	109	0	src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java
267	private  static  final  double  DEFAULT_EPSILON  =  10e-15;  	[BUGGY]  private  static  final  double  DEFAULT_EPSILON  =  10e-9  ;  [FE]  AssertionFailedError:  expected:<0632120558828558>  but  was:<06321205587649603>  [CLASS]  [CONTEXT]  	Math_104_Gamma_1_1	37	1	src/java/org/apache/commons/math/special/Gamma.java
268	return  Math.max(0d,  sumYY  -  sumXY  *  sumXY  /  sumXX);  	[BUGGY]  return  sumYY  -  sumXY  *  sumXY  /  sumXX  ;  [FE]  AssertionFailedError  assertTrue  (  reg  .  getSumSquaredErrors  (  )  >  =  0  .  0  )  ;  [METHOD]  getSumSquaredErrors  [TYPE]  double  [PARAMETER]  [CLASS]  SimpleRegression  [TYPE]  double  sumX  sumXX  sumXY  sumY  sumYY  xbar  ybar  [TYPE]  long  n  serialVersionUID  [TYPE]  boolean  false  true  [CONTEXT]  public  double  getSumSquaredErrors  (  )  {  [BUGGY]  return  sumYY  -  sumXY  *  sumXY  /  sumXX  ;  }  	Math_105_SimpleRegression_1_1	264	1	src/java/org/apache/commons/math/stat/regression/SimpleRegression.java
269	if  (!removeGlobals)  {  return;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  removeUnreferencedFunctionArgs  [TYPE]  void  [PARAMETER]  Scope  fnScope  [CLASS]  RemoveUnusedVars  [TYPE]  Multimap  assignsByVar  classDefiningCalls  continuations  [TYPE]  CallSiteOptimizer  callSiteOptimizer  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  modifyCallers  preserveFunctionExpressionNames  removeGlobals  true  [TYPE]  Set  referenced  [TYPE]  Scope  fnScope  scope  [TYPE]  Var  var  [TYPE]  CodingConvention  codingConvention  [TYPE]  Node  argList  assignNode  function  lastArg  nameNode  node  [TYPE]  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  [TYPE]  SimpleDefinitionFinder  defFinder  [TYPE]  Map  assignsByNode  [CONTEXT]  private  void  removeUnreferencedFunctionArgs  (  Scope  fnScope  )  {  [BUGGY]  Node  function  =  fnScope  .  getRootNode  (  )  ;  Preconditions  .  checkState  (  function  .  isFunction  (  )  )  ;  if  (  NodeUtil  .  isGetOrSetKey  (  function  .  getParent  (  )  )  )  {  	Closure_1_RemoveUnusedVars_1_1	379	0	src/com/google/javascript/jscomp/RemoveUnusedVars.java
270	if  (implicitProto  ==  null)  { currentPropertyNames = ImmutableSet.of(); }  else  {  }  	[BUGGY]  currentPropertyNames = implicitProto.getOwnPropertyNames(); [FE]  NullPointerException  [METHOD]  checkInterfaceConflictProperties  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  String  functionName  ObjectType>  properties  ObjectType>  currentProperties  ObjectType  interfaceType  [CLASS]  TypeCheck  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  Set  currentPropertyNames  [TYPE]  NodeTraversal  t  [TYPE]  HashMap  currentProperties  properties  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  CheckLevel  reportMissingOverride  reportUnknownTypes  [TYPE]  Node  n  [TYPE]  String  OVERRIDING_PROTOTYPE_WITH_NON_OBJECT  functionName  name  [TYPE]  MemoizedScopeCreator  scopeCreator  [TYPE]  int  noTypeCheckSection  nullCount  typedCount  unknownCount  [TYPE]  TypeValidator  validator  [TYPE]  ObjectType  iType  implicitProto  interfaceType  oType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  false  inExterns  reportMissingProperties  true  [TYPE]  Scope  topScope  [TYPE]  DiagnosticType  BAD_DELETE  BAD_IMPLEMENTED_TYPE  BIT_OPERATION  CONFLICTING_EXTENDED_TYPE  CONFLICTING_IMPLEMENTED_TYPE  CONSTRUCTOR_NOT_CALLABLE  DETERMINISTIC_TEST  DETERMINISTIC_TEST_NO_RESULT  ENUM_DUP  ENUM_NOT_CONSTANT  EXPECTED_THIS_TYPE  FUNCTION_MASKS_VARIABLE  HIDDEN_INTERFACE_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY_MISMATCH  ILLEGAL_IMPLICIT_CAST  ILLEGAL_OBJLIT_KEY  ILLEGAL_PROPERTY_CREATION  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE  INEXISTENT_ENUM_ELEMENT  INEXISTENT_PROPERTY  INTERFACE_FUNCTION_NOT_EMPTY  INTERFACE_METHOD_OVERRIDE  INVALID_INTERFACE_MEMBER_DECLARATION  IN_USED_WITH_STRUCT  MULTIPLE_VAR_DEF  NOT_A_CONSTRUCTOR  NOT_CALLABLE  UNEXPECTED_TOKEN  UNKNOWN_EXPR_TYPE  UNKNOWN_OVERRIDE  UNRESOLVED_TYPE  WRONG_ARGUMENT_COUNT  [TYPE]  InferJSDocInfo  inferJSDocInfo  [CONTEXT]  private  void  checkInterfaceConflictProperties  (  NodeTraversal  t  ,  Node  n  ,  String  functionName  ,  HashMap<String  ,  ObjectType>  properties  ,  HashMap<String  ,  ObjectType>  currentProperties  ,  ObjectType  interfaceType  )  {  ObjectType  implicitProto  =  interfaceType  .  getImplicitPrototype  (  )  ;  Set<String>  currentPropertyNames  ;  [BUGGY]  currentPropertyNames  =  implicitProto  .  getOwnPropertyNames  (  )  ;  for  (  String  name  :  currentPropertyNames  )  {  ObjectType  oType  =  properties  .  get  (  name  )  ;  if  (  oType  !  =  null  )  {  if  (  !interfaceType  .  getPropertyType  (  name  )  .  isEquivalentTo  (  oType  .  getPropertyType  (  name  )  )  )  {  compiler  .  report  (  t  .  makeError  (  n  ,  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE  ,  functionName  ,  name  ,  oType  .  toString  (  )  ,  interfaceType  .  toString  (  )  )  )  ;  }  }  currentProperties  .  put  (  name  ,  interfaceType  )  ;  }  for  (  ObjectType  iType  :  interfaceType  .  getCtorExtendedInterfaces  (  )  )  {  checkInterfaceConflictProperties  (  t  ,  n  ,  functionName  ,  properties  ,  currentProperties  ,  iType  )  ;  }  }  	Closure_2_TypeCheck_1_1	1572	0	src/com/google/javascript/jscomp/TypeCheck.java
271	if  (c.canInline(t.getScope()))  {  	[BUGGY]  if  (  c  .  canInline  (  )  )  {  [FE]  AssertionFailedError:  [METHOD]  enterScope  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  FlowSensitiveInlineVariables  [TYPE]  Candidate  c  [TYPE]  Set  inlinedNewDependencies  [TYPE]  NodeTraversal  t  [TYPE]  Node  def  use  useCfgNode  [TYPE]  Definition  defMetadata  [TYPE]  MaybeReachingVariableUse  reachingUses  [TYPE]  MustBeReachingVariableDef  reachingDef  [TYPE]  String  varName  [TYPE]  int  numUseWithinUseCfgNode  [TYPE]  Predicate  SIDE_EFFECT_PREDICATE  [TYPE]  AbstractCompiler  compiler  [TYPE]  ControlFlowAnalysis  cfa  [TYPE]  boolean  false  true  [TYPE]  ControlFlowGraph  cfg  [TYPE]  List  candidates  [CONTEXT]  if  (  LiveVariablesAnalysis  .  MAX_VARIABLES_TO_ANALYZE  <  t  .  getScope  (  )  .  getVarCount  (  )  )  {  return  ;  }  ControlFlowAnalysis  cfa  =  new  ControlFlowAnalysis  (  compiler  ,  false  ,  true  )  ;  Preconditions  .  checkState  (  t  .  getScopeRoot  (  )  .  isFunction  (  )  )  ;  cfa  .  process  (  null  ,  t  .  getScopeRoot  (  )  .  getLastChild  (  )  )  ;  cfg  =  cfa  .  getCfg  (  )  ;  reachingDef  =  new  MustBeReachingVariableDef  (  cfg  ,  t  .  getScope  (  )  ,  compiler  )  ;  reachingDef  .  analyze  (  )  ;  candidates  =  Lists  .  newLinkedList  (  )  ;  new  NodeTraversal  (  compiler  ,  new  GatherCandiates  (  )  )  .  traverse  (  t  .  getScopeRoot  (  )  .  getLastChild  (  )  )  ;  reachingUses  =  new  MaybeReachingVariableUse  (  cfg  ,  t  .  getScope  (  )  ,  compiler  )  ;  reachingUses  .  analyze  (  )  ;  for  (  Candidate  c  :  candidates  )  {  [BUGGY]  if  (  c  .  canInline  (  )  )  {  c  .  inlineVariable  (  )  ;  	Closure_3_FlowSensitiveInlineVariables_3_1	155	1	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
272	private  boolean  canInline(final  Scope  scope)  {  	[BUGGY]  private  boolean  canInline  (  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_3_FlowSensitiveInlineVariables_3_2	280	1	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
273	case  Token.NAME:  Var  var  =  scope.getOwnSlot(input.getString());  if  (var  !=  null  &&  var.getParentNode().isCatch())  {  return  true;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  apply  [TYPE]  boolean  [PARAMETER]  Node  input  [CLASS]  1  [TYPE]  boolean  false  true  [TYPE]  Node  input  [CONTEXT]  public  boolean  apply  (  Node  input  )  {  switch  (  input  .  getType  (  )  )  {  case  Token  .  GETELEM:  case  Token  .  GETPROP:  case  Token  .  ARRAYLIT:  case  Token  .  OBJECTLIT:  case  Token  .  REGEXP:  case  Token  .  NEW:  return  true  ;  [BUGGY]  }  return  false  ;  }  	Closure_3_FlowSensitiveInlineVariables_3_3	375	0	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
274	if  (detectInheritanceCycle())  {  	[BUGGY]  if  (  detectImplicitPrototypeCycle  (  )  )  {  [FE]  AssertionFailedError:  unexpected  warning  (  s  )  :  JSC_IMPLEMENTS_NON_INTERFACE  can  only  implement  interfaces  at  [testcode]  line  2  :  29  ,  JSC_IMPLEMENTS_NON_INTERFACE  can  only  implement  interfaces  at  [testcode]  line  3  :  26  expected:<1>  but  was:<2>  [METHOD]  resolveInternal  [TYPE]  JSType  [PARAMETER]  ErrorReporter  t  JSType>  enclosing  [CLASS]  NamedType  [TYPE]  ErrorReporter  t  [TYPE]  JSType  type  [TYPE]  boolean  false  inferred  resolved  true  [TYPE]  Node  propertyNode  [TYPE]  StaticScope  enclosing  [TYPE]  List  propertyContinuations  [TYPE]  String  propertyName  reference  sourceName  [TYPE]  long  serialVersionUID  [TYPE]  int  charno  lineno  [TYPE]  Predicate  validator  [CONTEXT]  JSType  resolveInternal  (  ErrorReporter  t  ,  StaticScope<JSType>  enclosing  )  {  boolean  resolved  =  resolveViaRegistry  (  t  ,  enclosing  )  ;  [BUGGY]  if  (  detectImplicitPrototypeCycle  (  )  )  {  handleTypeCycle  (  t  )  ;  }  if  (  resolved  )  {  super  .  resolveInternal  (  t  ,  enclosing  )  ;  finishPropertyContinuations  (  )  ;  return  registry  .  isLastGeneration  (  )  ?  getReferencedType  (  )  :  this  ;  }  resolveViaProperties  (  t  ,  enclosing  )  ;  if  (  detectImplicitPrototypeCycle  (  )  )  {  handleTypeCycle  (  t  )  ;  }  super  .  resolveInternal  (  t  ,  enclosing  )  ;  if  (  isResolved  (  )  )  {  finishPropertyContinuations  (  )  ;  }  return  registry  .  isLastGeneration  (  )  ?  getReferencedType  (  )  :  this  ;  }  	Closure_4_NamedType_2_1	190	1	src/com/google/javascript/rhino/jstype/NamedType.java
275	if  (detectInheritanceCycle())  {  	[BUGGY]  if  (  detectImplicitPrototypeCycle  (  )  )  {  [FE]  AssertionFailedError:  unexpected  warning  (  s  )  :  JSC_IMPLEMENTS_NON_INTERFACE  can  only  implement  interfaces  at  [testcode]  line  2  :  29  ,  JSC_IMPLEMENTS_NON_INTERFACE  can  only  implement  interfaces  at  [testcode]  line  3  :  26  expected:<1>  but  was:<2>  [METHOD]  resolveInternal  [TYPE]  JSType  [PARAMETER]  ErrorReporter  t  JSType>  enclosing  [CLASS]  NamedType  [TYPE]  ErrorReporter  t  [TYPE]  JSType  type  [TYPE]  boolean  false  inferred  resolved  true  [TYPE]  Node  propertyNode  [TYPE]  StaticScope  enclosing  [TYPE]  List  propertyContinuations  [TYPE]  String  propertyName  reference  sourceName  [TYPE]  long  serialVersionUID  [TYPE]  int  charno  lineno  [TYPE]  Predicate  validator  [CONTEXT]  JSType  resolveInternal  (  ErrorReporter  t  ,  StaticScope<JSType>  enclosing  )  {  boolean  resolved  =  resolveViaRegistry  (  t  ,  enclosing  )  ;  if  (  detectImplicitPrototypeCycle  (  )  )  {  handleTypeCycle  (  t  )  ;  }  if  (  resolved  )  {  super  .  resolveInternal  (  t  ,  enclosing  )  ;  finishPropertyContinuations  (  )  ;  return  registry  .  isLastGeneration  (  )  ?  getReferencedType  (  )  :  this  ;  }  resolveViaProperties  (  t  ,  enclosing  )  ;  [BUGGY]  if  (  detectImplicitPrototypeCycle  (  )  )  {  handleTypeCycle  (  t  )  ;  }  super  .  resolveInternal  (  t  ,  enclosing  )  ;  if  (  isResolved  (  )  )  {  finishPropertyContinuations  (  )  ;  }  return  registry  .  isLastGeneration  (  )  ?  getReferencedType  (  )  :  this  ;  }  	Closure_4_NamedType_2_2	202	1	src/com/google/javascript/rhino/jstype/NamedType.java
276	if  (gramps.isDelProp())  {  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isInlinableObject  [TYPE]  boolean  [PARAMETER]  Reference>  refs  [CLASS]  InliningBehavior  [TYPE]  List  refs  [TYPE]  Set  staleVars  validProperties  [TYPE]  boolean  false  ret  true  [TYPE]  String  propName  [TYPE]  Reference  ref  t  [TYPE]  Node  child  childVal  gramps  name  parent  refNode  val  [CONTEXT]  private  boolean  isInlinableObject  (  List<Reference>  refs  )  {  boolean  ret  =  false  ;  Set<String>  validProperties  =  Sets  .  newHashSet  (  )  ;  for  (  Reference  ref  :  refs  )  {  Node  name  =  ref  .  getNode  (  )  ;  Node  parent  =  ref  .  getParent  (  )  ;  Node  gramps  =  ref  .  getGrandparent  (  )  ;  if  (  parent  .  isGetProp  (  )  )  {  Preconditions  .  checkState  (  parent  .  getFirstChild  (  )  =  =  name  )  ;  if  (  gramps  .  isCall  (  )  &&  gramps  .  getFirstChild  (  )  =  =  parent  )  {  return  false  ;  }  [BUGGY]  	Closure_5_InlineObjectLiterals_1_1	176	0	src/com/google/javascript/jscomp/InlineObjectLiterals.java
277		[BUGGY]  if  (  (  leftType  .  isConstructor  (  )  ||  leftType  .  isEnumType  (  )  )  &&  (  rightType  .  isConstructor  (  )  ||  rightType  .  isEnumType  (  )  )  )  {  registerMismatch  (  rightType  ,  leftType  ,  null  )  ;  }  else  {  [FE]  AssertionFailedError:  expected:<2>  but  was:<1>  [METHOD]  expectCanAssignToPropertyOf  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  JSType  rightType  JSType  leftType  Node  owner  String  propName  [CLASS]  TypeValidator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  JSType  allValueTypes  leftType  nullOrUndefined  ownerType  rightType  typeA  typeB  [TYPE]  boolean  false  shouldReport  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  DUP_VAR_DECLARATION  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_PROPERTY_MISMATCH  ILLEGAL_PROPERTY_ACCESS  INTERFACE_METHOD_NOT_IMPLEMENTED  INVALID_CAST  MISSING_EXTENDS_TAG_WARNING  TYPE_MISMATCH_WARNING  UNKNOWN_TYPEOF_VALUE  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  Node  n  owner  [TYPE]  FunctionType  ownerFn  [TYPE]  List  mismatches  [TYPE]  String  FOUND_REQUIRED  propName  [TYPE]  JSError  src  [CONTEXT]  boolean  expectCanAssignToPropertyOf  (  NodeTraversal  t  ,  Node  n  ,  JSType  rightType  ,  JSType  leftType  ,  Node  owner  ,  String  propName  )  {  if  (  !leftType  .  isNoType  (  )  &&  !rightType  .  canAssignTo  (  leftType  )  )  {  [BUGGY]  if  (  (  leftType  .  isConstructor  (  )  ||  leftType  .  isEnumType  (  )  )  &&  (  rightType  .  isConstructor  (  )  ||  rightType  .  isEnumType  (  )  )  )  {  registerMismatch  (  rightType  ,  leftType  ,  null  )  ;  }  else  {  JSType  ownerType  =  getJSType  (  owner  )  ;  if  (  ownerType  .  isFunctionPrototypeType  (  )  )  {  FunctionType  ownerFn  =  ownerType  .  toObjectType  (  )  .  getOwnerFunction  (  )  ;  if  (  ownerFn  .  isInterface  (  )  &&  rightType  .  isFunctionType  (  )  &&  leftType  .  isFunctionType  (  )  )  {  return  true  ;  }  }  mismatch  (  t  ,  n  , "assignment  to  property "  +  propName  + "  of "  +  getReadableJSTypeName  (  owner  ,  true  )  ,  rightType  ,  leftType  )  ;  }  return  false  ;  }  return  true  ;  }  	Closure_6_TypeValidator_3_1	366	3	src/com/google/javascript/jscomp/TypeValidator.java
278		[BUGGY]  }  [FE]  AssertionFailedError:  expected:<2>  but  was:<1>  [METHOD]  expectCanAssignToPropertyOf  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  JSType  rightType  JSType  leftType  Node  owner  String  propName  [CLASS]  TypeValidator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  JSType  allValueTypes  leftType  nullOrUndefined  ownerType  rightType  typeA  typeB  [TYPE]  boolean  false  shouldReport  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  DUP_VAR_DECLARATION  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_PROPERTY_MISMATCH  ILLEGAL_PROPERTY_ACCESS  INTERFACE_METHOD_NOT_IMPLEMENTED  INVALID_CAST  MISSING_EXTENDS_TAG_WARNING  TYPE_MISMATCH_WARNING  UNKNOWN_TYPEOF_VALUE  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  Node  n  owner  [TYPE]  FunctionType  ownerFn  [TYPE]  List  mismatches  [TYPE]  String  FOUND_REQUIRED  propName  [TYPE]  JSError  src  [CONTEXT]  boolean  expectCanAssignToPropertyOf  (  NodeTraversal  t  ,  Node  n  ,  JSType  rightType  ,  JSType  leftType  ,  Node  owner  ,  String  propName  )  {  if  (  !leftType  .  isNoType  (  )  &&  !rightType  .  canAssignTo  (  leftType  )  )  {  if  (  (  leftType  .  isConstructor  (  )  ||  leftType  .  isEnumType  (  )  )  &&  (  rightType  .  isConstructor  (  )  ||  rightType  .  isEnumType  (  )  )  )  {  registerMismatch  (  rightType  ,  leftType  ,  null  )  ;  }  else  {  JSType  ownerType  =  getJSType  (  owner  )  ;  if  (  ownerType  .  isFunctionPrototypeType  (  )  )  {  FunctionType  ownerFn  =  ownerType  .  toObjectType  (  )  .  getOwnerFunction  (  )  ;  if  (  ownerFn  .  isInterface  (  )  &&  rightType  .  isFunctionType  (  )  &&  leftType  .  isFunctionType  (  )  )  {  return  true  ;  }  }  mismatch  (  t  ,  n  , "assignment  to  property "  +  propName  + "  of "  +  getReadableJSTypeName  (  owner  ,  true  )  ,  rightType  ,  leftType  )  ;  [BUGGY]  }  return  false  ;  }  return  true  ;  }  	Closure_6_TypeValidator_3_2	385	1	src/com/google/javascript/jscomp/TypeValidator.java
279		[BUGGY]  if  (  (  leftType  .  isConstructor  (  )  ||  leftType  .  isEnumType  (  )  )  &&  (  rightType  .  isConstructor  (  )  ||  rightType  .  isEnumType  (  )  )  )  {  registerMismatch  (  rightType  ,  leftType  ,  null  )  ;  }  else  {  }  [FE]  AssertionFailedError:  expected:<2>  but  was:<1>  [METHOD]  expectCanAssignTo  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  JSType  rightType  JSType  leftType  String  msg  [CLASS]  TypeValidator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  JSType  allValueTypes  leftType  nullOrUndefined  rightType  typeA  typeB  [TYPE]  boolean  false  shouldReport  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  DUP_VAR_DECLARATION  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_PROPERTY_MISMATCH  ILLEGAL_PROPERTY_ACCESS  INTERFACE_METHOD_NOT_IMPLEMENTED  INVALID_CAST  MISSING_EXTENDS_TAG_WARNING  TYPE_MISMATCH_WARNING  UNKNOWN_TYPEOF_VALUE  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  Node  n  [TYPE]  List  mismatches  [TYPE]  String  FOUND_REQUIRED  msg  [TYPE]  JSError  src  [CONTEXT]  boolean  expectCanAssignTo  (  NodeTraversal  t  ,  Node  n  ,  JSType  rightType  ,  JSType  leftType  ,  String  msg  )  {  if  (  !rightType  .  canAssignTo  (  leftType  )  )  {  [BUGGY]  if  (  (  leftType  .  isConstructor  (  )  ||  leftType  .  isEnumType  (  )  )  &&  (  rightType  .  isConstructor  (  )  ||  rightType  .  isEnumType  (  )  )  )  {  registerMismatch  (  rightType  ,  leftType  ,  null  )  ;  }  else  {  mismatch  (  t  ,  n  ,  msg  ,  rightType  ,  leftType  )  ;  }  return  false  ;  }  return  true  ;  }  	Closure_6_TypeValidator_3_3	405	4	src/com/google/javascript/jscomp/TypeValidator.java
280	if  (resultEqualsValue)  {  return  ctorType.getGreatestSubtype(type);  }  else  {  return  type.isSubtype(ctorType)  ?  null  :  type;  }  	[BUGGY]  return  resultEqualsValue  &&  ctorType  .  isSubtype  (  type  )  ?  ctorType  :  null  ;  [FE]  AssertionFailedError:  Expected:  (  Object|boolean|number|string  )  [METHOD]  caseObjectType  [TYPE]  JSType  [PARAMETER]  ObjectType  type  [CLASS]  RestrictByOneTypeOfResultVisitor  [TYPE]  ObjectType  type  [TYPE]  boolean  false  resultEqualsValue  true  [TYPE]  String  value  [TYPE]  JSType  ctorType  [CONTEXT]  public  JSType  caseObjectType  (  ObjectType  type  )  {  if  (  value  .  equals  ( "function "  )  )  {  JSType  ctorType  =  getNativeType  (  U2U_CONSTRUCTOR_TYPE  )  ;  [BUGGY]  return  resultEqualsValue  &&  ctorType  .  isSubtype  (  type  )  ?  ctorType  :  null  ;  }  return  matchesExpectation  ( "object "  )  ?  type  :  null  ;  }  	Closure_7_ChainableReverseAbstractInterpreter_1_1	613	1	src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java
281	&&  !isNamedParameter(var)  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  canBeRedeclared  [TYPE]  boolean  [PARAMETER]  Node  n  Scope  s  [CLASS]  GatherCollapses  [TYPE]  Set  blacklistedVars  [TYPE]  boolean  false  true  [TYPE]  Scope  s  [TYPE]  Var  var  [TYPE]  Node  assign  lhs  n  [CONTEXT]  private  boolean  canBeRedeclared  (  Node  n  ,  Scope  s  )  {  if  (  !NodeUtil  .  isExprAssign  (  n  )  )  {  return  false  ;  }  Node  assign  =  n  .  getFirstChild  (  )  ;  Node  lhs  =  assign  .  getFirstChild  (  )  ;  if  (  !lhs  .  isName  (  )  )  {  return  false  ;  }  Var  var  =  s  .  getVar  (  lhs  .  getString  (  )  )  ;  return  var  !  =  null  &&  var  .  getScope  (  )  =  =  s  [BUGGY]  &&  !blacklistedVars  .  contains  (  var  )  ;  }  	Closure_8_CollapseVariableDeclarations_2_1	204	0	src/com/google/javascript/jscomp/CollapseVariableDeclarations.java
282	private  boolean  isNamedParameter(Var  v)  {  return  v.getParentNode().isParamList();  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_8_CollapseVariableDeclarations_2_2	208	0	src/com/google/javascript/jscomp/CollapseVariableDeclarations.java
283	filename  =  filename.replace( "\\\\ ", "/ ");  	[BUGGY]  [FE]  ComparisonFailure:  expected:<module$[]baz>  but  was:<module$[foo  assertEquals  ( "module$bar$baz "  ,  [METHOD]  normalizeSourceName  [TYPE]  String  [PARAMETER]  String  filename  [CLASS]  ProcessCommonJSModules  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  reportDependencies  true  [TYPE]  Set  modulesWithExports  [TYPE]  JSModule  module  [TYPE]  String  DEFAULT_FILENAME_PREFIX  EXPORTS  MODULE_NAME_PREFIX  MODULE_NAME_SEPARATOR  MODULE_SLASH  filename  filenamePrefix  suffix  [TYPE]  int  scriptNodeCount  [CONTEXT]  private  String  normalizeSourceName  (  String  filename  )  {  [BUGGY]  if  (  filename  .  indexOf  (  filenamePrefix  )  =  =  0  )  {  filename  =  filename  .  substring  (  filenamePrefix  .  length  (  )  )  ;  }  return  filename  ;  }  	Closure_9_ProcessCommonJSModules_2_1	119	0	src/com/google/javascript/jscomp/ProcessCommonJSModules.java
284	String  moduleName  =  guessCJSModuleName(script.getSourceFileName());  	[BUGGY]  String  moduleName  =  guessCJSModuleName  (  normalizeSourceName  (  script  .  getSourceFileName  (  )  )  )  ;  [FE]  ComparisonFailure:  expected:<module$[]baz>  but  was:<module$[foo  assertEquals  ( "module$bar$baz "  ,  [METHOD]  visitScript  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  script  [CLASS]  ProcessCommonJsModulesCallback  [TYPE]  CompilerInput  ci  [TYPE]  Set  modulesWithExports  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  script  [TYPE]  JSModule  m  [TYPE]  String  moduleName  [TYPE]  int  scriptNodeCount  [CONTEXT]  private  void  visitScript  (  NodeTraversal  t  ,  Node  script  )  {  Preconditions  .  checkArgument  (  scriptNodeCount  =  =  1  , "ProcessCommonJSModules  supports  only  one  invocation  per "  + "CompilerInput  /  script  node "  )  ;  [BUGGY]  String  moduleName  =  guessCJSModuleName  (  normalizeSourceName  (  script  .  getSourceFileName  (  )  )  )  ;  script  .  addChildToFront  (  IR  .  var  (  IR  .  name  (  moduleName  )  ,  IR  .  objectlit  (  )  )  .  copyInformationFromForTree  (  script  )  )  ;  if  (  reportDependencies  )  {  CompilerInput  ci  =  t  .  getInput  (  )  ;  ci  .  addProvide  (  moduleName  )  ;  JSModule  m  =  new  JSModule  (  moduleName  )  ;  m  .  addAndOverrideModule  (  ci  )  ;  module  =  m  ;  }  script  .  addChildToFront  (  IR  .  exprResult  (  IR  .  call  (  IR  .  getprop  (  IR  .  name  ( "goog "  )  ,  IR  .  string  ( "provide "  )  )  ,  IR  .  string  (  moduleName  )  )  )  .  copyInformationFromForTree  (  script  )  )  ;  emitOptionalModuleExportsOverride  (  script  ,  moduleName  )  ;  NodeTraversal  .  traverse  (  compiler  ,  script  ,  new  SuffixVarsCallback  (  moduleName  )  )  ;  compiler  .  reportCodeChange  (  )  ;  }  	Closure_9_ProcessCommonJSModules_2_2	183	1	src/com/google/javascript/jscomp/ProcessCommonJSModules.java
285	return  anyResultsMatch(n,  MAY_BE_STRING_PREDICATE);  	[BUGGY]  return  allResultsMatch  (  n  ,  MAY_BE_STRING_PREDICATE  )  ;  [FE]  AssertionFailedError:  [METHOD]  mayBeString  [TYPE]  boolean  [PARAMETER]  Node  n  boolean  recurse  [CLASS]  NodeUtil  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  recurse  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  Node  n  [TYPE]  char  LARGEST_BASIC_LATIN  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  Map  vars  [TYPE]  long  MAX_POSITIVE_INTEGER_NUMBER  [TYPE]  int  type  [TYPE]  Predicate  MATCH_NOT_FUNCTION  [CONTEXT]  static  boolean  mayBeString  (  Node  n  ,  boolean  recurse  )  {  if  (  recurse  )  {  [BUGGY]  return  allResultsMatch  (  n  ,  MAY_BE_STRING_PREDICATE  )  ;  }  else  {  return  mayBeStringHelper  (  n  )  ;  }  }  	Closure_10_NodeUtil_1_1	1417	1	src/com/google/javascript/jscomp/NodeUtil.java
286		[BUGGY]  }  else  if  (  n  .  getJSType  (  )  !  =  null  &&  parent  .  isAssign  (  )  )  {  return  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  visitGetProp  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  TypeCheck  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  childType  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  CheckLevel  reportMissingOverride  reportUnknownTypes  [TYPE]  Node  n  objNode  parent  property  [TYPE]  ScopeCreator  scopeCreator  [TYPE]  String  OVERRIDING_PROTOTYPE_WITH_NON_OBJECT  [TYPE]  int  noTypeCheckSection  nullCount  typedCount  unknownCount  [TYPE]  TypeValidator  validator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  false  inExterns  reportMissingProperties  true  [TYPE]  Scope  topScope  [TYPE]  DiagnosticType  BAD_DELETE  BAD_IMPLEMENTED_TYPE  BIT_OPERATION  CONFLICTING_EXTENDED_TYPE  CONFLICTING_IMPLEMENTED_TYPE  CONSTRUCTOR_NOT_CALLABLE  DETERMINISTIC_TEST  DETERMINISTIC_TEST_NO_RESULT  ENUM_DUP  ENUM_NOT_CONSTANT  EXPECTED_THIS_TYPE  FUNCTION_MASKS_VARIABLE  HIDDEN_INTERFACE_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY_MISMATCH  ILLEGAL_IMPLICIT_CAST  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE  INEXISTENT_ENUM_ELEMENT  INEXISTENT_PROPERTY  INTERFACE_FUNCTION_NOT_EMPTY  INTERFACE_METHOD_OVERRIDE  INVALID_INTERFACE_MEMBER_DECLARATION  MULTIPLE_VAR_DEF  NOT_A_CONSTRUCTOR  NOT_CALLABLE  UNEXPECTED_TOKEN  UNKNOWN_EXPR_TYPE  UNKNOWN_OVERRIDE  UNRESOLVED_TYPE  WRONG_ARGUMENT_COUNT  [TYPE]  InferJSDocInfo  inferJSDocInfo  [CONTEXT]  private  void  visitGetProp  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  Node  property  =  n  .  getLastChild  (  )  ;  Node  objNode  =  n  .  getFirstChild  (  )  ;  JSType  childType  =  getJSType  (  objNode  )  ;  if  (  childType  .  isDict  (  )  )  {  report  (  t  ,  property  ,  TypeValidator  .  ILLEGAL_PROPERTY_ACCESS  , "'  .  ' "  , "dict "  )  ;  [BUGGY]  }  else  if  (  n  .  getJSType  (  )  !  =  null  &&  parent  .  isAssign  (  )  )  {  return  ;  }  else  if  (  validator  .  expectNotNullOrUndefined  (  t  ,  n  ,  childType  , "No  properties  on  this  expression "  ,  getNativeType  (  OBJECT_TYPE  )  )  )  {  checkPropertyAccess  (  childType  ,  property  .  getString  (  )  ,  t  ,  n  )  ;  }  ensureTyped  (  t  ,  n  )  ;  }  	Closure_11_TypeCheck_1_1	1314	2	src/com/google/javascript/jscomp/TypeCheck.java
287	List<DiGraphEdge<Node,  Branch>>  branchEdges  =  getCfg().getOutEdges(cfgNode);  for  (DiGraphEdge<Node,  Branch>  edge  :  branchEdges)  {  if  (edge.getValue()  ==  Branch.ON_EX)  {  return  true;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  hasExceptionHandler  [TYPE]  boolean  [PARAMETER]  Node  cfgNode  [CLASS]  MaybeReachingVariableUse  [TYPE]  Multimap  mayUseMap  [TYPE]  Set  escaped  [TYPE]  boolean  false  true  [TYPE]  Scope  jsScope  [TYPE]  Node  cfgNode  [CONTEXT]  private  boolean  hasExceptionHandler  (  Node  cfgNode  )  {  [BUGGY]  return  false  ;  }  	Closure_12_MaybeReachingVariableUse_1_1	160	0	src/com/google/javascript/jscomp/MaybeReachingVariableUse.java
288	traverse(c);  	[BUGGY]  traverse  (  c  )  ;  [FE]  AssertionFailedError:  [METHOD]  traverse  [TYPE]  void  [PARAMETER]  Node  node  [CLASS]  PeepholeOptimizationsPass  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  changed  false  traverseChildScopes  true  [TYPE]  AbstractPeepholeOptimization[]  peepholeOptimizations  [TYPE]  Node  c  next  node  [TYPE]  ArrayList  states  [TYPE]  int  currentDepth  visits  [TYPE]  StateStack  traversalState  [CONTEXT]  private  void  traverse  (  Node  node  )  {  if  (  !shouldVisit  (  node  )  )  {  return  ;  }  int  visits  =  0  ;  do  {  Node  c  =  node  .  getFirstChild  (  )  ;  while  (  c  !  =  null  )  {  [BUGGY]  traverse  (  c  )  ;  Node  next  =  c  .  getNext  (  )  ;  c  =  next  ;  }  visit  (  node  )  ;  visits++  ;  Preconditions  .  checkState  (  visits  <  10000  , "too  many  interations "  )  ;  }  while  (  shouldRetraverse  (  node  )  )  ;  exitNode  (  node  )  ;  }  	Closure_13_PeepholeOptimizationsPass_1_1	126	1	src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java
289	cfa.createEdge(fromNode,  Branch.ON_EX,  finallyNode);  	[BUGGY]  cfa  .  createEdge  (  fromNode  ,  Branch  .  UNCOND  ,  finallyNode  )  ;  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_MISSING_RETURN_STATEMENT  Missing  return  statement  Function  expected  to  return  number  at  testcode  line  1  :  24  expected:<0>  but  was:<1>  [METHOD]  computeFollowNode  [TYPE]  Node  [PARAMETER]  Node  fromNode  Node  node  ControlFlowAnalysis  cfa  [CLASS]  ControlFlowAnalysis  [TYPE]  Multimap  finallyMap  [TYPE]  AbstractCompiler  compiler  [TYPE]  ControlFlowAnalysis  cfa  [TYPE]  boolean  edgeAnnotations  false  shouldTraverseFunctions  true  [TYPE]  ControlFlowGraph  cfg  [TYPE]  Node  finallyNode  fromNode  nextSibling  node  parent  root  [TYPE]  Map  astPosition  nodePriorities  priorities  [TYPE]  Deque  exceptionHandler  [TYPE]  int  astPositionCounter  priorityCounter  [TYPE]  Comparator  priorityComparator  [CONTEXT]  }  else  {  return  parent  .  getFirstChild  (  )  .  getNext  (  )  .  getNext  (  )  ;  }  case  Token  .  WHILE:  case  Token  .  DO:  return  parent  ;  case  Token  .  TRY:  if  (  parent  .  getFirstChild  (  )  =  =  node  )  {  if  (  NodeUtil  .  hasFinally  (  parent  )  )  {  //  and  have  FINALLY  block  .  return  computeFallThrough  (  parent  .  getLastChild  (  )  )  ;  }  else  {  //  and  have  no  FINALLY  .  return  computeFollowNode  (  fromNode  ,  parent  ,  cfa  )  ;  }  }  else  if  (  NodeUtil  .  getCatchBlock  (  parent  )  =  =  node  )  {  if  (  NodeUtil  .  hasFinally  (  parent  )  )  {  //  and  have  FINALLY  block  .  return  computeFallThrough  (  node  .  getNext  (  )  )  ;  }  else  {  return  computeFollowNode  (  fromNode  ,  parent  ,  cfa  )  ;  }  }  else  if  (  parent  .  getLastChild  (  )  =  =  node  )  {  if  (  cfa  !  =  null  )  {  for  (  Node  finallyNode  :  cfa  .  finallyMap  .  get  (  parent  )  )  {  [BUGGY]  cfa  .  createEdge  (  fromNode  ,  Branch  .  UNCOND  ,  finallyNode  )  ;  }  }  return  computeFollowNode  (  fromNode  ,  parent  ,  cfa  )  ;  }  }  	Closure_14_ControlFlowAnalysis_1_1	767	1	src/com/google/javascript/jscomp/ControlFlowAnalysis.java
290	if  (n.isDelProp())  {  return  true;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  apply  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  1  [TYPE]  boolean  false  true  [TYPE]  Node  c  n  [CONTEXT]  public  boolean  apply  (  Node  n  )  {  if  (  n  =  =  null  )  {  return  false  ;  }  if  (  n  .  isCall  (  )  &&  NodeUtil  .  functionCallHasSideEffects  (  n  )  )  {  return  true  ;  }  if  (  n  .  isNew  (  )  &&  NodeUtil  .  constructorCallHasSideEffects  (  n  )  )  {  return  true  ;  }  [BUGGY]  for  (  Node  c  =  n  .  getFirstChild  (  )  ;  c  !  =  null  ;  c  =  c  .  getNext  (  )  )  {  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  c  )  &&  apply  (  c  )  )  {  return  true  ;  }  }  return  false  ;  }  	Closure_15_FlowSensitiveInlineVariables_1_1	102	0	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
291	private  final  Node  aliasDefinition;  AliasedTypeNode(Node  typeReference,  Node  aliasDefinition,  this.aliasDefinition  =  aliasDefinition;  	[BUGGY]  AliasedTypeNode  (  Node  typeReference  ,  [FE]  AssertionFailedError:  Expected  no  warnings  or  errors  [CLASS]  [CONTEXT]  	Closure_16_ScopedAliases_3_1	170	1	src/com/google/javascript/jscomp/ScopedAliases.java
292	String  typeName  =  typeReference.getString();  String  aliasExpanded  =  Preconditions.checkNotNull(aliasDefinition.getQualifiedName());  Preconditions.checkState(typeName.startsWith(aliasName));  typeReference.setString(typeName.replaceFirst(aliasName,  aliasExpanded));  	[BUGGY]  typeReference  .  setString  (  aliasName  )  ;  [FE]  AssertionFailedError:  Expected  no  warnings  or  errors  [METHOD]  applyAlias  [TYPE]  void  [PARAMETER]  [CLASS]  AliasedTypeNode  [TYPE]  Node  typeReference  [TYPE]  String  aliasName  [TYPE]  boolean  false  true  [CONTEXT]  public  void  applyAlias  (  )  {  [BUGGY]  typeReference  .  setString  (  aliasName  )  ;  }  	Closure_16_ScopedAliases_3_2	180	1	src/com/google/javascript/jscomp/ScopedAliases.java
293	aliasUsages.add(new  AliasedTypeNode(typeNode,  aliasedNode,  baseName));  	[BUGGY]  aliasUsages  .  add  (  new  AliasedTypeNode  (  typeNode  ,  aliasedNode  .  getQualifiedName  (  )  +  name  .  substring  (  endIndex  )  )  )  ;  [FE]  AssertionFailedError:  Expected  no  warnings  or  errors  [METHOD]  fixTypeNode  [TYPE]  void  [PARAMETER]  Node  typeNode  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  true  [TYPE]  Var  aliasVar  [TYPE]  Node  aliasedNode  child  typeNode  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  baseName  name  [TYPE]  Map  aliases  [TYPE]  int  endIndex  [CONTEXT]  private  void  fixTypeNode  (  Node  typeNode  )  {  if  (  typeNode  .  isString  (  )  )  {  String  name  =  typeNode  .  getString  (  )  ;  int  endIndex  =  name  .  indexOf  (  '  .  '  )  ;  if  (  endIndex  =  =  -1  )  {  endIndex  =  name  .  length  (  )  ;  }  String  baseName  =  name  .  substring  (  0  ,  endIndex  )  ;  Var  aliasVar  =  aliases  .  get  (  baseName  )  ;  if  (  aliasVar  !  =  null  )  {  Node  aliasedNode  =  aliasVar  .  getInitialValue  (  )  ;  [BUGGY]  aliasUsages  .  add  (  new  AliasedTypeNode  (  typeNode  ,  aliasedNode  .  getQualifiedName  (  )  +  name  .  substring  (  endIndex  )  )  )  ;  }  }  for  (  Node  child  =  typeNode  .  getFirstChild  (  )  ;  child  !  =  null  ;  child  =  child  .  getNext  (  )  )  {  fixTypeNode  (  child  )  ;  }  }  	Closure_16_ScopedAliases_3_3	468	1	src/com/google/javascript/jscomp/ScopedAliases.java
294	JSDocInfo  rValueInfo  =  rValue.getJSDocInfo();  if  (rValueInfo  !=  null  &&  rValueInfo.hasType())  {  return  rValueInfo.getType().evaluate(scope,  typeRegistry);  }  else  if  (rValue.getJSType()  !=  null  &&  !rValue.getJSType().isUnknownType())  {\n', "    	[BUGGY]  if  (  rValue  .  getJSType  (  )  !  =  null  &&  !rValue  .  getJSType  (  )  .  isUnknownType  (  )  )  {  [FE]  ComparisonFailure:  expected:<in[consistent  return  type  [METHOD]  getDeclaredType  [TYPE]  JSType  [PARAMETER]  String  sourceName  JSDocInfo  info  Node  lValue  Node  rValue  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  thisType  [TYPE]  JSType  knownType  [TYPE]  boolean  false  namesMatch  true  [TYPE]  Scope  scope  [TYPE]  Node  firstClause  lValue  rValue  secondClause  [TYPE]  InputId  inputId  [TYPE]  List  deferredSetTypes  lentObjectLiterals  nonExternFunctions  stubDeclarations  [TYPE]  String  sourceName  [TYPE]  JSDocInfo  info  [CONTEXT]  private  JSType  getDeclaredType  (  String  sourceName  ,  JSDocInfo  info  ,  Node  lValue  ,  @Nullable  Node  rValue  )  {  if  (  info  !  =  null  &&  info  .  hasType  (  )  )  {  return  getDeclaredTypeInAnnotation  (  sourceName  ,  lValue  ,  info  )  ;  }  else  if  (  rValue  !  =  null  &&  rValue  .  isFunction  (  )  &&  shouldUseFunctionLiteralType  (  JSType  .  toMaybeFunctionType  (  rValue  .  getJSType  (  )  )  ,  info  ,  lValue  )  )  {  return  rValue  .  getJSType  (  )  ;  }  else  if  (  info  !  =  null  )  {  if  (  info  .  hasEnumParameterType  (  )  )  {  if  (  rValue  !  =  null  &&  rValue  .  isObjectLit  (  )  )  {  return  rValue  .  getJSType  (  )  ;  }  else  {  return  createEnumTypeFromNodes  (  rValue  ,  lValue  .  getQualifiedName  (  )  ,  info  ,  lValue  )  ;  }  }  else  if  (  info  .  isConstructor  (  )  ||  info  .  isInterface  (  )  )  {  return  createFunctionTypeFromNodes  (  rValue  ,  lValue  .  getQualifiedName  (  )  ,  info  ,  lValue  )  ;  }  else  {  if  (  info  .  isConstant  (  )  )  {  JSType  knownType  =  null  ;  if  (  rValue  !  =  null  )  {  [BUGGY]  if  (  rValue  .  getJSType  (  )  !  =  null  &&  !rValue  .  getJSType  (  )  .  isUnknownType  (  )  )  {  return  rValue  .  getJSType  (  )  ;  }  else  if  (  rValue  .  isOr  (  )  )  {  	Closure_17_TypedScopeCreator_1_1	1291	1	src/com/google/javascript/jscomp/TypedScopeCreator.java
295	if  (options.dependencyOptions.needsManagement())  {  	[BUGGY]  if  (  options  .  dependencyOptions  .  needsManagement  (  )  &&  options  .  closurePass  )  {  [FE]  AssertionFailedError:  [METHOD]  parseInputs  [TYPE]  Node  [PARAMETER]  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  n  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  CONFIG_RESOURCE  SINGLETON_MODULE_NAME  SYNTHETIC_EXTERNS  currentPassName  externExports  provide  [TYPE]  LifeCycleStage  lifeCycleStage  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  GlobalVarReferenceMap  globalRefMap  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MISSING_ENTRY_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  inputs  modules  [TYPE]  CircularDependencyException  e  [TYPE]  WarningsGuard  warningsGuard  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  SourceInformationAnnotator  sia  [TYPE]  double  progress  [TYPE]  Tracer  currentTracer  tracer  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  syntheticCodeId  uniqueNameId  [TYPE]  CompilerInput  input  synthesizedExternsInput  [TYPE]  boolean  devMode  false  hasRegExpGlobalReferences  staleInputs  true  useThreads  [TYPE]  MissingProvideException  e  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  injectedLibraries  inputsById  [CONTEXT]  tracker  =  new  PerformanceTracker  (  jsRoot  ,  options  .  tracer  )  ;  addChangeHandler  (  tracker  .  getCodeChangeHandler  (  )  )  ;  }  Tracer  tracer  =  newTracer  ( "parseInputs "  )  ;  try  {  for  (  CompilerInput  input  :  externs  )  {  Node  n  =  input  .  getAstRoot  (  this  )  ;  if  (  hasErrors  (  )  )  {  return  null  ;  }  externsRoot  .  addChildToBack  (  n  )  ;  }  if  (  options  .  transformAMDToCJSModules  ||  options  .  processCommonJSModules  )  {  processAMDAndCommonJSModules  (  )  ;  }  hoistExterns  (  externsRoot  )  ;  boolean  staleInputs  =  false  ;  [BUGGY]  if  (  options  .  dependencyOptions  .  needsManagement  (  )  &&  options  .  closurePass  )  {  for  (  CompilerInput  input  :  inputs  )  {  for  (  String  provide  :  input  .  getProvides  (  )  )  {  getTypeRegistry  (  )  .  forwardDeclareType  (  provide  )  ;  	Closure_18_Compiler_1_1	1288	1	src/com/google/javascript/jscomp/Compiler.java
296	case  Token.THIS:  break;  	[BUGGY]  [FE]  IllegalArgumentException:  Node  cannot  be  refined  [METHOD]  declareNameInScope  [TYPE]  void  [PARAMETER]  FlowScope  scope  Node  node  JSType  type  [CLASS]  ChainableReverseAbstractInterpreter  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  false  resultEqualsValue  true  [TYPE]  JSType  origType  type  [TYPE]  Visitor  restrictNullVisitor  restrictUndefinedVisitor  [TYPE]  ChainableReverseAbstractInterpreter  firstLink  nextLink  [TYPE]  CodingConvention  convention  [TYPE]  Node  node  [TYPE]  String  qualifiedName  value  [TYPE]  FlowScope  scope  [CONTEXT]  protected  void  declareNameInScope  (  FlowScope  scope  ,  Node  node  ,  JSType  type  )  {  switch  (  node  .  getType  (  )  )  {  case  Token  .  NAME:  scope  .  inferSlotType  (  node  .  getString  (  )  ,  type  )  ;  break  ;  case  Token  .  GETPROP:  String  qualifiedName  =  node  .  getQualifiedName  (  )  ;  Preconditions  .  checkNotNull  (  qualifiedName  )  ;  JSType  origType  =  node  .  getJSType  (  )  ;  origType  =  origType  =  =  null  ?  getNativeType  (  UNKNOWN_TYPE  )  :  origType  ;  scope  .  inferQualifiedSlot  (  node  ,  qualifiedName  ,  origType  ,  type  )  ;  break  ;  [BUGGY]  default:  throw  new  IllegalArgumentException  ( "Node  cannot  be  refined  .  \n "  +  node  .  toStringTree  (  )  )  ;  }  }  	Closure_19_ChainableReverseAbstractInterpreter_1_1	172	0	src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java
297	if  (value  !=  null  &&  value.getNext()  ==  null  &&  NodeUtil.isImmutableValue(value))  {  	[BUGGY]  if  (  value  !  =  null  )  {  [FE]  AssertionFailedError:  [METHOD]  tryFoldSimpleFunctionCall  [TYPE]  Node  [PARAMETER]  Node  n  [CLASS]  PeepholeSubstituteAlternateSyntax  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  [TYPE]  boolean  false  late  true  [TYPE]  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  [TYPE]  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  [TYPE]  Node  addition  callTarget  n  value  [TYPE]  int  AND_PRECEDENCE  NOT_PRECEDENCE  OR_PRECEDENCE  STRING_SPLIT_OVERHEAD  [TYPE]  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  [CONTEXT]  private  Node  tryFoldSimpleFunctionCall  (  Node  n  )  {  Preconditions  .  checkState  (  n  .  isCall  (  )  )  ;  Node  callTarget  =  n  .  getFirstChild  (  )  ;  if  (  callTarget  !  =  null  &&  callTarget  .  isName  (  )  &&  callTarget  .  getString  (  )  .  equals  ( "String "  )  )  {  Node  value  =  callTarget  .  getNext  (  )  ;  [BUGGY]  if  (  value  !  =  null  )  {  Node  addition  =  IR  .  add  (  IR  .  string  ( " "  )  .  srcref  (  callTarget  )  ,  value  .  detachFromParent  (  )  )  ;  n  .  getParent  (  )  .  replaceChild  (  n  ,  addition  )  ;  reportCodeChange  (  )  ;  return  addition  ;  }  }  return  n  ;  }  	Closure_20_PeepholeSubstituteAlternateSyntax_1_1	220	1	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
298	if  (n.isExprResult()  ||  n.isBlock())  {  	[BUGGY]  if  (  n  .  isExprResult  (  )  )  {  [FE]  AssertionFailedError:  There  should  be  one  warning  ,  repeated  1  time  (  s  )  expected:<1>  but  was:<0>  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckSideEffects  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  isResultUsed  isSimpleOp  protectSideEffectFreeCode  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  USELESS_CODE_ERROR  [TYPE]  CheckLevel  level  [TYPE]  Node  an  n  parent  [TYPE]  List  problemNodes  [TYPE]  String  PROTECTOR_FN  msg  [TYPE]  int  ancestorType  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  isEmpty  (  )  ||  n  .  isComma  (  )  )  {  return  ;  }  if  (  parent  =  =  null  )  {  return  ;  }  [BUGGY]  if  (  n  .  isExprResult  (  )  )  {  return  ;  }  	Closure_21_CheckSideEffects_2_1	101	1	src/com/google/javascript/jscomp/CheckSideEffects.java
299	if  (!isResultUsed  &&  	[BUGGY]  if  (  parent  .  getType  (  )  =  =  Token  .  COMMA  )  {  if  (  isResultUsed  )  {  return  ;  }  if  (  n  =  =  parent  .  getLastChild  (  )  )  {  for  (  Node  an  :  parent  .  getAncestors  (  )  )  {  int  ancestorType  =  an  .  getType  (  )  ;  if  (  ancestorType  =  =  Token  .  COMMA  )  continue  ;  if  (  ancestorType  !  =  Token  .  EXPR_RESULT  &&  ancestorType  !  =  Token  .  BLOCK  )  return  ;  else  break  ;  }  }  }  else  if  (  parent  .  getType  (  )  !  =  Token  .  EXPR_RESULT  &&  parent  .  getType  (  )  !  =  Token  .  BLOCK  )  {  if  (  !  (  parent  .  getType  (  )  =  =  Token  .  FOR  &&  parent  .  getChildCount  (  )  =  =  4  &&  (  n  =  =  parent  .  getFirstChild  (  )  ||  n  =  =  parent  .  getFirstChild  (  )  .  getNext  (  )  .  getNext  (  )  )  )  )  {  return  ;  }  }  if  (  [FE]  AssertionFailedError:  There  should  be  one  warning  ,  repeated  1  time  (  s  )  expected:<1>  but  was:<0>  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckSideEffects  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  isResultUsed  isSimpleOp  protectSideEffectFreeCode  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  USELESS_CODE_ERROR  [TYPE]  CheckLevel  level  [TYPE]  Node  an  n  parent  [TYPE]  List  problemNodes  [TYPE]  String  PROTECTOR_FN  msg  [TYPE]  int  ancestorType  [CONTEXT]  if  (  n  .  isEmpty  (  )  ||  n  .  isComma  (  )  )  {  return  ;  }  if  (  parent  =  =  null  )  {  return  ;  }  if  (  n  .  isExprResult  (  )  )  {  return  ;  }  if  (  n  .  isQualifiedName  (  )  &&  n  .  getJSDocInfo  (  )  !  =  null  )  {  return  ;  }  boolean  isResultUsed  =  NodeUtil  .  isExpressionResultUsed  (  n  )  ;  boolean  isSimpleOp  =  NodeUtil  .  isSimpleOperatorType  (  n  .  getType  (  )  )  ;  [BUGGY]  if  (  parent  .  getType  (  )  =  =  Token  .  COMMA  )  {  if  (  isResultUsed  )  {  return  ;  }  if  (  n  =  =  parent  .  getLastChild  (  )  )  {  for  (  Node  an  :  parent  .  getAncestors  (  )  )  {  	Closure_21_CheckSideEffects_2_2	113	18	src/com/google/javascript/jscomp/CheckSideEffects.java
300	if  (n.isExprResult()  ||  n.isBlock())  {  	[BUGGY]  if  (  parent  .  getType  (  )  =  =  Token  .  COMMA  )  {  Node  gramps  =  parent  .  getParent  (  )  ;  if  (  gramps  .  isCall  (  )  &&  parent  =  =  gramps  .  getFirstChild  (  )  )  {  if  (  n  =  =  parent  .  getFirstChild  (  )  &&  parent  .  getChildCount  (  )  =  =  2  &&  n  .  getNext  (  )  .  isName  (  )  && "eval "  .  equals  (  n  .  getNext  (  )  .  getString  (  )  )  )  {  }  [FE]  AssertionFailedError:  There  should  be  one  warning  ,  repeated  1  time  (  s  )  expected:<1>  but  was:<0>  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckSideEffects  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  isResultUsed  isSimpleOp  protectSideEffectFreeCode  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  USELESS_CODE_ERROR  [TYPE]  CheckLevel  level  [TYPE]  Node  an  gramps  n  parent  [TYPE]  List  problemNodes  [TYPE]  String  PROTECTOR_FN  msg  [TYPE]  int  ancestorType  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  isEmpty  (  )  ||  n  .  isComma  (  )  )  {  return  ;  }  if  (  parent  =  =  null  )  {  return  ;  }  [BUGGY]  if  (  parent  .  getType  (  )  =  =  Token  .  COMMA  )  {  Node  gramps  =  parent  .  getParent  (  )  ;  if  (  gramps  .  isCall  (  )  &&  parent  =  =  gramps  .  getFirstChild  (  )  )  {  if  (  n  =  =  parent  .  getFirstChild  (  )  &&  parent  .  getChildCount  (  )  =  =  2  &&  n  .  getNext  (  )  .  isName  (  )  && "eval "  .  equals  (  n  .  getNext  (  )  .  getString  (  )  )  )  {  return  ;  }  	Closure_22_CheckSideEffects_3_1	101	5	src/com/google/javascript/jscomp/CheckSideEffects.java
301	if  (n.isQualifiedName()  &&  n.getJSDocInfo()  !=  null)  {  	[BUGGY]  if  (  n  =  =  parent  .  getLastChild  (  )  )  {  for  (  Node  an  :  parent  .  getAncestors  (  )  )  {  int  ancestorType  =  an  .  getType  (  )  ;  if  (  ancestorType  =  =  Token  .  COMMA  )  continue  ;  if  (  ancestorType  !  =  Token  .  EXPR_RESULT  &&  ancestorType  !  =  Token  .  BLOCK  )  return  ;  else  break  ;  }  }  }  else  if  (  parent  .  getType  (  )  !  =  Token  .  EXPR_RESULT  &&  parent  .  getType  (  )  !  =  Token  .  BLOCK  )  {  if  (  parent  .  getType  (  )  =  =  Token  .  FOR  &&  parent  .  getChildCount  (  )  =  =  4  &&  (  n  =  =  parent  .  getFirstChild  (  )  ||  n  =  =  parent  .  getFirstChild  (  )  .  getNext  (  )  .  getNext  (  )  )  )  {  }  else  {  }  [FE]  AssertionFailedError:  There  should  be  one  warning  ,  repeated  1  time  (  s  )  expected:<1>  but  was:<0>  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckSideEffects  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  isResultUsed  isSimpleOp  protectSideEffectFreeCode  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  USELESS_CODE_ERROR  [TYPE]  CheckLevel  level  [TYPE]  Node  an  gramps  n  parent  [TYPE]  List  problemNodes  [TYPE]  String  PROTECTOR_FN  msg  [TYPE]  int  ancestorType  [CONTEXT]  if  (  n  .  isEmpty  (  )  ||  n  .  isComma  (  )  )  {  return  ;  }  if  (  parent  =  =  null  )  {  return  ;  }  if  (  parent  .  getType  (  )  =  =  Token  .  COMMA  )  {  Node  gramps  =  parent  .  getParent  (  )  ;  if  (  gramps  .  isCall  (  )  &&  parent  =  =  gramps  .  getFirstChild  (  )  )  {  if  (  n  =  =  parent  .  getFirstChild  (  )  &&  parent  .  getChildCount  (  )  =  =  2  &&  n  .  getNext  (  )  .  isName  (  )  && "eval "  .  equals  (  n  .  getNext  (  )  .  getString  (  )  )  )  {  return  ;  }  }  [BUGGY]  if  (  n  =  =  parent  .  getLastChild  (  )  )  {  for  (  Node  an  :  parent  .  getAncestors  (  )  )  {  int  ancestorType  =  an  .  getType  (  )  ;  if  (  ancestorType  =  =  Token  .  COMMA  )  continue  ;  if  (  ancestorType  !  =  Token  .  EXPR_RESULT  &&  ancestorType  !  =  Token  .  BLOCK  )  	Closure_22_CheckSideEffects_3_2	111	16	src/com/google/javascript/jscomp/CheckSideEffects.java
302		[BUGGY]  if  (  n  .  isQualifiedName  (  )  &&  n  .  getJSDocInfo  (  )  !  =  null  )  {  return  ;  }  else  if  (  n  .  isExprResult  (  )  )  {  return  ;  }  [FE]  AssertionFailedError:  There  should  be  one  warning  ,  repeated  1  time  (  s  )  expected:<1>  but  was:<0>  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckSideEffects  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  isResultUsed  isSimpleOp  protectSideEffectFreeCode  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  USELESS_CODE_ERROR  [TYPE]  CheckLevel  level  [TYPE]  Node  an  gramps  n  parent  [TYPE]  List  problemNodes  [TYPE]  String  PROTECTOR_FN  msg  [TYPE]  int  ancestorType  [CONTEXT]  if  (  n  =  =  parent  .  getLastChild  (  )  )  {  for  (  Node  an  :  parent  .  getAncestors  (  )  )  {  int  ancestorType  =  an  .  getType  (  )  ;  if  (  ancestorType  =  =  Token  .  COMMA  )  continue  ;  if  (  ancestorType  !  =  Token  .  EXPR_RESULT  &&  ancestorType  !  =  Token  .  BLOCK  )  return  ;  else  break  ;  }  }  }  else  if  (  parent  .  getType  (  )  !  =  Token  .  EXPR_RESULT  &&  parent  .  getType  (  )  !  =  Token  .  BLOCK  )  {  if  (  parent  .  getType  (  )  =  =  Token  .  FOR  &&  parent  .  getChildCount  (  )  =  =  4  &&  (  n  =  =  parent  .  getFirstChild  (  )  ||  n  =  =  parent  .  getFirstChild  (  )  .  getNext  (  )  .  getNext  (  )  )  )  {  }  else  {  return  ;  }  }  boolean  isResultUsed  =  NodeUtil  .  isExpressionResultUsed  (  n  )  ;  boolean  isSimpleOp  =  NodeUtil  .  isSimpleOperatorType  (  n  .  getType  (  )  )  ;  if  (  !isResultUsed  &&  (  isSimpleOp  ||  !NodeUtil  .  mayHaveSideEffects  (  n  ,  t  .  getCompiler  (  )  )  )  )  {  [BUGGY]  if  (  n  .  isQualifiedName  (  )  &&  n  .  getJSDocInfo  (  )  !  =  null  )  {  return  ;  }  else  if  (  n  .  isExprResult  (  )  )  {  return  ;  }  String  msg  = "This  code  lacks  side-effects  .  Is  there  a  bug? "  ;  	Closure_22_CheckSideEffects_3_3	134	5	src/com/google/javascript/jscomp/CheckSideEffects.java
303	for  (int  i  =  0;  current  !=  null;  i++)  {  if  (i  !=  intIndex)  {  if  (mayHaveSideEffects(current))  {  return  n;  }  }  else  {  }  	[BUGGY]  for  (  int  i  =  0  ;  current  !  =  null  &&  i  <  intIndex  ;  i++  )  {  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_INDEX_OUT_OF_BOUNDS_ERROR  Array  index  out  of  bounds:  NUMBER  00  1  [source_file:  testcode]  at  testcode  line  1  :  10  expected:<0>  but  was:<1>  [METHOD]  tryFoldArrayAccess  [TYPE]  Node  [PARAMETER]  Node  n  Node  left  Node  right  [CLASS]  PeepholeFoldConstants  [TYPE]  boolean  false  late  true  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double  MAX_FOLD_NUMBER  index  [TYPE]  int  i  intIndex  [TYPE]  Node  current  elem  left  n  parent  right  [CONTEXT]  if  (  isAssignmentTarget  (  n  )  )  {  return  n  ;  }  if  (  !right  .  isNumber  (  )  )  {  return  n  ;  }  double  index  =  right  .  getDouble  (  )  ;  int  intIndex  =  (  int  )  index  ;  if  (  intIndex  !  =  index  )  {  error  (  INVALID_GETELEM_INDEX_ERROR  ,  right  )  ;  return  n  ;  }  if  (  intIndex  <  0  )  {  error  (  INDEX_OUT_OF_BOUNDS_ERROR  ,  right  )  ;  return  n  ;  }  Node  current  =  left  .  getFirstChild  (  )  ;  Node  elem  =  null  ;  [BUGGY]  for  (  int  i  =  0  ;  current  !  =  null  &&  i  <  intIndex  ;  i++  )  {  elem  =  current  ;  current  =  current  .  getNext  (  )  ;  }  	Closure_23_PeepholeFoldConstants_1_1	1451	1	src/com/google/javascript/jscomp/PeepholeFoldConstants.java
304	if  (parent.isVar()  &&  n.hasChildren()  &&  n.getFirstChild().isQualifiedName())  {  	[BUGGY]  if  (  parent  .  isVar  (  )  )  {  if  (  n  .  hasChildren  (  )  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  [FE]  AssertionFailedError:  There  should  be  one  error  expected:<1>  but  was:<0>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  boolean  false  hasErrors  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  v  [TYPE]  Node  n  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  qualifiedName  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  private  void  findAliases  (  NodeTraversal  t  )  {  Scope  scope  =  t  .  getScope  (  )  ;  for  (  Var  v  :  scope  .  getVarIterable  (  )  )  {  Node  n  =  v  .  getNode  (  )  ;  int  type  =  n  .  getType  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  [BUGGY]  if  (  parent  .  isVar  (  )  )  {  if  (  n  .  hasChildren  (  )  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  scope  .  getVar  (  name  )  ;  aliases  .  put  (  name  ,  aliasVar  )  ;  String  qualifiedName  =  aliasVar  .  getInitialValue  (  )  .  getQualifiedName  (  )  ;  transformation  .  addAlias  (  name  ,  qualifiedName  )  ;  }  else  {  report  (  t  ,  n  ,  GOOG_SCOPE_NON_ALIAS_LOCAL  ,  n  .  getString  (  )  )  ;  }  }  }  }  	Closure_24_ScopedAliases_3_1	278	2	src/com/google/javascript/jscomp/ScopedAliases.java
305	}  else  if  (v.isBleedingFunction())  {  }  else  if  (parent.getType()  ==  Token.LP)  {  	[BUGGY]  [FE]  AssertionFailedError:  There  should  be  one  error  expected:<1>  but  was:<0>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  boolean  false  hasErrors  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  v  [TYPE]  Node  n  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  qualifiedName  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  private  void  findAliases  (  NodeTraversal  t  )  {  Scope  scope  =  t  .  getScope  (  )  ;  for  (  Var  v  :  scope  .  getVarIterable  (  )  )  {  Node  n  =  v  .  getNode  (  )  ;  int  type  =  n  .  getType  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  if  (  parent  .  isVar  (  )  )  {  if  (  n  .  hasChildren  (  )  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  scope  .  getVar  (  name  )  ;  aliases  .  put  (  name  ,  aliasVar  )  ;  String  qualifiedName  =  aliasVar  .  getInitialValue  (  )  .  getQualifiedName  (  )  ;  transformation  .  addAlias  (  name  ,  qualifiedName  )  ;  [BUGGY]  }  else  {  report  (  t  ,  n  ,  GOOG_SCOPE_NON_ALIAS_LOCAL  ,  n  .  getString  (  )  )  ;  }  }  }  }  	Closure_24_ScopedAliases_3_2	287	0	src/com/google/javascript/jscomp/ScopedAliases.java
306		[BUGGY]  }  [FE]  AssertionFailedError:  There  should  be  one  error  expected:<1>  but  was:<0>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  boolean  false  hasErrors  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  v  [TYPE]  Node  n  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  qualifiedName  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  private  void  findAliases  (  NodeTraversal  t  )  {  Scope  scope  =  t  .  getScope  (  )  ;  for  (  Var  v  :  scope  .  getVarIterable  (  )  )  {  Node  n  =  v  .  getNode  (  )  ;  int  type  =  n  .  getType  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  if  (  parent  .  isVar  (  )  )  {  if  (  n  .  hasChildren  (  )  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  scope  .  getVar  (  name  )  ;  aliases  .  put  (  name  ,  aliasVar  )  ;  String  qualifiedName  =  aliasVar  .  getInitialValue  (  )  .  getQualifiedName  (  )  ;  transformation  .  addAlias  (  name  ,  qualifiedName  )  ;  }  else  {  report  (  t  ,  n  ,  GOOG_SCOPE_NON_ALIAS_LOCAL  ,  n  .  getString  (  )  )  ;  }  [BUGGY]  }  }  }  	Closure_24_ScopedAliases_3_3	295	1	src/com/google/javascript/jscomp/ScopedAliases.java
307	scope  =  traverseChildren(n,  scope);  	[BUGGY]  scope  =  traverse  (  constructor  ,  scope  )  ;  [FE]  ComparisonFailure:  expected:<{[foo:  (  number|undefined  )  ]}>  but  was:<{[]}>  assertEquals  ( "{foo:  (  number|undefined  )  } "  ,  getType  ( "y "  )  .  toString  (  )  )  ;  [METHOD]  traverseNew  [TYPE]  FlowScope  [PARAMETER]  Node  n  FlowScope  scope  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  JSType  constructorType  type  [TYPE]  boolean  false  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  [TYPE]  Node  arg  constructor  n  [TYPE]  FunctionType  ct  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  Map  assertionFunctionsMap  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  FlowScope  traverseNew  (  Node  n  ,  FlowScope  scope  )  {  [BUGGY]  Node  constructor  =  n  .  getFirstChild  (  )  ;  scope  =  traverse  (  constructor  ,  scope  )  ;  JSType  constructorType  =  constructor  .  getJSType  (  )  ;  JSType  type  =  null  ;  if  (  constructorType  !  =  null  )  {  constructorType  =  constructorType  .  restrictByNotNullOrUndefined  (  )  ;  if  (  constructorType  .  isUnknownType  (  )  )  {  type  =  getNativeType  (  UNKNOWN_TYPE  )  ;  }  else  {  FunctionType  ct  =  constructorType  .  toMaybeFunctionType  (  )  ;  if  (  ct  =  =  null  &&  constructorType  instanceof  FunctionType  )  {  ct  =  (  FunctionType  )  constructorType  ;  }  if  (  ct  !  =  null  &&  ct  .  isConstructor  (  )  )  {  type  =  ct  .  getInstanceType  (  )  ;  }  }  }  n  .  setJSType  (  type  )  ;  for  (  Node  arg  =  constructor  .  getNext  (  )  ;  arg  !  =  null  ;  arg  =  arg  .  getNext  (  )  )  {  scope  =  traverse  (  arg  ,  scope  )  ;  }  return  scope  ;  }  	Closure_25_TypeInference_3_1	1036	1	src/com/google/javascript/jscomp/TypeInference.java
308	backwardsInferenceFromCallSite(n,  ct);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[foo:  (  number|undefined  )  ]}>  but  was:<{[]}>  assertEquals  ( "{foo:  (  number|undefined  )  } "  ,  getType  ( "y "  )  .  toString  (  )  )  ;  [METHOD]  traverseNew  [TYPE]  FlowScope  [PARAMETER]  Node  n  FlowScope  scope  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  JSType  constructorType  type  [TYPE]  boolean  false  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  [TYPE]  Node  arg  constructor  n  [TYPE]  FunctionType  ct  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  Map  assertionFunctionsMap  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  FlowScope  traverseNew  (  Node  n  ,  FlowScope  scope  )  {  Node  constructor  =  n  .  getFirstChild  (  )  ;  scope  =  traverse  (  constructor  ,  scope  )  ;  JSType  constructorType  =  constructor  .  getJSType  (  )  ;  JSType  type  =  null  ;  if  (  constructorType  !  =  null  )  {  constructorType  =  constructorType  .  restrictByNotNullOrUndefined  (  )  ;  if  (  constructorType  .  isUnknownType  (  )  )  {  type  =  getNativeType  (  UNKNOWN_TYPE  )  ;  }  else  {  FunctionType  ct  =  constructorType  .  toMaybeFunctionType  (  )  ;  if  (  ct  =  =  null  &&  constructorType  instanceof  FunctionType  )  {  ct  =  (  FunctionType  )  constructorType  ;  }  if  (  ct  !  =  null  &&  ct  .  isConstructor  (  )  )  {  type  =  ct  .  getInstanceType  (  )  ;  [BUGGY]  }  }  }  n  .  setJSType  (  type  )  ;  for  (  Node  arg  =  constructor  .  getNext  (  )  ;  arg  !  =  null  ;  arg  =  arg  .  getNext  (  )  )  {  scope  =  traverse  (  arg  ,  scope  )  ;  }  return  scope  ;  }  	Closure_25_TypeInference_3_2	1055	0	src/com/google/javascript/jscomp/TypeInference.java
309		[BUGGY]  for  (  Node  arg  =  constructor  .  getNext  (  )  ;  arg  !  =  null  ;  arg  =  arg  .  getNext  (  )  )  {  scope  =  traverse  (  arg  ,  scope  )  ;  }  [FE]  ComparisonFailure:  expected:<{[foo:  (  number|undefined  )  ]}>  but  was:<{[]}>  assertEquals  ( "{foo:  (  number|undefined  )  } "  ,  getType  ( "y "  )  .  toString  (  )  )  ;  [METHOD]  traverseNew  [TYPE]  FlowScope  [PARAMETER]  Node  n  FlowScope  scope  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  JSType  constructorType  type  [TYPE]  boolean  false  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  [TYPE]  Node  arg  constructor  n  [TYPE]  FunctionType  ct  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  Map  assertionFunctionsMap  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  FlowScope  traverseNew  (  Node  n  ,  FlowScope  scope  )  {  Node  constructor  =  n  .  getFirstChild  (  )  ;  scope  =  traverse  (  constructor  ,  scope  )  ;  JSType  constructorType  =  constructor  .  getJSType  (  )  ;  JSType  type  =  null  ;  if  (  constructorType  !  =  null  )  {  constructorType  =  constructorType  .  restrictByNotNullOrUndefined  (  )  ;  if  (  constructorType  .  isUnknownType  (  )  )  {  type  =  getNativeType  (  UNKNOWN_TYPE  )  ;  }  else  {  FunctionType  ct  =  constructorType  .  toMaybeFunctionType  (  )  ;  if  (  ct  =  =  null  &&  constructorType  instanceof  FunctionType  )  {  ct  =  (  FunctionType  )  constructorType  ;  }  if  (  ct  !  =  null  &&  ct  .  isConstructor  (  )  )  {  type  =  ct  .  getInstanceType  (  )  ;  }  }  }  n  .  setJSType  (  type  )  ;  [BUGGY]  for  (  Node  arg  =  constructor  .  getNext  (  )  ;  arg  !  =  null  ;  arg  =  arg  .  getNext  (  )  )  {  scope  =  traverse  (  arg  ,  scope  )  ;  }  return  scope  ;  }  	Closure_25_TypeInference_3_3	1059	3	src/com/google/javascript/jscomp/TypeInference.java
310	private  Set<String>  modulesWithExports  =  Sets.newHashSet();  	[BUGGY]  [FE]  AssertionFailedError:  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [CLASS]  [CONTEXT]  	Closure_26_ProcessCommonJSModules_3_1	128	0	src/com/google/javascript/jscomp/ProcessCommonJSModules.java
311	if  (!modulesWithExports.contains(moduleName))  {  return;  }  	[BUGGY]  [FE]  AssertionFailedError:  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [METHOD]  emitOptionalModuleExportsOverride  [TYPE]  void  [PARAMETER]  Node  script  String  moduleName  [CLASS]  ProcessCommonJsModulesCallback  [TYPE]  String  moduleName  [TYPE]  boolean  false  true  [TYPE]  int  scriptNodeCount  [TYPE]  Node  moduleExportsProp  script  [CONTEXT]  private  void  emitOptionalModuleExportsOverride  (  Node  script  ,  String  moduleName  )  {  [BUGGY]  Node  moduleExportsProp  =  IR  .  getprop  (  IR  .  name  (  moduleName  )  ,  IR  .  string  ( "module$exports "  )  )  ;  script  .  addChildToBack  (  IR  .  ifNode  (  moduleExportsProp  ,  IR  .  block  (  IR  .  exprResult  (  IR  .  assign  (  IR  .  name  (  moduleName  )  ,  moduleExportsProp  .  cloneTree  (  )  )  )  )  )  .  copyInformationFromForTree  (  script  )  )  ;  }  	Closure_26_ProcessCommonJSModules_3_2	207	0	src/com/google/javascript/jscomp/ProcessCommonJSModules.java
312	modulesWithExports.add(moduleName);  	[BUGGY]  [FE]  AssertionFailedError:  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [CLASS]  [CONTEXT]  	Closure_26_ProcessCommonJSModules_3_3	228	0	src/com/google/javascript/jscomp/ProcessCommonJSModules.java
313	private  static  Node  blockUnchecked(Node  stmt)  {  return  new  Node(Token.BLOCK,  stmt);  }  	[BUGGY]  [FE]  IllegalStateException  [CLASS]  [CONTEXT]  	Closure_27_IR_3_1	111	0	src/com/google/javascript/rhino/IR.java
314	Preconditions.checkState(tryBody.isBlock());  Preconditions.checkState(finallyBody.isBlock());  	[BUGGY]  Preconditions  .  checkState  (  tryBody  .  isLabelName  (  )  )  ;  Preconditions  .  checkState  (  finallyBody  .  isLabelName  (  )  )  ;  [FE]  IllegalStateException  [METHOD]  tryFinally  [TYPE]  Node  [PARAMETER]  Node  tryBody  Node  finallyBody  [CLASS]  IR  [TYPE]  boolean  false  true  [TYPE]  Node  catchBody  finallyBody  tryBody  [CONTEXT]  public  static  Node  tryFinally  (  Node  tryBody  ,  Node  finallyBody  )  {  [BUGGY]  Preconditions  .  checkState  (  tryBody  .  isLabelName  (  )  )  ;  Preconditions  .  checkState  (  finallyBody  .  isLabelName  (  )  )  ;  Node  catchBody  =  block  (  )  .  copyInformationFrom  (  tryBody  )  ;  return  new  Node  (  Token  .  TRY  ,  tryBody  ,  catchBody  ,  finallyBody  )  ;  }  	Closure_27_IR_3_2	224	2	src/com/google/javascript/rhino/IR.java
315	Node  catchBody  =  blockUnchecked(catchNode).copyInformationFrom(catchNode);  	[BUGGY]  Node  catchBody  =  block  (  catchNode  )  .  copyInformationFrom  (  catchNode  )  ;  [FE]  IllegalStateException  [METHOD]  tryCatch  [TYPE]  Node  [PARAMETER]  Node  tryBody  Node  catchNode  [CLASS]  IR  [TYPE]  boolean  false  true  [TYPE]  Node  catchBody  catchNode  tryBody  [CONTEXT]  public  static  Node  tryCatch  (  Node  tryBody  ,  Node  catchNode  )  {  Preconditions  .  checkState  (  tryBody  .  isBlock  (  )  )  ;  Preconditions  .  checkState  (  catchNode  .  isCatch  (  )  )  ;  [BUGGY]  Node  catchBody  =  block  (  catchNode  )  .  copyInformationFrom  (  catchNode  )  ;  return  new  Node  (  Token  .  TRY  ,  tryBody  ,  catchBody  )  ;  }  	Closure_27_IR_3_3	233	1	src/com/google/javascript/rhino/IR.java
316	@Override  void  addConstant(String  newcode)  {  add( "0 ");  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<4>  assertEquals  (  example  .  length  (  )  ,  cost  (  source  )  )  ;  [CLASS]  [CONTEXT]  	Closure_28_InlineCostEstimator_1_1	102	0	src/com/google/javascript/jscomp/InlineCostEstimator.java
317	Set<String>  validProperties  =  Sets.newHashSet();  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isInlinableObject  [TYPE]  boolean  [PARAMETER]  Reference>  refs  [CLASS]  InliningBehavior  [TYPE]  List  refs  [TYPE]  Set  staleVars  [TYPE]  boolean  false  ret  true  [TYPE]  Reference  ref  t  [TYPE]  Node  child  childVal  gramps  name  parent  refNode  val  [CONTEXT]  private  boolean  isInlinableObject  (  List<Reference>  refs  )  {  boolean  ret  =  false  ;  [BUGGY]  for  (  Reference  ref  :  refs  )  {  Node  name  =  ref  .  getNode  (  )  ;  Node  parent  =  ref  .  getParent  (  )  ;  Node  gramps  =  ref  .  getGrandparent  (  )  ;  	Closure_29_InlineObjectLiterals_3_1	157	0	src/com/google/javascript/jscomp/InlineObjectLiterals.java
318	if  (!validProperties.contains(propName))  {  if  (NodeUtil.isVarOrSimpleAssignLhs(parent,  gramps))  {  validProperties.add(propName);  }  else  {  return  false;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isInlinableObject  [TYPE]  boolean  [PARAMETER]  Reference>  refs  [CLASS]  InliningBehavior  [TYPE]  List  refs  [TYPE]  Set  staleVars  [TYPE]  boolean  false  ret  true  [TYPE]  Reference  ref  t  [TYPE]  Node  child  childVal  gramps  name  parent  refNode  val  [CONTEXT]  boolean  ret  =  false  ;  for  (  Reference  ref  :  refs  )  {  Node  name  =  ref  .  getNode  (  )  ;  Node  parent  =  ref  .  getParent  (  )  ;  Node  gramps  =  ref  .  getGrandparent  (  )  ;  if  (  parent  .  isGetProp  (  )  )  {  Preconditions  .  checkState  (  parent  .  getFirstChild  (  )  =  =  name  )  ;  if  (  gramps  .  isCall  (  )  &&  gramps  .  getFirstChild  (  )  =  =  parent  )  {  return  false  ;  }  [BUGGY]  continue  ;  }  if  (  !isVarOrAssignExprLhs  (  name  )  )  {  return  false  ;  	Closure_29_InlineObjectLiterals_3_2	181	0	src/com/google/javascript/jscomp/InlineObjectLiterals.java
319	validProperties.add(child.getString());  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isInlinableObject  [TYPE]  boolean  [PARAMETER]  Reference>  refs  [CLASS]  InliningBehavior  [TYPE]  List  refs  [TYPE]  Set  staleVars  [TYPE]  boolean  false  ret  true  [TYPE]  Reference  ref  t  [TYPE]  Node  child  childVal  gramps  name  parent  refNode  val  [CONTEXT]  continue  ;  }  if  (  !val  .  isObjectLit  (  )  )  {  return  false  ;  }  for  (  Node  child  =  val  .  getFirstChild  (  )  ;  child  !  =  null  ;  child  =  child  .  getNext  (  )  )  {  if  (  child  .  isGetterDef  (  )  ||  child  .  isSetterDef  (  )  )  {  return  false  ;  }  [BUGGY]  Node  childVal  =  child  .  getFirstChild  (  )  ;  for  (  Reference  t  :  refs  )  {  	Closure_29_InlineObjectLiterals_3_3	216	0	src/com/google/javascript/jscomp/InlineObjectLiterals.java
320	(new  NodeTraversal(compiler,  this)).traverseRoots(externs,  root);  	[BUGGY]  (  new  NodeTraversal  (  compiler  ,  this  )  )  .  traverse  (  root  )  ;  [FE]  AssertionFailedError:  [METHOD]  process  [TYPE]  void  [PARAMETER]  Node  externs  Node  root  [CLASS]  FlowSensitiveInlineVariables  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  ControlFlowGraph  cfg  [TYPE]  Node  def  defCfgNode  externs  root  use  useCfgNode  [TYPE]  MaybeReachingVariableUse  reachingUses  [TYPE]  List  candidates  [TYPE]  MustBeReachingVariableDef  reachingDef  [TYPE]  String  varName  [TYPE]  int  numUseWithinUseCfgNode  [TYPE]  Predicate  SIDE_EFFECT_PREDICATE  [CONTEXT]  public  void  process  (  Node  externs  ,  Node  root  )  {  [BUGGY]  (  new  NodeTraversal  (  compiler  ,  this  )  )  .  traverse  (  root  )  ;  }  	Closure_30_FlowSensitiveInlineVariables_1_1	157	1	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
321	private  boolean  unknownDependencies  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_30_MustBeReachingVariableDef_3_1	71	0	src/com/google/javascript/jscomp/MustBeReachingVariableDef.java
322	if  (n.isName())  {  if  (dep  ==  null)  {  def.unknownDependencies  =  true;  }  else  {  }  	[BUGGY]  if  (  n  .  isName  (  )  &&  jsScope  .  isDeclared  (  n  .  getString  (  )  ,  true  )  )  {  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  1  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  dep  [TYPE]  Node  n  parent  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  [BUGGY]  if  (  n  .  isName  (  )  &&  jsScope  .  isDeclared  (  n  .  getString  (  )  ,  true  )  )  {  Var  dep  =  jsScope  .  getVar  (  n  .  getString  (  )  )  ;  def  .  depends  .  add  (  dep  )  ;  }  }  	Closure_30_MustBeReachingVariableDef_3_2	396	1	src/com/google/javascript/jscomp/MustBeReachingVariableDef.java
323	if  (def.unknownDependencies)  {  return  true;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  dependsOnOuterScopeVars  [TYPE]  boolean  [PARAMETER]  String  name  Node  useNode  [CLASS]  MustBeReachingVariableDef  [TYPE]  AbstractCompiler  compiler  [TYPE]  FlowState  state  [TYPE]  Set  depends  escaped  [TYPE]  boolean  false  true  [TYPE]  Scope  jsScope  [TYPE]  Var  s  [TYPE]  Node  node  useNode  [TYPE]  Definition  def  [TYPE]  GraphNode  n  [TYPE]  String  name  [TYPE]  Map  reachingDef  [CONTEXT]  boolean  dependsOnOuterScopeVars  (  String  name  ,  Node  useNode  )  {  Preconditions  .  checkArgument  (  getCfg  (  )  .  hasNode  (  useNode  )  )  ;  GraphNode<Node  ,  Branch>  n  =  getCfg  (  )  .  getNode  (  useNode  )  ;  FlowState<MustDef>  state  =  n  .  getAnnotation  (  )  ;  Definition  def  =  state  .  getIn  (  )  .  reachingDef  .  get  (  jsScope  .  getVar  (  name  )  )  ;  [BUGGY]  for  (  Var  s  :  def  .  depends  )  {  if  (  s  .  scope  !  =  jsScope  )  {  return  true  ;  }  }  return  false  ;  }  	Closure_30_MustBeReachingVariableDef_3_3	430	0	src/com/google/javascript/jscomp/MustBeReachingVariableDef.java
324		[BUGGY]  !options  .  skipAllPasses  &&  [FE]  AssertionFailedError:  [METHOD]  parseInputs  [TYPE]  Node  [PARAMETER]  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  n  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  SINGLETON_MODULE_NAME  SYNTHETIC_EXTERNS  currentPassName  externExports  provide  [TYPE]  LifeCycleStage  lifeCycleStage  [TYPE]  Logger  logger  [TYPE]  JSDocInfo  info  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  GlobalVarReferenceMap  globalRefMap  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MISSING_ENTRY_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  inputs  modules  [TYPE]  CircularDependencyException  e  [TYPE]  WarningsGuard  warningsGuard  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  SourceInformationAnnotator  sia  [TYPE]  double  progress  [TYPE]  Tracer  currentTracer  tracer  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  syntheticCodeId  uniqueNameId  [TYPE]  CompilerInput  input  synthesizedExternsInput  [TYPE]  boolean  devMode  false  hasRegExpGlobalReferences  staleInputs  true  useThreads  [TYPE]  MissingProvideException  e  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  injectedLibraries  inputsById  [CONTEXT]  addChangeHandler  (  tracker  .  getCodeChangeHandler  (  )  )  ;  }  Tracer  tracer  =  newTracer  ( "parseInputs "  )  ;  try  {  for  (  CompilerInput  input  :  externs  )  {  Node  n  =  input  .  getAstRoot  (  this  )  ;  if  (  hasErrors  (  )  )  {  return  null  ;  }  externsRoot  .  addChildToBack  (  n  )  ;  }  if  (  options  .  transformAMDToCJSModules  ||  options  .  processCommonJSModules  )  {  processAMDAndCommonJSModules  (  )  ;  }  boolean  staleInputs  =  false  ;  if  (  options  .  dependencyOptions  .  needsManagement  (  )  &&  [BUGGY]  !options  .  skipAllPasses  &&  options  .  closurePass  )  {  for  (  CompilerInput  input  :  inputs  )  {  for  (  String  provide  :  input  .  getProvides  (  )  )  {  	Closure_31_Compiler_1_1	1285	1	src/com/google/javascript/jscomp/Compiler.java
325	int  lineStartChar  =  -1;  	[BUGGY]  [FE]  ComparisonFailure:  expected:</*  assertEquals  (  result  ,  lastCompiler  .  toSource  (  )  )  ;  [METHOD]  extractMultilineTextualBlock  [TYPE]  JsDocInfoParser$ExtractionInfo  [PARAMETER]  JsDocToken  token  WhitespaceOption  option  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  StringBuilder  builder  [TYPE]  Node  associatedNode  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  line  multilineText  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  ignoreStar  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  StaticSourceFile  sourceFile  [TYPE]  Map  annotationNames  [CONTEXT]  token  =  =  JsDocToken  .  EOF  )  {  return  new  ExtractionInfo  ( " "  ,  token  )  ;  }  stream  .  update  (  )  ;  int  startLineno  =  stream  .  getLineno  (  )  ;  int  startCharno  =  stream  .  getCharno  (  )  +  1  ;  String  line  =  stream  .  getRemainingJSDocLine  (  )  ;  if  (  option  !  =  WhitespaceOption  .  PRESERVE  )  {  line  =  line  .  trim  (  )  ;  }  StringBuilder  builder  =  new  StringBuilder  (  )  ;  builder  .  append  (  line  )  ;  state  =  State  .  SEARCHING_ANNOTATION  ;  token  =  next  (  )  ;  boolean  ignoreStar  =  false  ;  [BUGGY]  do  {  switch  (  token  )  {  case  STAR:  if  (  ignoreStar  )  {  	Closure_32_JsDocInfoParser_5_1	1358	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
326	lineStartChar  =  stream.getCharno()  +  1;  	[BUGGY]  [FE]  ComparisonFailure:  expected:</*  assertEquals  (  result  ,  lastCompiler  .  toSource  (  )  )  ;  [METHOD]  extractMultilineTextualBlock  [TYPE]  JsDocInfoParser$ExtractionInfo  [PARAMETER]  JsDocToken  token  WhitespaceOption  option  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  StringBuilder  builder  [TYPE]  Node  associatedNode  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  line  multilineText  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  ignoreStar  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  StaticSourceFile  sourceFile  [TYPE]  Map  annotationNames  [CONTEXT]  int  startCharno  =  stream  .  getCharno  (  )  +  1  ;  String  line  =  stream  .  getRemainingJSDocLine  (  )  ;  if  (  option  !  =  WhitespaceOption  .  PRESERVE  )  {  line  =  line  .  trim  (  )  ;  }  StringBuilder  builder  =  new  StringBuilder  (  )  ;  builder  .  append  (  line  )  ;  state  =  State  .  SEARCHING_ANNOTATION  ;  token  =  next  (  )  ;  boolean  ignoreStar  =  false  ;  do  {  switch  (  token  )  {  case  STAR:  if  (  ignoreStar  )  {  [BUGGY]  }  else  {  if  (  builder  .  length  (  )  >  0  )  {  builder  .  append  (  '  '  )  ;  }  	Closure_32_JsDocInfoParser_5_2	1364	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
327	lineStartChar  =  0;  	[BUGGY]  [FE]  ComparisonFailure:  expected:</*  assertEquals  (  result  ,  lastCompiler  .  toSource  (  )  )  ;  [METHOD]  extractMultilineTextualBlock  [TYPE]  JsDocInfoParser$ExtractionInfo  [PARAMETER]  JsDocToken  token  WhitespaceOption  option  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  StringBuilder  builder  [TYPE]  Node  associatedNode  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  line  multilineText  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  ignoreStar  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  StaticSourceFile  sourceFile  [TYPE]  Map  annotationNames  [CONTEXT]  do  {  switch  (  token  )  {  case  STAR:  if  (  ignoreStar  )  {  }  else  {  if  (  builder  .  length  (  )  >  0  )  {  builder  .  append  (  '  '  )  ;  }  builder  .  append  (  '*'  )  ;  }  token  =  next  (  )  ;  continue  ;  case  EOL:  if  (  option  !  =  WhitespaceOption  .  SINGLE_LINE  )  {  builder  .  append  ( "\n "  )  ;  }  ignoreStar  =  true  ;  [BUGGY]  token  =  next  (  )  ;  continue  ;  default:  ignoreStar  =  false  ;  state  =  State  .  SEARCHING_ANNOTATION  ;  	Closure_32_JsDocInfoParser_5_3	1382	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
328	boolean  isEOC  =  token  ==  JsDocToken.EOC;  if  (!isEOC)  {  if  (lineStartChar  !=  -1  &&  option  ==  WhitespaceOption.PRESERVE)  {  int  numSpaces  =  stream.getCharno()  -  lineStartChar;  for  (int  i  =  0;  i  <  numSpaces;  i++)  {     builder.append('  ');    }  lineStartChar  =  -1;  }  else  if  (builder.length()  >  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:</*  assertEquals  (  result  ,  lastCompiler  .  toSource  (  )  )  ;  [METHOD]  extractMultilineTextualBlock  [TYPE]  JsDocInfoParser$ExtractionInfo  [PARAMETER]  JsDocToken  token  WhitespaceOption  option  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  StringBuilder  builder  [TYPE]  Node  associatedNode  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  line  multilineText  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  ignoreStar  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  StaticSourceFile  sourceFile  [TYPE]  Map  annotationNames  [CONTEXT]  }  else  {  if  (  builder  .  length  (  )  >  0  )  {  builder  .  append  (  '  '  )  ;  }  builder  .  append  (  '*'  )  ;  }  token  =  next  (  )  ;  continue  ;  case  EOL:  if  (  option  !  =  WhitespaceOption  .  SINGLE_LINE  )  {  builder  .  append  ( "\n "  )  ;  }  ignoreStar  =  true  ;  token  =  next  (  )  ;  continue  ;  default:  ignoreStar  =  false  ;  state  =  State  .  SEARCHING_ANNOTATION  ;  [BUGGY]  if  (  token  =  =  JsDocToken  .  EOC  ||  token  =  =  JsDocToken  .  EOF  ||  	Closure_32_JsDocInfoParser_5_4	1389	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
329		[BUGGY]  if  (  builder  .  length  (  )  >  0  )  {\n'  , "-  builder  .  append  (  '  '  )  ;  \n "  ,  '-  }  [FE]  ComparisonFailure:  expected:</*  assertEquals  (  result  ,  lastCompiler  .  toSource  (  )  )  ;  [METHOD]  extractMultilineTextualBlock  [TYPE]  JsDocInfoParser$ExtractionInfo  [PARAMETER]  JsDocToken  token  WhitespaceOption  option  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  StringBuilder  builder  [TYPE]  Node  associatedNode  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  line  multilineText  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  endCharno  endLineno  lineno  startCharno  startLineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  ignoreStar  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  StaticSourceFile  sourceFile  [TYPE]  Map  annotationNames  [CONTEXT]  if  (  token  =  =  JsDocToken  .  EOC  ||  token  =  =  JsDocToken  .  EOF  ||  (  token  =  =  JsDocToken  .  ANNOTATION  &&  option  !  =  WhitespaceOption  .  PRESERVE  )  )  {  String  multilineText  =  builder  .  toString  (  )  ;  if  (  option  !  =  WhitespaceOption  .  PRESERVE  )  {  multilineText  =  multilineText  .  trim  (  )  ;  }  int  endLineno  =  stream  .  getLineno  (  )  ;  int  endCharno  =  stream  .  getCharno  (  )  ;  if  (  multilineText  .  length  (  )  >  0  )  {  jsdocBuilder  .  markText  (  multilineText  ,  startLineno  ,  startCharno  ,  endLineno  ,  endCharno  )  ;  }  return  new  ExtractionInfo  (  multilineText  ,  token  )  ;  }  [BUGGY]  if  (  builder  .  length  (  )  >  0  )  {  builder  .  append  (  '  '  )  ;  }  builder  .  append  (  toString  (  token  )  )  ;  line  =  stream  .  getRemainingJSDocLine  (  )  ;  	Closure_32_JsDocInfoParser_5_5	1414	1	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
330	if  (hasReferenceName())  {  return;  }  	[BUGGY]  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  matchConstraint  [TYPE]  void  [PARAMETER]  ObjectType  constraintObj  [CLASS]  PrototypeObjectType  [TYPE]  ObjectType  constraintObj  implicitPrototypeFallback  [TYPE]  boolean  false  nativeType  prettyPrint  true  [TYPE]  JSType  propType  typeToInfer  [TYPE]  FunctionType  ownerFunction  [TYPE]  String  className  prop  [TYPE]  Map  properties  [TYPE]  long  serialVersionUID  [TYPE]  int  MAX_PRETTY_PRINTED_PROPERTIES  [CONTEXT]  public  void  matchConstraint  (  ObjectType  constraintObj  )  {  [BUGGY]  if  (  constraintObj  .  isRecordType  (  )  )  {  for  (  String  prop  :  constraintObj  .  getOwnPropertyNames  (  )  )  {  JSType  propType  =  constraintObj  .  getPropertyType  (  prop  )  ;  if  (  !isPropertyTypeDeclared  (  prop  )  )  {  JSType  typeToInfer  =  propType  ;  if  (  !hasProperty  (  prop  )  )  {  typeToInfer  =  getNativeType  (  JSTypeNative  .  VOID_TYPE  )  .  getLeastSupertype  (  propType  )  ;  }  defineInferredProperty  (  prop  ,  typeToInfer  ,  null  )  ;  }  }  }  }  	Closure_33_PrototypeObjectType_1_1	557	0	src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
331	unrollBinaryOperator(n,  type,  opstr,  context,  rhsContext,  p,  p  +  1);  	[BUGGY]  addExpr  (  first  ,  p  ,  context  )  ;  cc  .  addOp  (  opstr  ,  true  )  ;  addExpr  (  last  ,  p  +  1  ,  rhsContext  )  ;  [FE]  StackOverflowError  assertEquals  (  expected  ,  actual  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  Node  n  Context  context  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  context  rhsContext  [TYPE]  boolean  ambiguousElseClause  false  funcNeedsParens  hasElse  needsParens  preferLineBreaks  preserveBlock  true  [TYPE]  double  d  [TYPE]  Node  body  c  catchblock  first  fn  last  n  next  parameters  [TYPE]  CodeConsumer  cc  [TYPE]  String  key  name  o  opstr  regexp  [TYPE]  Map  ESCAPED_JS_STRINGS  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  childCount  p  postProp  precedence  type  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  if  (  opstr  !  =  null  &&  first  !  =  last  )  {  Preconditions  .  checkState  (  childCount  =  =  2  , "Bad  binary  operator  \ "%s\ ":  expected  2  arguments  but  got  %s "  ,  opstr  ,  childCount  )  ;  int  p  =  NodeUtil  .  precedence  (  type  )  ;  Context  rhsContext  =  getContextForNoInOperator  (  context  )  ;  if  (  last  .  getType  (  )  =  =  type  &&  NodeUtil  .  isAssociative  (  type  )  )  {  addExpr  (  first  ,  p  ,  context  )  ;  cc  .  addOp  (  opstr  ,  true  )  ;  addExpr  (  last  ,  p  ,  rhsContext  )  ;  }  else  if  (  NodeUtil  .  isAssignmentOp  (  n  )  &&  NodeUtil  .  isAssignmentOp  (  last  )  )  {  addExpr  (  first  ,  p  ,  context  )  ;  cc  .  addOp  (  opstr  ,  true  )  ;  addExpr  (  last  ,  p  ,  rhsContext  )  ;  }  else  {  [BUGGY]  addExpr  (  first  ,  p  ,  context  )  ;  cc  .  addOp  (  opstr  ,  true  )  ;  addExpr  (  last  ,  p  +  1  ,  rhsContext  )  ;  }  return  ;  }  	Closure_34_CodeGenerator_2_1	122	3	src/com/google/javascript/jscomp/CodeGenerator.java
332	cc.addOp(opStr,  true);  	[BUGGY]  cc  .  listSeparator  (  )  ;  [FE]  StackOverflowError  assertEquals  (  expected  ,  actual  )  ;  [METHOD]  unrollBinaryOperator  [TYPE]  void  [PARAMETER]  Node  n  int  op  String  opStr  Context  context  Context  rhsContext  int  leftPrecedence  int  rightPrecedence  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  context  rhsContext  [TYPE]  boolean  false  true  [TYPE]  Node  current  firstNonOperator  n  [TYPE]  CodeConsumer  cc  [TYPE]  String  opStr  [TYPE]  Map  ESCAPED_JS_STRINGS  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  leftPrecedence  op  rightPrecedence  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  private  void  unrollBinaryOperator  (  Node  n  ,  int  op  ,  String  opStr  ,  Context  context  ,  Context  rhsContext  ,  int  leftPrecedence  ,  int  rightPrecedence  )  {  Node  firstNonOperator  =  n  .  getFirstChild  (  )  ;  while  (  firstNonOperator  .  getType  (  )  =  =  op  )  {  firstNonOperator  =  firstNonOperator  .  getFirstChild  (  )  ;  }  addExpr  (  firstNonOperator  ,  leftPrecedence  ,  context  )  ;  Node  current  =  firstNonOperator  ;  do  {  current  =  current  .  getParent  (  )  ;  [BUGGY]  cc  .  listSeparator  (  )  ;  addExpr  (  current  .  getFirstChild  (  )  .  getNext  (  )  ,  rightPrecedence  ,  rhsContext  )  ;  }  while  (  current  !  =  n  )  ;  }  	Closure_34_CodeGenerator_2_2	754	1	src/com/google/javascript/jscomp/CodeGenerator.java
333		[BUGGY]  [FE]  StackOverflowError  assertEquals  (  expected  ,  actual  )  ;  [METHOD]  appendOp  [TYPE]  void  [PARAMETER]  String  op  boolean  binOp  [CLASS]  PrettyCodePrinter  [TYPE]  int  indent  [TYPE]  String  INDENT  op  [TYPE]  boolean  binOp  false  true  [CONTEXT]  void  appendOp  (  String  op  ,  boolean  binOp  )  {  if  (  binOp  )  {  [BUGGY]  if  (  getLastChar  (  )  !  =  '  '  )  {  append  ( " "  )  ;  }  append  (  op  )  ;  append  ( " "  )  ;  }  else  {  append  (  op  )  ;  }  }  	Closure_34_CodePrinter_1_1	334	0	src/com/google/javascript/jscomp/CodePrinter.java
334	if  (constraintObj  !=  null)  {  type.matchConstraint(constraintObj);  	[BUGGY]  if  (  constraintObj  !  =  null  &&  constraintObj  .  isRecordType  (  )  )  {  ObjectType  objType  =  ObjectType  .  cast  (  type  .  restrictByNotNullOrUndefined  (  )  )  ;  if  (  objType  !  =  null  )  {  for  (  String  prop  :  constraintObj  .  getOwnPropertyNames  (  )  )  {  JSType  propType  =  constraintObj  .  getPropertyType  (  prop  )  ;  if  (  !objType  .  isPropertyTypeDeclared  (  prop  )  )  {  JSType  typeToInfer  =  propType  ;  if  (  !objType  .  hasProperty  (  prop  )  )  {  typeToInfer  =  getNativeType  (  VOID_TYPE  )  .  getLeastSupertype  (  propType  )  ;  }  objType  .  defineInferredProperty  (  prop  ,  typeToInfer  ,  null  )  ;  }  }  }  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  inferPropertyTypesToMatchConstraint  [TYPE]  void  [PARAMETER]  JSType  type  JSType  constraint  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  ObjectType  constraintObj  objType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  JSType  constraint  propType  type  typeToInfer  [TYPE]  boolean  false  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  prop  [TYPE]  Map  assertionFunctionsMap  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  [CONTEXT]  private  void  inferPropertyTypesToMatchConstraint  (  JSType  type  ,  JSType  constraint  )  {  if  (  type  =  =  null  ||  constraint  =  =  null  )  {  return  ;  }  ObjectType  constraintObj  =  ObjectType  .  cast  (  constraint  .  restrictByNotNullOrUndefined  (  )  )  ;  [BUGGY]  if  (  constraintObj  !  =  null  &&  constraintObj  .  isRecordType  (  )  )  {  ObjectType  objType  =  ObjectType  .  cast  (  type  .  restrictByNotNullOrUndefined  (  )  )  ;  if  (  objType  !  =  null  )  {  for  (  String  prop  :  constraintObj  .  getOwnPropertyNames  (  )  )  {  JSType  propType  =  constraintObj  .  getPropertyType  (  prop  )  ;  if  (  !objType  .  isPropertyTypeDeclared  (  prop  )  )  {  JSType  typeToInfer  =  propType  ;  if  (  !objType  .  hasProperty  (  prop  )  )  {  typeToInfer  =  getNativeType  (  VOID_TYPE  )  .  getLeastSupertype  (  propType  )  ;  }  objType  .  defineInferredProperty  (  prop  ,  typeToInfer  ,  null  )  ;  }  }  }  }  }  	Closure_35_TypeInference_1_1	1121	15	src/com/google/javascript/jscomp/TypeInference.java
335	if  (convention.getSingletonGetterClassName(callNode)  !=  null)  {  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  canInline  [TYPE]  boolean  [PARAMETER]  Reference  declaration  Reference  initialization  Reference  reference  [CLASS]  InliningBehavior  [TYPE]  Set  staleVars  [TYPE]  boolean  false  true  [TYPE]  Reference  declaration  initialization  reference  [TYPE]  Node  callNode  value  [TYPE]  CodingConvention  convention  [TYPE]  SubclassRelationship  relationship  [TYPE]  Map  aliasCandidates  [CONTEXT]  Node  value  =  initialization  .  getAssignedValue  (  )  ;  Preconditions  .  checkState  (  value  !  =  null  )  ;  if  (  value  .  isGetProp  (  )  &&  reference  .  getParent  (  )  .  isCall  (  )  &&  reference  .  getParent  (  )  .  getFirstChild  (  )  =  =  reference  .  getNode  (  )  )  {  return  false  ;  }  if  (  value  .  isFunction  (  )  )  {  Node  callNode  =  reference  .  getParent  (  )  ;  if  (  reference  .  getParent  (  )  .  isCall  (  )  )  {  CodingConvention  convention  =  compiler  .  getCodingConvention  (  )  ;  SubclassRelationship  relationship  =  convention  .  getClassesDefinedByCall  (  callNode  )  ;  if  (  relationship  !  =  null  )  {  return  false  ;  }  [BUGGY]  }  }  return  canMoveAggressively  (  value  )  ||  canMoveModerately  (  initialization  ,  reference  )  ;  }  	Closure_36_InlineVariables_1_1	575	0	src/com/google/javascript/jscomp/InlineVariables.java
336	body.isBlock(),  body);  	[BUGGY]  body  .  isBlock  (  )  )  ;  [FE]  RuntimeException:  javalangRuntimeException:  INTERNAL  COMPILER  ERROR  assertEquals  ( "Unexpected  warnings  or  errors  .  \n "+  msg  ,  [METHOD]  traverseFunction  [TYPE]  void  [PARAMETER]  Node  n  Node  parent  [CLASS]  NodeTraversal  [TYPE]  ScopedCallback  scopeCallback  [TYPE]  AbstractCompiler  compiler  [TYPE]  Callback  callback  [TYPE]  Set  nodeTypes  [TYPE]  boolean  false  include  isFunctionExpression  true  [TYPE]  DiagnosticType  NODE_TRAVERSAL_ERROR  [TYPE]  Node  args  body  curNode  fnName  n  parent  [TYPE]  InputId  inputId  [TYPE]  ScopeCreator  scopeCreator  [TYPE]  String  MISSING_SOURCE  sourceName  [TYPE]  Deque  cfgs  scopeRoots  scopes  [CONTEXT]  boolean  isFunctionExpression  =  (  parent  !  =  null  )  &&  NodeUtil  .  isFunctionExpression  (  n  )  ;  if  (  !isFunctionExpression  )  {  traverseBranch  (  fnName  ,  n  )  ;  }  curNode  =  n  ;  pushScope  (  n  )  ;  if  (  isFunctionExpression  )  {  traverseBranch  (  fnName  ,  n  )  ;  }  final  Node  args  =  fnName  .  getNext  (  )  ;  final  Node  body  =  args  .  getNext  (  )  ;  traverseBranch  (  args  ,  n  )  ;  Preconditions  .  checkState  (  body  .  getNext  (  )  =  =  null  &&  [BUGGY]  body  .  isBlock  (  )  )  ;  traverseBranch  (  body  ,  n  )  ;  popScope  (  )  ;  }  	Closure_37_NodeTraversal_1_1	541	1	src/com/google/javascript/jscomp/NodeTraversal.java
337	if  (!bodyNode.isBlock())  {  	[BUGGY]  [FE]  RuntimeException:  javalangRuntimeException:  INTERNAL  COMPILER  ERROR  assertEquals  ( "Unexpected  warnings  or  errors  .  \n "+  msg  ,  [METHOD]  processFunctionNode  [TYPE]  Node  [PARAMETER]  FunctionNode  functionNode  [CLASS]  TransformDispatcher  [TYPE]  boolean  false  true  [TYPE]  Node  bodyNode  lp  newName  node  [TYPE]  FunctionNode  functionNode  [TYPE]  Boolean  isUnnamedFunction  [TYPE]  int  functionType  lpColumn  lparenCharno  [TYPE]  AstNode  param  [TYPE]  Name  fnName  name  [CONTEXT]  node  .  addChildToBack  (  newName  )  ;  Node  lp  =  newNode  (  Token  .  PARAM_LIST  )  ;  Name  fnName  =  functionNode  .  getFunctionName  (  )  ;  if  (  fnName  !  =  null  )  {  lp  .  setLineno  (  fnName  .  getLineno  (  )  )  ;  }  else  {  lp  .  setLineno  (  functionNode  .  getLineno  (  )  )  ;  }  int  lparenCharno  =  functionNode  .  getLp  (  )  +  functionNode  .  getAbsolutePosition  (  )  ;  lp  .  setCharno  (  position2charno  (  lparenCharno  )  )  ;  for  (  AstNode  param  :  functionNode  .  getParams  (  )  )  {  lp  .  addChildToBack  (  transform  (  param  )  )  ;  }  node  .  addChildToBack  (  lp  )  ;  Node  bodyNode  =  transform  (  functionNode  .  getBody  (  )  )  ;  [BUGGY]  parseDirectives  (  bodyNode  )  ;  node  .  addChildToBack  (  bodyNode  )  ;  return  node  ;  	Closure_37_IRFactory_2_1	667	0	src/com/google/javascript/jscomp/parsing/IRFactory.java
338	Preconditions.checkState(config.isIdeMode);  bodyNode  =  IR.block();  }  	[BUGGY]  [FE]  RuntimeException:  javalangRuntimeException:  INTERNAL  COMPILER  ERROR  assertEquals  ( "Unexpected  warnings  or  errors  .  \n "+  msg  ,  [METHOD]  processFunctionNode  [TYPE]  Node  [PARAMETER]  FunctionNode  functionNode  [CLASS]  TransformDispatcher  [TYPE]  boolean  false  true  [TYPE]  Node  bodyNode  lp  newName  node  [TYPE]  FunctionNode  functionNode  [TYPE]  Boolean  isUnnamedFunction  [TYPE]  int  functionType  lpColumn  lparenCharno  [TYPE]  AstNode  param  [TYPE]  Name  fnName  name  [CONTEXT]  Name  fnName  =  functionNode  .  getFunctionName  (  )  ;  if  (  fnName  !  =  null  )  {  lp  .  setLineno  (  fnName  .  getLineno  (  )  )  ;  }  else  {  lp  .  setLineno  (  functionNode  .  getLineno  (  )  )  ;  }  int  lparenCharno  =  functionNode  .  getLp  (  )  +  functionNode  .  getAbsolutePosition  (  )  ;  lp  .  setCharno  (  position2charno  (  lparenCharno  )  )  ;  for  (  AstNode  param  :  functionNode  .  getParams  (  )  )  {  lp  .  addChildToBack  (  transform  (  param  )  )  ;  }  node  .  addChildToBack  (  lp  )  ;  Node  bodyNode  =  transform  (  functionNode  .  getBody  (  )  )  ;  [BUGGY]  parseDirectives  (  bodyNode  )  ;  node  .  addChildToBack  (  bodyNode  )  ;  return  node  ;  }  @Override  	Closure_37_IRFactory_2_2	670	0	src/com/google/javascript/jscomp/parsing/IRFactory.java
339	if ((x < 0 || negativeZero) && prev == '-') {	[BUGGY] if (x < 0 && prev == '-') { [FE]  ComparisonFailure:  expected:<x-[  ]-00>  but  was:<x-[]-00>  assertPrint  ( "x-  -0 "  , "x-  -0  .  0 "  )  ;  [METHOD]  addNumber  [TYPE]  void  [PARAMETER]  double  x  [CLASS]  CodeConsumer  [TYPE]  char  prev  [TYPE]  boolean  false  negativeZero  sawFunction  statementNeedsEnded  statementStarted  true  [TYPE]  double  x  [TYPE]  long  mantissa  value  [TYPE]  int  exp  [CONTEXT]  void  addNumber  (  double  x  )  {  char  prev  =  getLastChar  (  )  ;  boolean  negativeZero  =  isNegativeZero  (  x  )  ;  [BUGGY]  if  (  x  <  0  &&  prev  =  =  '-'  )  {  add  ( " "  )  ;  }  if  (  (  long  )  x  =  =  x  &&  !negativeZero  )  {  long  value  =  (  long  )  x  ;  long  mantissa  =  value  ;  int  exp  =  0  ;  if  (  Math  .  abs  (  x  )  >  =  100  )  {  while  (  mantissa  /  10  *  Math  .  pow  (  10  ,  exp  +  1  )  =  =  value  )  {  mantissa  /  =  10  ;  exp++  ;  }  }  if  (  exp  >  2  )  {  add  (  Long  .  toString  (  mantissa  )  + "E "  +  Integer  .  toString  (  exp  )  )  ;  }  else  {  add  (  Long  .  toString  (  value  )  )  ;  }  }  else  {  add  (  String  .  valueOf  (  x  )  )  ;  }  }  	Closure_38_CodeConsumer_1_1	245	0	src/com/google/javascript/jscomp/CodeConsumer.java
340	sb.append(getPropertyType(property).toStringHelper(forAnnotations));  if  (!forAnnotations  &&  i  ==  MAX_PRETTY_PRINTED_PROPERTIES)  {  	[BUGGY]  sb  .  append  (  getPropertyType  (  property  )  .  toString  (  )  )  ;  if  (  i  =  =  MAX_PRETTY_PRINTED_PROPERTIES  )  {  [FE]  ComparisonFailure:  expected:<{loop:  [?]  ,  number:  number  ,  st>  but  was:<{loop:  [{}]  ,  number:  number  ,  st>  Asserts  .  assertEquivalenceOperations  (  record  ,  loop  )  ;  [METHOD]  toStringHelper  [TYPE]  String  [PARAMETER]  boolean  forAnnotations  [CLASS]  PrototypeObjectType  [TYPE]  ObjectType  current  implicitPrototypeFallback  [TYPE]  boolean  false  forAnnotations  nativeType  prettyPrint  true  [TYPE]  Set  propertyNames  [TYPE]  StringBuilder  sb  [TYPE]  FunctionType  ownerFunction  [TYPE]  String  className  property  [TYPE]  Map  properties  [TYPE]  long  serialVersionUID  [TYPE]  int  MAX_PRETTY_PRINTED_PROPERTIES  i  [CONTEXT]  return  getReferenceName  (  )  ;  }  else  if  (  prettyPrint  )  {  prettyPrint  =  false  ;  Set<String>  propertyNames  =  Sets  .  newTreeSet  (  )  ;  for  (  ObjectType  current  =  this  ;  current  !  =  null  &&  !current  .  isNativeObjectType  (  )  &&  propertyNames  .  size  (  )  <  =  MAX_PRETTY_PRINTED_PROPERTIES  ;  current  =  current  .  getImplicitPrototype  (  )  )  {  propertyNames  .  addAll  (  current  .  getOwnPropertyNames  (  )  )  ;  }  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  ( "{ "  )  ;  int  i  =  0  ;  for  (  String  property  :  propertyNames  )  {  if  (  i  >  0  )  {  sb  .  append  ( "  , "  )  ;  }  sb  .  append  (  property  )  ;  sb  .  append  ( ": "  )  ;  [BUGGY]  sb  .  append  (  getPropertyType  (  property  )  .  toString  (  )  )  ;  ++i  ;  if  (  i  =  =  MAX_PRETTY_PRINTED_PROPERTIES  )  {  sb  .  append  ( "  ,  .  .  . "  )  ;  break  ;  	Closure_39_PrototypeObjectType_2_1	380	2	src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
341	return  forAnnotations  ? "? "  : "{...} ";  	[BUGGY]  return "{  .  .  .  } "  ;  [FE]  ComparisonFailure:  expected:<{loop:  [?]  ,  number:  number  ,  st>  but  was:<{loop:  [{}]  ,  number:  number  ,  st>  Asserts  .  assertEquivalenceOperations  (  record  ,  loop  )  ;  [METHOD]  toStringHelper  [TYPE]  String  [PARAMETER]  boolean  forAnnotations  [CLASS]  PrototypeObjectType  [TYPE]  ObjectType  current  implicitPrototypeFallback  [TYPE]  boolean  false  forAnnotations  nativeType  prettyPrint  true  [TYPE]  Set  propertyNames  [TYPE]  StringBuilder  sb  [TYPE]  FunctionType  ownerFunction  [TYPE]  String  className  property  [TYPE]  Map  properties  [TYPE]  long  serialVersionUID  [TYPE]  int  MAX_PRETTY_PRINTED_PROPERTIES  i  [CONTEXT]  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  ( "{ "  )  ;  int  i  =  0  ;  for  (  String  property  :  propertyNames  )  {  if  (  i  >  0  )  {  sb  .  append  ( "  , "  )  ;  }  sb  .  append  (  property  )  ;  sb  .  append  ( ": "  )  ;  sb  .  append  (  getPropertyType  (  property  )  .  toString  (  )  )  ;  ++i  ;  if  (  i  =  =  MAX_PRETTY_PRINTED_PROPERTIES  )  {  sb  .  append  ( "  ,  .  .  . "  )  ;  break  ;  }  }  sb  .  append  ( "} "  )  ;  prettyPrint  =  true  ;  return  sb  .  toString  (  )  ;  }  else  {  [BUGGY]  return "{  .  .  .  } "  ;  }  }  void  setPrettyPrint  (  boolean  prettyPrint  )  {  this  .  prettyPrint  =  prettyPrint  ;  	Closure_39_PrototypeObjectType_2_2	394	1	src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
342	JsName  name  =  getName(ns.name,  true);  	[BUGGY]  JsName  name  =  getName  (  ns  .  name  ,  false  )  ;  if  (  name  !  =  null  )  {  }  [FE]  RuntimeException:  javalangRuntimeException:  INTERNAL  COMPILER  ERROR  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  FindDeclarationsAndSetters  [TYPE]  NameInformation  ns  [TYPE]  boolean  false  true  [TYPE]  JsName  name  nameInfo  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  nameNode  parent  [CONTEXT]  }  }  else  if  (  NodeUtil  .  isObjectLitKey  (  n  ,  parent  )  )  {  NameInformation  ns  =  createNameInformation  (  t  ,  n  ,  parent  )  ;  if  (  ns  !  =  null  )  {  recordSet  (  ns  .  name  ,  n  )  ;  }  }  }  if  (  n  .  isAssign  (  )  )  {  Node  nameNode  =  n  .  getFirstChild  (  )  ;  NameInformation  ns  =  createNameInformation  (  t  ,  nameNode  ,  n  )  ;  if  (  ns  !  =  null  )  {  if  (  ns  .  isPrototype  )  {  recordPrototypeSet  (  ns  .  prototypeClass  ,  ns  .  prototypeProperty  ,  n  )  ;  }  else  {  recordSet  (  ns  .  name  ,  nameNode  )  ;  }  }  }  else  if  (  n  .  isCall  (  )  )  {  Node  nameNode  =  n  .  getFirstChild  (  )  ;  NameInformation  ns  =  createNameInformation  (  t  ,  nameNode  ,  n  )  ;  if  (  ns  !  =  null  &&  ns  .  onlyAffectsClassDef  )  {  [BUGGY]  JsName  name  =  getName  (  ns  .  name  ,  false  )  ;  if  (  name  !  =  null  )  {  refNodes  .  add  (  new  ClassDefiningFunctionNode  (  name  ,  n  ,  parent  ,  parent  .  getParent  (  )  )  )  ;  }  }  	Closure_40_NameAnalyzer_1_1	635	3	src/com/google/javascript/jscomp/NameAnalyzer.java
343	paramBuilder.newParameterFromNode(oldParams.next());  }  	[BUGGY]  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  inferFromOverriddenFunction  [TYPE]  FunctionTypeBuilder  [PARAMETER]  FunctionType  oldType  Node  paramsParent  [CLASS]  FunctionTypeBuilder  [TYPE]  JSType  returnType  [TYPE]  Set  escapedVarNames  [TYPE]  Node  currentParam  errorRoot  n  newParam  oldParam  parametersNode  paramsParent  [TYPE]  FunctionType  oldType  [TYPE]  FunctionContents  contents  [TYPE]  String  fnName  sourceName  templateTypeName  [TYPE]  UnknownFunctionContents  singleton  [TYPE]  ObjectType  baseType  thisType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  false  hasNonEmptyReturns  isConstructor  isInterface  oldParamsListHitOptArgs  returnTypeInferred  true  warnedAboutArgList  [TYPE]  Scope  scope  [TYPE]  DiagnosticType  EXTENDS_NON_OBJECT  EXTENDS_WITHOUT_TYPEDEF  IMPLEMENTS_WITHOUT_CONSTRUCTOR  INEXISTANT_PARAM  OPTIONAL_ARG_AT_END  RESOLVED_TAG_EMPTY  TEMPLATE_TYPE_DUPLICATED  TEMPLATE_TYPE_EXPECTED  THIS_TYPE_NON_OBJECT  TYPE_REDEFINITION  VAR_ARGS_MUST_BE_LAST  [TYPE]  CodingConvention  codingConvention  [TYPE]  Iterator  oldParams  [TYPE]  List  extendedInterfaces  implementedInterfaces  [TYPE]  FunctionParamBuilder  paramBuilder  [CONTEXT]  Node  oldParam  =  oldParams  .  next  (  )  ;  Node  newParam  =  paramBuilder  .  newParameterFromNode  (  oldParam  )  ;  oldParamsListHitOptArgs  =  oldParamsListHitOptArgs  ||  oldParam  .  isVarArgs  (  )  ||  oldParam  .  isOptionalArg  (  )  ;  if  (  currentParam  .  getNext  (  )  !  =  null  &&  newParam  .  isVarArgs  (  )  )  {  newParam  .  setVarArgs  (  false  )  ;  newParam  .  setOptionalArg  (  true  )  ;  }  }  else  {  warnedAboutArgList  |  =  addParameter  (  paramBuilder  ,  typeRegistry  .  getNativeType  (  UNKNOWN_TYPE  )  ,  warnedAboutArgList  ,  codingConvention  .  isOptionalParameter  (  currentParam  )  ||  oldParamsListHitOptArgs  ,  codingConvention  .  isVarArgsParameter  (  currentParam  )  )  ;  }  }  [BUGGY]  parametersNode  =  paramBuilder  .  build  (  )  ;  }  return  this  ;  }  	Closure_41_FunctionTypeBuilder_2_1	292	0	src/com/google/javascript/jscomp/FunctionTypeBuilder.java
344	while  (oldParameterType  !=  null  &&  !isVarArgs)  {  builder.newParameterFromNode(oldParameterType);  oldParameterType  =  oldParameterType.getNext();  }  }  	[BUGGY]  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  inferParameterTypes  [TYPE]  FunctionTypeBuilder  [PARAMETER]  Node  argsParent  JSDocInfo  info  [CLASS]  FunctionTypeBuilder  [TYPE]  JSType  parameterType  returnType  [TYPE]  Set  allJsDocParams  escapedVarNames  [TYPE]  Node  arg  argsParent  errorRoot  n  oldParameterType  parametersNode  [TYPE]  FunctionContents  contents  [TYPE]  String  argumentName  fnName  inexistentName  sourceName  templateTypeName  [TYPE]  JSDocInfo  info  [TYPE]  UnknownFunctionContents  singleton  [TYPE]  ObjectType  baseType  thisType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  false  foundTemplateType  hasNonEmptyReturns  isConstructor  isInterface  isOptionalParam  isVarArgs  returnTypeInferred  true  warnedAboutArgList  [TYPE]  Scope  scope  [TYPE]  DiagnosticType  EXTENDS_NON_OBJECT  EXTENDS_WITHOUT_TYPEDEF  IMPLEMENTS_WITHOUT_CONSTRUCTOR  INEXISTANT_PARAM  OPTIONAL_ARG_AT_END  RESOLVED_TAG_EMPTY  TEMPLATE_TYPE_DUPLICATED  TEMPLATE_TYPE_EXPECTED  THIS_TYPE_NON_OBJECT  TYPE_REDEFINITION  VAR_ARGS_MUST_BE_LAST  [TYPE]  CodingConvention  codingConvention  [TYPE]  List  extendedInterfaces  implementedInterfaces  [TYPE]  FunctionParamBuilder  builder  [CONTEXT]  parameterType  =  oldParameterType  .  getJSType  (  )  ;  isOptionalParam  =  oldParameterType  .  isOptionalArg  (  )  ;  isVarArgs  =  oldParameterType  .  isVarArgs  (  )  ;  }  else  {  parameterType  =  typeRegistry  .  getNativeType  (  UNKNOWN_TYPE  )  ;  }  if  (  templateTypeName  !  =  null  &&  parameterType  .  restrictByNotNullOrUndefined  (  )  .  isTemplateType  (  )  )  {  if  (  foundTemplateType  )  {  reportError  (  TEMPLATE_TYPE_DUPLICATED  ,  fnName  )  ;  }  foundTemplateType  =  true  ;  }  warnedAboutArgList  |  =  addParameter  (  builder  ,  parameterType  ,  warnedAboutArgList  ,  isOptionalParam  ,  isVarArgs  )  ;  if  (  oldParameterType  !  =  null  )  {  oldParameterType  =  oldParameterType  .  getNext  (  )  ;  }  }  [BUGGY]  if  (  templateTypeName  !  =  null  &&  !foundTemplateType  )  {  reportError  (  TEMPLATE_TYPE_EXPECTED  ,  fnName  )  ;  }  for  (  String  inexistentName  :  allJsDocParams  )  {  	Closure_41_FunctionTypeBuilder_2_2	483	0	src/com/google/javascript/jscomp/FunctionTypeBuilder.java
345	if  (loopNode.isForEach())  {  errorReporter.error( "unsupported  language  extension:  for  each ",  sourceName,  loopNode.getLineno(), " ",  0);  return  newNode(Token.EXPR_RESULT,  Node.newNumber(0));  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  testErrorReporter  .  hasEncounteredAllWarnings  (  )  )  ;  [METHOD]  processForInLoop  [TYPE]  Node  [PARAMETER]  ForInLoop  loopNode  [CLASS]  TransformDispatcher  [TYPE]  ForInLoop  loopNode  [TYPE]  boolean  false  true  [CONTEXT]  Node  processForInLoop  (  ForInLoop  loopNode  )  {  [BUGGY]  return  newNode  (  Token  .  FOR  ,  transform  (  loopNode  .  getIterator  (  )  )  ,  transform  (  loopNode  .  getIteratedObject  (  )  )  ,  transformBlock  (  loopNode  .  getBody  (  )  )  )  ;  }  	Closure_42_IRFactory_1_1	568	0	src/com/google/javascript/jscomp/parsing/IRFactory.java
346	private  List<Node>  lentObjectLiterals  =  null;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[inconsistent  return  type  [CLASS]  [CONTEXT]  	Closure_43_TypedScopeCreator_3_1	420	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
347	if  (n.getParent()  !=  null  &&  NodeUtil.isStatement(n)  &&  lentObjectLiterals  !=  null)  {  for  (Node  objLit  :  lentObjectLiterals)  {  defineObjectLiteral(objLit);  }  lentObjectLiterals.clear();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[inconsistent  return  type  [CLASS]  [CONTEXT]  	Closure_43_TypedScopeCreator_3_2	547	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
348	JSDocInfo  info  =  n.getJSDocInfo();  if  (info  !=  null  &&  info.getLendsName()  !=  null)  {  if  (lentObjectLiterals  ==  null)  {  lentObjectLiterals  =  Lists.newArrayList();  }  lentObjectLiterals.add(n);  }  else  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[inconsistent  return  type  [METHOD]  attachLiteralTypes  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  thisType  [TYPE]  boolean  false  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  [TYPE]  InputId  inputId  [TYPE]  List  deferredSetTypes  nonExternFunctions  stubDeclarations  [TYPE]  String  sourceName  [CONTEXT]  case  Token  .  VOID:  n  .  setJSType  (  getNativeType  (  VOID_TYPE  )  )  ;  break  ;  case  Token  .  STRING:  if  (  !NodeUtil  .  isObjectLitKey  (  n  ,  n  .  getParent  (  )  )  )  {  n  .  setJSType  (  getNativeType  (  STRING_TYPE  )  )  ;  }  break  ;  case  Token  .  NUMBER:  n  .  setJSType  (  getNativeType  (  NUMBER_TYPE  )  )  ;  break  ;  case  Token  .  TRUE:  case  Token  .  FALSE:  n  .  setJSType  (  getNativeType  (  BOOLEAN_TYPE  )  )  ;  break  ;  case  Token  .  REGEXP:  n  .  setJSType  (  getNativeType  (  REGEXP_TYPE  )  )  ;  break  ;  case  Token  .  OBJECTLIT:  [BUGGY]  defineObjectLiteral  (  n  )  ;  break  ;  }  	Closure_43_TypedScopeCreator_3_3	580	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
349		[BUGGY]  [FE]  ComparisonFailure:  expected:<alert  (  /  //[  ]/  /  )  >  but  was:<alert  (  /  //[]/  /  )  >  assertPrint  ( "alert  (  /  //  /  /  )  ; "  , "alert  (  /  //  /  /  ) "  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  String  newcode  [CLASS]  CodeConsumer  [TYPE]  char  c  [TYPE]  boolean  false  sawFunction  statementNeedsEnded  statementStarted  true  [TYPE]  String  newcode  [CONTEXT]  void  add  (  String  newcode  )  {  maybeEndStatement  (  )  ;  if  (  newcode  .  length  (  )  =  =  0  )  {  return  ;  }  char  c  =  newcode  .  charAt  (  0  )  ;  if  (  (  isWordChar  (  c  )  ||  c  =  =  '\\'  )  &&  isWordChar  (  getLastChar  (  )  )  )  {  append  ( " "  )  ;  [BUGGY]  }  append  (  newcode  )  ;  }  	Closure_44_CodeConsumer_2_1	194	0	src/com/google/javascript/jscomp/CodeConsumer.java
350	append( " ");  	[BUGGY]  [FE]  ComparisonFailure:  expected:<alert  (  /  //[  ]/  /  )  >  but  was:<alert  (  /  //[]/  /  )  >  assertPrint  ( "alert  (  /  //  /  /  )  ; "  , "alert  (  /  //  /  /  ) "  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  String  newcode  [CLASS]  CodeConsumer  [TYPE]  char  c  [TYPE]  boolean  false  sawFunction  statementNeedsEnded  statementStarted  true  [TYPE]  String  newcode  [CONTEXT]  void  add  (  String  newcode  )  {  maybeEndStatement  (  )  ;  if  (  newcode  .  length  (  )  =  =  0  )  {  return  ;  }  char  c  =  newcode  .  charAt  (  0  )  ;  if  (  (  isWordChar  (  c  )  ||  c  =  =  '\\'  )  &&  isWordChar  (  getLastChar  (  )  )  )  {  append  ( " "  )  ;  [BUGGY]  }  append  (  newcode  )  ;  }  	Closure_44_CodeConsumer_2_2	199	0	src/com/google/javascript/jscomp/CodeConsumer.java
351	boolean  maybeEscaped  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  interpretAssigns  [TYPE]  void  [PARAMETER]  [CLASS]  RemoveUnusedVars  [TYPE]  Set  referenced  [TYPE]  Var  var  [TYPE]  Node  assignNode  nameNode  node  value  [TYPE]  SimpleDefinitionFinder  defFinder  [TYPE]  int  current  [TYPE]  Multimap  assignsByVar  continuations  inheritsCalls  [TYPE]  CallSiteOptimizer  callSiteOptimizer  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  assignedToUnknownValue  changes  false  hasPropertyAssign  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  true  [TYPE]  Scope  scope  [TYPE]  CodingConvention  codingConvention  [TYPE]  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  [TYPE]  Assign  assign  [TYPE]  Map  assignsByNode  [CONTEXT]  changes  =  false  ;  for  (  int  current  =  0  ;  current  <  maybeUnreferenced  .  size  (  )  ;  current++  )  {  Var  var  =  maybeUnreferenced  .  get  (  current  )  ;  if  (  referenced  .  contains  (  var  )  )  {  maybeUnreferenced  .  remove  (  current  )  ;  current--  ;  }  else  {  boolean  assignedToUnknownValue  =  false  ;  boolean  hasPropertyAssign  =  false  ;  if  (  var  .  getParentNode  (  )  .  isVar  (  )  &&  !NodeUtil  .  isForIn  (  var  .  getParentNode  (  )  .  getParent  (  )  )  )  {  Node  value  =  var  .  getInitialValue  (  )  ;  assignedToUnknownValue  =  value  !  =  null  &&  !NodeUtil  .  isLiteralValue  (  value  ,  true  )  ;  }  else  {  assignedToUnknownValue  =  true  ;  }  [BUGGY]  for  (  Assign  assign  :  assignsByVar  .  get  (  var  )  )  {  if  (  assign  .  isPropertyAssign  )  {  hasPropertyAssign  =  true  ;  }  else  if  (  !NodeUtil  .  isLiteralValue  (  assign  .  assignNode  .  getLastChild  (  )  ,  true  )  )  {  assignedToUnknownValue  =  true  ;  	Closure_45_RemoveUnusedVars_3_1	732	0	src/com/google/javascript/jscomp/RemoveUnusedVars.java
352	if  (assign.maybeAliased)  {  maybeEscaped  =  true;  }  if  ((assignedToUnknownValue  ||  maybeEscaped)  &&  hasPropertyAssign)  {  	[BUGGY]  if  (  assignedToUnknownValue  &&  hasPropertyAssign  )  {  [FE]  AssertionFailedError:  [METHOD]  interpretAssigns  [TYPE]  void  [PARAMETER]  [CLASS]  RemoveUnusedVars  [TYPE]  Set  referenced  [TYPE]  Var  var  [TYPE]  Node  assignNode  nameNode  node  value  [TYPE]  SimpleDefinitionFinder  defFinder  [TYPE]  int  current  [TYPE]  Multimap  assignsByVar  continuations  inheritsCalls  [TYPE]  CallSiteOptimizer  callSiteOptimizer  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  assignedToUnknownValue  changes  false  hasPropertyAssign  isPropertyAssign  mayHaveSecondarySideEffects  maybeAliased  modifyCallSites  preserveFunctionExpressionNames  removeGlobals  true  [TYPE]  Scope  scope  [TYPE]  CodingConvention  codingConvention  [TYPE]  List  allFunctionScopes  maybeUnreferenced  toRemove  toReplaceWithZero  [TYPE]  Assign  assign  [TYPE]  Map  assignsByNode  [CONTEXT]  if  (  referenced  .  contains  (  var  )  )  {  maybeUnreferenced  .  remove  (  current  )  ;  current--  ;  }  else  {  boolean  assignedToUnknownValue  =  false  ;  boolean  hasPropertyAssign  =  false  ;  if  (  var  .  getParentNode  (  )  .  isVar  (  )  &&  !NodeUtil  .  isForIn  (  var  .  getParentNode  (  )  .  getParent  (  )  )  )  {  Node  value  =  var  .  getInitialValue  (  )  ;  assignedToUnknownValue  =  value  !  =  null  &&  !NodeUtil  .  isLiteralValue  (  value  ,  true  )  ;  }  else  {  assignedToUnknownValue  =  true  ;  }  for  (  Assign  assign  :  assignsByVar  .  get  (  var  )  )  {  if  (  assign  .  isPropertyAssign  )  {  hasPropertyAssign  =  true  ;  }  else  if  (  !NodeUtil  .  isLiteralValue  (  assign  .  assignNode  .  getLastChild  (  )  ,  true  )  )  {  assignedToUnknownValue  =  true  ;  }  [BUGGY]  }  if  (  assignedToUnknownValue  &&  hasPropertyAssign  )  {  changes  =  markReferencedVar  (  var  )  ||  changes  ;  maybeUnreferenced  .  remove  (  current  )  ;  current--  ;  	Closure_45_RemoveUnusedVars_3_2	739	1	src/com/google/javascript/jscomp/RemoveUnusedVars.java
353	this.maybeAliased  =  NodeUtil.isExpressionResultUsed(assignNode);  	[BUGGY]  this  .  maybeAliased  =  !assignNode  .  getParent  (  )  .  isExprResult  (  )  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_45_RemoveUnusedVars_3_3	904	1	src/com/google/javascript/jscomp/RemoveUnusedVars.java
354		[BUGGY]  @Override  public  JSType  getLeastSupertype  (  JSType  that  )  {  if  (  !that  .  isRecordType  (  )  )  {  return  super  .  getLeastSupertype  (  that  )  ;  }  RecordTypeBuilder  builder  =  new  RecordTypeBuilder  (  registry  )  ;  for  (  String  property  :  properties  .  keySet  (  )  )  {  if  (  that  .  toMaybeRecordType  (  )  .  hasProperty  (  property  )  &&  that  .  toMaybeRecordType  (  )  .  getPropertyType  (  property  )  .  isEquivalentTo  (  getPropertyType  (  property  )  )  )  {  builder  .  addProperty  (  property  ,  getPropertyType  (  property  )  ,  getPropertyNode  (  property  )  )  ;  }  }  return  builder  .  build  (  )  ;  }  [FE]  AssertionFailedError:  Expected:  (  {a:  number  ,  b:  string}|{b:  string  ,  c:  string  ,  e:  number}  )  assertTypeEquals  (  [CLASS]  [CONTEXT]  	Closure_46_RecordType_1_1	140	16	src/com/google/javascript/rhino/jstype/RecordType.java
355	.setLineNumber(entry.getSourceLine()  +  1)  .setColumnPosition(entry.getSourceColumn()  +  1);  	[BUGGY]  .  setLineNumber  (  entry  .  getSourceLine  (  )  )  .  setColumnPosition  (  entry  .  getSourceColumn  (  )  )  ;  [FE]  AssertionFailedError:  expected:<5>  but  was:<4>  [METHOD]  getOriginalMappingForEntry  [TYPE]  OriginalMapping  [PARAMETER]  Entry  entry  [CLASS]  SourceMapConsumerV3  [TYPE]  StringCharIterator  content  [TYPE]  Entry  entry  [TYPE]  boolean  false  true  [TYPE]  Builder  x  [TYPE]  ArrayList  lines  [TYPE]  String[]  names  sources  [TYPE]  String  content  [TYPE]  Map  reverseSourceMapping  [TYPE]  int  MAX_ENTRY_VALUES  UNMAPPED  column  current  length  line  lineCount  name  previousCol  previousNameId  previousSrcColumn  previousSrcId  previousSrcLine  srcColumn  srcFile  srcLine  [CONTEXT]  private  OriginalMapping  getOriginalMappingForEntry  (  Entry  entry  )  {  if  (  entry  .  getSourceFileId  (  )  =  =  UNMAPPED  )  {  return  null  ;  }  else  {  Builder  x  =  OriginalMapping  .  newBuilder  (  )  .  setOriginalFile  (  sources[entry  .  getSourceFileId  (  )  ]  )  [BUGGY]  .  setLineNumber  (  entry  .  getSourceLine  (  )  )  .  setColumnPosition  (  entry  .  getSourceColumn  (  )  )  ;  if  (  entry  .  getNameId  (  )  !  =  UNMAPPED  )  {  x  .  setIdentifier  (  names[entry  .  getNameId  (  )  ]  )  ;  }  return  x  .  build  (  )  ;  }  }  	Closure_47_SourceMapConsumerV3_1_1	489	2	src/com/google/debugging/sourcemap/SourceMapConsumerV3.java
356	int  lineBaseOffset  =  1;  if  (generator  instanceof  SourceMapGeneratorV1  ||  generator  instanceof  SourceMapGeneratorV2)  {  lineBaseOffset  =  0;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<5>  but  was:<4>  [METHOD]  addMapping  [TYPE]  void  [PARAMETER]  Node  node  FilePosition  outputStartPosition  FilePosition  outputEndPosition  [CLASS]  SourceMap  [TYPE]  Format  DEFAULT  V1  V2  V3  [TYPE]  boolean  false  true  [TYPE]  DetailLevel  ALL  SYMBOLS  [TYPE]  Node  node  [TYPE]  List  prefixMappings  [TYPE]  String  originalName  prefix  replacement  sourceFile  [TYPE]  SourceMapGenerator  generator  [TYPE]  FilePosition  outputEndPosition  outputStartPosition  [TYPE]  Map  sourceLocationFixupCache  [CONTEXT]  public  void  addMapping  (  Node  node  ,  FilePosition  outputStartPosition  ,  FilePosition  outputEndPosition  )  {  String  sourceFile  =  node  .  getSourceFileName  (  )  ;  if  (  sourceFile  =  =  null  ||  node  .  getLineno  (  )  <  0  )  {  return  ;  }  sourceFile  =  fixupSourceLocation  (  sourceFile  )  ;  String  originalName  =  (  String  )  node  .  getProp  (  Node  .  ORIGINALNAME_PROP  )  ;  [BUGGY]  generator  .  addMapping  (  sourceFile  ,  originalName  ,  new  FilePosition  (  node  .  getLineno  (  )  ,  node  .  getCharno  (  )  )  ,  outputStartPosition  ,  outputEndPosition  )  ;  }  	Closure_47_SourceMap_2_1	138	0	src/com/google/javascript/jscomp/SourceMap.java
357	new  FilePosition(node.getLineno()  -  lineBaseOffset,  node.getCharno()),  	[BUGGY]  new  FilePosition  (  node  .  getLineno  (  )  ,  node  .  getCharno  (  )  )  ,  [FE]  AssertionFailedError:  expected:<5>  but  was:<4>  [METHOD]  addMapping  [TYPE]  void  [PARAMETER]  Node  node  FilePosition  outputStartPosition  FilePosition  outputEndPosition  [CLASS]  SourceMap  [TYPE]  Format  DEFAULT  V1  V2  V3  [TYPE]  boolean  false  true  [TYPE]  DetailLevel  ALL  SYMBOLS  [TYPE]  Node  node  [TYPE]  List  prefixMappings  [TYPE]  String  originalName  prefix  replacement  sourceFile  [TYPE]  SourceMapGenerator  generator  [TYPE]  FilePosition  outputEndPosition  outputStartPosition  [TYPE]  Map  sourceLocationFixupCache  [CONTEXT]  public  void  addMapping  (  Node  node  ,  FilePosition  outputStartPosition  ,  FilePosition  outputEndPosition  )  {  String  sourceFile  =  node  .  getSourceFileName  (  )  ;  if  (  sourceFile  =  =  null  ||  node  .  getLineno  (  )  <  0  )  {  return  ;  }  sourceFile  =  fixupSourceLocation  (  sourceFile  )  ;  String  originalName  =  (  String  )  node  .  getProp  (  Node  .  ORIGINALNAME_PROP  )  ;  generator  .  addMapping  (  sourceFile  ,  originalName  ,  [BUGGY]  new  FilePosition  (  node  .  getLineno  (  )  ,  node  .  getCharno  (  )  )  ,  outputStartPosition  ,  outputEndPosition  )  ;  }  	Closure_47_SourceMap_2_2	141	1	src/com/google/javascript/jscomp/SourceMap.java
358	if  (inferred  &&  rhsValue  !=  null  &&  rhsValue.isFunction())  {  if  (info  !=  null)  {  inferred  =  false;  }  else  if  (!scope.isDeclared(qName,  false)  &&  n.isUnscopedQualifiedName())  {  inferred  =  false;  }  	[BUGGY]  if  (  inferred  )  {  inferred  =  !  (  rhsValue  !  =  null  &&  rhsValue  .  isFunction  (  )  &&  (  info  !  =  null  ||  !scope  .  isDeclared  (  qName  ,  false  )  )  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  maybeDeclareQualifiedName  [TYPE]  void  [PARAMETER]  NodeTraversal  t  JSDocInfo  info  Node  n  Node  parent  Node  rhsValue  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  ownerType  qVarType  thisType  [TYPE]  JSType  delegateType  ownerTypeOfThis  valueType  [TYPE]  boolean  false  inferred  isExtern  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  qVar  [TYPE]  Node  n  ownerNode  parent  rhsValue  [TYPE]  FunctionType  ownerType  [TYPE]  InputId  inputId  [TYPE]  List  deferredSetTypes  nonExternFunctions  stubDeclarations  [TYPE]  String  delegateName  ownerName  propName  qName  sourceName  [TYPE]  JSDocInfo  info  [CONTEXT]  boolean  inferred  =  true  ;  if  (  info  !  =  null  )  {  inferred  =  !  (  info  .  hasType  (  )  ||  info  .  hasEnumParameterType  (  )  ||  (  info  .  isConstant  (  )  &&  valueType  !  =  null  &&  !valueType  .  isUnknownType  (  )  )  ||  FunctionTypeBuilder  .  isFunctionTypeDeclaration  (  info  )  )  ;  }  [BUGGY]  if  (  inferred  )  {  inferred  =  !  (  rhsValue  !  =  null  &&  rhsValue  .  isFunction  (  )  &&  (  info  !  =  null  ||  !scope  .  isDeclared  (  qName  ,  false  )  )  )  ;  }  	Closure_48_TypedScopeCreator_1_1	1521	4	src/com/google/javascript/jscomp/TypedScopeCreator.java
359		[BUGGY]  if  (  declarationRoot  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  for  (  Node  c  =  declarationRoot  .  getFirstChild  (  )  .  getNext  (  )  .  getFirstChild  (  )  ;  c  !  =  null  ;  c  =  c  .  getNext  (  )  )  {  String  name  =  c  .  getString  (  )  ;  renamer  .  addDeclaredName  (  name  )  ;  }  Node  functionBody  =  declarationRoot  .  getLastChild  (  )  ;  findDeclaredNames  (  functionBody  ,  null  ,  renamer  )  ;  }  else  [FE]  AssertionFailedError:  [METHOD]  enterScope  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  MakeDeclaredNamesUnique  [TYPE]  Renamer  renamer  rootRenamer  [TYPE]  AbstractCompiler  compiler  [TYPE]  Set  referencedNames  [TYPE]  boolean  false  global  removeConstness  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  c  declarationRoot  functionBody  [TYPE]  Multiset  nameUsage  [TYPE]  Supplier  uniqueIdSupplier  [TYPE]  String  ARGUMENTS  UNIQUE_ID_SEPARATOR  idPrefix  name  [TYPE]  Deque  nameStack  referenceStack  [TYPE]  Map  declarations  nameMap  [CONTEXT]  public  void  enterScope  (  NodeTraversal  t  )  {  Node  declarationRoot  =  t  .  getScopeRoot  (  )  ;  Renamer  renamer  ;  if  (  nameStack  .  isEmpty  (  )  )  {  Preconditions  .  checkState  (  declarationRoot  .  getType  (  )  !  =  Token  .  FUNCTION  ||  !  (  rootRenamer  instanceof  ContextualRenamer  )  )  ;  Preconditions  .  checkState  (  t  .  inGlobalScope  (  )  )  ;  renamer  =  rootRenamer  ;  }  else  {  renamer  =  nameStack  .  peek  (  )  .  forChildScope  (  )  ;  }  [BUGGY]  if  (  declarationRoot  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  for  (  Node  c  =  declarationRoot  .  getFirstChild  (  )  .  getNext  (  )  .  getFirstChild  (  )  ;  c  !  =  null  ;  c  =  c  .  getNext  (  )  )  {  String  name  =  c  .  getString  (  )  ;  renamer  .  addDeclaredName  (  name  )  ;  }  Node  functionBody  =  declarationRoot  .  getLastChild  (  )  ;  findDeclaredNames  (  functionBody  ,  null  ,  renamer  )  ;  }else  if  (  declarationRoot  .  getType  (  )  !  =  Token  .  FUNCTION  )  {  findDeclaredNames  (  declarationRoot  ,  null  ,  renamer  )  ;  }  nameStack  .  push  (  renamer  )  ;  }  	Closure_49_MakeDeclaredNamesUnique_5_1	91	8	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
360	nameStack.push(renamer);  }  break;  case  Token.LP:  {  Renamer  renamer  =  nameStack.peek().forChildScope();  for  (Node  c  =  n.getFirstChild();  c  !=  null;  c  =  c.getNext())  {  String  name  =  c.getString();  renamer.addDeclaredName(name);  }  Node  functionBody  =  n.getNext();  findDeclaredNames(functionBody,  null,  renamer);  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  shouldTraverse  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  MakeDeclaredNamesUnique  [TYPE]  Renamer  renamer  rootRenamer  [TYPE]  AbstractCompiler  compiler  [TYPE]  Set  referencedNames  [TYPE]  boolean  false  global  removeConstness  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  parent  [TYPE]  Multiset  nameUsage  [TYPE]  Supplier  uniqueIdSupplier  [TYPE]  String  ARGUMENTS  UNIQUE_ID_SEPARATOR  idPrefix  name  [TYPE]  Deque  nameStack  referenceStack  [TYPE]  Map  declarations  nameMap  [CONTEXT]  public  boolean  shouldTraverse  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  FUNCTION:  {  Renamer  renamer  =  nameStack  .  peek  (  )  .  forChildScope  (  )  ;  String  name  =  n  .  getFirstChild  (  )  .  getString  (  )  ;  if  (  name  !  =  null  &&  !name  .  isEmpty  (  )  &&  parent  !  =  null  &&  !NodeUtil  .  isFunctionDeclaration  (  n  )  )  {  renamer  .  addDeclaredName  (  name  )  ;  }  [BUGGY]  	Closure_49_MakeDeclaredNamesUnique_5_2	130	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
361	nameStack.pop();  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  MakeDeclaredNamesUnique  [TYPE]  Renamer  renamer  rootRenamer  [TYPE]  AbstractCompiler  compiler  [TYPE]  Set  referencedNames  [TYPE]  boolean  false  global  removeConstness  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  parent  [TYPE]  Multiset  nameUsage  [TYPE]  Supplier  uniqueIdSupplier  [TYPE]  String  ARGUMENTS  UNIQUE_ID_SEPARATOR  idPrefix  newName  [TYPE]  Deque  nameStack  referenceStack  [TYPE]  Map  declarations  nameMap  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  NAME:  String  newName  =  getReplacementName  (  n  .  getString  (  )  )  ;  if  (  newName  !  =  null  )  {  Renamer  renamer  =  nameStack  .  peek  (  )  ;  if  (  renamer  .  stripConstIfReplaced  (  )  )  {  n  .  removeProp  (  Node  .  IS_CONSTANT_NAME  )  ;  }  n  .  setString  (  newName  )  ;  t  .  getCompiler  (  )  .  reportCodeChange  (  )  ;  }  break  ;  case  Token  .  FUNCTION:  [BUGGY]  nameStack  .  pop  (  )  ;  break  ;  	Closure_49_MakeDeclaredNamesUnique_5_3	173	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
362	case  Token.LP:  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  MakeDeclaredNamesUnique  [TYPE]  Renamer  renamer  rootRenamer  [TYPE]  AbstractCompiler  compiler  [TYPE]  Set  referencedNames  [TYPE]  boolean  false  global  removeConstness  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  parent  [TYPE]  Multiset  nameUsage  [TYPE]  Supplier  uniqueIdSupplier  [TYPE]  String  ARGUMENTS  UNIQUE_ID_SEPARATOR  idPrefix  newName  [TYPE]  Deque  nameStack  referenceStack  [TYPE]  Map  declarations  nameMap  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  NAME:  String  newName  =  getReplacementName  (  n  .  getString  (  )  )  ;  if  (  newName  !  =  null  )  {  Renamer  renamer  =  nameStack  .  peek  (  )  ;  if  (  renamer  .  stripConstIfReplaced  (  )  )  {  n  .  removeProp  (  Node  .  IS_CONSTANT_NAME  )  ;  }  n  .  setString  (  newName  )  ;  t  .  getCompiler  (  )  .  reportCodeChange  (  )  ;  }  break  ;  case  Token  .  FUNCTION:  nameStack  .  pop  (  )  ;  break  ;  [BUGGY]  case  Token  .  CATCH:  	Closure_49_MakeDeclaredNamesUnique_5_4	177	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
363	break;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  MakeDeclaredNamesUnique  [TYPE]  Renamer  renamer  rootRenamer  [TYPE]  AbstractCompiler  compiler  [TYPE]  Set  referencedNames  [TYPE]  boolean  false  global  removeConstness  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  parent  [TYPE]  Multiset  nameUsage  [TYPE]  Supplier  uniqueIdSupplier  [TYPE]  String  ARGUMENTS  UNIQUE_ID_SEPARATOR  idPrefix  newName  [TYPE]  Deque  nameStack  referenceStack  [TYPE]  Map  declarations  nameMap  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  NAME:  String  newName  =  getReplacementName  (  n  .  getString  (  )  )  ;  if  (  newName  !  =  null  )  {  Renamer  renamer  =  nameStack  .  peek  (  )  ;  if  (  renamer  .  stripConstIfReplaced  (  )  )  {  n  .  removeProp  (  Node  .  IS_CONSTANT_NAME  )  ;  }  n  .  setString  (  newName  )  ;  t  .  getCompiler  (  )  .  reportCodeChange  (  )  ;  }  break  ;  case  Token  .  FUNCTION:  nameStack  .  pop  (  )  ;  break  ;  [BUGGY]  case  Token  .  CATCH:  nameStack  .  pop  (  )  ;  break  ;  }  	Closure_49_MakeDeclaredNamesUnique_5_5	180	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
364	if  (right.getNext()  !=  null  ||  !NodeUtil.isImmutableValue(right))  {  	[BUGGY]  if  (  !NodeUtil  .  isImmutableValue  (  right  )  )  {  [FE]  AssertionFailedError:  [METHOD]  tryFoldArrayJoin  [TYPE]  Node  [PARAMETER]  Node  n  [CLASS]  PeepholeReplaceKnownMethods  [TYPE]  Locale  ROOT_LOCALE  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  [TYPE]  List  arrayFoldedChildren  [TYPE]  String  joinString  [TYPE]  int  foldedSize  kJoinOverhead  originalSize  [CONTEXT]  private  Node  tryFoldArrayJoin  (  Node  n  )  {  Node  callTarget  =  n  .  getFirstChild  (  )  ;  if  (  callTarget  =  =  null  ||  !NodeUtil  .  isGetProp  (  callTarget  )  )  {  return  n  ;  }  Node  right  =  callTarget  .  getNext  (  )  ;  if  (  right  !  =  null  )  {  [BUGGY]  if  (  !NodeUtil  .  isImmutableValue  (  right  )  )  {  return  n  ;  }  }  Node  arrayNode  =  callTarget  .  getFirstChild  (  )  ;  	Closure_50_PeepholeReplaceKnownMethods_2_1	376	1	src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java
365	if  (right  !=  null  &&  right.getType()  ==  Token.STRING  && ", ".equals(right.getString()))  {  n.removeChild(right);  reportCodeChange();  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  tryFoldArrayJoin  [TYPE]  Node  [PARAMETER]  Node  n  [CLASS]  PeepholeReplaceKnownMethods  [TYPE]  Locale  ROOT_LOCALE  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Node  arrayNode  callTarget  elem  emptyStringNode  foldedStringNode  functionName  n  node  prev  replacement  right  [TYPE]  List  arrayFoldedChildren  [TYPE]  String  joinString  [TYPE]  int  foldedSize  kJoinOverhead  originalSize  [CONTEXT]  private  Node  tryFoldArrayJoin  (  Node  n  )  {  Node  callTarget  =  n  .  getFirstChild  (  )  ;  if  (  callTarget  =  =  null  ||  !NodeUtil  .  isGetProp  (  callTarget  )  )  {  return  n  ;  }  Node  right  =  callTarget  .  getNext  (  )  ;  if  (  right  !  =  null  )  {  if  (  !NodeUtil  .  isImmutableValue  (  right  )  )  {  return  n  ;  }  }  Node  arrayNode  =  callTarget  .  getFirstChild  (  )  ;  Node  functionName  =  arrayNode  .  getNext  (  )  ;  if  (  (  arrayNode  .  getType  (  )  !  =  Token  .  ARRAYLIT  )  ||  !functionName  .  getString  (  )  .  equals  ( "join "  )  )  {  return  n  ;  }  [BUGGY]  String  joinString  =  (  right  =  =  null  )  ? "  , "  :  NodeUtil  .  getStringValue  (  right  )  ;  List<Node>  arrayFoldedChildren  =  Lists  .  newLinkedList  (  )  ;  StringBuilder  sb  =  null  ;  int  foldedSize  =  0  ;  	Closure_50_PeepholeReplaceKnownMethods_2_2	389	0	src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java
366	if  ((long)  x  ==  x  &&  !isNegativeZero(x))  {  	[BUGGY]  if  (  (  long  )  x  ==  x  )  {  [FE]  ComparisonFailure:  expected:<var  x  =  [-0]0>  but  was:<var  x  =  []0>  assertPrint  ( "var  x  =  -0  .  0  ; "  , "var  x  =  -0  .  0 "  )  ;  [METHOD]  addNumber  [TYPE]  void  [PARAMETER]  double  x  [CLASS]  CodeConsumer  [TYPE]  char  prev  [TYPE]  boolean  false  sawFunction  statementNeedsEnded  statementStarted  true  [TYPE]  double  x  [TYPE]  long  mantissa  value  [TYPE]  int  exp  [CONTEXT]  void  addNumber  (  double  x  )  {  char  prev  =  getLastChar  (  )  ;  if  (  x  <  0  &&  prev  =  =  '-'  )  {  add  ( " "  )  ;  }  [BUGGY]  if  (  (  long  )  x  =  =  x  )  {  long  value  =  (  long  )  x  ;  long  mantissa  =  value  ;  int  exp  =  0  ;  if  (  Math  .  abs  (  x  )  >  =  100  )  {  while  (  mantissa  /  10  *  Math  .  pow  (  10  ,  exp  +  1  )  =  =  value  )  {  mantissa  /  =  10  ;  exp++  ;  }  }  if  (  exp  >  2  )  {  add  (  Long  .  toString  (  mantissa  )  + "E "  +  Integer  .  toString  (  exp  )  )  ;  }  else  {  add  (  Long  .  toString  (  value  )  )  ;  }  }  else  {  add  (  String  .  valueOf  (  x  )  )  ;  }  }  	Closure_51_CodeConsumer_1_1	241	1	src/com/google/javascript/jscomp/CodeConsumer.java
368	return len > 0 && s.charAt(0) != '0';	[BUGGY]  return  len  >  0  ;    [FE]  ComparisonFailure:  expected:<var  x  =  {[ "010 "]:1}>  but  was:<var  x  =  {[10]:1}>  assertPrint  ( "var  x  =  {'0  .  2':  1}  ; "  , "var  x  =  {\ "0  .  2\ ":1} "  )  ;  [METHOD]  isSimpleNumber  [TYPE]  boolean  [PARAMETER]  String  s  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  [TYPE]  boolean  false  true  [TYPE]  char  c  [TYPE]  CodeConsumer  cc  [TYPE]  String  s  [TYPE]  Map  ESCAPED_JS_STRINGS  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  index  len  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  static  boolean  isSimpleNumber  (  String  s  )  {  int  len  =  s  .  length  (  )  ;  for  (  int  index  =  0  ;  index  <  len  ;  index++  )  {  char  c  =  s  .  charAt  (  index  )  ;  if  (  c  <  '0'  ||  c  >  '9'  )  {  return  false  ;  }  }  [BUGGY]  return  len  >  0  ;  }  	Closure_52_CodeGenerator_1_1	745	1	src/com/google/javascript/jscomp/CodeGenerator.java
369	if  (nodes.isEmpty())  {  replacement  =  new  Node(Token.TRUE);  }  else  {  	[BUGGY]  [FE]  RuntimeException:  INTERNAL  COMPILER  ERROR  [METHOD]  replaceAssignmentExpression  [TYPE]  void  [PARAMETER]  Var  v  Reference  ref  String>  varmap  [CLASS]  InliningBehavior  [TYPE]  Set  all  staleVars  [TYPE]  boolean  false  true  [TYPE]  Var  v  [TYPE]  Reference  ref  [TYPE]  Node  cur  key  replace  replacement  t  val  value  [TYPE]  List  nodes  [TYPE]  String  var  [TYPE]  Map  varmap  [TYPE]  int  i  [CONTEXT]  List<Node>  nodes  =  Lists  .  newArrayList  (  )  ;  Node  val  =  ref  .  getAssignedValue  (  )  ;  blacklistVarReferencesInTree  (  val  ,  v  .  scope  )  ;  Preconditions  .  checkState  (  val  .  getType  (  )  =  =  Token  .  OBJECTLIT  )  ;  Set<String>  all  =  Sets  .  newLinkedHashSet  (  varmap  .  keySet  (  )  )  ;  for  (  Node  key  =  val  .  getFirstChild  (  )  ;  key  !  =  null  ;  key  =  key  .  getNext  (  )  )  {  String  var  =  key  .  getString  (  )  ;  Node  value  =  key  .  removeFirstChild  (  )  ;  nodes  .  add  (  new  Node  (  Token  .  ASSIGN  ,  Node  .  newString  (  Token  .  NAME  ,  varmap  .  get  (  var  )  )  ,  value  )  )  ;  all  .  remove  (  var  )  ;  }  for  (  String  var  :  all  )  {  nodes  .  add  (  new  Node  (  Token  .  ASSIGN  ,  Node  .  newString  (  Token  .  NAME  ,  varmap  .  get  (  var  )  )  ,  NodeUtil  .  newUndefinedNode  (  null  )  )  )  ;  }  Node  replacement  ;  [BUGGY]  nodes  .  add  (  new  Node  (  Token  .  TRUE  )  )  ;  	Closure_53_InlineObjectLiterals_2_1	331	0	src/com/google/javascript/jscomp/InlineObjectLiterals.java
370	}  	[BUGGY]  [FE]  RuntimeException:  INTERNAL  COMPILER  ERROR  [METHOD]  replaceAssignmentExpression  [TYPE]  void  [PARAMETER]  Var  v  Reference  ref  String>  varmap  [CLASS]  InliningBehavior  [TYPE]  Set  all  staleVars  [TYPE]  boolean  false  true  [TYPE]  Var  v  [TYPE]  Reference  ref  [TYPE]  Node  cur  key  replace  replacement  t  val  value  [TYPE]  List  nodes  [TYPE]  String  var  [TYPE]  Map  varmap  [TYPE]  int  i  [CONTEXT]  new  Node  (  Token  .  ASSIGN  ,  Node  .  newString  (  Token  .  NAME  ,  varmap  .  get  (  var  )  )  ,  NodeUtil  .  newUndefinedNode  (  null  )  )  )  ;  }  Node  replacement  ;  nodes  .  add  (  new  Node  (  Token  .  TRUE  )  )  ;  nodes  =  Lists  .  reverse  (  nodes  )  ;  replacement  =  new  Node  (  Token  .  COMMA  )  ;  Node  cur  =  replacement  ;  int  i  ;  for  (  i  =  0  ;  i  <  nodes  .  size  (  )  -  2  ;  i++  )  {  cur  .  addChildToFront  (  nodes  .  get  (  i  )  )  ;  Node  t  =  new  Node  (  Token  .  COMMA  )  ;  cur  .  addChildToFront  (  t  )  ;  cur  =  t  ;  }  cur  .  addChildToFront  (  nodes  .  get  (  i  )  )  ;  cur  .  addChildToFront  (  nodes  .  get  (  i  +  1  )  )  ;  [BUGGY]  Node  replace  =  ref  .  getParent  (  )  ;  replacement  .  copyInformationFromForTree  (  replace  )  ;  if  (  replace  .  getType  (  )  =  =  Token  .  VAR  )  {  replace  .  getParent  (  )  .  replaceChild  (  	Closure_53_InlineObjectLiterals_2_2	350	0	src/com/google/javascript/jscomp/InlineObjectLiterals.java
371	ObjectType  qVarType  =  ObjectType.cast(qVar.getType());  if  (qVarType  !=  null  &&  rhsValue  !=  null  &&  rhsValue.getType()  ==  Token.OBJECTLIT)  {  typeRegistry.resetImplicitPrototype(  rhsValue.getJSType(),  qVarType.getImplicitPrototype());  }  else  if  (!qVar.isTypeInferred())  {  	[BUGGY]  if  (  !qVar  .  isTypeInferred  (  )  )  {  [FE]  ComparisonFailure:  expected:<[Function  Fooprototypemethod:  called  with  1  argument  (  s  )  Function  requires  at  least  0  argument  (  s  )  and  no  more  than  0  argument  (  s  )  ]>  but  was:<[Property  baz  never  defined  on  Bar]>  [METHOD]  maybeDeclareQualifiedName  [TYPE]  void  [PARAMETER]  NodeTraversal  t  JSDocInfo  info  Node  n  Node  parent  Node  rhsValue  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  ownerType  thisType  [TYPE]  JSType  delegateType  ownerTypeOfThis  valueType  [TYPE]  boolean  false  inferred  isExtern  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  qVar  [TYPE]  Node  n  ownerNode  parent  rhsValue  [TYPE]  FunctionType  ownerType  [TYPE]  InputId  inputId  [TYPE]  List  deferredSetTypes  nonExternFunctions  stubDeclarations  [TYPE]  String  delegateName  ownerName  propName  qName  sourceName  [TYPE]  JSDocInfo  info  [CONTEXT]  JSType  valueType  =  getDeclaredType  (  t  .  getSourceName  (  )  ,  info  ,  n  ,  rhsValue  )  ;  if  (  valueType  =  =  null  &&  rhsValue  !  =  null  )  {  valueType  =  rhsValue  .  getJSType  (  )  ;  }  if  ( "prototype "  .  equals  (  propName  )  )  {  Var  qVar  =  scope  .  getVar  (  qName  )  ;  if  (  qVar  !  =  null  )  {  [BUGGY]  if  (  !qVar  .  isTypeInferred  (  )  )  {  	Closure_54_TypedScopeCreator_1_1	1413	1	src/com/google/javascript/jscomp/TypedScopeCreator.java
372		[BUGGY]  baseType  .  isUnknownType  (  )  ||  [FE]  ComparisonFailure:  expected:<[Function  Fooprototypemethod:  called  with  1  argument  (  s  )  Function  requires  at  least  0  argument  (  s  )  and  no  more  than  0  argument  (  s  )  ]>  but  was:<[Property  baz  never  defined  on  Bar]>  [METHOD]  setPrototypeBasedOn  [TYPE]  void  [PARAMETER]  ObjectType  baseType  [CLASS]  FunctionType  [TYPE]  ObjectType  baseType  typeOfThis  [TYPE]  boolean  false  true  [TYPE]  Kind  CONSTRUCTOR  INTERFACE  ORDINARY  kind  [TYPE]  Node  source  [TYPE]  ArrowType  call  [TYPE]  PrototypeObjectType  prototype  [TYPE]  List  extendedInterfaces  implementedInterfaces  subTypes  [TYPE]  String  templateTypeName  [TYPE]  SimpleSlot  prototypeSlot  [TYPE]  long  serialVersionUID  [CONTEXT]  public  void  setPrototypeBasedOn  (  ObjectType  baseType  )  {  if  (  baseType  .  hasReferenceName  (  )  ||  [BUGGY]  baseType  .  isUnknownType  (  )  ||  isNativeObjectType  (  )  ||  baseType  .  isFunctionPrototypeType  (  )  ||  !  (  baseType  instanceof  PrototypeObjectType  )  )  {  baseType  =  new  PrototypeObjectType  (  registry  ,  this  .  getReferenceName  (  )  + "  .  prototype "  ,  baseType  )  ;  }  setPrototype  (  (  PrototypeObjectType  )  baseType  )  ;  }  	Closure_54_FunctionType_3_1	341	1	src/com/google/javascript/rhino/jstype/FunctionType.java
373	PrototypeObjectType  oldPrototype  =  this.prototype;  boolean  replacedPrototype  =  oldPrototype  !=  null;  	[BUGGY]  boolean  replacedPrototype  =  prototype  !  =  null  ;  [FE]  ComparisonFailure:  expected:<[Function  Fooprototypemethod:  called  with  1  argument  (  s  )  Function  requires  at  least  0  argument  (  s  )  and  no  more  than  0  argument  (  s  )  ]>  but  was:<[Property  baz  never  defined  on  Bar]>  [METHOD]  setPrototype  [TYPE]  boolean  [PARAMETER]  PrototypeObjectType  prototype  [CLASS]  FunctionType  [TYPE]  ObjectType  interfaceType  typeOfThis  [TYPE]  boolean  false  replacedPrototype  true  [TYPE]  Kind  CONSTRUCTOR  INTERFACE  ORDINARY  kind  [TYPE]  Node  source  [TYPE]  FunctionType  superClass  [TYPE]  ArrowType  call  [TYPE]  PrototypeObjectType  prototype  [TYPE]  List  extendedInterfaces  implementedInterfaces  subTypes  [TYPE]  String  templateTypeName  [TYPE]  SimpleSlot  prototypeSlot  [TYPE]  long  serialVersionUID  [CONTEXT]  public  boolean  setPrototype  (  PrototypeObjectType  prototype  )  {  if  (  prototype  =  =  null  )  {  return  false  ;  }  if  (  isConstructor  (  )  &&  prototype  =  =  getInstanceType  (  )  )  {  return  false  ;  }  [BUGGY]  boolean  replacedPrototype  =  prototype  !  =  null  ;  this  .  prototype  =  prototype  ;  this  .  prototypeSlot  =  new  SimpleSlot  ( "prototype "  ,  prototype  ,  true  )  ;  this  .  prototype  .  setOwnerFunction  (  this  )  ;  	Closure_54_FunctionType_3_2	366	1	src/com/google/javascript/rhino/jstype/FunctionType.java
374	if  (oldPrototype  !=  null)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[Function  Fooprototypemethod:  called  with  1  argument  (  s  )  Function  requires  at  least  0  argument  (  s  )  and  no  more  than  0  argument  (  s  )  ]>  but  was:<[Property  baz  never  defined  on  Bar]>  [METHOD]  setPrototype  [TYPE]  boolean  [PARAMETER]  PrototypeObjectType  prototype  [CLASS]  FunctionType  [TYPE]  ObjectType  interfaceType  typeOfThis  [TYPE]  boolean  false  replacedPrototype  true  [TYPE]  Kind  CONSTRUCTOR  INTERFACE  ORDINARY  kind  [TYPE]  Node  source  [TYPE]  FunctionType  superClass  [TYPE]  ArrowType  call  [TYPE]  PrototypeObjectType  prototype  [TYPE]  List  extendedInterfaces  implementedInterfaces  subTypes  [TYPE]  String  templateTypeName  [TYPE]  SimpleSlot  prototypeSlot  [TYPE]  long  serialVersionUID  [CONTEXT]  public  boolean  setPrototype  (  PrototypeObjectType  prototype  )  {  if  (  prototype  =  =  null  )  {  return  false  ;  }  if  (  isConstructor  (  )  &&  prototype  =  =  getInstanceType  (  )  )  {  return  false  ;  }  boolean  replacedPrototype  =  prototype  !  =  null  ;  this  .  prototype  =  prototype  ;  this  .  prototypeSlot  =  new  SimpleSlot  ( "prototype "  ,  prototype  ,  true  )  ;  this  .  prototype  .  setOwnerFunction  (  this  )  ;  [BUGGY]  if  (  isConstructor  (  )  ||  isInterface  (  )  )  {  FunctionType  superClass  =  getSuperClassConstructor  (  )  ;  if  (  superClass  !  =  null  )  {  	Closure_54_FunctionType_3_3	372	0	src/com/google/javascript/rhino/jstype/FunctionType.java
375	return  NodeUtil.isFunctionExpression(n)  &&  !NodeUtil.isGetOrSetKey(n.getParent());  	[BUGGY]  return  NodeUtil  .  isFunctionExpression  (  n  )  ;  [FE]  IllegalStateException:  Expected  function  but  was  call  Reference  node  CALL  4  [free_call:  1]  [source_file:  testcode]  [METHOD]  isReduceableFunctionExpression  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  FunctionRewriter  [TYPE]  Multimap  reductions  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  n  newChild  oldChild  parent  [TYPE]  List  reducers  [TYPE]  String  FACTORY_METHOD_NAME  HELPER_SOURCE  [TYPE]  int  SAVINGS_THRESHOLD  [CONTEXT]  private  static  boolean  isReduceableFunctionExpression  (  Node  n  )  {  [BUGGY]  return  NodeUtil  .  isFunctionExpression  (  n  )  ;  }  	Closure_55_FunctionRewriter_1_1	117	1	src/com/google/javascript/jscomp/FunctionRewriter.java
376	if  (pos  >=  js.length())  {  }  else  {  return  js.substring(pos,  js.length());  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<foo2:third  line>  but  was:<null>  assertEquals  (  null  ,  provider  .  getSourceLine  ( "foo2 "  ,  4  )  )  ;  [METHOD]  getLine  [TYPE]  String  [PARAMETER]  int  lineNumber  [CLASS]  SourceFile  [TYPE]  boolean  false  isExternFile  true  [TYPE]  int[]  lineOffsets  [TYPE]  String  code  fileName  inputCharset  js  originalPath  [TYPE]  IOException  e  [TYPE]  File  file  [TYPE]  long  serialVersionUID  [TYPE]  int  SOURCE_EXCERPT_REGION_LENGTH  lastLine  lastOffset  lineNumber  n  nextpos  pos  startLine  [TYPE]  Generator  generator  [CONTEXT]  int  startLine  =  1  ;  if  (  lineNumber  >  =  lastLine  )  {  pos  =  lastOffset  ;  startLine  =  lastLine  ;  }  for  (  int  n  =  startLine  ;  n  <  lineNumber  ;  n++  )  {  int  nextpos  =  js  .  indexOf  (  '\n'  ,  pos  )  ;  if  (  nextpos  =  =  -1  )  {  return  null  ;  }  pos  =  nextpos  +  1  ;  }  lastOffset  =  pos  ;  lastLine  =  lineNumber  ;  if  (  js  .  indexOf  (  '\n'  ,  pos  )  =  =  -1  )  {  [BUGGY]  return  null  ;  }  else  {  return  js  .  substring  (  pos  ,  js  .  indexOf  (  '\n'  ,  pos  )  )  ;  }  }  	Closure_56_SourceFile_1_1	242	0	src/com/google/javascript/jscomp/SourceFile.java
377	if  (target  !=  null  &&  target.getType()  ==  Token.STRING)  {  	[BUGGY]  if  (  target  !  =  null  )  {  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  foo  assertEquals  (  superclassName  ,  classes  .  superclassName  )  ;  [METHOD]  extractClassNameIfGoog  [TYPE]  String  [PARAMETER]  Node  node  Node  parent  String  functionName  [CLASS]  ClosureCodingConvention  [TYPE]  Set  propertyTestFunctions  [TYPE]  String  className  functionName  qualifiedName  [TYPE]  boolean  false  true  [TYPE]  DiagnosticType  OBJECTLIT_EXPECTED  [TYPE]  long  serialVersionUID  [TYPE]  Node  callee  node  parent  target  [CONTEXT]  private  static  String  extractClassNameIfGoog  (  Node  node  ,  Node  parent  ,  String  functionName  )  {  String  className  =  null  ;  if  (  NodeUtil  .  isExprCall  (  parent  )  )  {  Node  callee  =  node  .  getFirstChild  (  )  ;  if  (  callee  !  =  null  &&  callee  .  getType  (  )  =  =  Token  .  GETPROP  )  {  String  qualifiedName  =  callee  .  getQualifiedName  (  )  ;  if  (  functionName  .  equals  (  qualifiedName  )  )  {  Node  target  =  callee  .  getNext  (  )  ;  [BUGGY]  if  (  target  !  =  null  )  {  className  =  target  .  getString  (  )  ;  }  }  }  }  return  className  ;  }  	Closure_57_ClosureCodingConvention_1_1	197	1	src/com/google/javascript/jscomp/ClosureCodingConvention.java
378	if  (NodeUtil.isName(lhs))  {  }  else  {  computeGenKill(lhs,  gen,  kill,  conditional);  }  	[BUGGY]  [FE]  IllegalStateException  assertLiveBeforeX  ( "var  a  =  [0]  ;  X:for  (  a[1]  in  foo  )  {  } "  , "a "  )  ;  [METHOD]  computeGenKill  [TYPE]  void  [PARAMETER]  Node  n  BitSet  gen  BitSet  kill  boolean  conditional  [CLASS]  LiveVariablesAnalysis  [TYPE]  BitSet  gen  kill  liveSet  [TYPE]  Set  escaped  [TYPE]  String  ARGUMENT_ARRAY_ALIAS  [TYPE]  boolean  conditional  false  true  [TYPE]  Scope  jsScope  [TYPE]  Node  c  lhs  n  rhs  [CONTEXT]  switch  (  n  .  getType  (  )  )  {  case  Token  .  SCRIPT:  case  Token  .  BLOCK:  case  Token  .  FUNCTION:  return  ;  case  Token  .  WHILE:  case  Token  .  DO:  case  Token  .  IF:  computeGenKill  (  NodeUtil  .  getConditionExpression  (  n  )  ,  gen  ,  kill  ,  conditional  )  ;  return  ;  case  Token  .  FOR:  if  (  !NodeUtil  .  isForIn  (  n  )  )  {  computeGenKill  (  NodeUtil  .  getConditionExpression  (  n  )  ,  gen  ,  kill  ,  conditional  )  ;  }  else  {  Node  lhs  =  n  .  getFirstChild  (  )  ;  Node  rhs  =  lhs  .  getNext  (  )  ;  if  (  NodeUtil  .  isVar  (  lhs  )  )  {  lhs  =  lhs  .  getLastChild  (  )  ;  }  [BUGGY]  addToSetIfLocal  (  lhs  ,  kill  )  ;  addToSetIfLocal  (  lhs  ,  gen  )  ;  computeGenKill  (  rhs  ,  gen  ,  kill  ,  conditional  )  ;  }  return  ;  	Closure_58_LiveVariablesAnalysis_1_1	206	0	src/com/google/javascript/jscomp/LiveVariablesAnalysis.java
379	if  (options.checkGlobalThisLevel.isOn()  &&  !options.disables(DiagnosticGroups.GLOBAL_THIS))  {  	[BUGGY]  if  (  options  .  checkGlobalThisLevel  .  isOn  (  )  )  {  [FE]  AssertionFailedError:  Expected  no  warnings  or  errors  [METHOD]  initOptions  [TYPE]  void  [PARAMETER]  CompilerOptions  options  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  LifeCycleStage  lifeCycleStage  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  GlobalVarReferenceMap  globalRefMap  [TYPE]  PrintStreamErrorManager  printer  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MISSING_ENTRY_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  guards  inputs  modules  [TYPE]  WarningsGuard  warningsGuard  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  uniqueNameId  [TYPE]  boolean  false  hasRegExpGlobalReferences  true  useThreads  [TYPE]  ComposeWarningsGuard  composedGuards  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  inputsByName  [CONTEXT]  setErrorManager  (  new  LoggerErrorManager  (  createMessageFormatter  (  )  ,  logger  )  )  ;  }  else  {  PrintStreamErrorManager  printer  =  new  PrintStreamErrorManager  (  createMessageFormatter  (  )  ,  outStream  )  ;  printer  .  setSummaryDetailLevel  (  options  .  summaryDetailLevel  )  ;  setErrorManager  (  printer  )  ;  }  }  if  (  options  .  enables  (  DiagnosticGroups  .  CHECK_TYPES  )  )  {  options  .  checkTypes  =  true  ;  }  else  if  (  options  .  disables  (  DiagnosticGroups  .  CHECK_TYPES  )  )  {  options  .  checkTypes  =  false  ;  }  else  if  (  !options  .  checkTypes  )  {  options  .  setWarningLevel  (  DiagnosticGroup  .  forType  (  RhinoErrorReporter  .  TYPE_PARSE_ERROR  )  ,  CheckLevel  .  OFF  )  ;  }  [BUGGY]  if  (  options  .  checkGlobalThisLevel  .  isOn  (  )  )  {  options  .  setWarningLevel  (  DiagnosticGroups  .  GLOBAL_THIS  ,  options  .  checkGlobalThisLevel  )  ;  }  	Closure_59_Compiler_1_1	255	1	src/com/google/javascript/jscomp/Compiler.java
380	case  Token.VOID:  return  TernaryValue.FALSE;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  getImpureBooleanValue  [TYPE]  TernaryValue  [PARAMETER]  Node  n  [CLASS]  NodeUtil  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  Node  n  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  TernaryValue  falseValue  lhs  rhs  trueValue  value  [TYPE]  Map  vars  [TYPE]  long  MAX_POSITIVE_INTEGER_NUMBER  [TYPE]  int  type  [TYPE]  Predicate  MATCH_NOT_FUNCTION  [CONTEXT]  case  Token  .  AND:  {  TernaryValue  lhs  =  getImpureBooleanValue  (  n  .  getFirstChild  (  )  )  ;  TernaryValue  rhs  =  getImpureBooleanValue  (  n  .  getLastChild  (  )  )  ;  return  lhs  .  and  (  rhs  )  ;  }  case  Token  .  OR:{  TernaryValue  lhs  =  getImpureBooleanValue  (  n  .  getFirstChild  (  )  )  ;  TernaryValue  rhs  =  getImpureBooleanValue  (  n  .  getLastChild  (  )  )  ;  return  lhs  .  or  (  rhs  )  ;  }  case  Token  .  HOOK:{  TernaryValue  trueValue  =  getImpureBooleanValue  (  n  .  getFirstChild  (  )  .  getNext  (  )  )  ;  TernaryValue  falseValue  =  getImpureBooleanValue  (  n  .  getLastChild  (  )  )  ;  if  (  trueValue  .  equals  (  falseValue  )  )  {  return  trueValue  ;  }  else  {  return  TernaryValue  .  UNKNOWN  ;  }  }  case  Token  .  ARRAYLIT:  case  Token  .  OBJECTLIT:  return  TernaryValue  .  TRUE  ;  [BUGGY]  default:  return  getPureBooleanValue  (  n  )  ;  }  }  	Closure_60_NodeUtil_2_1	108	0	src/com/google/javascript/jscomp/NodeUtil.java
381	if  (!mayHaveSideEffects(n.getFirstChild()))  {  }  break;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  getPureBooleanValue  [TYPE]  TernaryValue  [PARAMETER]  Node  n  [CLASS]  NodeUtil  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  Node  n  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  Map  vars  [TYPE]  long  MAX_POSITIVE_INTEGER_NUMBER  [TYPE]  int  type  [TYPE]  Predicate  MATCH_NOT_FUNCTION  [CONTEXT]  static  TernaryValue  getPureBooleanValue  (  Node  n  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  STRING:  return  TernaryValue  .  forBoolean  (  n  .  getString  (  )  .  length  (  )  >  0  )  ;  case  Token  .  NUMBER:  return  TernaryValue  .  forBoolean  (  n  .  getDouble  (  )  !  =  0  )  ;  case  Token  .  NOT:  return  getPureBooleanValue  (  n  .  getLastChild  (  )  )  .  not  (  )  ;  case  Token  .  NULL:  case  Token  .  FALSE:  return  TernaryValue  .  FALSE  ;  case  Token  .  VOID:  [BUGGY]  return  TernaryValue  .  FALSE  ;  case  Token  .  NAME:  String  name  =  n  .  getString  (  )  ;  if  ( "undefined "  .  equals  (  name  )  || "NaN "  .  equals  (  name  )  )  {  	Closure_60_NodeUtil_2_2	136	0	src/com/google/javascript/jscomp/NodeUtil.java
382	if  (nameNode.getFirstChild().getType()  ==  Token.NAME)  {  String  namespaceName  =  nameNode.getFirstChild().getString();  if  (namespaceName.equals( "Math "))  {  return  false;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  functionCallHasSideEffects  [TYPE]  boolean  [PARAMETER]  Node  callNode  AbstractCompiler  compiler  [CLASS]  NodeUtil  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  AbstractCompiler  compiler  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  Node  callNode  nameNode  param  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  Map  vars  [TYPE]  long  MAX_POSITIVE_INTEGER_NUMBER  [TYPE]  int  type  [TYPE]  Predicate  MATCH_NOT_FUNCTION  [CONTEXT]  if  (  callNode  .  isNoSideEffectsCall  (  )  )  {  return  false  ;  }  Node  nameNode  =  callNode  .  getFirstChild  (  )  ;  if  (  nameNode  .  getType  (  )  =  =  Token  .  NAME  )  {  String  name  =  nameNode  .  getString  (  )  ;  if  (  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  .  contains  (  name  )  )  {  return  false  ;  }  }  else  if  (  nameNode  .  getType  (  )  =  =  Token  .  GETPROP  )  {  if  (  callNode  .  hasOneChild  (  )  &&  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  .  contains  (  nameNode  .  getLastChild  (  )  .  getString  (  )  )  )  {  return  false  ;  }  if  (  callNode  .  isOnlyModifiesThisCall  (  )  &&  evaluatesToLocalValue  (  nameNode  .  getFirstChild  (  )  )  )  {  return  false  ;  }  [BUGGY]  if  (  compiler  !  =  null  &&  !compiler  .  hasRegExpGlobalReferences  (  )  )  {  if  (  nameNode  .  getFirstChild  (  )  .  getType  (  )  =  =  Token  .  REGEXP  &&  REGEXP_METHODS  .  contains  (  nameNode  .  getLastChild  (  )  .  getString  (  )  )  )  {  return  false  ;  }  else  if  (  nameNode  .  getFirstChild  (  )  .  getType  (  )  =  =  Token  .  STRING  	Closure_61_NodeUtil_1_1	958	0	src/com/google/javascript/jscomp/NodeUtil.java
383	&&  0  <=  charno  &&  charno  <=  sourceExcerpt.length())  {  	[BUGGY]  &&  0  <  =  charno  &&  charno  <  sourceExcerpt  .  length  (  )  )  {  [FE]  ComparisonFailure:  expected:<ion  here "assert  (  1  ;  "  +  [METHOD]  format  [TYPE]  String  [PARAMETER]  JSError  error  boolean  warning  [CLASS]  LightweightMessageFormatter  [TYPE]  boolean  false  true  warning  [TYPE]  StringBuilder  b  [TYPE]  ExcerptFormatter  excerptFormatter  [TYPE]  char  c  [TYPE]  SourceExcerpt  excerpt  [TYPE]  SourceExcerptProvider  source  [TYPE]  String  sourceExcerpt  [TYPE]  JSError  error  [TYPE]  int  charno  i  [CONTEXT]  StringBuilder  b  =  new  StringBuilder  (  )  ;  if  (  error  .  sourceName  !  =  null  )  {  b  .  append  (  error  .  sourceName  )  ;  if  (  error  .  lineNumber  >  0  )  {  b  .  append  (  ':'  )  ;  b  .  append  (  error  .  lineNumber  )  ;  }  b  .  append  ( ": "  )  ;  }  b  .  append  (  getLevelName  (  warning  ?  CheckLevel  .  WARNING  :  CheckLevel  .  ERROR  )  )  ;  b  .  append  ( "  - "  )  ;  b  .  append  (  error  .  description  )  ;  b  .  append  (  '\n'  )  ;  if  (  sourceExcerpt  !  =  null  )  {  b  .  append  (  sourceExcerpt  )  ;  b  .  append  (  '\n'  )  ;  int  charno  =  error  .  getCharno  (  )  ;  if  (  excerpt  .  equals  (  LINE  )  [BUGGY]  &&  0  <  =  charno  &&  charno  <  sourceExcerpt  .  length  (  )  )  {  for  (  int  i  =  0  ;  i  <  charno  ;  i++  )  {  char  c  =  sourceExcerpt  .  charAt  (  i  )  ;  if  (  Character  .  isWhitespace  (  c  )  )  {  b  .  append  (  c  )  ;  }  else  {  	Closure_62_LightweightMessageFormatter_1_1	98	1	src/com/google/javascript/jscomp/LightweightMessageFormatter.java
384	String  code  =  toSource(root,  sourceMap,  inputSeqNum  ==  0);  	[BUGGY]  String  code  =  toSource  (  root  ,  sourceMap  )  ;  [FE]  AssertionFailedError:  expected:<17>  but  was:<-1>  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [METHOD]  call  [TYPE]  Void  [PARAMETER]  [CLASS]  9  [TYPE]  boolean  false  hasSemiColon  true  [TYPE]  char  lastChar  secondLastChar  [TYPE]  String  code  delimiter  sourceName  [TYPE]  int  length  [CONTEXT]  Preconditions  .  checkState  (  sourceName  !  =  null  )  ;  Preconditions  .  checkState  (  !sourceName  .  isEmpty  (  )  )  ;  delimiter  =  delimiter  .  replaceAll  ( "%name% "  ,  sourceName  )  .  replaceAll  ( "%num% "  ,  String  .  valueOf  (  inputSeqNum  )  )  ;  cb  .  append  (  delimiter  )  .  append  ( "\n "  )  ;  }  if  (  root  .  getJSDocInfo  (  )  !  =  null  &&  root  .  getJSDocInfo  (  )  .  getLicense  (  )  !  =  null  )  {  cb  .  append  ( "/*\n "  )  .  append  (  root  .  getJSDocInfo  (  )  .  getLicense  (  )  )  .  append  ( "*/\n "  )  ;  }  if  (  options  .  sourceMapOutputPath  !  =  null  )  {  sourceMap  .  setStartingPosition  (  cb  .  getLineIndex  (  )  ,  cb  .  getColumnIndex  (  )  )  ;  }  [BUGGY]  String  code  =  toSource  (  root  ,  sourceMap  )  ;  if  (  !code  .  isEmpty  (  )  )  {  cb  .  append  (  code  )  ;  	Closure_64_Compiler_4_1	1432	1	src/com/google/javascript/jscomp/Compiler.java
385	return  toSource(n,  null,  true);  	[BUGGY]  return  toSource  (  n  ,  null  )  ;  [FE]  AssertionFailedError:  expected:<17>  but  was:<-1>  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [METHOD]  toSource  [TYPE]  String  [PARAMETER]  Node  n  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  n  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  LifeCycleStage  lifeCycleStage  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  GlobalVarReferenceMap  globalRefMap  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MISSING_ENTRY_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  inputs  modules  [TYPE]  WarningsGuard  warningsGuard  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  uniqueNameId  [TYPE]  boolean  false  hasRegExpGlobalReferences  true  useThreads  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  inputsByName  [CONTEXT]  String  toSource  (  Node  n  )  {  initCompilerOptionsIfTesting  (  )  ;  [BUGGY]  return  toSource  (  n  ,  null  )  ;  }  	Closure_64_Compiler_4_2	1461	1	src/com/google/javascript/jscomp/Compiler.java
386	private  String  toSource(Node  n,  SourceMap  sourceMap,  boolean  firstOutput)  {  	[BUGGY]  private  String  toSource  (  Node  n  ,  SourceMap  sourceMap  )  {  [FE]  AssertionFailedError:  expected:<17>  but  was:<-1>  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [CLASS]  [CONTEXT]  	Closure_64_Compiler_4_3	1467	1	src/com/google/javascript/jscomp/Compiler.java
387	builder.setTagAsStrict(firstOutput  &&  	[BUGGY]  builder  .  setTagAsStrict  (  [FE]  AssertionFailedError:  expected:<17>  but  was:<-1>  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [METHOD]  toSource  [TYPE]  String  [PARAMETER]  Node  n  SourceMap  sourceMap  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  n  [TYPE]  Builder  builder  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  LifeCycleStage  lifeCycleStage  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  GlobalVarReferenceMap  globalRefMap  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MISSING_ENTRY_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  inputs  modules  [TYPE]  WarningsGuard  warningsGuard  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  Charset  charset  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  uniqueNameId  [TYPE]  boolean  false  hasRegExpGlobalReferences  true  useThreads  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  inputsByName  [CONTEXT]  private  String  toSource  (  Node  n  ,  SourceMap  sourceMap  )  {  CodePrinter  .  Builder  builder  =  new  CodePrinter  .  Builder  (  n  )  ;  builder  .  setPrettyPrint  (  options  .  prettyPrint  )  ;  builder  .  setLineBreak  (  options  .  lineBreak  )  ;  builder  .  setSourceMap  (  sourceMap  )  ;  builder  .  setSourceMapDetailLevel  (  options  .  sourceMapDetailLevel  )  ;  [BUGGY]  builder  .  setTagAsStrict  (  options  .  getLanguageOut  (  )  =  =  LanguageMode  .  ECMASCRIPT5_STRICT  )  ;  builder  .  setLineLengthThreshold  (  options  .  lineLengthThreshold  )  ;  Charset  charset  =  options  .  outputCharset  !  =  null  ?  Charset  .  forName  (  options  .  outputCharset  )  :  null  ;  builder  .  setOutputCharset  (  charset  )  ;  return  builder  .  build  (  )  ;  }  	Closure_64_Compiler_4_4	1473	1	src/com/google/javascript/jscomp/Compiler.java
388	case  \'\\0\':  sb.append( "\\\\000 ");  break;  	[BUGGY]  case  \'\\0\':  sb  .  append  ( "\\\\0 "  )  ;  break  ;  [FE]  ComparisonFailure:  expected:<var  x  = "  assertPrint  ( "var  x  =  '\\u00003'  ; "  , "var  x  =  \ "\\0003\ " "  )  ;  [METHOD]  strEscape  [TYPE]  String  [PARAMETER]  String  s  char  quote  String  doublequoteEscape  String  singlequoteEscape  String  backslashEscape  CharsetEncoder  outputCharsetEncoder  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  char  c  quote  [TYPE]  CodeConsumer  cc  [TYPE]  String  END_SCRIPT  START_COMMENT  backslashEscape  doublequoteEscape  s  singlequoteEscape  [TYPE]  Map  ESCAPED_JS_STRINGS  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  i  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  static  String  strEscape  (  String  s  ,  char  quote  ,  String  doublequoteEscape  ,  String  singlequoteEscape  ,  String  backslashEscape  ,  CharsetEncoder  outputCharsetEncoder  )  {  StringBuilder  sb  =  new  StringBuilder  (  s  .  length  (  )  +  2  )  ;  sb  .  append  (  quote  )  ;  for  (  int  i  =  0  ;  i  <  s  .  length  (  )  ;  i++  )  {  char  c  =  s  .  charAt  (  i  )  ;  switch  (  c  )  {  [BUGGY]  case  '\0':  sb  .  append  ( "\\0 "  )  ;  break  ;  case  '\n':  sb  .  append  ( "\\n "  )  ;  break  ;  case  '\r':  sb  .  append  ( "\\r "  )  ;  break  ;  case  '\t':  sb  .  append  ( "\\t "  )  ;  break  ;  case  '\\':  sb  .  append  (  backslashEscape  )  ;  break  ;  case  '\ "':  sb  .  append  (  doublequoteEscape  )  ;  break  ;  	Closure_65_CodeGenerator_1_1	1015	1	src/com/google/javascript/jscomp/CodeGenerator.java
389	}  else  {  typeable  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1000>  but  was:<625>  assertEquals  (  100  .  0  ,  getTypedPercent  (  js  )  ,  0  .  1  )  ;  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  TypeCheck  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  caseType  childType  leftType  leftTypeRestricted  rightType  rightTypeRestricted  switchType  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  CheckLevel  reportMissingOverride  reportUnknownTypes  [TYPE]  Node  child  key  left  n  parent  right  [TYPE]  ScopeCreator  scopeCreator  [TYPE]  String  OVERRIDING_PROTOTYPE_WITH_NON_OBJECT  message  [TYPE]  TernaryValue  result  [TYPE]  int  noTypeCheckSection  nullCount  typedCount  unknownCount  [TYPE]  TypeValidator  validator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  false  inExterns  reportMissingProperties  true  typeable  [TYPE]  Scope  topScope  [TYPE]  DiagnosticType  BAD_DELETE  BAD_IMPLEMENTED_TYPE  BIT_OPERATION  CONFLICTING_EXTENDED_TYPE  CONFLICTING_IMPLEMENTED_TYPE  CONSTRUCTOR_NOT_CALLABLE  DETERMINISTIC_TEST  DETERMINISTIC_TEST_NO_RESULT  ENUM_DUP  ENUM_NOT_CONSTANT  EXPECTED_THIS_TYPE  FUNCTION_MASKS_VARIABLE  HIDDEN_INTERFACE_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY_MISMATCH  ILLEGAL_IMPLICIT_CAST  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE  INEXISTENT_ENUM_ELEMENT  INEXISTENT_PROPERTY  INTERFACE_FUNCTION_NOT_EMPTY  INTERFACE_METHOD_OVERRIDE  INVALID_INTERFACE_MEMBER_DECLARATION  MULTIPLE_VAR_DEF  NOT_A_CONSTRUCTOR  NOT_CALLABLE  UNEXPECTED_TOKEN  UNKNOWN_EXPR_TYPE  UNKNOWN_OVERRIDE  UNRESOLVED_TYPE  WRONG_ARGUMENT_COUNT  [TYPE]  InferJSDocInfo  inferJSDocInfo  [CONTEXT]  case  Token  .  THIS:  ensureTyped  (  t  ,  n  ,  t  .  getScope  (  )  .  getTypeOfThis  (  )  )  ;  break  ;  case  Token  .  REF_SPECIAL:  ensureTyped  (  t  ,  n  )  ;  break  ;  case  Token  .  GET_REF:  ensureTyped  (  t  ,  n  ,  getJSType  (  n  .  getFirstChild  (  )  )  )  ;  break  ;  case  Token  .  NULL:  ensureTyped  (  t  ,  n  ,  NULL_TYPE  )  ;  break  ;  case  Token  .  NUMBER:  ensureTyped  (  t  ,  n  ,  NUMBER_TYPE  )  ;  break  ;  case  Token  .  STRING:  if  (  !NodeUtil  .  isObjectLitKey  (  n  ,  n  .  getParent  (  )  )  )  {  ensureTyped  (  t  ,  n  ,  STRING_TYPE  )  ;  [BUGGY]  }  break  ;  case  Token  .  GET:  case  Token  .  SET:  	Closure_66_TypeCheck_1_1	516	0	src/com/google/javascript/jscomp/TypeCheck.java
390	&&  assign.getParent().getType()  ==  Token.EXPR_RESULT)  {  	[BUGGY]  )  {  [FE]  AssertionFailedError:  [METHOD]  isPrototypePropertyAssign  [TYPE]  boolean  [PARAMETER]  Node  assign  [CLASS]  ProcessProperties  [TYPE]  Stack  symbolStack  [TYPE]  Node  assign  child  n  [TYPE]  boolean  false  isChainedProperty  true  [CONTEXT]  private  boolean  isPrototypePropertyAssign  (  Node  assign  )  {  Node  n  =  assign  .  getFirstChild  (  )  ;  if  (  n  !  =  null  &&  NodeUtil  .  isVarOrSimpleAssignLhs  (  n  ,  assign  )  &&  n  .  getType  (  )  =  =  Token  .  GETPROP  [BUGGY]  )  {  boolean  isChainedProperty  =  n  .  getFirstChild  (  )  .  getType  (  )  =  =  Token  .  GETPROP  ;  if  (  isChainedProperty  )  {  Node  child  =  n  .  getFirstChild  (  )  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  child  .  getType  (  )  =  =  Token  .  STRING  &&  child  .  getString  (  )  .  equals  ( "prototype "  )  )  {  return  true  ;  }  }  }  return  false  ;  }  	Closure_67_AnalyzePrototypeProperties_1_1	318	1	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
391	}  	[BUGGY]  }  [FE]  AssertionFailedError:  extra  warning:  Unexpected  end  of  file  [METHOD]  parse  [TYPE]  boolean  [PARAMETER]  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  Node  templateNode  typeNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  annotationName  author  description  fileOverview  meaning  name  paramDescription  preserve  reason  reference  returnDescription  sourceName  string  templateTypeName  version  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  lineno  [TYPE]  Annotation  annotation  [TYPE]  ExtractionInfo  authorInfo  blockInfo  descriptionInfo  fileOverviewInfo  meaningInfo  paramDescriptionInfo  preserveInfo  reasonInfo  referenceInfo  returnDescriptionInfo  templateInfo  versionInfo  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  isBracketedParam  matchingRc  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  List  extendedTypes  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  Map  annotationNames  [CONTEXT]  token  =  eatTokensUntilEOL  (  token  )  ;  }  continue  retry  ;  case  THIS:  if  (  !jsdocBuilder  .  recordThisType  (  type  )  )  {  parser  .  addTypeWarning  ( "msg  .  jsdoc  .  incompat  .  type "  ,  lineno  ,  charno  )  ;  }  break  ;  case  TYPE:  if  (  !jsdocBuilder  .  recordType  (  type  )  )  {  parser  .  addTypeWarning  ( "msg  .  jsdoc  .  incompat  .  type "  ,  lineno  ,  charno  )  ;  }  break  ;  case  TYPEDEF:  if  (  !jsdocBuilder  .  recordTypedef  (  type  )  )  {  parser  .  addTypeWarning  ( "msg  .  jsdoc  .  incompat  .  type "  ,  lineno  ,  charno  )  ;  }  break  ;  }  [BUGGY]  token  =  eatTokensUntilEOL  (  )  ;  }  continue  retry  ;  }  }  	Closure_68_JsDocInfoParser_3_1	868	1	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
392	restoreLookAhead(token);  	[BUGGY]  [FE]  AssertionFailedError:  extra  warning:  Unexpected  end  of  file  [METHOD]  parseBasicTypeExpression  [TYPE]  Node  [PARAMETER]  JsDocToken  token  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  Node  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  sourceName  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  lineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  Map  annotationNames  [CONTEXT]  private  Node  parseBasicTypeExpression  (  JsDocToken  token  )  {  if  (  token  =  =  JsDocToken  .  STAR  )  {  return  newNode  (  Token  .  STAR  )  ;  }  else  if  (  token  =  =  JsDocToken  .  LB  )  {  skipEOLs  (  )  ;  return  parseArrayType  (  next  (  )  )  ;  }  else  if  (  token  =  =  JsDocToken  .  LC  )  {  skipEOLs  (  )  ;  return  parseRecordType  (  next  (  )  )  ;  }  else  if  (  token  =  =  JsDocToken  .  LP  )  {  skipEOLs  (  )  ;  return  parseUnionType  (  next  (  )  )  ;  }  else  if  (  token  =  =  JsDocToken  .  STRING  )  {  String  string  =  stream  .  getString  (  )  ;  if  ( "function "  .  equals  (  string  )  )  {  skipEOLs  (  )  ;  return  parseFunctionType  (  next  (  )  )  ;  }  else  if  ( "null "  .  equals  (  string  )  || "undefined "  .  equals  (  string  )  )  {  return  newStringNode  (  string  )  ;  }  else  {  return  parseTypeName  (  token  )  ;  }  }  [BUGGY]  return  reportGenericTypeSyntaxWarning  (  )  ;  }  	Closure_68_JsDocInfoParser_3_2	1709	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
393	restoreLookAhead(token);  	[BUGGY]  [FE]  AssertionFailedError:  extra  warning:  Unexpected  end  of  file  [METHOD]  parseFunctionType  [TYPE]  Node  [PARAMETER]  JsDocToken  token  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  Node  contextType  functionType  parameters  resultType  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  sourceName  string  tokenStr  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  lineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  hasParams  isNew  isThis  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  Map  annotationNames  [CONTEXT]  private  Node  parseFunctionType  (  JsDocToken  token  )  {  if  (  token  !  =  JsDocToken  .  LP  )  {  [BUGGY]  return  reportTypeSyntaxWarning  ( "msg  .  jsdoc  .  missing  .  lp "  )  ;  }  Node  functionType  =  newNode  (  Token  .  FUNCTION  )  ;  Node  parameters  =  null  ;  skipEOLs  (  )  ;  	Closure_68_JsDocInfoParser_3_3	1761	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
394	if  (functionType.isOrdinaryFunction()  &&  !functionType.getTypeOfThis().isUnknownType()  &&  !functionType.getTypeOfThis().isNativeObjectType()  &&  !(child.getType()  ==  Token.GETELEM  ||  child.getType()  ==  Token.GETPROP))  {  report(t,  n,  EXPECTED_THIS_TYPE,  functionType.toString());  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  visitCall  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  TypeCheck  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  childType  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  CheckLevel  reportMissingOverride  reportUnknownTypes  [TYPE]  Node  child  n  [TYPE]  FunctionType  functionType  [TYPE]  ScopeCreator  scopeCreator  [TYPE]  String  OVERRIDING_PROTOTYPE_WITH_NON_OBJECT  sourceName  [TYPE]  JSDocInfo  functionJSDocInfo  [TYPE]  int  noTypeCheckSection  nullCount  typedCount  unknownCount  [TYPE]  TypeValidator  validator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  CompilerInput  functionSource  [TYPE]  boolean  false  inExterns  isExtern  reportMissingProperties  true  [TYPE]  Scope  topScope  [TYPE]  DiagnosticType  BAD_DELETE  BAD_IMPLEMENTED_TYPE  BIT_OPERATION  CONFLICTING_EXTENDED_TYPE  CONFLICTING_IMPLEMENTED_TYPE  CONSTRUCTOR_NOT_CALLABLE  DETERMINISTIC_TEST  DETERMINISTIC_TEST_NO_RESULT  ENUM_DUP  ENUM_NOT_CONSTANT  EXPECTED_THIS_TYPE  FUNCTION_MASKS_VARIABLE  HIDDEN_INTERFACE_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY_MISMATCH  ILLEGAL_IMPLICIT_CAST  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE  INEXISTENT_ENUM_ELEMENT  INEXISTENT_PROPERTY  INTERFACE_FUNCTION_NOT_EMPTY  INTERFACE_METHOD_OVERRIDE  INVALID_INTERFACE_MEMBER_DECLARATION  MULTIPLE_VAR_DEF  NOT_A_CONSTRUCTOR  NOT_CALLABLE  UNEXPECTED_TOKEN  UNKNOWN_EXPR_TYPE  UNKNOWN_OVERRIDE  UNRESOLVED_TYPE  WRONG_ARGUMENT_COUNT  [TYPE]  InferJSDocInfo  inferJSDocInfo  [CONTEXT]  if  (  childType  instanceof  FunctionType  )  {  FunctionType  functionType  =  (  FunctionType  )  childType  ;  boolean  isExtern  =  false  ;  JSDocInfo  functionJSDocInfo  =  functionType  .  getJSDocInfo  (  )  ;  if  (  functionJSDocInfo  !  =  null  )  {  String  sourceName  =  functionJSDocInfo  .  getSourceName  (  )  ;  CompilerInput  functionSource  =  compiler  .  getInput  (  sourceName  )  ;  isExtern  =  functionSource  .  isExtern  (  )  ;  }  if  (  functionType  .  isConstructor  (  )  &&  !functionType  .  isNativeObjectType  (  )  &&  (  functionType  .  getReturnType  (  )  .  isUnknownType  (  )  ||  functionType  .  getReturnType  (  )  .  isVoidType  (  )  ||  !isExtern  )  )  {  report  (  t  ,  n  ,  CONSTRUCTOR_NOT_CALLABLE  ,  childType  .  toString  (  )  )  ;  }  [BUGGY]  visitParameterList  (  t  ,  n  ,  functionType  )  ;  ensureTyped  (  t  ,  n  ,  functionType  .  getReturnType  (  )  )  ;  }  else  {  ensureTyped  (  t  ,  n  )  ;  }  	Closure_69_TypeCheck_1_1	1580	0	src/com/google/javascript/jscomp/TypeCheck.java
395	jsDocParameter.getJSType(),  false);  	[BUGGY]  jsDocParameter  .  getJSType  (  )  ,  true  )  ;  [FE]  AssertionFailedError:  expected:<2>  but  was:<1>  [METHOD]  declareArguments  [TYPE]  void  [PARAMETER]  Node  functionNode  [CLASS]  LocalScopeBuilder  [TYPE]  boolean  false  true  [TYPE]  Node  astParameter  astParameters  body  functionNode  jsDocParameter  jsDocParameters  [TYPE]  FunctionType  functionType  [CONTEXT]  private  void  declareArguments  (  Node  functionNode  )  {  Node  astParameters  =  functionNode  .  getFirstChild  (  )  .  getNext  (  )  ;  Node  body  =  astParameters  .  getNext  (  )  ;  FunctionType  functionType  =  (  FunctionType  )  functionNode  .  getJSType  (  )  ;  if  (  functionType  !  =  null  )  {  Node  jsDocParameters  =  functionType  .  getParametersNode  (  )  ;  if  (  jsDocParameters  !  =  null  )  {  Node  jsDocParameter  =  jsDocParameters  .  getFirstChild  (  )  ;  for  (  Node  astParameter  :  astParameters  .  children  (  )  )  {  if  (  jsDocParameter  !  =  null  )  {  defineSlot  (  astParameter  ,  functionNode  ,  [BUGGY]  jsDocParameter  .  getJSType  (  )  ,  true  )  ;  jsDocParameter  =  jsDocParameter  .  getNext  (  )  ;  }  else  {  defineSlot  (  astParameter  ,  functionNode  ,  null  ,  true  )  ;  }  }  }  }  }  //  end  declareArguments  	Closure_70_TypedScopeCreator_1_1	1745	1	src/com/google/javascript/jscomp/TypedScopeCreator.java
396	boolean  isOverride  =  parent.getJSDocInfo()  !=  null  &&  	[BUGGY]  boolean  isOverride  =  t  .  inGlobalScope  (  )  &&  [FE]  AssertionFailedError:  Overriding  private  property  of  Fooprototype  [METHOD]  checkPropertyVisibility  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  getprop  Node  parent  [CLASS]  CheckAccessControls  [TYPE]  JSType  currentClass  ownerType  [TYPE]  NodeTraversal  t  [TYPE]  Node  getprop  parent  [TYPE]  String  propertyName  [TYPE]  JSDocInfo  docInfo  overridingInfo  [TYPE]  int  deprecatedDepth  methodDepth  [TYPE]  TypeValidator  validator  [TYPE]  Multimap  initializedConstantProperties  [TYPE]  ObjectType  objectType  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  isOverride  sameInput  true  [TYPE]  DiagnosticType  BAD_PRIVATE_GLOBAL_ACCESS  BAD_PRIVATE_PROPERTY_ACCESS  BAD_PROTECTED_PROPERTY_ACCESS  CONST_PROPERTY_REASSIGNED_VALUE  DEPRECATED_CLASS  DEPRECATED_CLASS_REASON  DEPRECATED_NAME  DEPRECATED_NAME_REASON  DEPRECATED_PROP  DEPRECATED_PROP_REASON  PRIVATE_OVERRIDE  VISIBILITY_MISMATCH  [TYPE]  Visibility  overridingVisibility  visibility  [CONTEXT]  private  void  checkPropertyVisibility  (  NodeTraversal  t  ,  Node  getprop  ,  Node  parent  )  {  ObjectType  objectType  =  ObjectType  .  cast  (  dereference  (  getprop  .  getFirstChild  (  )  .  getJSType  (  )  )  )  ;  String  propertyName  =  getprop  .  getLastChild  (  )  .  getString  (  )  ;  if  (  objectType  !  =  null  )  {  [BUGGY]  boolean  isOverride  =  t  .  inGlobalScope  (  )  &&  parent  .  getType  (  )  =  =  Token  .  ASSIGN  &&  parent  .  getFirstChild  (  )  =  =  getprop  ;  	Closure_71_CheckAccessControls_1_1	416	1	src/com/google/javascript/jscomp/CheckAccessControls.java
397	new  RenameLabels(compiler,  new  LabelNameSupplier(idSupplier),  false)  .process(null,  fnNode);  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_72_FunctionToBlockMutator_1_1	152	0	src/com/google/javascript/jscomp/FunctionToBlockMutator.java
398	if  (li.referenced  ||  !removeUnused)  {  	[BUGGY]  if  (  li  .  referenced  )  {  [FE]  AssertionFailedError:  [METHOD]  visitLabel  [TYPE]  void  [PARAMETER]  Node  node  Node  parent  [CLASS]  ProcessLabels  [TYPE]  ArrayList  names  [TYPE]  LabelInfo  li  [TYPE]  String  name  newName  [TYPE]  boolean  false  true  [TYPE]  Deque  namespaceStack  [TYPE]  Node  nameNode  newChild  node  parent  [CONTEXT]  private  void  visitLabel  (  Node  node  ,  Node  parent  )  {  Node  nameNode  =  node  .  getFirstChild  (  )  ;  Preconditions  .  checkState  (  nameNode  !  =  null  )  ;  String  name  =  nameNode  .  getString  (  )  ;  LabelInfo  li  =  getLabelInfo  (  name  )  ;  [BUGGY]  if  (  li  .  referenced  )  {  String  newName  =  getNameForId  (  li  .  id  )  ;  if  (  !name  .  equals  (  newName  )  )  {  nameNode  .  setString  (  newName  )  ;  compiler  .  reportCodeChange  (  )  ;  }  }  else  {  Node  newChild  =  node  .  getLastChild  (  )  ;  node  .  removeChild  (  newChild  )  ;  parent  .  replaceChild  (  node  ,  newChild  )  ;  if  (  newChild  .  getType  (  )  =  =  Token  .  BLOCK  )  {  NodeUtil  .  tryMergeBlock  (  newChild  )  ;  }  compiler  .  reportCodeChange  (  )  ;  }  namespaceStack  .  peek  (  )  .  renameMap  .  remove  (  name  )  ;  }  	Closure_72_RenameLabels_1_1	215	1	src/com/google/javascript/jscomp/RenameLabels.java
399	if  (c  >  0x1f  &&  c  <  0x7f)  {  	[BUGGY]  if  (  c  >  0x1f  &&  c  <  =  0x7f  )  {  [FE]  ComparisonFailure:  expected:<var  x  = "[  assertPrint  ( "var  x  =  '\\x7f'  ; "  , "var  x  =  \ "\\u007f\ " "  )  ;  [METHOD]  strEscape  [TYPE]  String  [PARAMETER]  String  s  char  quote  String  doublequoteEscape  String  singlequoteEscape  String  backslashEscape  CharsetEncoder  outputCharsetEncoder  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  char  c  quote  [TYPE]  CodeConsumer  cc  [TYPE]  String  END_SCRIPT  START_COMMENT  backslashEscape  doublequoteEscape  s  singlequoteEscape  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  i  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  if  (  s  .  regionMatches  (  true  ,  i  +  1  ,  END_SCRIPT  ,  0  ,  END_SCRIPT  .  length  (  )  )  )  {  sb  .  append  ( "<\\ "  )  ;  }  else  if  (  s  .  regionMatches  (  false  ,  i  +  1  ,  START_COMMENT  ,  0  ,  START_COMMENT  .  length  (  )  )  )  {  sb  .  append  ( "<\\ "  )  ;  }  else  {  sb  .  append  (  c  )  ;  }  break  ;  default:  if  (  outputCharsetEncoder  !  =  null  )  {  if  (  outputCharsetEncoder  .  canEncode  (  c  )  )  {  sb  .  append  (  c  )  ;  }  else  {  appendHexJavaScriptRepresentation  (  sb  ,  c  )  ;  }  }  else  {  [BUGGY]  if  (  c  >  0x1f  &&  c  <  =  0x7f  )  {  sb  .  append  (  c  )  ;  }  else  {  	Closure_73_CodeGenerator_1_1	1045	1	src/com/google/javascript/jscomp/CodeGenerator.java
400	int  lhType  =  getNormalizedNodeType(left);  int  rhType  =  getNormalizedNodeType(right);  	[BUGGY]  int  lhType  =  left  .  getType  (  )  ;  int  rhType  =  right  .  getType  (  )  ;  [FE]  AssertionFailedError:  [METHOD]  tryFoldComparison  [TYPE]  Node  [PARAMETER]  Node  n  Node  left  Node  right  [CLASS]  PeepholeFoldConstants  [TYPE]  Locale  ROOT_LOCALE  [TYPE]  boolean  false  result  rightLiteral  true  undefinedLeft  undefinedRight  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double  MAX_FOLD_NUMBER  [TYPE]  Node  left  n  newNode  right  [TYPE]  String  ln  rn  [TYPE]  Boolean  compareResult  [TYPE]  int  lhType  op  rhType  [CONTEXT]  private  Node  tryFoldComparison  (  Node  n  ,  Node  left  ,  Node  right  )  {  if  (  !NodeUtil  .  isLiteralValue  (  left  ,  false  )  ||  !NodeUtil  .  isLiteralValue  (  right  ,  false  )  )  {  if  (  n  .  getType  (  )  !  =  Token  .  GT  &&  n  .  getType  (  )  !  =  Token  .  LT  )  {  return  n  ;  }  }  int  op  =  n  .  getType  (  )  ;  boolean  result  ;  boolean  rightLiteral  =  NodeUtil  .  isLiteralValue  (  right  ,  false  )  ;  boolean  undefinedRight  =  (  (  Token  .  NAME  =  =  right  .  getType  (  )  &&  right  .  getString  (  )  .  equals  ( "undefined "  )  )  ||  (  Token  .  VOID  =  =  right  .  getType  (  )  &&  NodeUtil  .  isLiteralValue  (  right  .  getFirstChild  (  )  ,  false  )  )  )  ;  [BUGGY]  int  lhType  =  left  .  getType  (  )  ;  int  rhType  =  right  .  getType  (  )  ;  switch  (  lhType  )  {  case  Token  .  VOID:  if  (  !NodeUtil  .  isLiteralValue  (  left  .  getFirstChild  (  )  ,  false  )  )  {  return  n  ;  	Closure_74_PeepholeFoldConstants_2_1	907	2	src/com/google/javascript/jscomp/PeepholeFoldConstants.java
401	private  int  getNormalizedNodeType(Node  n)  {  int  type  =  n.getType();  if  (type  ==  Token.NOT)  {  TernaryValue  value  =  NodeUtil.getPureBooleanValue(n);  switch  (value)  {  case  TRUE:  return  Token.TRUE;  case  FALSE:  return  Token.FALSE;  }  }  return  type;  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_74_PeepholeFoldConstants_2_2	1074	0	src/com/google/javascript/jscomp/PeepholeFoldConstants.java
402	if  (rawJsString.contains( "\\u000b "))  {  return  null;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  getStringNumberValue  [TYPE]  Double  [PARAMETER]  String  rawJsString  [CLASS]  NodeUtil  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  NumberFormatException  e  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  rawJsString  s  [TYPE]  Map  vars  [TYPE]  int  type  [CONTEXT]  static  Double  getStringNumberValue  (  String  rawJsString  )  {  [BUGGY]  String  s  =  trimJsWhiteSpace  (  rawJsString  )  ;  if  (  s  .  length  (  )  =  =  0  )  {  return  0  .  0  ;  	Closure_75_NodeUtil_2_1	313	0	src/com/google/javascript/jscomp/NodeUtil.java
403	return  TernaryValue.UNKNOWN;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isStrWhiteSpaceChar  [TYPE]  TernaryValue  [PARAMETER]  int  c  [CLASS]  NodeUtil  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  Map  vars  [TYPE]  int  c  type  [CONTEXT]  static  TernaryValue  isStrWhiteSpaceChar  (  int  c  )  {  switch  (  c  )  {  case  '\u000B':  //  <VT>  [BUGGY]  return  TernaryValue  .  TRUE  ;  case  '  ':  //  <SP>  case  '\n':  //  <LF>  case  '\r':  //  <CR>  case  '\t':  //  <TAB>  case  '\u00A0':  //  <NBSP>  case  '\u000C':  //  <FF>  case  '\u2028':  //  <LS>  case  '\u2029':  //  <PS>  case  '\uFEFF':  //  <BOM>  return  TernaryValue  .  TRUE  ;  default:  return  (  Character  .  getType  (  c  )  =  =  Character  .  SPACE_SEPARATOR  )  ?  TernaryValue  .  TRUE  :  TernaryValue  .  FALSE  ;  }  }  	Closure_75_NodeUtil_2_2	375	0	src/com/google/javascript/jscomp/NodeUtil.java
404	if  (n.getNext()  !=  null)  {  state  =  isVariableReadBeforeKill(  n.getNext(),  variable);  if  (state  ==  VariableLiveness.KILL)  {  state  =  VariableLiveness.MAYBE_LIVE;  }  }  break;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isVariableStillLiveWithinExpression  [TYPE]  boolean  [PARAMETER]  Node  n  Node  exprRoot  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  exprRoot  n  sibling  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  private  boolean  isVariableStillLiveWithinExpression  (  Node  n  ,  Node  exprRoot  ,  String  variable  )  {  while  (  n  !  =  exprRoot  )  {  VariableLiveness  state  =  VariableLiveness  .  MAYBE_LIVE  ;  switch  (  n  .  getParent  (  )  .  getType  (  )  )  {  case  Token  .  OR:  case  Token  .  AND:  [BUGGY]  case  Token  .  HOOK:  	Closure_76_DeadAssignmentsElimination_8_1	300	0	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
405	if  (n.getNext()  !=  null  &&  n.getNext().getNext()  !=  null)  {  state  =  checkHookBranchReadBeforeKill(  n.getNext(),  n.getNext().getNext(),  variable);  }  break;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isVariableStillLiveWithinExpression  [TYPE]  boolean  [PARAMETER]  Node  n  Node  exprRoot  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  exprRoot  n  sibling  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  private  boolean  isVariableStillLiveWithinExpression  (  Node  n  ,  Node  exprRoot  ,  String  variable  )  {  while  (  n  !  =  exprRoot  )  {  VariableLiveness  state  =  VariableLiveness  .  MAYBE_LIVE  ;  switch  (  n  .  getParent  (  )  .  getType  (  )  )  {  case  Token  .  OR:  case  Token  .  AND:  case  Token  .  HOOK:  [BUGGY]  default:  for  (  Node  sibling  =  n  .  getNext  (  )  ;  sibling  !  =  null  ;  sibling  =  sibling  .  getNext  (  )  )  {  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  sibling  )  )  {  state  =  isVariableReadBeforeKill  (  sibling  ,  variable  )  ;  	Closure_76_DeadAssignmentsElimination_8_2	305	0	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
406	if  (state  !=  VariableLiveness.MAYBE_LIVE)  {  break;  }  }  }  	[BUGGY]  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  sibling  )  )  {  [FE]  AssertionFailedError:  [METHOD]  isVariableStillLiveWithinExpression  [TYPE]  boolean  [PARAMETER]  Node  n  Node  exprRoot  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  exprRoot  n  sibling  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  private  boolean  isVariableStillLiveWithinExpression  (  Node  n  ,  Node  exprRoot  ,  String  variable  )  {  while  (  n  !  =  exprRoot  )  {  VariableLiveness  state  =  VariableLiveness  .  MAYBE_LIVE  ;  switch  (  n  .  getParent  (  )  .  getType  (  )  )  {  case  Token  .  OR:  case  Token  .  AND:  case  Token  .  HOOK:  default:  for  (  Node  sibling  =  n  .  getNext  (  )  ;  sibling  !  =  null  ;  sibling  =  sibling  .  getNext  (  )  )  {  [BUGGY]  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  sibling  )  )  {  state  =  isVariableReadBeforeKill  (  sibling  ,  variable  )  ;  if  (  state  =  =  VariableLiveness  .  READ  )  {  return  true  ;  	Closure_76_DeadAssignmentsElimination_8_3	309	1	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
407		[BUGGY]  }  }  }  [FE]  AssertionFailedError:  [METHOD]  isVariableStillLiveWithinExpression  [TYPE]  boolean  [PARAMETER]  Node  n  Node  exprRoot  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  exprRoot  n  sibling  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  while  (  n  !  =  exprRoot  )  {  VariableLiveness  state  =  VariableLiveness  .  MAYBE_LIVE  ;  switch  (  n  .  getParent  (  )  .  getType  (  )  )  {  case  Token  .  OR:  case  Token  .  AND:  case  Token  .  HOOK:  default:  for  (  Node  sibling  =  n  .  getNext  (  )  ;  sibling  !  =  null  ;  sibling  =  sibling  .  getNext  (  )  )  {  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  sibling  )  )  {  state  =  isVariableReadBeforeKill  (  sibling  ,  variable  )  ;  if  (  state  =  =  VariableLiveness  .  READ  )  {  return  true  ;  }  else  if  (  state  =  =  VariableLiveness  .  KILL  )  {  return  false  ;  [BUGGY]  }  }  }  }  n  =  n  .  getParent  (  )  ;  }  	Closure_76_DeadAssignmentsElimination_8_4	317	3	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
408	if  (ControlFlowGraph.isEnteringNewCfgNode(n))  {  return  VariableLiveness.MAYBE_LIVE;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isVariableReadBeforeKill  [TYPE]  DeadAssignmentsElimination$VariableLiveness  [PARAMETER]  Node  n  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  child  n  rhs  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  private  VariableLiveness  isVariableReadBeforeKill  (  Node  n  ,  String  variable  )  {  [BUGGY]  if  (  NodeUtil  .  isName  (  n  )  &&  variable  .  equals  (  n  .  getString  (  )  )  )  {  if  (  NodeUtil  .  isLhs  (  n  ,  n  .  getParent  (  )  )  )  {  Preconditions  .  checkState  (  n  .  getParent  (  )  .  getType  (  )  =  =  Token  .  ASSIGN  )  ;  	Closure_76_DeadAssignmentsElimination_8_5	340	0	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
409	VariableLiveness  v1  =  isVariableReadBeforeKill(  n.getFirstChild(),  variable);  VariableLiveness  v2  =  isVariableReadBeforeKill(  n.getLastChild(),  variable);  if  (v1  !=  VariableLiveness.MAYBE_LIVE)  {  return  v1;  }  else  if  (v2  ==  VariableLiveness.READ)  {  return  VariableLiveness.READ;  }  else  {  return  VariableLiveness.MAYBE_LIVE;  }  VariableLiveness  first  =  isVariableReadBeforeKill(  n.getFirstChild(),  variable);  if  (first  !=  VariableLiveness.MAYBE_LIVE)  {  return  first;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isVariableReadBeforeKill  [TYPE]  DeadAssignmentsElimination$VariableLiveness  [PARAMETER]  Node  n  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  child  n  rhs  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  private  VariableLiveness  isVariableReadBeforeKill  (  Node  n  ,  String  variable  )  {  if  (  NodeUtil  .  isName  (  n  )  &&  variable  .  equals  (  n  .  getString  (  )  )  )  {  if  (  NodeUtil  .  isLhs  (  n  ,  n  .  getParent  (  )  )  )  {  Preconditions  .  checkState  (  n  .  getParent  (  )  .  getType  (  )  =  =  Token  .  ASSIGN  )  ;  Node  rhs  =  n  .  getNext  (  )  ;  VariableLiveness  state  =  isVariableReadBeforeKill  (  rhs  ,  variable  )  ;  if  (  state  =  =  VariableLiveness  .  READ  )  {  return  state  ;  }  return  VariableLiveness  .  KILL  ;  }  else  {  return  VariableLiveness  .  READ  ;  }  }  switch  (  n  .  getType  (  )  )  {  case  Token  .  OR:  case  Token  .  AND:  [BUGGY]  case  Token  .  HOOK:  return  checkHookBranchReadBeforeKill  (  n  .  getFirstChild  (  )  .  getNext  (  )  ,  n  .  getLastChild  (  )  ,  variable  )  ;  	Closure_76_DeadAssignmentsElimination_8_6	362	0	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
410		[BUGGY]  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  child  )  )  {  [FE]  AssertionFailedError:  [METHOD]  isVariableReadBeforeKill  [TYPE]  DeadAssignmentsElimination$VariableLiveness  [PARAMETER]  Node  n  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  child  n  rhs  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  Node  rhs  =  n  .  getNext  (  )  ;  VariableLiveness  state  =  isVariableReadBeforeKill  (  rhs  ,  variable  )  ;  if  (  state  =  =  VariableLiveness  .  READ  )  {  return  state  ;  }  return  VariableLiveness  .  KILL  ;  }  else  {  return  VariableLiveness  .  READ  ;  }  }  switch  (  n  .  getType  (  )  )  {  case  Token  .  OR:  case  Token  .  AND:  case  Token  .  HOOK:  return  checkHookBranchReadBeforeKill  (  n  .  getFirstChild  (  )  .  getNext  (  )  ,  n  .  getLastChild  (  )  ,  variable  )  ;  default:  for  (  Node  child  =  n  .  getFirstChild  (  )  ;  child  !  =  null  ;  child  =  child  .  getNext  (  )  )  {  [BUGGY]  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  child  )  )  {  //  Not  a  FUNCTION  VariableLiveness  state  =  isVariableReadBeforeKill  (  child  ,  variable  )  ;  if  (  state  !  =  VariableLiveness  .  MAYBE_LIVE  )  {  return  state  ;  }  }  	Closure_76_DeadAssignmentsElimination_8_7	372	1	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
411		[BUGGY]  }  [FE]  AssertionFailedError:  [METHOD]  isVariableReadBeforeKill  [TYPE]  DeadAssignmentsElimination$VariableLiveness  [PARAMETER]  Node  n  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  child  n  rhs  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  }  else  {  return  VariableLiveness  .  READ  ;  }  }  switch  (  n  .  getType  (  )  )  {  case  Token  .  OR:  case  Token  .  AND:  case  Token  .  HOOK:  return  checkHookBranchReadBeforeKill  (  n  .  getFirstChild  (  )  .  getNext  (  )  ,  n  .  getLastChild  (  )  ,  variable  )  ;  default:  for  (  Node  child  =  n  .  getFirstChild  (  )  ;  child  !  =  null  ;  child  =  child  .  getNext  (  )  )  {  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  child  )  )  {  //  Not  a  FUNCTION  VariableLiveness  state  =  isVariableReadBeforeKill  (  child  ,  variable  )  ;  if  (  state  !  =  VariableLiveness  .  MAYBE_LIVE  )  {  return  state  ;  }  }  [BUGGY]  }  }  return  VariableLiveness  .  MAYBE_LIVE  ;  }  	Closure_76_DeadAssignmentsElimination_8_8	378	1	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
412	case  \'\\0\':  sb.append( "\\\\0 ");  break;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<var  x  = "  assertPrint  ( "var  x  =  '\\u0000'  ; "  , "var  x  =  \ "\\0\ " "  )  ;  [METHOD]  strEscape  [TYPE]  String  [PARAMETER]  String  s  char  quote  String  doublequoteEscape  String  singlequoteEscape  String  backslashEscape  CharsetEncoder  outputCharsetEncoder  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  char  c  quote  [TYPE]  CodeConsumer  cc  [TYPE]  String  END_SCRIPT  START_COMMENT  backslashEscape  doublequoteEscape  s  singlequoteEscape  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  i  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  static  String  strEscape  (  String  s  ,  char  quote  ,  String  doublequoteEscape  ,  String  singlequoteEscape  ,  String  backslashEscape  ,  CharsetEncoder  outputCharsetEncoder  )  {  StringBuilder  sb  =  new  StringBuilder  (  s  .  length  (  )  +  2  )  ;  sb  .  append  (  quote  )  ;  for  (  int  i  =  0  ;  i  <  s  .  length  (  )  ;  i++  )  {  char  c  =  s  .  charAt  (  i  )  ;  switch  (  c  )  {  [BUGGY]  case  '\n':  sb  .  append  ( "\\n "  )  ;  break  ;  case  '\r':  sb  .  append  ( "\\r "  )  ;  break  ;  case  '\t':  sb  .  append  ( "\\t "  )  ;  break  ;  case  '\\':  sb  .  append  (  backslashEscape  )  ;  break  ;  case  '\ "':  sb  .  append  (  doublequoteEscape  )  ;  break  ;  case  '\'':  sb  .  append  (  singlequoteEscape  )  ;  break  ;  	Closure_77_CodeGenerator_1_1	966	0	src/com/google/javascript/jscomp/CodeGenerator.java
413		[BUGGY]  error  (  DiagnosticType  .  error  ( "JSC_DIVIDE_BY_0_ERROR "  , "Divide  by  0 "  )  ,  right  )  ;  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_DIVIDE_BY_0_ERROR  Divide  by  0  at  testcode  line  1  :  8  expected:<0>  but  was:<1>  assertResultString  ( "x  =  10  -  20 "  , "x  =  -10 "  )  ;  [METHOD]  performArithmeticOp  [TYPE]  Node  [PARAMETER]  int  opType  Node  left  Node  right  [CLASS]  PeepholeFoldConstants  [TYPE]  Locale  ROOT_LOCALE  [TYPE]  boolean  false  true  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double  MAX_FOLD_NUMBER  lval  result  rval  [TYPE]  Node  left  newNumber  right  [TYPE]  Double  lValObj  rValObj  [TYPE]  int  opType  [CONTEXT]  double  lval  =  lValObj  ;  double  rval  =  rValObj  ;  switch  (  opType  )  {  case  Token  .  BITAND:  result  =  ScriptRuntime  .  toInt32  (  lval  )  &  ScriptRuntime  .  toInt32  (  rval  )  ;  break  ;  case  Token  .  BITOR:  result  =  ScriptRuntime  .  toInt32  (  lval  )  |  ScriptRuntime  .  toInt32  (  rval  )  ;  break  ;  case  Token  .  BITXOR:  result  =  ScriptRuntime  .  toInt32  (  lval  )  ^  ScriptRuntime  .  toInt32  (  rval  )  ;  break  ;  case  Token  .  ADD:  result  =  lval  +  rval  ;  break  ;  case  Token  .  SUB:  result  =  lval  -  rval  ;  break  ;  case  Token  .  MUL:  result  =  lval  *  rval  ;  break  ;  case  Token  .  MOD:  if  (  rval  =  =  0  )  {  [BUGGY]  error  (  DiagnosticType  .  error  ( "JSC_DIVIDE_BY_0_ERROR "  , "Divide  by  0 "  )  ,  right  )  ;  return  null  ;  }  result  =  lval  %  rval  ;  break  ;  case  Token  .  DIV:  	Closure_78_PeepholeFoldConstants_2_1	711	1	src/com/google/javascript/jscomp/PeepholeFoldConstants.java
414		[BUGGY]  error  (  DiagnosticType  .  error  ( "JSC_DIVIDE_BY_0_ERROR "  , "Divide  by  0 "  )  ,  right  )  ;  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_DIVIDE_BY_0_ERROR  Divide  by  0  at  testcode  line  1  :  8  expected:<0>  but  was:<1>  assertResultString  ( "x  =  10  -  20 "  , "x  =  -10 "  )  ;  [METHOD]  performArithmeticOp  [TYPE]  Node  [PARAMETER]  int  opType  Node  left  Node  right  [CLASS]  PeepholeFoldConstants  [TYPE]  Locale  ROOT_LOCALE  [TYPE]  boolean  false  true  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double  MAX_FOLD_NUMBER  lval  result  rval  [TYPE]  Node  left  newNumber  right  [TYPE]  Double  lValObj  rValObj  [TYPE]  int  opType  [CONTEXT]  break  ;  case  Token  .  BITOR:  result  =  ScriptRuntime  .  toInt32  (  lval  )  |  ScriptRuntime  .  toInt32  (  rval  )  ;  break  ;  case  Token  .  BITXOR:  result  =  ScriptRuntime  .  toInt32  (  lval  )  ^  ScriptRuntime  .  toInt32  (  rval  )  ;  break  ;  case  Token  .  ADD:  result  =  lval  +  rval  ;  break  ;  case  Token  .  SUB:  result  =  lval  -  rval  ;  break  ;  case  Token  .  MUL:  result  =  lval  *  rval  ;  break  ;  case  Token  .  MOD:  if  (  rval  =  =  0  )  {  error  (  DiagnosticType  .  error  ( "JSC_DIVIDE_BY_0_ERROR "  , "Divide  by  0 "  )  ,  right  )  ;  return  null  ;  }  result  =  lval  %  rval  ;  break  ;  case  Token  .  DIV:  if  (  rval  =  =  0  )  {  [BUGGY]  error  (  DiagnosticType  .  error  ( "JSC_DIVIDE_BY_0_ERROR "  , "Divide  by  0 "  )  ,  right  )  ;  return  null  ;  }  result  =  lval  /  rval  ;  break  ;  default:  	Closure_78_PeepholeFoldConstants_2_2	718	1	src/com/google/javascript/jscomp/PeepholeFoldConstants.java
415	.traverseRoots(externs,  root);  	[BUGGY]  .  traverse  (  root  )  ;  [FE]  RuntimeException:  INTERNAL  COMPILER  ERROR  [METHOD]  process  [TYPE]  void  [PARAMETER]  Node  externs  Node  root  [CLASS]  Normalize  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  CONVERT_WHILE_TO_FOR  MAKE_LOCAL_NAMES_UNIQUE  assertOnChange  checkUserDeclarations  false  true  [TYPE]  Set  hasOkDuplicateDeclaration  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  CATCH_BLOCK_VAR_ERROR  [TYPE]  Node  externs  root  [TYPE]  MakeDeclaredNamesUnique  renamer  [TYPE]  Map  constantMap  [CONTEXT]  public  void  process  (  Node  externs  ,  Node  root  )  {  new  NodeTraversal  (  compiler  ,  new  NormalizeStatements  (  compiler  ,  assertOnChange  )  )  [BUGGY]  .  traverse  (  root  )  ;  if  (  MAKE_LOCAL_NAMES_UNIQUE  )  {  MakeDeclaredNamesUnique  renamer  =  new  MakeDeclaredNamesUnique  (  )  ;  NodeTraversal  t  =  new  NodeTraversal  (  compiler  ,  renamer  )  ;  t  .  traverseRoots  (  externs  ,  root  )  ;  }  	Closure_79_Normalize_1_1	122	1	src/com/google/javascript/jscomp/Normalize.java
416	compiler.reportCodeChange();  	[BUGGY]  [FE]  RuntimeException:  INTERNAL  COMPILER  ERROR  [CLASS]  [CONTEXT]  	Closure_79_VarCheck_1_1	221	0	src/com/google/javascript/jscomp/VarCheck.java
417	case  Token.DELPROP:  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  NodeUtil  .  isBooleanResult  (  getNode  ( "a  =  1 "  )  )  )  ;  [METHOD]  isBooleanResultHelper  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  NodeUtil  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  Node  n  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  Map  vars  [TYPE]  int  type  [CONTEXT]  static  boolean  isBooleanResultHelper  (  Node  n  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  TRUE:  case  Token  .  FALSE:  case  Token  .  EQ:  case  Token  .  NE:  case  Token  .  SHEQ:  case  Token  .  SHNE:  case  Token  .  LT:  case  Token  .  GT:  case  Token  .  LE:  case  Token  .  GE:  case  Token  .  IN:  case  Token  .  INSTANCEOF:  case  Token  .  NOT:  [BUGGY]  return  true  ;  default:  return  false  ;  }  }  	Closure_80_NodeUtil_2_1	1262	0	src/com/google/javascript/jscomp/NodeUtil.java
418	case  Token.DELPROP:  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  NodeUtil  .  isBooleanResult  (  getNode  ( "a  =  1 "  )  )  )  ;  [METHOD]  evaluatesToLocalValue  [TYPE]  boolean  [PARAMETER]  Node  value  Node>  locals  [CLASS]  NodeUtil  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  Node  value  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  Map  vars  [TYPE]  int  type  [TYPE]  Predicate  locals  [CONTEXT]  return  evaluatesToLocalValue  (  value  .  getFirstChild  (  )  ,  locals  )  ;  }  else  {  return  true  ;  }  case  Token  .  THIS:  return  locals  .  apply  (  value  )  ;  case  Token  .  NAME:  return  isImmutableValue  (  value  )  ||  locals  .  apply  (  value  )  ;  case  Token  .  GETELEM:  case  Token  .  GETPROP:  return  locals  .  apply  (  value  )  ;  case  Token  .  CALL:  return  callHasLocalResult  (  value  )  ||  isToStringMethodCall  (  value  )  ||  locals  .  apply  (  value  )  ;  case  Token  .  NEW:  return  newHasLocalResult  (  value  )  ||  locals  .  apply  (  value  )  ;  case  Token  .  FUNCTION:  case  Token  .  REGEXP:  case  Token  .  ARRAYLIT:  case  Token  .  OBJECTLIT:  return  true  ;  [BUGGY]  case  Token  .  IN:  return  true  ;  default:  	Closure_80_NodeUtil_2_2	2910	0	src/com/google/javascript/jscomp/NodeUtil.java
419	int  functionType  =  functionNode.getFunctionType();  if  (functionType  !=  FunctionNode.FUNCTION_EXPRESSION)  {  errorReporter.error( "unnamed  function  statement ",  sourceName,  functionNode.getLineno(), " ",  0);  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  testErrorReporter  .  hasEncounteredAllWarnings  (  )  )  ;  [METHOD]  processFunctionNode  [TYPE]  Node  [PARAMETER]  FunctionNode  functionNode  [CLASS]  TransformDispatcher  [TYPE]  boolean  false  true  [TYPE]  Node  bodyNode  lp  newName  node  [TYPE]  FunctionNode  functionNode  [TYPE]  Boolean  isUnnamedFunction  [TYPE]  int  lpColumn  lparenCharno  [TYPE]  AstNode  param  [TYPE]  Name  fnName  name  [CONTEXT]  Node  processFunctionNode  (  FunctionNode  functionNode  )  {  Name  name  =  functionNode  .  getFunctionName  (  )  ;  Boolean  isUnnamedFunction  =  false  ;  if  (  name  =  =  null  )  {  [BUGGY]  name  =  new  Name  (  )  ;  name  .  setIdentifier  ( " "  )  ;  isUnnamedFunction  =  true  ;  }  Node  node  =  newNode  (  Token  .  FUNCTION  )  ;  Node  newName  =  transform  (  name  )  ;  	Closure_81_IRFactory_1_1	517	0	src/com/google/javascript/jscomp/parsing/IRFactory.java
420	return  isNoType()  ||  isNoObjectType()  ||  isNoResolvedType()  ||  (registry.getNativeFunctionType(  JSTypeNative.LEAST_FUNCTION_TYPE)  ==  this);  	[BUGGY]  return  isNoType  (  )  ||  isNoObjectType  (  )  ||  isNoResolvedType  (  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  isEmptyType  [TYPE]  boolean  [PARAMETER]  [CLASS]  JSType  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  resolved  true  [TYPE]  JSType  resolveResult  typeA  typeB  [TYPE]  String  EMPTY_TYPE_COMPONENT  NOT_A_CLASS  NOT_A_TYPE  UNKNOWN_NAME  [TYPE]  long  serialVersionUID  [TYPE]  int  ENUMDECL  NOT_ENUMDECL  [TYPE]  Comparator  ALPHA  [CONTEXT]  public  final  boolean  isEmptyType  (  )  {  [BUGGY]  return  isNoType  (  )  ||  isNoObjectType  (  )  ||  isNoResolvedType  (  )  ;  }  	Closure_82_JSType_1_1	163	1	src/com/google/javascript/rhino/jstype/JSType.java
421	String  param  =  null;  try  {  param  =  params.getParameter(0);  }  catch  (CmdLineException  e)  {}  	[BUGGY]  String  param  =  params  .  getParameter  (  0  )  ;  [FE]  AssertionFailedError  assertEquals  (  [METHOD]  parseArguments  [TYPE]  int  [PARAMETER]  Parameters  params  [CLASS]  BooleanOptionHandler  [TYPE]  Set  FALSES  TRUES  [TYPE]  Parameters  params  [TYPE]  String  lowerParam  param  [TYPE]  boolean  false  true  [CONTEXT]  public  int  parseArguments  (  Parameters  params  )  throws  CmdLineException  {  [BUGGY]  String  param  =  params  .  getParameter  (  0  )  ;  if  (  param  =  =  null  )  {  setter  .  addValue  (  true  )  ;  return  0  ;  }  else  {  String  lowerParam  =  param  .  toLowerCase  (  )  ;  if  (  TRUES  .  contains  (  lowerParam  )  )  {  setter  .  addValue  (  true  )  ;  }  else  if  (  FALSES  .  contains  (  lowerParam  )  )  {  setter  .  addValue  (  false  )  ;  }  else  {  setter  .  addValue  (  true  )  ;  return  0  ;  }  return  1  ;  }  }  	Closure_83_CommandLineRunner_1_1	334	1	src/com/google/javascript/jscomp/CommandLineRunner.java
422	Node  target  =  assign.getFirstChild();  if  (!validAssignmentTarget(target))  {  errorReporter.error( "invalid  assignment  target ",  sourceName,  target.getLineno(), " ",  0);  }  	[BUGGY]  [FE]  AssertionFailedError  [METHOD]  processAssignment  [TYPE]  Node  [PARAMETER]  Assignment  assignmentNode  [CLASS]  TransformDispatcher  [TYPE]  Assignment  assignmentNode  [TYPE]  boolean  false  true  [TYPE]  Node  assign  [CONTEXT]  Node  processAssignment  (  Assignment  assignmentNode  )  {  Node  assign  =  processInfixExpression  (  assignmentNode  )  ;  [BUGGY]  return  assign  ;  }  	Closure_84_IRFactory_3_1	341	0	src/com/google/javascript/jscomp/parsing/IRFactory.java
423	if  (type  ==  Token.INC  ||  type  ==  Token.DEC)  {  if  (!validAssignmentTarget(operand))  {  String  msg  =  (type  ==  Token.INC)  ? "invalid  increment  target "  : "invalid  decrement  target ";  errorReporter.error(  msg,  sourceName,  operand.getLineno(), " ",  0);  }  }  	[BUGGY]  [FE]  AssertionFailedError  [METHOD]  processUnaryExpression  [TYPE]  Node  [PARAMETER]  UnaryExpression  exprNode  [CLASS]  TransformDispatcher  [TYPE]  boolean  false  true  [TYPE]  Node  node  operand  [TYPE]  UnaryExpression  exprNode  [TYPE]  int  type  [CONTEXT]  Node  processUnaryExpression  (  UnaryExpression  exprNode  )  {  int  type  =  transformTokenType  (  exprNode  .  getType  (  )  )  ;  Node  operand  =  transform  (  exprNode  .  getOperand  (  )  )  ;  if  (  type  =  =  Token  .  NEG  &&  operand  .  getType  (  )  =  =  Token  .  NUMBER  )  {  operand  .  setDouble  (  -operand  .  getDouble  (  )  )  ;  return  operand  ;  }  else  {  [BUGGY]  Node  node  =  newNode  (  type  ,  operand  )  ;  if  (  exprNode  .  isPostfix  (  )  )  {  node  .  putBooleanProp  (  Node  .  INCRDECR_PROP  ,  true  )  ;  }  return  node  ;  }  }  	Closure_84_IRFactory_3_2	797	0	src/com/google/javascript/jscomp/parsing/IRFactory.java
424	private  boolean  validAssignmentTarget(Node  target)  {  switch  (target.getType())  {  case  Token.NAME:  case  Token.GETPROP:  case  Token.GETELEM:  return  true;  }  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError  [CLASS]  [CONTEXT]  	Closure_84_IRFactory_3_3	806	0	src/com/google/javascript/jscomp/parsing/IRFactory.java
425		[BUGGY]  if  (  n  .  getParent  (  )  =  =  null  )  {  List<DiGraphEdge<Node  ,  Branch>>  outEdges  =  gNode  .  getOutEdges  (  )  ;  if  (  outEdges  .  size  (  )  =  =  1  )  {  return  tryRemoveUnconditionalBranching  (  outEdges  .  get  (  0  )  .  getDestination  (  )  .  getValue  (  )  )  ;  }  }  case  Token  .  BLOCK:  if  (  n  .  hasChildren  (  )  )  {  Node  first  =  n  .  getFirstChild  (  )  ;  return  tryRemoveUnconditionalBranching  (  first  )  ;  }  else  {  return  tryRemoveUnconditionalBranching  (  ControlFlowAnalysis  .  computeFollowNode  (  n  )  )  ;  }  [FE]  AssertionFailedError:  [METHOD]  tryRemoveUnconditionalBranching  [TYPE]  Node  [PARAMETER]  Node  n  [CLASS]  UnreachableCodeElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  DiGraphNode  gNode  [TYPE]  boolean  false  removeNoOpStatements  true  [TYPE]  ControlFlowGraph  curCfg  [TYPE]  Node  fallThrough  first  n  nextCfgNode  [TYPE]  List  outEdges  [TYPE]  Logger  logger  [TYPE]  Deque  cfgStack  [CONTEXT]  private  Node  tryRemoveUnconditionalBranching  (  Node  n  )  {  if  (  n  =  =  null  )  {  return  n  ;  }  DiGraphNode<Node  ,  Branch>  gNode  =  curCfg  .  getDirectedGraphNode  (  n  )  ;  if  (  gNode  =  =  null  )  {  return  n  ;  }  [BUGGY]  if  (  n  .  getParent  (  )  =  =  null  )  {  List<DiGraphEdge<Node  ,  Branch>>  outEdges  =  gNode  .  getOutEdges  (  )  ;  if  (  outEdges  .  size  (  )  =  =  1  )  {  return  tryRemoveUnconditionalBranching  (  outEdges  .  get  (  0  )  .  getDestination  (  )  .  getValue  (  )  )  ;  }  }  	Closure_85_UnreachableCodeElimination_3_1	153	13	src/com/google/javascript/jscomp/UnreachableCodeElimination.java
426	Node  fallThrough  =  computeFollowing(n);  	[BUGGY]  Node  fallThrough  =  tryRemoveUnconditionalBranching  (  computeFollowing  (  n  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  tryRemoveUnconditionalBranching  [TYPE]  Node  [PARAMETER]  Node  n  [CLASS]  UnreachableCodeElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  DiGraphNode  gNode  [TYPE]  boolean  false  removeNoOpStatements  true  [TYPE]  ControlFlowGraph  curCfg  [TYPE]  Node  fallThrough  first  n  nextCfgNode  [TYPE]  List  outEdges  [TYPE]  Logger  logger  [TYPE]  Deque  cfgStack  [CONTEXT]  }  switch  (  n  .  getType  (  )  )  {  case  Token  .  BLOCK:  if  (  n  .  hasChildren  (  )  )  {  Node  first  =  n  .  getFirstChild  (  )  ;  return  tryRemoveUnconditionalBranching  (  first  )  ;  }  else  {  return  tryRemoveUnconditionalBranching  (  ControlFlowAnalysis  .  computeFollowNode  (  n  )  )  ;  }  case  Token  .  RETURN:  if  (  n  .  hasChildren  (  )  )  {  break  ;  }  case  Token  .  BREAK:  case  Token  .  CONTINUE:  List<DiGraphEdge<Node  ,  Branch>>  outEdges  =  gNode  .  getOutEdges  (  )  ;  if  (  outEdges  .  size  (  )  =  =  1  &&  (  n  .  getNext  (  )  =  =  null  ||  n  .  getNext  (  )  .  getType  (  )  =  =  Token  .  FUNCTION  )  )  {  Preconditions  .  checkState  (  outEdges  .  get  (  0  )  .  getValue  (  )  =  =  Branch  .  UNCOND  )  ;  [BUGGY]  Node  fallThrough  =  tryRemoveUnconditionalBranching  (  computeFollowing  (  n  )  )  ;  Node  nextCfgNode  =  outEdges  .  get  (  0  )  .  getDestination  (  )  .  getValue  (  )  ;  if  (  nextCfgNode  =  =  fallThrough  )  {  removeDeadExprStatementSafely  (  n  )  ;  return  fallThrough  ;  }  	Closure_85_UnreachableCodeElimination_3_2	183	1	src/com/google/javascript/jscomp/UnreachableCodeElimination.java
427	while  (next  !=  null  &&  next.getType()  ==  Token.BLOCK)  {  if  (next.hasChildren())  {  next  =  next.getFirstChild();  }  else  {  next  =  computeFollowing(next);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  computeFollowing  [TYPE]  Node  [PARAMETER]  Node  n  [CLASS]  UnreachableCodeElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  removeNoOpStatements  true  [TYPE]  Logger  logger  [TYPE]  Deque  cfgStack  [TYPE]  ControlFlowGraph  curCfg  [TYPE]  Node  n  next  [CONTEXT]  private  Node  computeFollowing  (  Node  n  )  {  Node  next  =  ControlFlowAnalysis  .  computeFollowNode  (  n  )  ;  [BUGGY]  return  next  ;  }  	Closure_85_UnreachableCodeElimination_3_3	196	0	src/com/google/javascript/jscomp/UnreachableCodeElimination.java
428	return  false;  	[BUGGY]  return  true  ;  [FE]  AssertionFailedError  assertFalse  (  testLocalValue  ( "o  .  valueOf  (  ) "  )  )  ;  [METHOD]  evaluatesToLocalValue  [TYPE]  boolean  [PARAMETER]  Node  value  Node>  locals  [CLASS]  NodeUtil  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  boolean  false  true  [TYPE]  Node  value  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  Map  vars  [TYPE]  int  type  [TYPE]  Predicate  locals  [CONTEXT]  return  evaluatesToLocalValue  (  value  .  getFirstChild  (  )  .  getNext  (  )  ,  locals  )  &&  evaluatesToLocalValue  (  value  .  getLastChild  (  )  ,  locals  )  ;  case  Token  .  INC:  case  Token  .  DEC:  if  (  value  .  getBooleanProp  (  Node  .  INCRDECR_PROP  )  )  {  return  evaluatesToLocalValue  (  value  .  getFirstChild  (  )  ,  locals  )  ;  }  else  {  return  true  ;  }  case  Token  .  THIS:  return  locals  .  apply  (  value  )  ;  case  Token  .  NAME:  return  isImmutableValue  (  value  )  ||  locals  .  apply  (  value  )  ;  case  Token  .  GETELEM:  case  Token  .  GETPROP:  return  locals  .  apply  (  value  )  ;  case  Token  .  CALL:  return  callHasLocalResult  (  value  )  ||  isToStringMethodCall  (  value  )  ||  locals  .  apply  (  value  )  ;  case  Token  .  NEW:  [BUGGY]  return  true  ;  case  Token  .  FUNCTION:  case  Token  .  REGEXP:  case  Token  .  ARRAYLIT:  case  Token  .  OBJECTLIT:  	Closure_86_NodeUtil_1_1	2465	1	src/com/google/javascript/jscomp/NodeUtil.java
429	if  (maybeExpr.getType()  ==  Token.EXPR_RESULT)  {  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isFoldableExpressBlock  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  PeepholeSubstituteAlternateSyntax  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  [TYPE]  boolean  false  true  [TYPE]  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  [TYPE]  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  [TYPE]  Node  maybeExpr  n  [TYPE]  int  AND_PRECEDENCE  OR_PRECEDENCE  [TYPE]  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  [CONTEXT]  private  boolean  isFoldableExpressBlock  (  Node  n  )  {  if  (  n  .  getType  (  )  =  =  Token  .  BLOCK  )  {  if  (  n  .  hasOneChild  (  )  )  {  Node  maybeExpr  =  n  .  getFirstChild  (  )  ;  [BUGGY]  return  NodeUtil  .  isExpressionNode  (  maybeExpr  )  ;  }  }  return  false  ;  }  	Closure_87_PeepholeSubstituteAlternateSyntax_3_1	523	0	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
430	if  (maybeExpr.getFirstChild().getType()  ==  Token.CALL)  {  Node  calledFn  =  maybeExpr.getFirstChild().getFirstChild();  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isFoldableExpressBlock  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  PeepholeSubstituteAlternateSyntax  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  [TYPE]  boolean  false  true  [TYPE]  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  [TYPE]  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  [TYPE]  Node  maybeExpr  n  [TYPE]  int  AND_PRECEDENCE  OR_PRECEDENCE  [TYPE]  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  [CONTEXT]  private  boolean  isFoldableExpressBlock  (  Node  n  )  {  if  (  n  .  getType  (  )  =  =  Token  .  BLOCK  )  {  if  (  n  .  hasOneChild  (  )  )  {  Node  maybeExpr  =  n  .  getFirstChild  (  )  ;  [BUGGY]  return  NodeUtil  .  isExpressionNode  (  maybeExpr  )  ;  }  }  return  false  ;  }  	Closure_87_PeepholeSubstituteAlternateSyntax_3_2	529	0	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
431	return  false;  }  else  if  (calledFn.getType()  ==  Token.GETPROP  &&  calledFn.getLastChild().getString().startsWith( "on "))  {  return  false;  }  }  return  true;  }  return  false;  	[BUGGY]  return  NodeUtil  .  isExpressionNode  (  maybeExpr  )  ;  [FE]  AssertionFailedError:  [METHOD]  isFoldableExpressBlock  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  PeepholeSubstituteAlternateSyntax  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  [TYPE]  boolean  false  true  [TYPE]  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  [TYPE]  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  [TYPE]  Node  maybeExpr  n  [TYPE]  int  AND_PRECEDENCE  OR_PRECEDENCE  [TYPE]  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  [CONTEXT]  private  boolean  isFoldableExpressBlock  (  Node  n  )  {  if  (  n  .  getType  (  )  =  =  Token  .  BLOCK  )  {  if  (  n  .  hasOneChild  (  )  )  {  Node  maybeExpr  =  n  .  getFirstChild  (  )  ;  [BUGGY]  return  NodeUtil  .  isExpressionNode  (  maybeExpr  )  ;  }  }  return  false  ;  }  	Closure_87_PeepholeSubstituteAlternateSyntax_3_3	532	1	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
432	Preconditions.checkState(n.getParent().getType()  ==  Token.ASSIGN);  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isVariableReadBeforeKill  [TYPE]  DeadAssignmentsElimination$VariableLiveness  [PARAMETER]  Node  n  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  child  n  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  private  VariableLiveness  isVariableReadBeforeKill  (  Node  n  ,  String  variable  )  {  if  (  NodeUtil  .  isName  (  n  )  &&  variable  .  equals  (  n  .  getString  (  )  )  )  {  if  (  NodeUtil  .  isLhs  (  n  ,  n  .  getParent  (  )  )  )  {  [BUGGY]  return  VariableLiveness  .  KILL  ;  }  else  {  return  VariableLiveness  .  READ  ;  }  }  for  (  Node  child  =  n  .  getFirstChild  (  )  ;  child  !  =  null  ;  child  =  child  .  getNext  (  )  )  {  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  child  )  )  {  //  Not  a  FUNCTION  VariableLiveness  state  =  isVariableReadBeforeKill  (  child  ,  variable  )  ;  if  (  state  !  =  VariableLiveness  .  MAYBE_LIVE  )  {  return  state  ;  }  }  }  return  VariableLiveness  .  MAYBE_LIVE  ;  }  	Closure_88_DeadAssignmentsElimination_2_1	327	0	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
433	Node  rhs  =  n.getNext();  VariableLiveness  state  =  isVariableReadBeforeKill(rhs,  variable);  if  (state  ==  VariableLiveness.READ)  {  return  state;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isVariableReadBeforeKill  [TYPE]  DeadAssignmentsElimination$VariableLiveness  [PARAMETER]  Node  n  String  variable  [CLASS]  DeadAssignmentsElimination  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Node  child  n  [TYPE]  String  variable  [TYPE]  VariableLiveness  KILL  MAYBE_LIVE  READ  state  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  Predicate  matchRemovableAssigns  [CONTEXT]  private  VariableLiveness  isVariableReadBeforeKill  (  Node  n  ,  String  variable  )  {  if  (  NodeUtil  .  isName  (  n  )  &&  variable  .  equals  (  n  .  getString  (  )  )  )  {  if  (  NodeUtil  .  isLhs  (  n  ,  n  .  getParent  (  )  )  )  {  [BUGGY]  return  VariableLiveness  .  KILL  ;  }  else  {  return  VariableLiveness  .  READ  ;  }  }  for  (  Node  child  =  n  .  getFirstChild  (  )  ;  child  !  =  null  ;  child  =  child  .  getNext  (  )  )  {  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  child  )  )  {  //  Not  a  FUNCTION  VariableLiveness  state  =  isVariableReadBeforeKill  (  child  ,  variable  )  ;  if  (  state  !  =  VariableLiveness  .  MAYBE_LIVE  )  {  return  state  ;  }  }  }  return  VariableLiveness  .  MAYBE_LIVE  ;  }  	Closure_88_DeadAssignmentsElimination_2_2	330	0	src/com/google/javascript/jscomp/DeadAssignmentsElimination.java
434	if  (rvalue  !=  null  &&  rvalue.getType()  ==  Token.FUNCTION)  {  checkForHosedThisReferences(rvalue,  refName.docInfo,  refName);  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  updateSimpleDeclaration  [TYPE]  void  [PARAMETER]  String  alias  Name  refName  Ref  ref  [CLASS]  CollapseProperties  [TYPE]  AbstractCompiler  compiler  [TYPE]  Ref  ref  [TYPE]  boolean  collapsePropertiesOnExternTypes  false  inlineAliases  true  [TYPE]  DiagnosticType  NAMESPACE_REDEFINED_WARNING  UNSAFE_NAMESPACE_WARNING  UNSAFE_THIS  [TYPE]  Node  current  currentParent  gramps  greatGramps  greatGreatGramps  nameNode  parent  rvalue  stubVar  varNode  [TYPE]  List  globalNames  [TYPE]  String  alias  [TYPE]  Map  nameMap  [TYPE]  Name  refName  [CONTEXT]  private  void  updateSimpleDeclaration  (  String  alias  ,  Name  refName  ,  Ref  ref  )  {  Node  rvalue  =  ref  .  node  .  getNext  (  )  ;  Node  parent  =  ref  .  node  .  getParent  (  )  ;  Node  gramps  =  parent  .  getParent  (  )  ;  Node  greatGramps  =  gramps  .  getParent  (  )  ;  Node  greatGreatGramps  =  greatGramps  .  getParent  (  )  ;  [BUGGY]  Node  nameNode  =  NodeUtil  .  newName  (  compiler  .  getCodingConvention  (  )  ,  alias  ,  gramps  .  getFirstChild  (  )  ,  refName  .  fullName  (  )  )  ;  NodeUtil  .  copyNameAnnotations  (  ref  .  node  .  getLastChild  (  )  ,  nameNode  )  ;  	Closure_89_CollapseProperties_1_1	484	0	src/com/google/javascript/jscomp/CollapseProperties.java
435	if  (aliasingGets  >  0)  {  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  canCollapseUnannotatedChildNames  [TYPE]  boolean  [PARAMETER]  [CLASS]  Name  [TYPE]  Type  FUNCTION  OBJECTLIT  OTHER  type  [TYPE]  Ref  declaration  [TYPE]  boolean  false  hasClassOrEnumDescendant  inExterns  isClassOrEnum  true  [TYPE]  List  props  refs  [TYPE]  String  name  [TYPE]  JSDocInfo  docInfo  [TYPE]  int  aliasingGets  callGets  globalSets  localSets  totalGets  [TYPE]  Name  parent  [CONTEXT]  boolean  canCollapseUnannotatedChildNames  (  )  {  if  (  type  =  =  Type  .  OTHER  ||  globalSets  !  =  1  ||  localSets  !  =  0  )  {  return  false  ;  }  Preconditions  .  checkNotNull  (  declaration  )  ;  if  (  declaration  .  getTwin  (  )  !  =  null  )  {  return  false  ;  }  if  (  isClassOrEnum  )  {  return  true  ;  }  if  (  parent  !  =  null  &&  parent  .  shouldKeepKeys  (  )  )  {  return  false  ;  }  [BUGGY]  if  (  type  !  =  Type  .  FUNCTION  &&  aliasingGets  >  0  )  {  return  false  ;  }  return  (  parent  =  =  null  ||  parent  .  canCollapseUnannotatedChildNames  (  )  )  ;  }  	Closure_89_GlobalNamespace_1_1	920	0	src/com/google/javascript/jscomp/GlobalNamespace.java
436	if  (!type.restrictByNotNullOrUndefined().isSubtype(  	[BUGGY]  if  (  !type  .  isSubtype  (  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  apply  [TYPE]  boolean  [PARAMETER]  JSType  type  [CLASS]  ThisTypeValidator  [TYPE]  JSType  type  [TYPE]  boolean  false  true  [CONTEXT]  public  boolean  apply  (  JSType  type  )  {  [BUGGY]  if  (  !type  .  isSubtype  (  typeRegistry  .  getNativeType  (  OBJECT_TYPE  )  )  )  {  reportWarning  (  THIS_TYPE_NON_OBJECT  ,  type  .  toString  (  )  )  ;  return  false  ;  }  return  true  ;  }  	Closure_90_FunctionTypeBuilder_1_1	184	1	src/com/google/javascript/jscomp/FunctionTypeBuilder.java
437	if  (maybeTypeOfThis  !=  null)  {  maybeTypeOfThis  =  maybeTypeOfThis.restrictByNotNullOrUndefined();  }  	[BUGGY]  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  resolveInternal  [TYPE]  JSType  [PARAMETER]  ErrorReporter  t  JSType>  scope  [CLASS]  FunctionType  [TYPE]  JSType  maybeTypeOfThis  [TYPE]  FunctionPrototypeType  prototype  [TYPE]  Node  source  [TYPE]  StaticScope  scope  [TYPE]  Builder  resolvedInterfaces  [TYPE]  ArrowType  call  [TYPE]  String  templateTypeName  [TYPE]  long  serialVersionUID  [TYPE]  int  i  [TYPE]  ObjectType  iface  resolvedIface  typeOfThis  [TYPE]  ErrorReporter  t  [TYPE]  boolean  changed  false  true  [TYPE]  Kind  CONSTRUCTOR  INTERFACE  ORDINARY  kind  [TYPE]  List  implementedInterfaces  subTypes  [CONTEXT]  JSType  resolveInternal  (  ErrorReporter  t  ,  StaticScope<JSType>  scope  )  {  setResolvedTypeInternal  (  this  )  ;  call  =  (  ArrowType  )  safeResolve  (  call  ,  t  ,  scope  )  ;  prototype  =  (  FunctionPrototypeType  )  safeResolve  (  prototype  ,  t  ,  scope  )  ;  JSType  maybeTypeOfThis  =  safeResolve  (  typeOfThis  ,  t  ,  scope  )  ;  [BUGGY]  if  (  maybeTypeOfThis  instanceof  ObjectType  )  {  typeOfThis  =  (  ObjectType  )  maybeTypeOfThis  ;  }  boolean  changed  =  false  ;  ImmutableList  .  Builder<ObjectType>  resolvedInterfaces  =  	Closure_90_FunctionType_1_1	880	0	src/com/google/javascript/rhino/jstype/FunctionType.java
438	if  (NodeUtil.isObjectLitKey(parent,  gramps))  {  JSDocInfo  maybeLends  =  gramps.getJSDocInfo();  if  (maybeLends  !=  null  &&  maybeLends.getLendsName()  !=  null  &&  maybeLends.getLendsName().endsWith( ".prototype "))  {  return  false;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_USED_GLOBAL_THIS  dangerous  use  of  the  global  this  object  at  testcode  line  1  :  110  expected:<0>  but  was:<1>  [METHOD]  shouldTraverse  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckGlobalThis  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  GLOBAL_THIS  [TYPE]  CheckLevel  level  [TYPE]  Node  assignLhsChild  lhs  llhs  n  parent  rhs  [TYPE]  JSDocInfo  jsDoc  [TYPE]  int  pType  [CONTEXT]  jsDoc  .  isInterface  (  )  ||  jsDoc  .  hasThisType  (  )  ||  jsDoc  .  isOverride  (  )  )  )  {  return  false  ;  }  int  pType  =  parent  .  getType  (  )  ;  if  (  !  (  pType  =  =  Token  .  BLOCK  ||  pType  =  =  Token  .  SCRIPT  ||  pType  =  =  Token  .  NAME  ||  pType  =  =  Token  .  ASSIGN  ||  pType  =  =  Token  .  STRING  ||  pType  =  =  Token  .  NUMBER  )  )  {  return  false  ;  }  [BUGGY]  }  if  (  parent  !  =  null  &&  parent  .  getType  (  )  =  =  Token  .  ASSIGN  )  {  Node  lhs  =  parent  .  getFirstChild  (  )  ;  Node  rhs  =  lhs  .  getNext  (  )  ;  	Closure_91_CheckGlobalThis_1_1	115	0	src/com/google/javascript/jscomp/CheckGlobalThis.java
439	int  indexOfDot  =  namespace  .  lastIndexOf  (  '  .  '  )  ;	[BUGGY] int  indexOfDot  =  namespace  .  indexOf  (  '  .  '  )  ;  [FE]  AssertionFailedError:  [METHOD]  replace  [TYPE]  void  [PARAMETER]  [CLASS]  ProvidedName  [TYPE]  JSModule  explicitModule  firstModule  minimumModule  [TYPE]  String  namespace  [TYPE]  boolean  false  true  [TYPE]  int  indexOfDot  [TYPE]  ProvidedName  parentName  [TYPE]  Node  assignNode  candidateDefinition  explicitNode  firstNode  nameNode  replacementNode  valueNode  varNode  [CONTEXT]  Node  assignNode  =  candidateDefinition  .  getFirstChild  (  )  ;  Node  nameNode  =  assignNode  .  getFirstChild  (  )  ;  if  (  nameNode  .  getType  (  )  =  =  Token  .  NAME  )  {  Node  valueNode  =  nameNode  .  getNext  (  )  ;  assignNode  .  removeChild  (  nameNode  )  ;  assignNode  .  removeChild  (  valueNode  )  ;  nameNode  .  addChildToFront  (  valueNode  )  ;  Node  varNode  =  new  Node  (  Token  .  VAR  ,  nameNode  )  ;  varNode  .  copyInformationFrom  (  candidateDefinition  )  ;  candidateDefinition  .  getParent  (  )  .  replaceChild  (  candidateDefinition  ,  varNode  )  ;  nameNode  .  setJSDocInfo  (  assignNode  .  getJSDocInfo  (  )  )  ;  compiler  .  reportCodeChange  (  )  ;  replacementNode  =  varNode  ;  }  }  }  else  {  replacementNode  =  createDeclarationNode  (  )  ;  if  (  firstModule  =  =  minimumModule  )  {  firstNode  .  getParent  (  )  .  addChildBefore  (  replacementNode  ,  firstNode  )  ;  }  else  {  [BUGGY]  int  indexOfDot  =  namespace  .  indexOf  (  '  .  '  )  ;  if  (  indexOfDot  =  =  -1  )  {  compiler  .  getNodeForCodeInsertion  (  minimumModule  )  .  addChildToBack  (  replacementNode  )  ;  }  else  {  	Closure_92_ProcessClosurePrimitives_1_1	789	0	src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
440	case  Token.ADD:  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  testValidDefineValue  ( "1  &  foo "  )  )  ;  [METHOD]  isValidDefineValue  [TYPE]  boolean  [PARAMETER]  Node  val  String>  defines  [CLASS]  NodeUtil  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  defines  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  vars  [TYPE]  int  type  [TYPE]  Node  val  [CONTEXT]  static  boolean  isValidDefineValue  (  Node  val  ,  Set<String>  defines  )  {  switch  (  val  .  getType  (  )  )  {  case  Token  .  STRING:  case  Token  .  NUMBER:  case  Token  .  TRUE:  case  Token  .  FALSE:  return  true  ;  [BUGGY]  case  Token  .  BITAND:  case  Token  .  BITNOT:  case  Token  .  BITOR:  case  Token  .  BITXOR:  case  Token  .  NOT:  case  Token  .  NEG:  return  isValidDefineValue  (  val  .  getFirstChild  (  )  ,  defines  )  ;  case  Token  .  NAME:  case  Token  .  GETPROP:  if  (  val  .  isQualifiedName  (  )  )  {  return  defines  .  contains  (  val  .  getQualifiedName  (  )  )  ;  }  }  return  false  ;  }  	Closure_94_NodeUtil_3_1	329	0	src/com/google/javascript/jscomp/NodeUtil.java
441	case  Token.DIV:  case  Token.EQ:  case  Token.GE:  case  Token.GT:  case  Token.LE:  case  Token.LSH:  case  Token.LT:  case  Token.MOD:  case  Token.MUL:  case  Token.NE:  case  Token.RSH:  case  Token.SHEQ:  case  Token.SHNE:  case  Token.SUB:  case  Token.URSH:  return  isValidDefineValue(val.getFirstChild(),  defines)  &&  isValidDefineValue(val.getLastChild(),  defines);  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  testValidDefineValue  ( "1  &  foo "  )  )  ;  [METHOD]  isValidDefineValue  [TYPE]  boolean  [PARAMETER]  Node  val  String>  defines  [CLASS]  NodeUtil  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  defines  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  vars  [TYPE]  int  type  [TYPE]  Node  val  [CONTEXT]  static  boolean  isValidDefineValue  (  Node  val  ,  Set<String>  defines  )  {  switch  (  val  .  getType  (  )  )  {  case  Token  .  STRING:  case  Token  .  NUMBER:  case  Token  .  TRUE:  case  Token  .  FALSE:  return  true  ;  case  Token  .  BITAND:  case  Token  .  BITNOT:  case  Token  .  BITOR:  case  Token  .  BITXOR:  [BUGGY]  case  Token  .  NOT:  case  Token  .  NEG:  return  isValidDefineValue  (  val  .  getFirstChild  (  )  ,  defines  )  ;  case  Token  .  NAME:  case  Token  .  GETPROP:  if  (  val  .  isQualifiedName  (  )  )  {  return  defines  .  contains  (  val  .  getQualifiedName  (  )  )  ;  }  }  return  false  ;  }  	Closure_94_NodeUtil_3_2	333	0	src/com/google/javascript/jscomp/NodeUtil.java
442	case  Token.POS:  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  testValidDefineValue  ( "1  &  foo "  )  )  ;  [METHOD]  isValidDefineValue  [TYPE]  boolean  [PARAMETER]  Node  val  String>  defines  [CLASS]  NodeUtil  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  defines  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Map  vars  [TYPE]  int  type  [TYPE]  Node  val  [CONTEXT]  static  boolean  isValidDefineValue  (  Node  val  ,  Set<String>  defines  )  {  switch  (  val  .  getType  (  )  )  {  case  Token  .  STRING:  case  Token  .  NUMBER:  case  Token  .  TRUE:  case  Token  .  FALSE:  return  true  ;  case  Token  .  BITAND:  case  Token  .  BITNOT:  case  Token  .  BITOR:  case  Token  .  BITXOR:  case  Token  .  NOT:  case  Token  .  NEG:  [BUGGY]  return  isValidDefineValue  (  val  .  getFirstChild  (  )  ,  defines  )  ;  case  Token  .  NAME:  case  Token  .  GETPROP:  if  (  val  .  isQualifiedName  (  )  )  {  return  defines  .  contains  (  val  .  getQualifiedName  (  )  )  ;  }  }  return  false  ;  }  	Closure_94_NodeUtil_3_3	337	0	src/com/google/javascript/jscomp/NodeUtil.java
443	if  (n.getType()  ==  Token.GETPROP  &&  !scope.isGlobal()  &&  isQnameRootedInGlobalScope(n))  {  Scope  globalScope  =  scope.getGlobalScope();  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  defineSlot  [TYPE]  void  [PARAMETER]  Node  n  Node  parent  JSType  type  boolean  inferred  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  globalThis  thisType  [TYPE]  CompilerInput  input  [TYPE]  JSType  type  [TYPE]  boolean  false  inferred  isExtern  shouldDeclareOnGlobalThis  true  [TYPE]  Scope  scope  scopeToDeclareIn  [TYPE]  Var  oldVar  [TYPE]  Node  n  parent  [TYPE]  FunctionType  fnType  superClassCtor  [TYPE]  List  deferredSetTypes  nonExternFunctions  stubDeclarations  [TYPE]  String  sourceName  variableName  [CONTEXT]  boolean  shouldDeclareOnGlobalThis  =  false  ;  if  (  n  .  getType  (  )  =  =  Token  .  NAME  )  {  Preconditions  .  checkArgument  (  parent  .  getType  (  )  =  =  Token  .  FUNCTION  ||  parent  .  getType  (  )  =  =  Token  .  VAR  ||  parent  .  getType  (  )  =  =  Token  .  LP  ||  parent  .  getType  (  )  =  =  Token  .  CATCH  )  ;  shouldDeclareOnGlobalThis  =  scope  .  isGlobal  (  )  &&  (  parent  .  getType  (  )  =  =  Token  .  VAR  ||  parent  .  getType  (  )  =  =  Token  .  FUNCTION  )  ;  }  else  {  Preconditions  .  checkArgument  (  n  .  getType  (  )  =  =  Token  .  GETPROP  &&  (  parent  .  getType  (  )  =  =  Token  .  ASSIGN  ||  parent  .  getType  (  )  =  =  Token  .  EXPR_RESULT  )  )  ;  }  String  variableName  =  n  .  getQualifiedName  (  )  ;  Preconditions  .  checkArgument  (  !variableName  .  isEmpty  (  )  )  ;  Scope  scopeToDeclareIn  =  scope  ;  [BUGGY]  if  (  scopeToDeclareIn  .  isDeclared  (  variableName  ,  false  )  )  {  	Closure_95_TypedScopeCreator_2_1	899	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
444	if  (!globalScope.isDeclared(variableName,  false))  {  scopeToDeclareIn  =  scope.getGlobalScope();  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  defineSlot  [TYPE]  void  [PARAMETER]  Node  n  Node  parent  JSType  type  boolean  inferred  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  globalThis  thisType  [TYPE]  CompilerInput  input  [TYPE]  JSType  type  [TYPE]  boolean  false  inferred  isExtern  shouldDeclareOnGlobalThis  true  [TYPE]  Scope  scope  scopeToDeclareIn  [TYPE]  Var  oldVar  [TYPE]  Node  n  parent  [TYPE]  FunctionType  fnType  superClassCtor  [TYPE]  List  deferredSetTypes  nonExternFunctions  stubDeclarations  [TYPE]  String  sourceName  variableName  [CONTEXT]  if  (  n  .  getType  (  )  =  =  Token  .  NAME  )  {  Preconditions  .  checkArgument  (  parent  .  getType  (  )  =  =  Token  .  FUNCTION  ||  parent  .  getType  (  )  =  =  Token  .  VAR  ||  parent  .  getType  (  )  =  =  Token  .  LP  ||  parent  .  getType  (  )  =  =  Token  .  CATCH  )  ;  shouldDeclareOnGlobalThis  =  scope  .  isGlobal  (  )  &&  (  parent  .  getType  (  )  =  =  Token  .  VAR  ||  parent  .  getType  (  )  =  =  Token  .  FUNCTION  )  ;  }  else  {  Preconditions  .  checkArgument  (  n  .  getType  (  )  =  =  Token  .  GETPROP  &&  (  parent  .  getType  (  )  =  =  Token  .  ASSIGN  ||  parent  .  getType  (  )  =  =  Token  .  EXPR_RESULT  )  )  ;  }  String  variableName  =  n  .  getQualifiedName  (  )  ;  Preconditions  .  checkArgument  (  !variableName  .  isEmpty  (  )  )  ;  Scope  scopeToDeclareIn  =  scope  ;  [BUGGY]  if  (  scopeToDeclareIn  .  isDeclared  (  variableName  ,  false  )  )  {  Var  oldVar  =  scopeToDeclareIn  .  getVar  (  variableName  )  ;  validator  .  expectUndeclaredVariable  (  sourceName  ,  n  ,  parent  ,  oldVar  ,  variableName  ,  type  )  ;  	Closure_95_TypedScopeCreator_2_2	902	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
445	(parameters.hasNext()  ||  parameter  !=  null  &&  parameter.isVarArgs()))  {  if  (parameters.hasNext())  {  }  	[BUGGY]  parameters  .  hasNext  (  )  )  {  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  visitParameterList  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  call  FunctionType  functionType  [CLASS]  TypeCheck  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  CheckLevel  reportMissingOverride  reportUnknownTypes  [TYPE]  Node  argument  call  parameter  [TYPE]  FunctionType  functionType  [TYPE]  ScopeCreator  scopeCreator  [TYPE]  String  OVERRIDING_PROTOTYPE_WITH_NON_OBJECT  [TYPE]  int  maxArgs  minArgs  noTypeCheckSection  nullCount  numArgs  ordinal  typedCount  unknownCount  [TYPE]  TypeValidator  validator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  false  inExterns  reportMissingProperties  true  [TYPE]  Scope  topScope  [TYPE]  DiagnosticType  BAD_DELETE  BAD_IMPLEMENTED_TYPE  BIT_OPERATION  CONFLICTING_EXTENDED_TYPE  CONSTRUCTOR_NOT_CALLABLE  DETERMINISTIC_TEST  DETERMINISTIC_TEST_NO_RESULT  ENUM_DUP  ENUM_NOT_CONSTANT  FUNCTION_MASKS_VARIABLE  HIDDEN_INTERFACE_PROPERTY  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_SUPERCLASS_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY_MISMATCH  ILLEGAL_IMPLICIT_CAST  INEXISTENT_ENUM_ELEMENT  INEXISTENT_PROPERTY  INTERFACE_FUNCTION_NOT_EMPTY  INTERFACE_METHOD_OVERRIDE  INVALID_INTERFACE_MEMBER_DECLARATION  MULTIPLE_VAR_DEF  NOT_A_CONSTRUCTOR  NOT_CALLABLE  UNEXPECTED_TOKEN  UNKNOWN_EXPR_TYPE  UNKNOWN_OVERRIDE  UNRESOLVED_TYPE  WRONG_ARGUMENT_COUNT  [TYPE]  Iterator  arguments  parameters  [TYPE]  InferJSDocInfo  inferJSDocInfo  [CONTEXT]  private  void  visitParameterList  (  NodeTraversal  t  ,  Node  call  ,  FunctionType  functionType  )  {  Iterator<Node>  arguments  =  call  .  children  (  )  .  iterator  (  )  ;  arguments  .  next  (  )  ;  //  skip  the  function  name  Iterator<Node>  parameters  =  functionType  .  getParameters  (  )  .  iterator  (  )  ;  int  ordinal  =  0  ;  Node  parameter  =  null  ;  Node  argument  =  null  ;  while  (  arguments  .  hasNext  (  )  &&  [BUGGY]  parameters  .  hasNext  (  )  )  {  parameter  =  parameters  .  next  (  )  ;  argument  =  arguments  .  next  (  )  ;  ordinal++  ;  	Closure_96_TypeCheck_1_1	1409	1	src/com/google/javascript/jscomp/TypeCheck.java
446	long  lvalLong  =  lvalInt  &  0xffffffffL;  result  =  lvalLong  >>>  rvalInt;  	[BUGGY]  result  =  lvalInt  >>>  rvalInt  ;  [FE]  AssertionFailedError:  assertResultString  ( "x  =  -1  >>  0 "  , "x  =  -1 "  )  ;  [METHOD]  tryFoldShift  [TYPE]  Node  [PARAMETER]  Node  n  Node  left  Node  right  [CLASS]  PeepholeFoldConstants  [TYPE]  boolean  false  true  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double  MAX_FOLD_NUMBER  lval  result  rval  [TYPE]  int  lvalInt  rvalInt  [TYPE]  Node  left  n  newNumber  right  [CONTEXT]  int  lvalInt  =  (  int  )  lval  ;  if  (  lvalInt  !  =  lval  )  {  error  (  FRACTIONAL_BITWISE_OPERAND  ,  left  )  ;  return  n  ;  }  int  rvalInt  =  (  int  )  rval  ;  if  (  rvalInt  !  =  rval  )  {  error  (  FRACTIONAL_BITWISE_OPERAND  ,  right  )  ;  return  n  ;  }  switch  (  n  .  getType  (  )  )  {  case  Token  .  LSH:  result  =  lvalInt  <<  rvalInt  ;  break  ;  case  Token  .  RSH:  result  =  lvalInt  >>  rvalInt  ;  break  ;  case  Token  .  URSH:  [BUGGY]  result  =  lvalInt  >>>  rvalInt  ;  break  ;  default:  throw  new  AssertionError  ( "Unknown  shift  operator: "  +  Node  .  tokenToName  (  n  .  getType  (  )  )  )  ;  }  	Closure_97_PeepholeFoldConstants_1_1	698	1	src/com/google/javascript/jscomp/PeepholeFoldConstants.java
447	for  (BasicBlock  block  =  ref.getBasicBlock();  block  !=  null;  block  =  block.getParent())  {  if  (block.isFunction)  {  break;  }  else  if  (block.isLoop)  {  return  false;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isAssignedOnceInLifetime  [TYPE]  boolean  [PARAMETER]  [CLASS]  ReferenceCollection  [TYPE]  List  references  [TYPE]  Reference  ref  [TYPE]  boolean  false  true  [CONTEXT]  boolean  isAssignedOnceInLifetime  (  )  {  Reference  ref  =  getOneAndOnlyAssignment  (  )  ;  if  (  ref  =  =  null  )  {  return  false  ;  }  [BUGGY]  return  true  ;  }  	Closure_98_ReferenceCollectingCallback_4_1	361	0	src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
448	private  final  boolean  isFunction;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_98_ReferenceCollectingCallback_4_2	545	0	src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
449	private  final  boolean  isLoop;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_98_ReferenceCollectingCallback_4_3	549	0	src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
450	this.isFunction  =  root.getType()  ==  Token.FUNCTION;  if  (root.getParent()  !=  null)  {  int  pType  =  root.getParent().getType();  this.isLoop  =  pType  ==  Token.DO  ||  pType  ==  Token.WHILE  ||  pType  ==  Token.FOR;  }  else  {  this.isLoop  =  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_98_ReferenceCollectingCallback_4_4	561	0	src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
451	jsDoc.isInterface()  ||  	[BUGGY]  [FE]  AssertionFailedError:  There  should  be  one  error  expected:<1>  but  was:<0>  [METHOD]  shouldTraverse  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckGlobalThis  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  GLOBAL_THIS  [TYPE]  CheckLevel  level  [TYPE]  Node  assignLhsChild  lhs  n  parent  rhs  [TYPE]  JSDocInfo  jsDoc  [TYPE]  int  pType  [CONTEXT]  public  boolean  shouldTraverse  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  JSDocInfo  jsDoc  =  getFunctionJsDocInfo  (  n  )  ;  if  (  jsDoc  !  =  null  &&  (  jsDoc  .  isConstructor  (  )  ||  [BUGGY]  jsDoc  .  hasThisType  (  )  ||  jsDoc  .  isOverride  (  )  )  )  {  return  false  ;  }  	Closure_99_CheckGlobalThis_3_1	92	0	src/com/google/javascript/jscomp/CheckGlobalThis.java
452	if  (NodeUtil.isGet(lhs))  {  	[BUGGY]  [FE]  AssertionFailedError:  There  should  be  one  error  expected:<1>  but  was:<0>  [METHOD]  shouldTraverse  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckGlobalThis  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  GLOBAL_THIS  [TYPE]  CheckLevel  level  [TYPE]  Node  assignLhsChild  lhs  n  parent  rhs  [TYPE]  JSDocInfo  jsDoc  [TYPE]  int  pType  [CONTEXT]  int  pType  =  parent  .  getType  (  )  ;  if  (  !  (  pType  =  =  Token  .  BLOCK  ||  pType  =  =  Token  .  SCRIPT  ||  pType  =  =  Token  .  NAME  ||  pType  =  =  Token  .  ASSIGN  )  )  {  return  false  ;  }  }  if  (  parent  !  =  null  &&  parent  .  getType  (  )  =  =  Token  .  ASSIGN  )  {  Node  lhs  =  parent  .  getFirstChild  (  )  ;  Node  rhs  =  lhs  .  getNext  (  )  ;  if  (  n  =  =  lhs  )  {  if  (  assignLhsChild  =  =  null  )  {  assignLhsChild  =  lhs  ;  }  }  else  {  [BUGGY]  if  (  lhs  .  getType  (  )  =  =  Token  .  GETPROP  &&  lhs  .  getLastChild  (  )  .  getString  (  )  .  equals  ( "prototype "  )  )  {  return  false  ;  }  if  (  lhs  .  getQualifiedName  (  )  !  =  null  &&  lhs  .  getQualifiedName  (  )  .  contains  ( "  .  prototype  . "  )  )  {  return  false  ;  	Closure_99_CheckGlobalThis_3_2	125	0	src/com/google/javascript/jscomp/CheckGlobalThis.java
453	Node  llhs  =  lhs.getFirstChild();  if  (llhs.getType()  ==  Token.GETPROP  &&  llhs.getLastChild().getString().equals( "prototype "))  {  }  	[BUGGY]  if  (  lhs  .  getQualifiedName  (  )  !  =  null  &&  lhs  .  getQualifiedName  (  )  .  contains  ( "  .  prototype  . "  )  )  {  [FE]  AssertionFailedError:  There  should  be  one  error  expected:<1>  but  was:<0>  [METHOD]  shouldTraverse  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckGlobalThis  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  GLOBAL_THIS  [TYPE]  CheckLevel  level  [TYPE]  Node  assignLhsChild  lhs  n  parent  rhs  [TYPE]  JSDocInfo  jsDoc  [TYPE]  int  pType  [CONTEXT]  pType  =  =  Token  .  SCRIPT  ||  pType  =  =  Token  .  NAME  ||  pType  =  =  Token  .  ASSIGN  )  )  {  return  false  ;  }  }  if  (  parent  !  =  null  &&  parent  .  getType  (  )  =  =  Token  .  ASSIGN  )  {  Node  lhs  =  parent  .  getFirstChild  (  )  ;  Node  rhs  =  lhs  .  getNext  (  )  ;  if  (  n  =  =  lhs  )  {  if  (  assignLhsChild  =  =  null  )  {  assignLhsChild  =  lhs  ;  }  }  else  {  if  (  lhs  .  getType  (  )  =  =  Token  .  GETPROP  &&  lhs  .  getLastChild  (  )  .  getString  (  )  .  equals  ( "prototype "  )  )  {  return  false  ;  }  [BUGGY]  if  (  lhs  .  getQualifiedName  (  )  !  =  null  &&  lhs  .  getQualifiedName  (  )  .  contains  ( "  .  prototype  . "  )  )  {  return  false  ;  }  }  }  	Closure_99_CheckGlobalThis_3_3	129	1	src/com/google/javascript/jscomp/CheckGlobalThis.java
454	int  pType  =  parent.getType();  if  (!(pType  ==  Token.BLOCK  ||  pType  ==  Token.SCRIPT  ||  pType  ==  Token.NAME  ||  pType  ==  Token.ASSIGN))  {  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_USED_GLOBAL_THIS  dangerous  use  of  the  global  this  object  at  testcode  line  1  :  35  expected:<0>  but  was:<1>  [METHOD]  shouldTraverse  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckGlobalThis  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  GLOBAL_THIS  [TYPE]  CheckLevel  level  [TYPE]  Node  assignLhsChild  lhs  n  parent  rhs  [TYPE]  String  leftName  [TYPE]  JSDocInfo  jsDoc  [CONTEXT]  public  boolean  shouldTraverse  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  JSDocInfo  jsDoc  =  getFunctionJsDocInfo  (  n  )  ;  if  (  jsDoc  !  =  null  &&  (  jsDoc  .  isConstructor  (  )  ||  jsDoc  .  hasThisType  (  )  )  )  {  return  false  ;  }  [BUGGY]  }  if  (  parent  !  =  null  &&  parent  .  getType  (  )  =  =  Token  .  ASSIGN  )  {  Node  lhs  =  parent  .  getFirstChild  (  )  ;  Node  rhs  =  lhs  .  getNext  (  )  ;  	Closure_100_CheckGlobalThis_2_1	99	0	src/com/google/javascript/jscomp/CheckGlobalThis.java
455	return  parent  !=  null  &&  NodeUtil.isGet(parent);  	[BUGGY]  return  false  ;  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_USED_GLOBAL_THIS  dangerous  use  of  the  global  this  object  at  testcode  line  1  :  35  expected:<0>  but  was:<1>  [METHOD]  shouldReportThis  [TYPE]  boolean  [PARAMETER]  Node  n  Node  parent  [CLASS]  CheckGlobalThis  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  DiagnosticType  GLOBAL_THIS  [TYPE]  CheckLevel  level  [TYPE]  Node  assignLhsChild  n  parent  [CONTEXT]  private  boolean  shouldReportThis  (  Node  n  ,  Node  parent  )  {  if  (  assignLhsChild  !  =  null  )  {  return  true  ;  }  [BUGGY]  return  false  ;  }  	Closure_100_CheckGlobalThis_2_2	146	1	src/com/google/javascript/jscomp/CheckGlobalThis.java
456	options.closurePass  =  flags.process_closure_primitives;  	[BUGGY]  if  (  flags  .  process_closure_primitives  )  {  options  .  closurePass  =  true  ;  }  [FE]  AssertionFailedError:  [METHOD]  createOptions  [TYPE]  CompilerOptions  [PARAMETER]  [CLASS]  CommandLineRunner  [TYPE]  CompilationLevel  compilation_level  level  [TYPE]  boolean  compute_phase_ordering  create_name_map_files  debug  false  print_ast  print_pass_graph  print_tree  process_closure_primitives  third_party  true  use_only_custom_externs  [TYPE]  Set  FALSES  TRUES  [TYPE]  WarningLevel  wLevel  warning_level  [TYPE]  FormattingOption  PRETTY_PRINT  PRINT_INPUT_DELIMITER  formattingOption  [TYPE]  CompilerOptions  options  [TYPE]  List  define  externs  formatting  js  jscomp_error  jscomp_off  jscomp_warning  module  module_wrapper  [TYPE]  String  charset  create_source_map  js_output_file  logging_level  module_output_path_prefix  output_wrapper  output_wrapper_marker  property_map_input_file  property_map_output_file  variable_map_input_file  variable_map_output_file  [TYPE]  Flags  flags  [TYPE]  DevMode  jscomp_dev_mode  [TYPE]  int  summary_detail_level  [CONTEXT]  protected  CompilerOptions  createOptions  (  )  {  CompilerOptions  options  =  new  CompilerOptions  (  )  ;  options  .  setCodingConvention  (  new  ClosureCodingConvention  (  )  )  ;  CompilationLevel  level  =  flags  .  compilation_level  ;  level  .  setOptionsForCompilationLevel  (  options  )  ;  if  (  flags  .  debug  )  {  level  .  setDebugOptionsForCompilationLevel  (  options  )  ;  }  WarningLevel  wLevel  =  flags  .  warning_level  ;  wLevel  .  setOptionsForWarningLevel  (  options  )  ;  for  (  FormattingOption  formattingOption  :  flags  .  formatting  )  {  formattingOption  .  applyToOptions  (  options  )  ;  }  [BUGGY]  if  (  flags  .  process_closure_primitives  )  {  options  .  closurePass  =  true  ;  }  initOptionsFromFlags  (  options  )  ;  return  options  ;  }  	Closure_101_CommandLineRunner_1_1	433	3	src/com/google/javascript/jscomp/CommandLineRunner.java
457	removeDuplicateDeclarations(root);  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  process  [TYPE]  void  [PARAMETER]  Node  externs  Node  root  [CLASS]  Normalize  [TYPE]  AbstractCompiler  compiler  [TYPE]  MakeDeclaredNamesUnique  renamer  [TYPE]  boolean  CONVERT_WHILE_TO_FOR  MAKE_LOCAL_NAMES_UNIQUE  assertOnChange  checkUserDeclarations  false  true  [TYPE]  Map  constantMap  [TYPE]  NodeTraversal  t  [TYPE]  Node  externs  root  [CONTEXT]  public  void  process  (  Node  externs  ,  Node  root  )  {  NodeTraversal  .  traverse  (  compiler  ,  root  ,  this  )  ;  [BUGGY]  if  (  MAKE_LOCAL_NAMES_UNIQUE  )  {  MakeDeclaredNamesUnique  renamer  =  new  MakeDeclaredNamesUnique  (  )  ;  NodeTraversal  t  =  new  NodeTraversal  (  compiler  ,  renamer  )  ;  t  .  traverseRoots  (  externs  ,  root  )  ;  }  removeDuplicateDeclarations  (  root  )  ;  new  PropogateConstantAnnotations  (  compiler  ,  assertOnChange  )  .  process  (  externs  ,  root  )  ;  }  	Closure_102_Normalize_2_1	89	0	src/com/google/javascript/jscomp/Normalize.java
458		[BUGGY]  removeDuplicateDeclarations  (  root  )  ;  [FE]  AssertionFailedError:  [METHOD]  process  [TYPE]  void  [PARAMETER]  Node  externs  Node  root  [CLASS]  Normalize  [TYPE]  AbstractCompiler  compiler  [TYPE]  MakeDeclaredNamesUnique  renamer  [TYPE]  boolean  CONVERT_WHILE_TO_FOR  MAKE_LOCAL_NAMES_UNIQUE  assertOnChange  checkUserDeclarations  false  true  [TYPE]  Map  constantMap  [TYPE]  NodeTraversal  t  [TYPE]  Node  externs  root  [CONTEXT]  public  void  process  (  Node  externs  ,  Node  root  )  {  NodeTraversal  .  traverse  (  compiler  ,  root  ,  this  )  ;  if  (  MAKE_LOCAL_NAMES_UNIQUE  )  {  MakeDeclaredNamesUnique  renamer  =  new  MakeDeclaredNamesUnique  (  )  ;  NodeTraversal  t  =  new  NodeTraversal  (  compiler  ,  renamer  )  ;  t  .  traverseRoots  (  externs  ,  root  )  ;  }  [BUGGY]  removeDuplicateDeclarations  (  root  )  ;  new  PropogateConstantAnnotations  (  compiler  ,  assertOnChange  )  .  process  (  externs  ,  root  )  ;  }  	Closure_102_Normalize_2_2	94	1	src/com/google/javascript/jscomp/Normalize.java
459	case  Token.INSTANCEOF:  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_UNREACHABLE_CODE  unreachable  code  at  testcode  line  1  expected:<0>  but  was:<1>  private  void  assertUnreachable  (  String  js  )  {  [METHOD]  mayThrowException  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  ControlFlowAnalysis  [TYPE]  Multimap  finallyMap  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  shouldTraverseFunctions  true  [TYPE]  ControlFlowGraph  cfg  [TYPE]  Node  c  n  root  [TYPE]  Map  astPosition  nodePriorities  priorities  [TYPE]  Deque  exceptionHandler  [TYPE]  int  astPositionCounter  priorityCounter  [TYPE]  Comparator  priorityComparator  [CONTEXT]  private  static  boolean  mayThrowException  (  Node  n  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  CALL:  case  Token  .  GETPROP:  case  Token  .  GETELEM:  case  Token  .  THROW:  case  Token  .  NEW:  case  Token  .  ASSIGN:  case  Token  .  INC:  case  Token  .  DEC:  [BUGGY]  return  true  ;  case  Token  .  FUNCTION:  return  false  ;  }  for  (  Node  c  =  n  .  getFirstChild  (  )  ;  c  !  =  null  ;  c  =  c  .  getNext  (  )  )  {  if  (  !ControlFlowGraph  .  isEnteringNewCfgNode  (  c  )  &&  mayThrowException  (  c  )  )  {  return  true  ;  }  }  return  false  ;  }  	Closure_103_ControlFlowAnalysis_1_1	894	0	src/com/google/javascript/jscomp/ControlFlowAnalysis.java
460	if  (foundType  ==  null)  {  ObjectType  maybeType  =  ObjectType.cast(  registry.getGreatestSubtypeWithProperty(type,  field));  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_UNREACHABLE_CODE  unreachable  code  at  testcode  line  1  expected:<0>  but  was:<1>  private  void  assertUnreachable  (  String  js  )  {  [METHOD]  getTypeWithProperty  [TYPE]  ObjectType  [PARAMETER]  String  field  JSType  type  [CLASS]  JSTypeSystem  [TYPE]  ObjectType  foundType  objType  [TYPE]  JSTypeRegistry  registry  [TYPE]  Set  invalidatingTypes  [TYPE]  String  field  [TYPE]  JSType  type  [TYPE]  boolean  false  true  [CONTEXT]  if  (  type  .  autoboxesTo  (  )  !  =  null  )  {  type  =  type  .  autoboxesTo  (  )  ;  }  else  {  return  null  ;  }  }  if  ( "prototype "  .  equals  (  field  )  )  {  return  null  ;  }  ObjectType  foundType  =  null  ;  ObjectType  objType  =  ObjectType  .  cast  (  type  )  ;  while  (  objType  !  =  null  &&  objType  .  getImplicitPrototype  (  )  !  =  objType  )  {  if  (  objType  .  hasOwnProperty  (  field  )  )  {  foundType  =  objType  ;  }  objType  =  objType  .  getImplicitPrototype  (  )  ;  }  [BUGGY]  return  foundType  ;  }  	Closure_103_DisambiguateProperties_2_1	763	0	src/com/google/javascript/jscomp/DisambiguateProperties.java
461	if  (maybeType  !=  null  &&  maybeType.hasOwnProperty(field))  {  foundType  =  maybeType;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_UNREACHABLE_CODE  unreachable  code  at  testcode  line  1  expected:<0>  but  was:<1>  private  void  assertUnreachable  (  String  js  )  {  [METHOD]  getTypeWithProperty  [TYPE]  ObjectType  [PARAMETER]  String  field  JSType  type  [CLASS]  JSTypeSystem  [TYPE]  ObjectType  foundType  objType  [TYPE]  JSTypeRegistry  registry  [TYPE]  Set  invalidatingTypes  [TYPE]  String  field  [TYPE]  JSType  type  [TYPE]  boolean  false  true  [CONTEXT]  return  null  ;  }  }  if  ( "prototype "  .  equals  (  field  )  )  {  return  null  ;  }  ObjectType  foundType  =  null  ;  ObjectType  objType  =  ObjectType  .  cast  (  type  )  ;  while  (  objType  !  =  null  &&  objType  .  getImplicitPrototype  (  )  !  =  objType  )  {  if  (  objType  .  hasOwnProperty  (  field  )  )  {  foundType  =  objType  ;  }  objType  =  objType  .  getImplicitPrototype  (  )  ;  }  [BUGGY]  return  foundType  ;  }  @Override  public  JSType  getInstanceFromPrototype  (  JSType  type  )  {  if  (  type  .  isFunctionPrototypeType  (  )  )  {  FunctionPrototypeType  prototype  =  (  FunctionPrototypeType  )  type  ;  	Closure_103_DisambiguateProperties_2_2	766	0	src/com/google/javascript/jscomp/DisambiguateProperties.java
462	if  (!result.isNoType())  {  	[BUGGY]  if  (  result  !  =  null  )  {  [FE]  AssertionFailedError:  expected:<NoObject>  but  was:<None>  assertEquals  (  NO_OBJECT_TYPE  ,  [METHOD]  meet  [TYPE]  JSType  [PARAMETER]  JSType  that  [CLASS]  UnionType  [TYPE]  Set  alternates  [TYPE]  JSType  alternate  otherAlternate  result  that  [TYPE]  boolean  false  true  [TYPE]  UnionTypeBuilder  builder  [TYPE]  long  serialVersionUID  [CONTEXT]  JSType  meet  (  JSType  that  )  {  UnionTypeBuilder  builder  =  new  UnionTypeBuilder  (  registry  )  ;  for  (  JSType  alternate  :  alternates  )  {  if  (  alternate  .  isSubtype  (  that  )  )  {  builder  .  addAlternate  (  alternate  )  ;  }  }  if  (  that  instanceof  UnionType  )  {  for  (  JSType  otherAlternate  :  (  (  UnionType  )  that  )  .  alternates  )  {  if  (  otherAlternate  .  isSubtype  (  this  )  )  {  builder  .  addAlternate  (  otherAlternate  )  ;  }  }  }  else  if  (  that  .  isSubtype  (  this  )  )  {  builder  .  addAlternate  (  that  )  ;  }  JSType  result  =  builder  .  build  (  )  ;  [BUGGY]  if  (  result  !  =  null  )  {  return  result  ;  }  else  if  (  this  .  isObject  (  )  &&  that  .  isObject  (  )  )  {  return  getNativeType  (  JSTypeNative  .  NO_OBJECT_TYPE  )  ;  }  else  {  return  getNativeType  (  JSTypeNative  .  NO_TYPE  )  ;  }  }  	Closure_104_UnionType_1_1	291	1	src/com/google/javascript/rhino/jstype/UnionType.java
463	StringBuilder  sb  =  null;  	[BUGGY]  StringBuilder  sb  =  new  StringBuilder  (  )  ;  [FE]  AssertionFailedError:  [METHOD]  tryFoldStringJoin  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  left  Node  right  Node  parent  [CLASS]  FoldConstants  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List  arrayFoldedChildren  [TYPE]  String  joinString  [TYPE]  int  AND_PRECEDENCE  OR_PRECEDENCE  foldedSize  kJoinOverhead  originalSize  [CONTEXT]  void  tryFoldStringJoin  (  NodeTraversal  t  ,  Node  n  ,  Node  left  ,  Node  right  ,  Node  parent  )  {  if  (  !NodeUtil  .  isGetProp  (  left  )  ||  !NodeUtil  .  isImmutableValue  (  right  )  )  {  return  ;  }  Node  arrayNode  =  left  .  getFirstChild  (  )  ;  Node  functionName  =  arrayNode  .  getNext  (  )  ;  if  (  (  arrayNode  .  getType  (  )  !  =  Token  .  ARRAYLIT  )  ||  !functionName  .  getString  (  )  .  equals  ( "join "  )  )  {  return  ;  }  String  joinString  =  NodeUtil  .  getStringValue  (  right  )  ;  List<Node>  arrayFoldedChildren  =  Lists  .  newLinkedList  (  )  ;  [BUGGY]  StringBuilder  sb  =  new  StringBuilder  (  )  ;  int  foldedSize  =  0  ;  Node  elem  =  arrayNode  .  getFirstChild  (  )  ;  while  (  elem  !  =  null  )  {  if  (  NodeUtil  .  isImmutableValue  (  elem  )  )  {  	Closure_105_FoldConstants_5_1	1477	1	src/com/google/javascript/jscomp/FoldConstants.java
464	if  (sb  ==  null)  {  sb  =  new  StringBuilder();  }  else  {  	[BUGGY]  if  (  sb  .  length  (  )  >  0  )  {  [FE]  AssertionFailedError:  [METHOD]  tryFoldStringJoin  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  left  Node  right  Node  parent  [CLASS]  FoldConstants  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List  arrayFoldedChildren  [TYPE]  String  joinString  [TYPE]  int  AND_PRECEDENCE  OR_PRECEDENCE  foldedSize  kJoinOverhead  originalSize  [CONTEXT]  void  tryFoldStringJoin  (  NodeTraversal  t  ,  Node  n  ,  Node  left  ,  Node  right  ,  Node  parent  )  {  if  (  !NodeUtil  .  isGetProp  (  left  )  ||  !NodeUtil  .  isImmutableValue  (  right  )  )  {  return  ;  }  Node  arrayNode  =  left  .  getFirstChild  (  )  ;  Node  functionName  =  arrayNode  .  getNext  (  )  ;  if  (  (  arrayNode  .  getType  (  )  !  =  Token  .  ARRAYLIT  )  ||  !functionName  .  getString  (  )  .  equals  ( "join "  )  )  {  return  ;  }  String  joinString  =  NodeUtil  .  getStringValue  (  right  )  ;  List<Node>  arrayFoldedChildren  =  Lists  .  newLinkedList  (  )  ;  StringBuilder  sb  =  new  StringBuilder  (  )  ;  int  foldedSize  =  0  ;  Node  elem  =  arrayNode  .  getFirstChild  (  )  ;  while  (  elem  !  =  null  )  {  if  (  NodeUtil  .  isImmutableValue  (  elem  )  )  {  [BUGGY]  if  (  sb  .  length  (  )  >  0  )  {  sb  .  append  (  joinString  )  ;  }  sb  .  append  (  NodeUtil  .  getStringValue  (  elem  )  )  ;  }  else  {  if  (  sb  .  length  (  )  >  0  )  {  	Closure_105_FoldConstants_5_2	1483	1	src/com/google/javascript/jscomp/FoldConstants.java
465	if  (sb  !=  null)  {  	[BUGGY]  if  (  sb  .  length  (  )  >  0  )  {  [FE]  AssertionFailedError:  [METHOD]  tryFoldStringJoin  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  left  Node  right  Node  parent  [CLASS]  FoldConstants  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List  arrayFoldedChildren  [TYPE]  String  joinString  [TYPE]  int  AND_PRECEDENCE  OR_PRECEDENCE  foldedSize  kJoinOverhead  originalSize  [CONTEXT]  if  (  !NodeUtil  .  isGetProp  (  left  )  ||  !NodeUtil  .  isImmutableValue  (  right  )  )  {  return  ;  }  Node  arrayNode  =  left  .  getFirstChild  (  )  ;  Node  functionName  =  arrayNode  .  getNext  (  )  ;  if  (  (  arrayNode  .  getType  (  )  !  =  Token  .  ARRAYLIT  )  ||  !functionName  .  getString  (  )  .  equals  ( "join "  )  )  {  return  ;  }  String  joinString  =  NodeUtil  .  getStringValue  (  right  )  ;  List<Node>  arrayFoldedChildren  =  Lists  .  newLinkedList  (  )  ;  StringBuilder  sb  =  new  StringBuilder  (  )  ;  int  foldedSize  =  0  ;  Node  elem  =  arrayNode  .  getFirstChild  (  )  ;  while  (  elem  !  =  null  )  {  if  (  NodeUtil  .  isImmutableValue  (  elem  )  )  {  if  (  sb  .  length  (  )  >  0  )  {  sb  .  append  (  joinString  )  ;  }  sb  .  append  (  NodeUtil  .  getStringValue  (  elem  )  )  ;  }  else  {  [BUGGY]  if  (  sb  .  length  (  )  >  0  )  {  foldedSize  +  =  sb  .  length  (  )  +  2  ;  arrayFoldedChildren  .  add  (  Node  .  newString  (  sb  .  toString  (  )  )  )  ;  sb  =  new  StringBuilder  (  )  ;  }  	Closure_105_FoldConstants_5_3	1488	1	src/com/google/javascript/jscomp/FoldConstants.java
466	sb  =  null;  	[BUGGY]  sb  =  new  StringBuilder  (  )  ;  [FE]  AssertionFailedError:  [METHOD]  tryFoldStringJoin  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  left  Node  right  Node  parent  [CLASS]  FoldConstants  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List  arrayFoldedChildren  [TYPE]  String  joinString  [TYPE]  int  AND_PRECEDENCE  OR_PRECEDENCE  foldedSize  kJoinOverhead  originalSize  [CONTEXT]  Node  arrayNode  =  left  .  getFirstChild  (  )  ;  Node  functionName  =  arrayNode  .  getNext  (  )  ;  if  (  (  arrayNode  .  getType  (  )  !  =  Token  .  ARRAYLIT  )  ||  !functionName  .  getString  (  )  .  equals  ( "join "  )  )  {  return  ;  }  String  joinString  =  NodeUtil  .  getStringValue  (  right  )  ;  List<Node>  arrayFoldedChildren  =  Lists  .  newLinkedList  (  )  ;  StringBuilder  sb  =  new  StringBuilder  (  )  ;  int  foldedSize  =  0  ;  Node  elem  =  arrayNode  .  getFirstChild  (  )  ;  while  (  elem  !  =  null  )  {  if  (  NodeUtil  .  isImmutableValue  (  elem  )  )  {  if  (  sb  .  length  (  )  >  0  )  {  sb  .  append  (  joinString  )  ;  }  sb  .  append  (  NodeUtil  .  getStringValue  (  elem  )  )  ;  }  else  {  if  (  sb  .  length  (  )  >  0  )  {  foldedSize  +  =  sb  .  length  (  )  +  2  ;  arrayFoldedChildren  .  add  (  Node  .  newString  (  sb  .  toString  (  )  )  )  ;  [BUGGY]  sb  =  new  StringBuilder  (  )  ;  }  foldedSize  +  =  InlineCostEstimator  .  getCost  (  elem  )  ;  arrayFoldedChildren  .  add  (  elem  )  ;  }  elem  =  elem  .  getNext  (  )  ;  	Closure_105_FoldConstants_5_4	1492	1	src/com/google/javascript/jscomp/FoldConstants.java
467	if  (sb  !=  null)  {  	[BUGGY]  if  (  sb  .  length  (  )  >  0  )  {  [FE]  AssertionFailedError:  [METHOD]  tryFoldStringJoin  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  left  Node  right  Node  parent  [CLASS]  FoldConstants  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  INVALID_REGULAR_EXPRESSION_FLAGS  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  Node  arrayNode  elem  emptyStringNode  foldedStringNode  functionName  left  n  node  parent  replacement  right  [TYPE]  List  arrayFoldedChildren  [TYPE]  String  joinString  [TYPE]  int  AND_PRECEDENCE  OR_PRECEDENCE  foldedSize  kJoinOverhead  originalSize  [CONTEXT]  String  joinString  =  NodeUtil  .  getStringValue  (  right  )  ;  List<Node>  arrayFoldedChildren  =  Lists  .  newLinkedList  (  )  ;  StringBuilder  sb  =  new  StringBuilder  (  )  ;  int  foldedSize  =  0  ;  Node  elem  =  arrayNode  .  getFirstChild  (  )  ;  while  (  elem  !  =  null  )  {  if  (  NodeUtil  .  isImmutableValue  (  elem  )  )  {  if  (  sb  .  length  (  )  >  0  )  {  sb  .  append  (  joinString  )  ;  }  sb  .  append  (  NodeUtil  .  getStringValue  (  elem  )  )  ;  }  else  {  if  (  sb  .  length  (  )  >  0  )  {  foldedSize  +  =  sb  .  length  (  )  +  2  ;  arrayFoldedChildren  .  add  (  Node  .  newString  (  sb  .  toString  (  )  )  )  ;  sb  =  new  StringBuilder  (  )  ;  }  foldedSize  +  =  InlineCostEstimator  .  getCost  (  elem  )  ;  arrayFoldedChildren  .  add  (  elem  )  ;  }  elem  =  elem  .  getNext  (  )  ;  }  [BUGGY]  if  (  sb  .  length  (  )  >  0  )  {  foldedSize  +  =  sb  .  length  (  )  +  2  ;  arrayFoldedChildren  .  add  (  Node  .  newString  (  sb  .  toString  (  )  )  )  ;  }  	Closure_105_FoldConstants_5_5	1500	1	src/com/google/javascript/jscomp/FoldConstants.java
468	if  (declaration.getTwin()  !=  null)  {  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_USELESS_CODE  Suspicious  code  This  code  lacks  side-effects  Is  there  a  bug?  at  testcode  line  1  expected:<0>  but  was:<1>  [METHOD]  canCollapseUnannotatedChildNames  [TYPE]  boolean  [PARAMETER]  [CLASS]  Name  [TYPE]  Type  FUNCTION  OBJECTLIT  OTHER  type  [TYPE]  Ref  declaration  [TYPE]  boolean  false  hasClassOrEnumDescendant  inExterns  isClassOrEnum  true  [TYPE]  List  props  refs  [TYPE]  String  name  [TYPE]  JSDocInfo  docInfo  [TYPE]  int  aliasingGets  callGets  globalSets  localSets  totalGets  [TYPE]  Name  parent  [CONTEXT]  boolean  canCollapseUnannotatedChildNames  (  )  {  if  (  type  =  =  Type  .  OTHER  ||  globalSets  !  =  1  ||  localSets  !  =  0  )  {  return  false  ;  }  [BUGGY]  if  (  isClassOrEnum  )  {  return  true  ;  }  return  (  type  =  =  Type  .  FUNCTION  ||  aliasingGets  =  =  0  )  &&  (  parent  =  =  null  ||  parent  .  canCollapseUnannotatedChildNames  (  )  )  ;  }  	Closure_106_GlobalNamespace_1_1	907	0	src/com/google/javascript/jscomp/GlobalNamespace.java
469		[BUGGY]  if  (  parseDocumentation  )  {  }  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_USELESS_CODE  Suspicious  code  This  code  lacks  side-effects  Is  there  a  bug?  at  testcode  line  1  expected:<0>  but  was:<1>  [METHOD]  recordBlockDescription  [TYPE]  boolean  [PARAMETER]  String  description  [CLASS]  JSDocInfoBuilder  [TYPE]  boolean  false  parseDocumentation  populated  true  [TYPE]  Marker  currentMarker  [TYPE]  String  description  [TYPE]  JSDocInfo  currentInfo  [CONTEXT]  public  boolean  recordBlockDescription  (  String  description  )  {  [BUGGY]  if  (  parseDocumentation  )  {  populated  =  true  ;  }  return  currentInfo  .  documentBlock  (  description  )  ;  }  	Closure_106_JSDocInfoBuilder_1_1	189	2	src/com/google/javascript/rhino/JSDocInfoBuilder.java
470	options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS,  CheckLevel.OFF);  	[BUGGY]  [FE]  AssertionFailedError:  Expected  no  warnings  or  errors  [METHOD]  createOptions  [TYPE]  CompilerOptions  [PARAMETER]  [CLASS]  CommandLineRunner  [TYPE]  CompilationLevel  compilationLevel  level  [TYPE]  TracerMode  tracerMode  [TYPE]  Set  FALSES  TRUES  [TYPE]  WarningLevel  wLevel  warningLevel  [TYPE]  CheckLevel  level  [TYPE]  String  charset  commonJsEntryModule  commonJsPathPrefix  createSourceMap  flagFile  jsOutputFile  languageIn  loggingLevel  moduleOutputPathPrefix  name  outputManifest  outputModuleDependencies  outputWrapper  propertyMapInputFile  propertyMapOutputFile  translationsFile  translationsProject  variableMapInputFile  variableMapOutputFile  warningsWhitelistFile  [TYPE]  Flags  flags  [TYPE]  IOException  e  [TYPE]  int  summaryDetailLevel  [TYPE]  boolean  acceptConstKeyword  angularPass  createNameMapFiles  debug  displayHelp  false  generateExports  isConfigValid  manageClosureDependencies  onlyClosureDependencies  printAst  printPassGraph  printTree  processClosurePrimitives  processCommonJsModules  processJqueryPrimitives  thirdParty  transformAmdModules  true  useOnlyCustomExterns  useTypesForOptimization  version  [TYPE]  Format  sourceMapFormat  [TYPE]  FormattingOption  PRETTY_PRINT  PRINT_INPUT_DELIMITER  SINGLE_QUOTES  formattingOption  [TYPE]  Setter  proxy  [TYPE]  CompilerOptions  options  [TYPE]  List  DEFAULT_EXTERNS_NAMES  arguments  closureEntryPoint  define  externs  extraAnnotationName  formatting  guardLevels  js  jscompError  jscompOff  jscompWarning  module  moduleWrapper  [TYPE]  DevMode  jscompDevMode  [CONTEXT]  options  .  closurePass  =  flags  .  processClosurePrimitives  ;  options  .  jqueryPass  =  CompilationLevel  .  ADVANCED_OPTIMIZATIONS  =  =  level  &&  flags  .  processJqueryPrimitives  ;  options  .  angularPass  =  flags  .  angularPass  ;  if  (  !flags  .  translationsFile  .  isEmpty  (  )  )  {  try  {  options  .  messageBundle  =  new  XtbMessageBundle  (  new  FileInputStream  (  flags  .  translationsFile  )  ,  flags  .  translationsProject  )  ;  }  catch  (  IOException  e  )  {  throw  new  RuntimeException  ( "Reading  XTB  file "  ,  e  )  ;  }  }  else  if  (  CompilationLevel  .  ADVANCED_OPTIMIZATIONS  =  =  level  )  {  options  .  messageBundle  =  new  EmptyMessageBundle  (  )  ;  [BUGGY]  }  return  options  ;  }  @Override  	Closure_107_CommandLineRunner_1_1	862	0	src/com/google/javascript/jscomp/CommandLineRunner.java
471	private  final  Set<Node>  injectedDecls  =  Sets.newHashSet();  	[BUGGY]  [FE]  IllegalStateException  [CLASS]  [CONTEXT]  	Closure_108_ScopedAliases_4_1	259	0	src/com/google/javascript/jscomp/ScopedAliases.java
472	injectedDecls.clear();  	[BUGGY]  [FE]  IllegalStateException  [METHOD]  exitScope  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  true  [TYPE]  Map  aliases  [TYPE]  NodeTraversal  t  [CONTEXT]  public  void  exitScope  (  NodeTraversal  t  )  {  if  (  t  .  getScopeDepth  (  )  >  2  )  {  findNamespaceShadows  (  t  )  ;  }  if  (  t  .  getScopeDepth  (  )  =  =  2  )  {  renameNamespaceShadows  (  t  )  ;  [BUGGY]  aliases  .  clear  (  )  ;  forbiddenLocals  .  clear  (  )  ;  transformation  =  null  ;  hasNamespaceShadows  =  false  ;  }  }  	Closure_108_ScopedAliases_4_2	316	0	src/com/google/javascript/jscomp/ScopedAliases.java
473	injectedDecls.add(newDecl.getFirstChild());  	[BUGGY]  [FE]  IllegalStateException  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isFunctionDecl  isHoisted  isVar  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  existingName  grandparent  n  newDecl  newName  parent  value  varNode  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  if  (  value  !  =  null  )  {  value  .  detachFromParent  (  )  ;  }  varNode  =  parent  ;  }  if  (  value  !  =  null  ||  v  .  getJSDocInfo  (  )  !  =  null  )  {  Node  newDecl  =  NodeUtil  .  newQualifiedNameNodeDeclaration  (  compiler  .  getCodingConvention  (  )  ,  globalName  ,  value  ,  v  .  getJSDocInfo  (  )  )  .  useSourceInfoIfMissingFromForTree  (  n  )  ;  NodeUtil  .  setDebugInformation  (  newDecl  .  getFirstChild  (  )  .  getFirstChild  (  )  ,  n  ,  name  )  ;  if  (  isHoisted  )  {  grandparent  .  addChildToFront  (  newDecl  )  ;  }  else  {  grandparent  .  addChildBefore  (  newDecl  ,  varNode  )  ;  }  [BUGGY]  }  v  .  getNameNode  (  )  .  addChildToFront  (  NodeUtil  .  newQualifiedNameNode  (  compiler  .  getCodingConvention  (  )  ,  globalName  ,  n  ,  name  )  )  ;  	Closure_108_ScopedAliases_4_3	432	0	src/com/google/javascript/jscomp/ScopedAliases.java
474	if  (info  !=  null  &&  !injectedDecls.contains(n))  {  	[BUGGY]  if  (  info  !  =  null  )  {  [FE]  IllegalStateException  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  lexicalVar  [TYPE]  Node  n  node  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  [TYPE]  JSDocInfo  info  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  if  (  type  =  =  Token  .  RETURN  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_USES_RETURN  )  ;  }  else  if  (  type  =  =  Token  .  THIS  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_REFERENCES_THIS  )  ;  }  else  if  (  type  =  =  Token  .  THROW  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_USES_THROW  )  ;  }  }  if  (  t  .  getScopeDepth  (  )  >  =  2  )  {  if  (  aliasVar  !  =  null  )  {  aliasUsages  .  add  (  new  AliasedNode  (  aliasVar  ,  n  )  )  ;  }  JSDocInfo  info  =  n  .  getJSDocInfo  (  )  ;  [BUGGY]  if  (  info  !  =  null  )  {  for  (  Node  node  :  info  .  getTypeNodes  (  )  )  {  fixTypeNode  (  node  )  ;  }  }  	Closure_108_ScopedAliases_4_4	581	1	src/com/google/javascript/jscomp/ScopedAliases.java
475	if  (token  ==  JsDocToken.QMARK)  {  return  newNode(Token.QMARK);  }  else  {  return  parseBasicTypeExpression(token);  }  	[BUGGY]  return  parseTypeName  (  token  )  ;  [FE]  AssertionFailedError:  extra  warning:  Bad  type  annotation  type  not  recognized  due  to  syntax  error  assertFalse  (  type  .  isNominalConstructor  (  )  )  ;  [METHOD]  parseContextTypeExpression  [TYPE]  Node  [PARAMETER]  JsDocToken  token  [CLASS]  JsDocInfoParser  [TYPE]  Set  idGeneratorAnnotationKeywords  modifiesAnnotationKeywords  suppressionNames  [TYPE]  Node  associatedNode  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  lineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  StaticSourceFile  sourceFile  [TYPE]  Map  annotationNames  [CONTEXT]  private  Node  parseContextTypeExpression  (  JsDocToken  token  )  {  [BUGGY]  return  parseTypeName  (  token  )  ;  }  	Closure_109_JsDocInfoParser_1_1	1908	1	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
476	boolean  isFunctionDecl  =  NodeUtil.isFunctionDeclaration(parent);  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  f  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  39  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVar  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  grandparent  n  newDecl  parent  value  varNode  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  private  void  findAliases  (  NodeTraversal  t  )  {  Scope  scope  =  t  .  getScope  (  )  ;  for  (  Var  v  :  scope  .  getVarIterable  (  )  )  {  Node  n  =  v  .  getNode  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  boolean  isVar  =  parent  .  isVar  (  )  ;  [BUGGY]  if  (  isVar  &&  n  .  getFirstChild  (  )  !  =  null  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  recordAlias  (  v  )  ;  }  else  if  (  v  .  isBleedingFunction  (  )  )  {  }  else  if  (  parent  .  getType  (  )  =  =  Token  .  LP  )  {  	Closure_110_ScopedAliases_5_1	358	0	src/com/google/javascript/jscomp/ScopedAliases.java
477	}  else  if  (isVar  ||  isFunctionDecl)  {  boolean  isHoisted  =  NodeUtil.isHoistedFunctionDeclaration(parent);  Node  value  =  v.getInitialValue()  !=  null  ?  v.getInitialValue()  :  Node  varNode  =  null;  	[BUGGY]  }  else  if  (  isVar  )  {  Node  value  =  n  .  hasChildren  (  )  ?  v  .  getInitialValue  (  )  .  detachFromParent  (  )  :  Node  varNode  =  parent  ;  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  f  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  39  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVar  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  grandparent  n  newDecl  parent  value  varNode  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  private  void  findAliases  (  NodeTraversal  t  )  {  Scope  scope  =  t  .  getScope  (  )  ;  for  (  Var  v  :  scope  .  getVarIterable  (  )  )  {  Node  n  =  v  .  getNode  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  boolean  isVar  =  parent  .  isVar  (  )  ;  if  (  isVar  &&  n  .  getFirstChild  (  )  !  =  null  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  recordAlias  (  v  )  ;  }  else  if  (  v  .  isBleedingFunction  (  )  )  {  }  else  if  (  parent  .  getType  (  )  =  =  Token  .  LP  )  {  [BUGGY]  }  else  if  (  isVar  )  {  Node  grandparent  =  parent  .  getParent  (  )  ;  Node  value  =  n  .  hasChildren  (  )  ?  v  .  getInitialValue  (  )  .  detachFromParent  (  )  :  null  ;  Node  varNode  =  parent  ;  	Closure_110_ScopedAliases_5_2	366	4	src/com/google/javascript/jscomp/ScopedAliases.java
478	if  (isFunctionDecl)  {  Node  existingName  =  v.getNameNode();  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  f  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  39  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVar  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  grandparent  n  newDecl  parent  value  varNode  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  if  (  isVar  &&  n  .  getFirstChild  (  )  !  =  null  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  recordAlias  (  v  )  ;  }  else  if  (  v  .  isBleedingFunction  (  )  )  {  }  else  if  (  parent  .  getType  (  )  =  =  Token  .  LP  )  {  }  else  if  (  isVar  )  {  Node  grandparent  =  parent  .  getParent  (  )  ;  Node  value  =  n  .  hasChildren  (  )  ?  v  .  getInitialValue  (  )  .  detachFromParent  (  )  :  null  ;  Node  varNode  =  parent  ;  String  name  =  n  .  getString  (  )  ;  int  nameCount  =  scopedAliasNames  .  count  (  name  )  ;  scopedAliasNames  .  add  (  name  )  ;  String  globalName  = "$jscomp  .  scope  . "  +  name  +  (  nameCount  =  =  0  ? " "  :  ( "$ "  +  nameCount  )  )  ;  compiler  .  ensureLibraryInjected  ( "base "  )  ;  [BUGGY]  	Closure_110_ScopedAliases_5_3	383	0	src/com/google/javascript/jscomp/ScopedAliases.java
479	Node  newName  =  IR.name( " ").useSourceInfoFrom(existingName);  value.replaceChild(existingName,  newName);  varNode  =  IR.var(existingName).useSourceInfoFrom(existingName);  grandparent.replaceChild(parent,  varNode);  }  else  {  if  (value  !=  null)  {  value.detachFromParent();  }  varNode  =  parent;  }  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  f  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  39  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVar  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  grandparent  n  newDecl  parent  value  varNode  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  Node  grandparent  =  parent  .  getParent  (  )  ;  Node  value  =  n  .  hasChildren  (  )  ?  v  .  getInitialValue  (  )  .  detachFromParent  (  )  :  null  ;  Node  varNode  =  parent  ;  String  name  =  n  .  getString  (  )  ;  int  nameCount  =  scopedAliasNames  .  count  (  name  )  ;  scopedAliasNames  .  add  (  name  )  ;  String  globalName  = "$jscomp  .  scope  . "  +  name  +  (  nameCount  =  =  0  ? " "  :  ( "$ "  +  nameCount  )  )  ;  compiler  .  ensureLibraryInjected  ( "base "  )  ;  [BUGGY]  	Closure_110_ScopedAliases_5_4	392	0	src/com/google/javascript/jscomp/ScopedAliases.java
480	if  (isHoisted)  {  grandparent.addChildToFront(newDecl);  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  f  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  39  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVar  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  grandparent  n  newDecl  parent  value  varNode  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  if  (  value  !  =  null  ||  v  .  getJSDocInfo  (  )  !  =  null  )  {  Node  newDecl  =  NodeUtil  .  newQualifiedNameNodeDeclaration  (  compiler  .  getCodingConvention  (  )  ,  globalName  ,  value  ,  v  .  getJSDocInfo  (  )  )  .  useSourceInfoIfMissingFromForTree  (  n  )  ;  NodeUtil  .  setDebugInformation  (  newDecl  .  getFirstChild  (  )  .  getFirstChild  (  )  ,  n  ,  name  )  ;  [BUGGY]  grandparent  .  addChildBefore  (  newDecl  ,  varNode  )  ;  }  v  .  getNameNode  (  )  .  addChildToFront  (  NodeUtil  .  newQualifiedNameNode  (  	Closure_110_ScopedAliases_5_5	408	0	src/com/google/javascript/jscomp/ScopedAliases.java
481	if  (n  ==  null)  {  throw  new  RuntimeException( "node  is  not  a  child ");  }  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  f  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  39  expected:<0>  but  was:<1>  [METHOD]  getChildBefore  [TYPE]  Node  [PARAMETER]  Node  child  [CLASS]  Node  [TYPE]  JSType  jsType  [TYPE]  boolean  false  true  used  [TYPE]  double  number  [TYPE]  Node  child  cur  current  first  last  n  next  nodeA  nodeB  parent  start  [TYPE]  PropListItem  next  propListHead  [TYPE]  Object  objectValue  [TYPE]  String  str  [TYPE]  long  serialVersionUID  [TYPE]  int  CHANGE_TIME  COLUMN_BITS  COLUMN_MASK  DECR_FLAG  DIRECTIVES  DIRECT_EVAL  EMPTY_BLOCK  FLAG_ARGUMENTS_UNMODIFIED  FLAG_GLOBAL_STATE_UNMODIFIED  FLAG_LOCAL_RESULTS  FLAG_NO_THROWS  FLAG_THIS_UNMODIFIED  FREE_CALL  INCRDECR_PROP  INFERRED_FUNCTION  INPUT_ID  IS_CONSTANT_NAME  IS_DISPATCHER  IS_NAMESPACE  JSDOC_INFO_PROP  LAST_PROP  LENGTH  MAX_COLUMN_NUMBER  NO_SIDE_EFFECTS  OPT_ARG_NAME  ORIGINALNAME_PROP  POST_FLAG  QUOTED_PROP  REFLECTED_OBJECT  SIDE_EFFECTS_ALL  SIDE_EFFECTS_FLAGS_MASK  SIDE_EFFECT_FLAGS  SLASH_V  STATIC_SOURCE_FILE  SYNTHETIC_BLOCK_PROP  VAR_ARGS_NAME  intValue  propType  sourcePosition  type  value  [CONTEXT]  public  Node  getChildBefore  (  Node  child  )  {  if  (  child  =  =  first  )  {  return  null  ;  }  Node  n  =  first  ;  [BUGGY]  while  (  n  .  next  !  =  child  )  {  n  =  n  .  next  ;  if  (  n  =  =  null  )  {  throw  new  RuntimeException  ( "node  is  not  a  child "  )  ;  }  }  return  n  ;  }  	Closure_110_Node_1_1	554	0	src/com/google/javascript/rhino/Node.java
482	return  topType.isAllType()  ?  getNativeType(ARRAY_TYPE)  :  topType;  	[BUGGY]  return  topType  ;  [FE]  AssertionFailedError:  Expected:  Array  [METHOD]  caseTopType  [TYPE]  JSType  [PARAMETER]  JSType  topType  [CLASS]  1  [TYPE]  JSType  topType  [TYPE]  boolean  false  true  [CONTEXT]  protected  JSType  caseTopType  (  JSType  topType  )  {  [BUGGY]  return  topType  ;  }  	Closure_111_ClosureReverseAbstractInterpreter_1_1	54	1	src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java
483	Map<TemplateType,  JSType>  inferred  =  Maps.filterKeys(  inferTemplateTypesFromParameters(fnType,  n),  new  Predicate<TemplateType>()  {  @Override  public  boolean  apply(TemplateType  key)  {  return  keys.contains(key);  }}  );  	[BUGGY]  Map<TemplateType  ,  JSType>  inferred  =  inferTemplateTypesFromParameters  (  fnType  ,  n  )  ;  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  inferTemplatedTypesForCall  [TYPE]  boolean  [PARAMETER]  Node  n  FunctionType  fnType  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  TemplateTypeReplacer  replacer  [TYPE]  ImmutableList  keys  [TYPE]  Node  callTarget  n  [TYPE]  FunctionType  fnType  replacementFnType  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  ObjectType  unknownType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  madeChanges  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  [TYPE]  Map  assertionFunctionsMap  inferred  replacements  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  [CONTEXT]  private  boolean  inferTemplatedTypesForCall  (  Node  n  ,  FunctionType  fnType  )  {  final  ImmutableList<TemplateType>  keys  =  fnType  .  getTemplateTypeMap  (  )  .  getTemplateKeys  (  )  ;  if  (  keys  .  isEmpty  (  )  )  {  return  false  ;  }  [BUGGY]  Map<TemplateType  ,  JSType>  inferred  =  inferTemplateTypesFromParameters  (  fnType  ,  n  )  ;  TemplateTypeReplacer  replacer  =  new  TemplateTypeReplacer  (  registry  ,  inferred  )  ;  Node  callTarget  =  n  .  getFirstChild  (  )  ;  FunctionType  replacementFnType  =  fnType  .  visit  (  replacer  )  .  toMaybeFunctionType  (  )  ;  Preconditions  .  checkNotNull  (  replacementFnType  )  ;  callTarget  .  setJSType  (  replacementFnType  )  ;  n  .  setJSType  (  replacementFnType  .  getReturnType  (  )  )  ;  return  replacer  .  madeChanges  ;  }  	Closure_112_TypeInference_1_1	1192	3	src/com/google/javascript/jscomp/TypeInference.java
484	if  (provided  !=  null  ||  requiresLevel.isOn())  {  	[BUGGY]  if  (  provided  !  =  null  )  {  [FE]  AssertionFailedError:  There  should  be  one  error  required "namespaceClass1 "  namespace  never  provided  [METHOD]  processRequireCall  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ProcessClosurePrimitives  [TYPE]  Set  exportedVariables  [TYPE]  NodeTraversal  t  [TYPE]  CheckLevel  requiresLevel  [TYPE]  ProvidedName  provided  [TYPE]  Node  arg  candidateDefinition  explicitNode  firstNode  left  n  parent  replacementNode  requireNode  [TYPE]  PreprocessorSymbolTable  preprocessorSymbolTable  [TYPE]  String  GOOG  inputName  namespace  ns  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  DiagnosticType  BASE_CLASS_ERROR  DUPLICATE_NAMESPACE_ERROR  EXPECTED_OBJECTLIT_ERROR  EXPECTED_STRING_ERROR  FUNCTION_NAMESPACE_ERROR  INVALID_ARGUMENT_ERROR  INVALID_CSS_RENAMING_MAP  INVALID_DEFINE_NAME_ERROR  INVALID_PROVIDE_ERROR  INVALID_STYLE_ERROR  LATE_PROVIDE_ERROR  MISSING_DEFINE_ANNOTATION  MISSING_PROVIDE_ERROR  NON_STRING_PASSED_TO_SET_CSS_NAME_MAPPING_ERROR  NULL_ARGUMENT_ERROR  TOO_MANY_ARGUMENTS_ERROR  XMODULE_REQUIRE_ERROR  [TYPE]  JSModule  explicitModule  firstModule  minimumModule  module  providedModule  [TYPE]  List  defineCalls  unrecognizedRequires  [TYPE]  Map  providedNames  [CONTEXT]  }  else  {  JSModule  providedModule  =  provided  .  explicitModule  ;  Preconditions  .  checkNotNull  (  providedModule  )  ;  JSModule  module  =  t  .  getModule  (  )  ;  if  (  moduleGraph  !  =  null  &&  module  !  =  providedModule  &&  !moduleGraph  .  dependsOn  (  module  ,  providedModule  )  )  {  compiler  .  report  (  t  .  makeError  (  n  ,  XMODULE_REQUIRE_ERROR  ,  ns  ,  providedModule  .  getName  (  )  ,  module  .  getName  (  )  )  )  ;  }  }  maybeAddToSymbolTable  (  left  )  ;  maybeAddStringNodeToSymbolTable  (  arg  )  ;  [BUGGY]  if  (  provided  !  =  null  )  {  parent  .  detachFromParent  (  )  ;  compiler  .  reportCodeChange  (  )  ;  }  }  }  	Closure_113_ProcessClosurePrimitives_1_1	329	1	src/com/google/javascript/jscomp/ProcessClosurePrimitives.java
485	}  else  if  (!(parent.isCall()  &&  parent.getFirstChild()  ==  n))  {\n', "    	[BUGGY]  }  else  {  [FE]  AssertionFailedError:  [METHOD]  recordAssignment  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  recordNode  [CLASS]  FindDependencyScopes  [TYPE]  NameInformation  ns  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  nameNode  parent  recordNode  [CONTEXT]  private  void  recordAssignment  (  NodeTraversal  t  ,  Node  n  ,  Node  recordNode  )  {  Node  nameNode  =  n  .  getFirstChild  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  NameInformation  ns  =  createNameInformation  (  t  ,  nameNode  )  ;  if  (  ns  !  =  null  )  {  if  (  parent  .  isFor  (  )  &&  !NodeUtil  .  isForIn  (  parent  )  )  {  if  (  parent  .  getFirstChild  (  )  .  getNext  (  )  !  =  n  )  {  recordDepScope  (  recordNode  ,  ns  )  ;  }  else  {  recordDepScope  (  nameNode  ,  ns  )  ;  }  [BUGGY]  }  else  {  	Closure_114_NameAnalyzer_1_1	578	1	src/com/google/javascript/jscomp/NameAnalyzer.java
486		[BUGGY]  boolean  hasSideEffects  =  false  ;  if  (  block  .  hasChildren  (  )  )  {  Preconditions  .  checkState  (  block  .  hasOneChild  (  )  )  ;  Node  stmt  =  block  .  getFirstChild  (  )  ;  if  (  stmt  .  isReturn  (  )  )  {  hasSideEffects  =  NodeUtil  .  mayHaveSideEffects  (  stmt  .  getFirstChild  (  )  ,  compiler  )  ;  }  }  [FE]  AssertionFailedError:  [METHOD]  canInlineReferenceDirectly  [TYPE]  FunctionInjector$CanInlineResult  [PARAMETER]  Node  callNode  Node  fnNode  [CLASS]  FunctionInjector  [TYPE]  CanInlineResult  AFTER_PREPARATION  NO  YES  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  allowDecomposition  assumeMinimumCapture  assumeStrictThis  false  hasSideEffects  true  [TYPE]  Set  knownConstants  [TYPE]  InliningMode  BLOCK  DIRECT  mode  [TYPE]  CallSiteType  DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node  block  cArg  callNode  fnNode  fnParam  stmt  [TYPE]  JSModule  module  [TYPE]  Supplier  safeNameIdSupplier  [TYPE]  int  COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [CONTEXT]  private  CanInlineResult  canInlineReferenceDirectly  (  Node  callNode  ,  Node  fnNode  )  {  if  (  !isDirectCallNodeReplacementPossible  (  fnNode  )  )  {  return  CanInlineResult  .  NO  ;  }  Node  block  =  fnNode  .  getLastChild  (  )  ;  [BUGGY]  boolean  hasSideEffects  =  false  ;  if  (  block  .  hasChildren  (  )  )  {  Preconditions  .  checkState  (  block  .  hasOneChild  (  )  )  ;  Node  stmt  =  block  .  getFirstChild  (  )  ;  if  (  stmt  .  isReturn  (  )  )  {  hasSideEffects  =  NodeUtil  .  mayHaveSideEffects  (  stmt  .  getFirstChild  (  )  ,  compiler  )  ;  	Closure_115_FunctionInjector_2_1	697	8	src/com/google/javascript/jscomp/FunctionInjector.java
487		[BUGGY]  if  (  hasSideEffects  &&  NodeUtil  .  canBeSideEffected  (  cArg  )  )  {  return  CanInlineResult  .  NO  ;  }  [FE]  AssertionFailedError:  [METHOD]  canInlineReferenceDirectly  [TYPE]  FunctionInjector$CanInlineResult  [PARAMETER]  Node  callNode  Node  fnNode  [CLASS]  FunctionInjector  [TYPE]  CanInlineResult  AFTER_PREPARATION  NO  YES  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  allowDecomposition  assumeMinimumCapture  assumeStrictThis  false  hasSideEffects  true  [TYPE]  Set  knownConstants  [TYPE]  InliningMode  BLOCK  DIRECT  mode  [TYPE]  CallSiteType  DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node  block  cArg  callNode  fnNode  fnParam  stmt  [TYPE]  JSModule  module  [TYPE]  Supplier  safeNameIdSupplier  [TYPE]  int  COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [CONTEXT]  Node  cArg  =  callNode  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  !callNode  .  getFirstChild  (  )  .  isName  (  )  )  {  if  (  NodeUtil  .  isFunctionObjectCall  (  callNode  )  )  {  if  (  cArg  =  =  null  ||  !cArg  .  isThis  (  )  )  {  return  CanInlineResult  .  NO  ;  }  cArg  =  cArg  .  getNext  (  )  ;  }  else  {  Preconditions  .  checkState  (  !NodeUtil  .  isFunctionObjectApply  (  callNode  )  )  ;  }  }  Node  fnParam  =  NodeUtil  .  getFunctionParameters  (  fnNode  )  .  getFirstChild  (  )  ;  while  (  cArg  !  =  null  ||  fnParam  !  =  null  )  {  if  (  fnParam  !  =  null  )  {  if  (  cArg  !  =  null  )  {  [BUGGY]  if  (  hasSideEffects  &&  NodeUtil  .  canBeSideEffected  (  cArg  )  )  {  return  CanInlineResult  .  NO  ;  }  	Closure_115_FunctionInjector_2_2	730	3	src/com/google/javascript/jscomp/FunctionInjector.java
488	boolean  hasSideEffects  =  false;  if  (block.hasChildren())  {  Preconditions.checkState(block.hasOneChild());  Node  stmt  =  block.getFirstChild();  if  (stmt.isReturn())  {  hasSideEffects  =  NodeUtil.mayHaveSideEffects(  stmt.getFirstChild(),  compiler);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<NO>  but  was:<YES>  [METHOD]  canInlineReferenceDirectly  [TYPE]  FunctionInjector$CanInlineResult  [PARAMETER]  Node  callNode  Node  fnNode  [CLASS]  FunctionInjector  [TYPE]  CanInlineResult  AFTER_PREPARATION  NO  YES  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  allowDecomposition  assumeMinimumCapture  assumeStrictThis  false  true  [TYPE]  Set  knownConstants  [TYPE]  InliningMode  BLOCK  DIRECT  mode  [TYPE]  CallSiteType  DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node  block  cArg  callNode  fnNode  fnParam  [TYPE]  JSModule  module  [TYPE]  Supplier  safeNameIdSupplier  [TYPE]  int  COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [CONTEXT]  private  CanInlineResult  canInlineReferenceDirectly  (  Node  callNode  ,  Node  fnNode  )  {  if  (  !isDirectCallNodeReplacementPossible  (  fnNode  )  )  {  return  CanInlineResult  .  NO  ;  }  Node  block  =  fnNode  .  getLastChild  (  )  ;  [BUGGY]  Node  cArg  =  callNode  .  getFirstChild  (  )  .  getNext  (  )  ;  	Closure_116_FunctionInjector_2_1	697	0	src/com/google/javascript/jscomp/FunctionInjector.java
489	if  (hasSideEffects  &&  NodeUtil.canBeSideEffected(cArg))  {  return  CanInlineResult.NO;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<NO>  but  was:<YES>  [METHOD]  canInlineReferenceDirectly  [TYPE]  FunctionInjector$CanInlineResult  [PARAMETER]  Node  callNode  Node  fnNode  [CLASS]  FunctionInjector  [TYPE]  CanInlineResult  AFTER_PREPARATION  NO  YES  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  allowDecomposition  assumeMinimumCapture  assumeStrictThis  false  true  [TYPE]  Set  knownConstants  [TYPE]  InliningMode  BLOCK  DIRECT  mode  [TYPE]  CallSiteType  DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node  block  cArg  callNode  fnNode  fnParam  [TYPE]  JSModule  module  [TYPE]  Supplier  safeNameIdSupplier  [TYPE]  int  COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [CONTEXT]  Node  cArg  =  callNode  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  !callNode  .  getFirstChild  (  )  .  isName  (  )  )  {  if  (  NodeUtil  .  isFunctionObjectCall  (  callNode  )  )  {  if  (  cArg  =  =  null  ||  !cArg  .  isThis  (  )  )  {  return  CanInlineResult  .  NO  ;  }  cArg  =  cArg  .  getNext  (  )  ;  }  else  {  Preconditions  .  checkState  (  !NodeUtil  .  isFunctionObjectApply  (  callNode  )  )  ;  }  }  Node  fnParam  =  NodeUtil  .  getFunctionParameters  (  fnNode  )  .  getFirstChild  (  )  ;  while  (  cArg  !  =  null  ||  fnParam  !  =  null  )  {  if  (  fnParam  !  =  null  )  {  if  (  cArg  !  =  null  )  {  [BUGGY]  if  (  NodeUtil  .  mayEffectMutableState  (  cArg  ,  compiler  )  &&  NodeUtil  .  getNameReferenceCount  (  	Closure_116_FunctionInjector_2_2	723	0	src/com/google/javascript/jscomp/FunctionInjector.java
490	JSType  type  =  getJSType(n);  if  (dereference)  {  ObjectType  dereferenced  =  type.dereference();  if  (dereferenced  !=  null)  {  type  =  dereferenced;  }  }  if  (type.isFunctionPrototypeType()  ||  (type.toObjectType()  !=  null  &&  type.toObjectType().getConstructor()  !=  null))  {  return  type.toString();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<p  never  defined  on  C[2]>  but  was:<p  never  defined  on  C[3c2_]>  [METHOD]  getReadableJSTypeName  [TYPE]  String  [PARAMETER]  Node  n  boolean  dereference  [CLASS]  TypeValidator  [TYPE]  ObjectType  dereferenced  objectType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  JSType  allValueTypes  nullOrUndefined  type  typeA  typeB  [TYPE]  boolean  dereference  false  shouldReport  true  [TYPE]  DiagnosticType  DUP_VAR_DECLARATION  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_PROPERTY_MISMATCH  ILLEGAL_PROPERTY_ACCESS  INTERFACE_METHOD_NOT_IMPLEMENTED  INVALID_CAST  MISSING_EXTENDS_TAG_WARNING  TYPE_MISMATCH_WARNING  UNKNOWN_TYPEOF_VALUE  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  Node  n  [TYPE]  List  mismatches  [TYPE]  String  FOUND_REQUIRED  propName  qualifiedName  [TYPE]  JSError  src  [CONTEXT]  String  getReadableJSTypeName  (  Node  n  ,  boolean  dereference  )  {  [BUGGY]  	Closure_117_TypeValidator_2_1	725	0	src/com/google/javascript/jscomp/TypeValidator.java
491		[BUGGY]  JSType  type  =  getJSType  (  n  )  ;  if  (  dereference  )  {  ObjectType  dereferenced  =  type  .  dereference  (  )  ;  if  (  dereferenced  !  =  null  )  {  type  =  dereferenced  ;  }  }  if  (  type  .  isFunctionPrototypeType  (  )  ||  (  type  .  toObjectType  (  )  !  =  null  &&  type  .  toObjectType  (  )  .  getConstructor  (  )  !  =  null  )  )  {  return  type  .  toString  (  )  ;  }  [FE]  ComparisonFailure:  expected:<p  never  defined  on  C[2]>  but  was:<p  never  defined  on  C[3c2_]>  [METHOD]  getReadableJSTypeName  [TYPE]  String  [PARAMETER]  Node  n  boolean  dereference  [CLASS]  TypeValidator  [TYPE]  ObjectType  dereferenced  objectType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  JSType  allValueTypes  nullOrUndefined  type  typeA  typeB  [TYPE]  boolean  dereference  false  shouldReport  true  [TYPE]  DiagnosticType  DUP_VAR_DECLARATION  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_PROPERTY_MISMATCH  ILLEGAL_PROPERTY_ACCESS  INTERFACE_METHOD_NOT_IMPLEMENTED  INVALID_CAST  MISSING_EXTENDS_TAG_WARNING  TYPE_MISMATCH_WARNING  UNKNOWN_TYPEOF_VALUE  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  Node  n  [TYPE]  List  mismatches  [TYPE]  String  FOUND_REQUIRED  propName  qualifiedName  [TYPE]  JSError  src  [CONTEXT]  if  (  n  .  isGetProp  (  )  )  {  ObjectType  objectType  =  getJSType  (  n  .  getFirstChild  (  )  )  .  dereference  (  )  ;  if  (  objectType  !  =  null  )  {  String  propName  =  n  .  getLastChild  (  )  .  getString  (  )  ;  if  (  objectType  .  getConstructor  (  )  !  =  null  &&  objectType  .  getConstructor  (  )  .  isInterface  (  )  )  {  objectType  =  FunctionType  .  getTopDefiningInterface  (  objectType  ,  propName  )  ;  }  else  {  while  (  objectType  !  =  null  &&  !objectType  .  hasOwnProperty  (  propName  )  )  {  objectType  =  objectType  .  getImplicitPrototype  (  )  ;  }  }  if  (  objectType  !  =  null  &&  (  objectType  .  getConstructor  (  )  !  =  null  ||  objectType  .  isFunctionPrototypeType  (  )  )  )  {  return  objectType  .  toString  (  )  + "  . "  +  propName  ;  }  }  }  [BUGGY]  JSType  type  =  getJSType  (  n  )  ;  if  (  dereference  )  {  ObjectType  dereferenced  =  type  .  dereference  (  )  ;  if  (  dereferenced  !  =  null  )  {  type  =  dereferenced  ;  }  	Closure_117_TypeValidator_2_2	756	12	src/com/google/javascript/jscomp/TypeValidator.java
492	if  (child.isQuotedString())  {  continue;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[a  =  [[Fooprototype]]]}>  [METHOD]  handleObjectLit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  FindRenameableProperties  [TYPE]  boolean  false  true  [TYPE]  T  type  [TYPE]  NodeTraversal  t  [TYPE]  Node  child  n  [TYPE]  String  name  [TYPE]  Property  prop  [CONTEXT]  private  void  handleObjectLit  (  NodeTraversal  t  ,  Node  n  )  {  for  (  Node  child  =  n  .  getFirstChild  (  )  ;  child  !  =  null  ;  child  =  child  .  getNext  (  )  )  {  [BUGGY]  String  name  =  child  .  getString  (  )  ;  T  type  =  typeSystem  .  getType  (  getScope  (  )  ,  n  ,  name  )  ;  Property  prop  =  getProperty  (  name  )  ;  if  (  !prop  .  scheduleRenaming  (  child  ,  processProperty  (  t  ,  prop  ,  type  ,  null  )  )  )  {  if  (  propertiesToErrorFor  .  containsKey  (  name  )  )  {  compiler  .  report  (  JSError  .  make  (  t  .  getSourceName  (  )  ,  child  ,  propertiesToErrorFor  .  get  (  name  )  ,  Warnings  .  INVALIDATION  ,  name  ,  (  type  =  =  null  ? "null "  :  type  .  toString  (  )  )  ,  n  .  toString  (  )  , " "  )  )  ;  }  }  }  }  	Closure_118_DisambiguateProperties_1_1	495	0	src/com/google/javascript/jscomp/DisambiguateProperties.java
493	case  Token.CATCH:  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  warning  (  s  )  :  JSC_UNDEFINED_NAME  e  is  never  defined  at  testcode  line  1  :  48  [METHOD]  collect  [TYPE]  void  [PARAMETER]  JSModule  module  Scope  scope  Node  n  [CLASS]  BuildGlobalNamespace  [TYPE]  Type  type  [TYPE]  boolean  false  isPropAssign  isSet  true  [TYPE]  Scope  scope  [TYPE]  Node  gramps  n  parent  rvalue  [TYPE]  JSModule  module  [TYPE]  String  name  [CONTEXT]  case  Token  .  NAME:  if  (  parent  !  =  null  )  {  switch  (  parent  .  getType  (  )  )  {  case  Token  .  VAR:  isSet  =  true  ;  Node  rvalue  =  n  .  getFirstChild  (  )  ;  type  =  rvalue  =  =  null  ?  Name  .  Type  .  OTHER  :  getValueType  (  rvalue  )  ;  break  ;  case  Token  .  ASSIGN:  if  (  parent  .  getFirstChild  (  )  =  =  n  )  {  isSet  =  true  ;  type  =  getValueType  (  n  .  getNext  (  )  )  ;  }  break  ;  case  Token  .  GETPROP:  return  ;  case  Token  .  FUNCTION:  Node  gramps  =  parent  .  getParent  (  )  ;  if  (  gramps  =  =  null  ||  NodeUtil  .  isFunctionExpression  (  parent  )  )  {  return  ;  }  isSet  =  true  ;  type  =  Name  .  Type  .  FUNCTION  ;  break  ;  [BUGGY]  case  Token  .  INC:  case  Token  .  DEC:  isSet  =  true  ;  type  =  Name  .  Type  .  OTHER  ;  break  ;  default:  	Closure_119_GlobalNamespace_1_1	366	0	src/com/google/javascript/jscomp/GlobalNamespace.java
494	if  (ref.getSymbol().getScope()  !=  ref.scope)  {  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isAssignedOnceInLifetime  [TYPE]  boolean  [PARAMETER]  [CLASS]  ReferenceCollection  [TYPE]  BasicBlock  block  [TYPE]  List  references  [TYPE]  boolean  false  true  [TYPE]  Reference  ref  [CONTEXT]  boolean  isAssignedOnceInLifetime  (  )  {  Reference  ref  =  getOneAndOnlyAssignment  (  )  ;  if  (  ref  =  =  null  )  {  return  false  ;  }  for  (  BasicBlock  block  =  ref  .  getBasicBlock  (  )  ;  block  !  =  null  ;  block  =  block  .  getParent  (  )  )  {  if  (  block  .  isFunction  )  {  [BUGGY]  break  ;  }  else  if  (  block  .  isLoop  )  {  return  false  ;  }  }  return  true  ;  }  	Closure_120_ReferenceCollectingCallback_1_1	431	0	src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
495	referenceInfo.isAssignedOnceInLifetime()  &&  	[BUGGY]  referenceInfo  .  isAssignedOnceInLifetime  (  )  )  {  [FE]  AssertionFailedError:  [METHOD]  inlineNonConstants  [TYPE]  void  [PARAMETER]  Var  v  ReferenceCollection  referenceInfo  boolean  maybeModifiedArguments  [CLASS]  InliningBehavior  [TYPE]  Set  staleVars  [TYPE]  boolean  false  maybeModifiedArguments  true  [TYPE]  Var  v  [TYPE]  Reference  aliasInit  declaration  init  reference  [TYPE]  Node  nameNode  srcLocation  value  [TYPE]  List  refs  [TYPE]  Map  aliasCandidates  [TYPE]  ReferenceCollection  referenceInfo  [TYPE]  int  firstRefAfterInit  i  refCount  [TYPE]  AliasCandidate  candidate  [CONTEXT]  Reference  reference  =  referenceInfo  .  references  .  get  (  firstRefAfterInit  -  1  )  ;  if  (  canInline  (  declaration  ,  init  ,  reference  )  )  {  inline  (  v  ,  declaration  ,  init  ,  reference  )  ;  staleVars  .  add  (  v  )  ;  }  }  else  if  (  declaration  !  =  init  &&  refCount  =  =  2  )  {  if  (  isValidDeclaration  (  declaration  )  &&  isValidInitialization  (  init  )  )  {  Node  value  =  init  .  getAssignedValue  (  )  ;  Preconditions  .  checkNotNull  (  value  )  ;  inlineWellDefinedVariable  (  v  ,  value  ,  referenceInfo  .  references  )  ;  staleVars  .  add  (  v  )  ;  }  }  if  (  !maybeModifiedArguments  &&  !staleVars  .  contains  (  v  )  &&  referenceInfo  .  isWellDefined  (  )  &&  [BUGGY]  referenceInfo  .  isAssignedOnceInLifetime  (  )  )  {  List<Reference>  refs  =  referenceInfo  .  references  ;  for  (  int  i  =  1  /*  start  from  a  read  */  ;  i  <  refs  .  size  (  )  ;  i++  )  {  	Closure_121_InlineVariables_2_1	304	1	src/com/google/javascript/jscomp/InlineVariables.java
496	(isInlineableDeclaredConstant(v,  referenceInfo)  ||  referenceInfo.isOnlyAssignmentSameScopeAsDeclaration()))  {  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  inlineNonConstants  [TYPE]  void  [PARAMETER]  Var  v  ReferenceCollection  referenceInfo  boolean  maybeModifiedArguments  [CLASS]  InliningBehavior  [TYPE]  Set  staleVars  [TYPE]  boolean  false  maybeModifiedArguments  true  [TYPE]  Var  v  [TYPE]  Reference  aliasInit  declaration  init  reference  [TYPE]  Node  nameNode  srcLocation  value  [TYPE]  List  refs  [TYPE]  Map  aliasCandidates  [TYPE]  ReferenceCollection  referenceInfo  [TYPE]  int  firstRefAfterInit  i  refCount  [TYPE]  AliasCandidate  candidate  [CONTEXT]  inline  (  v  ,  declaration  ,  init  ,  reference  )  ;  staleVars  .  add  (  v  )  ;  }  }  else  if  (  declaration  !  =  init  &&  refCount  =  =  2  )  {  if  (  isValidDeclaration  (  declaration  )  &&  isValidInitialization  (  init  )  )  {  Node  value  =  init  .  getAssignedValue  (  )  ;  Preconditions  .  checkNotNull  (  value  )  ;  inlineWellDefinedVariable  (  v  ,  value  ,  referenceInfo  .  references  )  ;  staleVars  .  add  (  v  )  ;  }  }  if  (  !maybeModifiedArguments  &&  !staleVars  .  contains  (  v  )  &&  referenceInfo  .  isWellDefined  (  )  &&  referenceInfo  .  isAssignedOnceInLifetime  (  )  )  {  [BUGGY]  List<Reference>  refs  =  referenceInfo  .  references  ;  for  (  int  i  =  1  /*  start  from  a  read  */  ;  i  <  refs  .  size  (  )  ;  i++  )  {  Node  nameNode  =  refs  .  get  (  i  )  .  getNode  (  )  ;  if  (  aliasCandidates  .  containsKey  (  nameNode  )  )  {  AliasCandidate  candidate  =  aliasCandidates  .  get  (  nameNode  )  ;  if  (  !staleVars  .  contains  (  candidate  .  alias  )  &&  	Closure_121_InlineVariables_2_2	308	0	src/com/google/javascript/jscomp/InlineVariables.java
497	Pattern  p  =  Pattern.compile( "(/|(\\n[  \\t]*))\\\\*[  \\t]*@[a-zA-Z] ");  if  (p.matcher(comment.getValue()).find())  {  	[BUGGY]  if  (  comment  .  getValue  (  )  .  indexOf  ( "/*  @ "  )  !  =  -1  ||  comment  .  getValue  (  )  .  indexOf  ( "\\n  *  @ "  )  !  =  -1  )  {  [FE]  AssertionFailedError  [METHOD]  handleBlockComment  [TYPE]  void  [PARAMETER]  Comment  comment  [CLASS]  IRFactory  [TYPE]  Comment  comment  [TYPE]  ErrorReporter  errorReporter  [TYPE]  Set  parsedComments  reservedKeywords  [TYPE]  boolean  false  true  [TYPE]  ImmutableSet  ALLOWED_DIRECTIVES  ES5_RESERVED_KEYWORDS  ES5_STRICT_RESERVED_KEYWORDS  [TYPE]  Config  config  [TYPE]  Node  rootNodeJsDocHolder  templateNode  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  GETTER_ERROR_MESSAGE  INVALID_ES3_PROP_NAME  MISPLACED_TYPE_ANNOTATION  SETTER_ERROR_MESSAGE  SUSPICIOUS_COMMENT_WARNING  sourceName  sourceString  [TYPE]  StaticSourceFile  sourceFile  [TYPE]  TransformDispatcher  transformDispatcher  [TYPE]  JSDocInfo  fileOverviewInfo  [CONTEXT]  private  void  handleBlockComment  (  Comment  comment  )  {  [BUGGY]  if  (  comment  .  getValue  (  )  .  indexOf  ( "/*  @ "  )  !  =  -1  ||  comment  .  getValue  (  )  .  indexOf  ( "\n  *  @ "  )  !  =  -1  )  {  errorReporter  .  warning  (  SUSPICIOUS_COMMENT_WARNING  ,  sourceName  ,  comment  .  getLineno  (  )  , " "  ,  0  )  ;  }  }  	Closure_122_IRFactory_1_1	252	1	src/com/google/javascript/jscomp/parsing/IRFactory.java
498	Context  rhsContext  =  getContextForNoInOperator(context);  	[BUGGY]  Context  rhsContext  =  Context  .  OTHER  ;  [FE]  ComparisonFailure:  expected:<for  (  a  =  c?0:[  (  0  in  d  )  ]  ;  ;  )  foo  (  )  >  but  was:<for  (  a  =  c?0:[0  in  d]  ;  ;  )  foo  (  )  >  assertPrintSame  ( "for  (  a  =  c?0:  (  0  in  d  )  ;  ;  )  foo  (  ) "  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  Node  n  Context  context  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  context  rhsContext  [TYPE]  LanguageMode  languageMode  [TYPE]  boolean  ambiguousElseClause  false  funcNeedsParens  hasElse  needsParens  preferLineBreaks  preferSingleQuotes  preserveBlock  true  trustedStrings  [TYPE]  double  d  [TYPE]  Node  body  c  catchblock  first  fn  last  n  next  parameters  [TYPE]  CodeConsumer  cc  [TYPE]  String  GT_ESCAPED  LT_ESCAPED  key  name  o  opstr  regexp  [TYPE]  Map  escapedJsStrings  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  childCount  p  postProp  precedence  type  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  Preconditions  .  checkState  (  childCount  =  =  1  )  ;  cc  .  addOp  (  NodeUtil  .  opToStrNoFail  (  type  )  ,  false  )  ;  addExpr  (  first  ,  NodeUtil  .  precedence  (  type  )  ,  Context  .  OTHER  )  ;  break  ;  }  case  Token  .  NEG:  {  Preconditions  .  checkState  (  childCount  =  =  1  )  ;  if  (  n  .  getFirstChild  (  )  .  isNumber  (  )  )  {  cc  .  addNumber  (  -n  .  getFirstChild  (  )  .  getDouble  (  )  )  ;  }  else  {  cc  .  addOp  (  NodeUtil  .  opToStrNoFail  (  type  )  ,  false  )  ;  addExpr  (  first  ,  NodeUtil  .  precedence  (  type  )  ,  Context  .  OTHER  )  ;  }  break  ;  }  case  Token  .  HOOK:  {  Preconditions  .  checkState  (  childCount  =  =  3  )  ;  int  p  =  NodeUtil  .  precedence  (  type  )  ;  [BUGGY]  Context  rhsContext  =  Context  .  OTHER  ;  addExpr  (  first  ,  p  +  1  ,  context  )  ;  cc  .  addOp  ( "? "  ,  true  )  ;  addExpr  (  first  .  getNext  (  )  ,  1  ,  rhsContext  )  ;  cc  .  addOp  ( ": "  ,  true  )  ;  addExpr  (  last  ,  1  ,  rhsContext  )  ;  	Closure_123_CodeGenerator_1_1	285	1	src/com/google/javascript/jscomp/CodeGenerator.java
499	while  (node.isGetProp())  {  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isSafeReplacement  [TYPE]  boolean  [PARAMETER]  Node  node  Node  replacement  [CLASS]  ExploitAssigns  [TYPE]  boolean  false  true  [TYPE]  Node  node  replacement  [CONTEXT]  private  boolean  isSafeReplacement  (  Node  node  ,  Node  replacement  )  {  if  (  node  .  isName  (  )  )  {  return  true  ;  }  Preconditions  .  checkArgument  (  node  .  isGetProp  (  )  )  ;  [BUGGY]  node  =  node  .  getFirstChild  (  )  ;  if  (  node  .  isName  (  )  &&  isNameAssignedTo  (  node  .  getString  (  )  ,  replacement  )  )  {  return  false  ;  }  return  true  ;  }  	Closure_124_ExploitAssigns_1_1	213	0	src/com/google/javascript/jscomp/ExploitAssigns.java
500	if  (fnType  !=  null  &&  fnType.hasInstanceType())  {  	[BUGGY]  if  (  fnType  !  =  null  )  {  [FE]  IllegalStateException  [METHOD]  visitNew  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  TypeCheck  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  type  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  CheckLevel  reportMissingOverride  [TYPE]  Node  constructor  n  [TYPE]  FunctionType  fnType  [TYPE]  String  OVERRIDING_PROTOTYPE_WITH_NON_OBJECT  suggestion  [TYPE]  Method  editDistance  [TYPE]  MemoizedScopeCreator  scopeCreator  [TYPE]  int  distance  noTypeCheckSection  nullCount  typedCount  unknownCount  [TYPE]  TypeValidator  validator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  false  inExterns  reportMissingProperties  reportUnknownTypes  true  [TYPE]  Scope  topScope  [TYPE]  DiagnosticType  BAD_IMPLEMENTED_TYPE  BIT_OPERATION  CONFLICTING_EXTENDED_TYPE  CONFLICTING_IMPLEMENTED_TYPE  CONFLICTING_SHAPE_TYPE  CONSTRUCTOR_NOT_CALLABLE  DETERMINISTIC_TEST  ENUM_DUP  ENUM_NOT_CONSTANT  EXPECTED_THIS_TYPE  FUNCTION_MASKS_VARIABLE  HIDDEN_INTERFACE_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY_MISMATCH  ILLEGAL_IMPLICIT_CAST  ILLEGAL_OBJLIT_KEY  ILLEGAL_PROPERTY_CREATION  INCOMPATIBLE_EXTENDED_PROPERTY_TYPE  INEXISTENT_ENUM_ELEMENT  INEXISTENT_PROPERTY  INEXISTENT_PROPERTY_WITH_SUGGESTION  INTERFACE_FUNCTION_NOT_EMPTY  INTERFACE_METHOD_OVERRIDE  INVALID_INTERFACE_MEMBER_DECLARATION  IN_USED_WITH_STRUCT  MULTIPLE_VAR_DEF  NOT_A_CONSTRUCTOR  NOT_CALLABLE  UNEXPECTED_TOKEN  UNKNOWN_EXPR_TYPE  UNKNOWN_OVERRIDE  UNRESOLVED_TYPE  WRONG_ARGUMENT_COUNT  [TYPE]  InferJSDocInfo  inferJSDocInfo  [CONTEXT]  private  void  visitNew  (  NodeTraversal  t  ,  Node  n  )  {  Node  constructor  =  n  .  getFirstChild  (  )  ;  JSType  type  =  getJSType  (  constructor  )  .  restrictByNotNullOrUndefined  (  )  ;  if  (  type  .  isConstructor  (  )  ||  type  .  isEmptyType  (  )  ||  type  .  isUnknownType  (  )  )  {  FunctionType  fnType  =  type  .  toMaybeFunctionType  (  )  ;  [BUGGY]  if  (  fnType  !  =  null  )  {  visitParameterList  (  t  ,  n  ,  fnType  )  ;  ensureTyped  (  t  ,  n  ,  fnType  .  getInstanceType  (  )  )  ;  }  else  {  ensureTyped  (  t  ,  n  )  ;  }  }  else  {  report  (  t  ,  n  ,  NOT_A_CONSTRUCTOR  )  ;  ensureTyped  (  t  ,  n  )  ;  }  }  	Closure_125_TypeCheck_1_1	1661	1	src/com/google/javascript/jscomp/TypeCheck.java
501		[BUGGY]  if  (  NodeUtil  .  hasFinally  (  n  )  )  {    [FE]  AssertionFailedError:  [METHOD]  tryMinimizeExits  [TYPE]  void  [PARAMETER]  Node  n  int  exitType  String  labelName  [CLASS]  MinimizeExitPoints  [TYPE]  AbstractCompiler  compiler  [TYPE]  String  labelName  [TYPE]  boolean  false  true  [TYPE]  int  exitType  [TYPE]  Node  allCatchNodes  c  catchCodeBlock  catchNode  elseBlock  falseBlock  finallyBlock  ifBlock  ifTree  labelBlock  n  trueBlock  tryBlock  [CONTEXT]  if  (  n  .  isIf  (  )  )  {  Node  ifBlock  =  n  .  getFirstChild  (  )  .  getNext  (  )  ;  tryMinimizeExits  (  ifBlock  ,  exitType  ,  labelName  )  ;  Node  elseBlock  =  ifBlock  .  getNext  (  )  ;  if  (  elseBlock  !  =  null  )  {  tryMinimizeExits  (  elseBlock  ,  exitType  ,  labelName  )  ;  }  return  ;  }  if  (  n  .  isTry  (  )  )  {  Node  tryBlock  =  n  .  getFirstChild  (  )  ;  tryMinimizeExits  (  tryBlock  ,  exitType  ,  labelName  )  ;  Node  allCatchNodes  =  NodeUtil  .  getCatchBlock  (  n  )  ;  if  (  NodeUtil  .  hasCatchHandler  (  allCatchNodes  )  )  {  Preconditions  .  checkState  (  allCatchNodes  .  hasOneChild  (  )  )  ;  Node  catchNode  =  allCatchNodes  .  getFirstChild  (  )  ;  Node  catchCodeBlock  =  catchNode  .  getLastChild  (  )  ;  tryMinimizeExits  (  catchCodeBlock  ,  exitType  ,  labelName  )  ;  }  [BUGGY]  if  (  NodeUtil  .  hasFinally  (  n  )  )  {  Node  finallyBlock  =  n  .  getLastChild  (  )  ;  tryMinimizeExits  (  finallyBlock  ,  exitType  ,  labelName  )  ;  }  }  	Closure_126_MinimizeExitPoints_1_1	141	1	src/com/google/javascript/jscomp/MinimizeExitPoints.java
502	if  (nextCfgNode  ==  fallThrough  &&  !inFinally(n.getParent(),  n))  {  	[BUGGY]  if  (  nextCfgNode  =  =  fallThrough  )  {  [FE]  AssertionFailedError:  [METHOD]  tryRemoveUnconditionalBranching  [TYPE]  void  [PARAMETER]  Node  n  [CLASS]  EliminationPass  [TYPE]  DiGraphNode  gNode  [TYPE]  List  outEdges  [TYPE]  boolean  false  true  [TYPE]  ControlFlowGraph  cfg  [TYPE]  Node  fallThrough  n  nextCfgNode  [CONTEXT]  DiGraphNode<Node  ,  Branch>  gNode  =  cfg  .  getDirectedGraphNode  (  n  )  ;  if  (  gNode  =  =  null  )  {  return  ;  }  switch  (  n  .  getType  (  )  )  {  case  Token  .  RETURN:  if  (  n  .  hasChildren  (  )  )  {  break  ;  }  case  Token  .  BREAK:  case  Token  .  CONTINUE:  List<DiGraphEdge<Node  ,  Branch>>  outEdges  =  gNode  .  getOutEdges  (  )  ;  if  (  outEdges  .  size  (  )  =  =  1  &&  (  n  .  getNext  (  )  =  =  null  ||  n  .  getNext  (  )  .  isFunction  (  )  )  )  {  Preconditions  .  checkState  (  outEdges  .  get  (  0  )  .  getValue  (  )  =  =  Branch  .  UNCOND  )  ;  Node  fallThrough  =  computeFollowing  (  n  )  ;  Node  nextCfgNode  =  outEdges  .  get  (  0  )  .  getDestination  (  )  .  getValue  (  )  ;  [BUGGY]  if  (  nextCfgNode  =  =  fallThrough  )  {  removeNode  (  n  )  ;  }  }  }  }  	Closure_127_UnreachableCodeElimination_2_1	170	1	src/com/google/javascript/jscomp/UnreachableCodeElimination.java
503	private  boolean  inFinally(Node  parent,  Node  child)  {  if  (parent  ==  null  ||  parent.isFunction())  {  return  false;  }  else  if  (NodeUtil.isTryFinallyNode(parent,  child))  {  return  true;  }  else  {  return  inFinally(parent.getParent(),  parent);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_127_UnreachableCodeElimination_2_2	177	0	src/com/google/javascript/jscomp/UnreachableCodeElimination.java
504	if  (len  ==  0)  {  return  false;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<var  x  =  {[0]:1}>  but  was:<var  x  =  {[ "0 "]:1}>  assertPrint  ( "var  x  =  {0:  1}  ; "  , "var  x  =  {0:1} "  )  ;  [METHOD]  isSimpleNumber  [TYPE]  boolean  [PARAMETER]  String  s  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  [TYPE]  boolean  false  preferSingleQuotes  true  trustedStrings  [TYPE]  char  c  [TYPE]  CodeConsumer  cc  [TYPE]  String  GT_ESCAPED  LT_ESCAPED  s  [TYPE]  Map  ESCAPED_JS_STRINGS  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  index  len  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  static  boolean  isSimpleNumber  (  String  s  )  {  int  len  =  s  .  length  (  )  ;  [BUGGY]  for  (  int  index  =  0  ;  index  <  len  ;  index++  )  {  char  c  =  s  .  charAt  (  index  )  ;  if  (  c  <  '0'  ||  c  >  '9'  )  {  return  false  ;  }  }  return  len  >  0  &&  s  .  charAt  (  0  )  !  =  '0'  ;  }  	Closure_128_CodeGenerator_2_1	785	0	src/com/google/javascript/jscomp/CodeGenerator.java
505	return len == 1 || s.charAt(0) != '0';	[BUGGY] return len > 0 && s.charAt(0) != '0';  [FE]  ComparisonFailure:  expected:<var  x  =  {[0]:1}>  but  was:<var  x  =  {[ "0 "]:1}>  assertPrint  ( "var  x  =  {0:  1}  ; "  , "var  x  =  {0:1} "  )  ;  [METHOD]  isSimpleNumber  [TYPE]  boolean  [PARAMETER]  String  s  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  [TYPE]  boolean  false  preferSingleQuotes  true  trustedStrings  [TYPE]  char  c  [TYPE]  CodeConsumer  cc  [TYPE]  String  GT_ESCAPED  LT_ESCAPED  s  [TYPE]  Map  ESCAPED_JS_STRINGS  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  index  len  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  static  boolean  isSimpleNumber  (  String  s  )  {  int  len  =  s  .  length  (  )  ;  for  (  int  index  =  0  ;  index  <  len  ;  index++  )  {  char  c  =  s  .  charAt  (  index  )  ;  if  (  c  <  '0'  ||  c  >  '9'  )  {  return  false  ;  }  }  [BUGGY]  return  len  >  0  &&  s  .  charAt  (  0  )  !  =  '0'  ;  }  	Closure_128_CodeGenerator_2_2	791	0	src/com/google/javascript/jscomp/CodeGenerator.java
506	while  (first.isCast())  {  first  =  first.getFirstChild();  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  annotateCalls  [TYPE]  void  [PARAMETER]  Node  n  [CLASS]  PrepareAnnotations  [TYPE]  boolean  false  true  [TYPE]  Node  first  n  [CONTEXT]  private  void  annotateCalls  (  Node  n  )  {  Preconditions  .  checkState  (  n  .  isCall  (  )  )  ;  Node  first  =  n  .  getFirstChild  (  )  ;  [BUGGY]  if  (  !NodeUtil  .  isGet  (  first  )  )  {  n  .  putBooleanProp  (  Node  .  FREE_CALL  ,  true  )  ;  }  if  (  first  .  isName  (  )  && "eval "  .  equals  (  first  .  getString  (  )  )  )  {  first  .  putBooleanProp  (  Node  .  DIRECT_EVAL  ,  true  )  ;  }  }  	Closure_129_PrepareAst_1_1	166	0	src/com/google/javascript/jscomp/PrepareAst.java
507	if  (!name.inExterns  &&  name.globalSets  ==  1  &&  name.localSets  ==  0  &&  	[BUGGY]  if  (  name  .  globalSets  =  =  1  &&  name  .  localSets  =  =  0  &&  [FE]  AssertionFailedError:  [METHOD]  inlineAliases  [TYPE]  void  [PARAMETER]  GlobalNamespace  namespace  [CLASS]  CollapseProperties  [TYPE]  AbstractCompiler  compiler  [TYPE]  Ref  ref  [TYPE]  boolean  collapsePropertiesOnExternTypes  false  inlineAliases  true  [TYPE]  DiagnosticType  NAMESPACE_REDEFINED_WARNING  UNSAFE_NAMESPACE_WARNING  UNSAFE_THIS  [TYPE]  List  globalNames  refs  [TYPE]  Map  nameMap  [TYPE]  GlobalNamespace  namespace  [TYPE]  Deque  workList  [TYPE]  Name  name  [CONTEXT]  private  void  inlineAliases  (  GlobalNamespace  namespace  )  {  Deque<Name>  workList  =  new  ArrayDeque<Name>  (  namespace  .  getNameForest  (  )  )  ;  while  (  !workList  .  isEmpty  (  )  )  {  Name  name  =  workList  .  pop  (  )  ;  if  (  name  .  type  =  =  Name  .  Type  .  GET  ||  name  .  type  =  =  Name  .  Type  .  SET  )  {  continue  ;  }  [BUGGY]  if  (  name  .  globalSets  =  =  1  &&  name  .  localSets  =  =  0  &&  name  .  aliasingGets  >  0  )  {  List<Ref>  refs  =  Lists  .  newArrayList  (  name  .  getRefs  (  )  )  ;  for  (  Ref  ref  :  refs  )  {  	Closure_130_CollapseProperties_1_1	172	1	src/com/google/javascript/jscomp/CollapseProperties.java
508	Character.isIdentifierIgnorable(s.charAt(0))  ||  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  isJSIdentifier  [TYPE]  boolean  [PARAMETER]  String  s  [CLASS]  TokenStream  [TYPE]  boolean  false  true  [TYPE]  String  s  [TYPE]  int  i  length  [CONTEXT]  public  static  boolean  isJSIdentifier  (  String  s  )  {  int  length  =  s  .  length  (  )  ;  if  (  length  =  =  0  ||  [BUGGY]  !Character  .  isJavaIdentifierStart  (  s  .  charAt  (  0  )  )  )  {  return  false  ;  }  for  (  int  i  =  1  ;  i  <  length  ;  i++  )  {  if  (  !Character  .  isJavaIdentifierPart  (  s  .  charAt  (  i  )  )  )  {  return  false  ;  }  }  return  true  ;  }  	Closure_131_TokenStream_2_1	194	0	src/com/google/javascript/rhino/TokenStream.java
509	if  (Character.isIdentifierIgnorable(s.charAt(i))  ||  	[BUGGY]  if  (  [FE]  AssertionFailedError:  [METHOD]  isJSIdentifier  [TYPE]  boolean  [PARAMETER]  String  s  [CLASS]  TokenStream  [TYPE]  boolean  false  true  [TYPE]  String  s  [TYPE]  int  i  length  [CONTEXT]  public  static  boolean  isJSIdentifier  (  String  s  )  {  int  length  =  s  .  length  (  )  ;  if  (  length  =  =  0  ||  !Character  .  isJavaIdentifierStart  (  s  .  charAt  (  0  )  )  )  {  return  false  ;  }  for  (  int  i  =  1  ;  i  <  length  ;  i++  )  {  [BUGGY]  if  (  !Character  .  isJavaIdentifierPart  (  s  .  charAt  (  i  )  )  )  {  return  false  ;  }  }  return  true  ;  }  	Closure_131_TokenStream_2_2	199	1	src/com/google/javascript/rhino/TokenStream.java
510	!mayEffectMutableState(lhs)  &&  (!mayHaveSideEffects(cond)  ||  (thenOp.isAssign()  &&  thenOp.getFirstChild().isName())))  {  	[BUGGY]  !mayEffectMutableState  (  lhs  )  )  {  [FE]  AssertionFailedError:  [METHOD]  tryMinimizeIf  [TYPE]  Node  [PARAMETER]  Node  n  [CLASS]  PeepholeSubstituteAlternateSyntax  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  [TYPE]  boolean  elseBranchIsExpressionBlock  elseBranchIsVar  false  late  thenBranchIsExpressionBlock  thenBranchIsVar  true  [TYPE]  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  [TYPE]  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  [TYPE]  Node  and  assign  assignName  cond  elseAssign  elseBranch  elseExpr  elseOp  expr  hookNode  innerCond  innerElseBranch  innerIf  innerThenBranch  lhs  maybeName1  maybeName2  n  name1  name2  newExpr  or  parent  returnNode  thenAssign  thenBranch  thenExpr  thenOp  var  [TYPE]  CodeGenerator  REGEXP_ESCAPER  [TYPE]  int  AND_PRECEDENCE  NOT_PRECEDENCE  OR_PRECEDENCE  STRING_SPLIT_OVERHEAD  [TYPE]  Predicate  DONT_TRAVERSE_FUNCTIONS_PREDICATE  [CONTEXT]  Node  returnNode  =  IR  .  returnNode  (  IR  .  hook  (  cond  ,  thenExpr  ,  elseExpr  )  .  srcref  (  n  )  )  ;  parent  .  replaceChild  (  n  ,  returnNode  )  ;  reportCodeChange  (  )  ;  return  returnNode  ;  }  boolean  thenBranchIsExpressionBlock  =  isFoldableExpressBlock  (  thenBranch  )  ;  boolean  elseBranchIsExpressionBlock  =  isFoldableExpressBlock  (  elseBranch  )  ;  if  (  thenBranchIsExpressionBlock  &&  elseBranchIsExpressionBlock  )  {  Node  thenOp  =  getBlockExpression  (  thenBranch  )  .  getFirstChild  (  )  ;  Node  elseOp  =  getBlockExpression  (  elseBranch  )  .  getFirstChild  (  )  ;  if  (  thenOp  .  getType  (  )  =  =  elseOp  .  getType  (  )  )  {  if  (  NodeUtil  .  isAssignmentOp  (  thenOp  )  )  {  Node  lhs  =  thenOp  .  getFirstChild  (  )  ;  if  (  areNodesEqualForInlining  (  lhs  ,  elseOp  .  getFirstChild  (  )  )  &&  [BUGGY]  !mayEffectMutableState  (  lhs  )  )  {  n  .  removeChild  (  cond  )  ;  Node  assignName  =  thenOp  .  removeFirstChild  (  )  ;  Node  thenExpr  =  thenOp  .  removeFirstChild  (  )  ;  Node  elseExpr  =  elseOp  .  getLastChild  (  )  ;  	Closure_132_PeepholeSubstituteAlternateSyntax_1_1	782	1	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
511	unreadToken  =  NO_UNREAD_TOKEN;  	[BUGGY]  [FE]  IllegalStateException:  Recorded  bad  position  information  assertEquals  (  [METHOD]  getRemainingJSDocLine  [TYPE]  String  [PARAMETER]  [CLASS]  JsDocInfoParser  [TYPE]  Set  modifiesAnnotationKeywords  suppressionNames  [TYPE]  Node  associatedNode  templateNode  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  result  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  charno  lineno  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSTypeExpression  type  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  StaticSourceFile  sourceFile  [TYPE]  Map  annotationNames  [CONTEXT]  private  String  getRemainingJSDocLine  (  )  {  String  result  =  stream  .  getRemainingJSDocLine  (  )  ;  [BUGGY]  return  result  ;  }  	Closure_133_JsDocInfoParser_1_1	2401	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
512		[BUGGY]  computeRelatedTypes  (  p  .  type  )  ;  [FE]  AssertionFailedError:  [METHOD]  process  [TYPE]  void  [PARAMETER]  Node  externs  Node  root  [CLASS]  AmbiguateProperties  [TYPE]  Set  externedNames  invalidatingTypes  propsByFreq  quotedNames  reservedNames  [TYPE]  JSType  type  [TYPE]  GraphColoring  coloring  [TYPE]  BiMap  intForType  [TYPE]  Node  externs  n  root  [TYPE]  NameGenerator  nameGen  [TYPE]  GraphNode  node  [TYPE]  String  SKIP_PREFIX  newName  oldName  [TYPE]  Logger  logger  [TYPE]  Annotation  annotation  [TYPE]  int  i  numNewPropertyNames  numOccurrences  numRenamedPropertyNames  numSkippedPropertyNames  [TYPE]  long  serialVersionUID  [TYPE]  char[]  reservedCharacters  [TYPE]  Comparator  FREQUENCY_COMPARATOR  [TYPE]  PropertyGraph  graph  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  skipAmbiguating  true  [TYPE]  List  stringNodesToRename  [TYPE]  Map  colorMap  nodes  propertyMap  relatedBitsets  renamingMap  [TYPE]  Property  p  property  [TYPE]  JSTypeBitSet  typesInSet  typesRelatedToSet  typesSet  [CONTEXT]  public  void  process  (  Node  externs  ,  Node  root  )  {  NodeTraversal  .  traverse  (  compiler  ,  externs  ,  new  ProcessExterns  (  )  )  ;  NodeTraversal  .  traverse  (  compiler  ,  root  ,  new  ProcessProperties  (  )  )  ;  Set<String>  reservedNames  =  new  HashSet<String>  (  externedNames  .  size  (  )  +  quotedNames  .  size  (  )  )  ;  reservedNames  .  addAll  (  externedNames  )  ;  reservedNames  .  addAll  (  quotedNames  )  ;  int  numRenamedPropertyNames  =  0  ;  int  numSkippedPropertyNames  =  0  ;  Set<Property>  propsByFreq  =  new  TreeSet<Property>  (  FREQUENCY_COMPARATOR  )  ;  for  (  Property  p  :  propertyMap  .  values  (  )  )  {  if  (  !p  .  skipAmbiguating  )  {  ++numRenamedPropertyNames  ;  [BUGGY]  computeRelatedTypes  (  p  .  type  )  ;  propsByFreq  .  add  (  p  )  ;  }  else  {  ++numSkippedPropertyNames  ;  reservedNames  .  add  (  p  .  oldName  )  ;  }  	Closure_134_AmbiguateProperties_6_1	210	1	src/com/google/javascript/jscomp/AmbiguateProperties.java
513	return  !prop.relatedTypesSet.intersects(typesInSet);  	[BUGGY]  return  !getRelated  (  prop  .  type  )  .  intersects  (  typesInSet  )  ;  [FE]  AssertionFailedError:  [METHOD]  isIndependentOf  [TYPE]  boolean  [PARAMETER]  Property  prop  [CLASS]  PropertySubGraph  [TYPE]  Property  prop  [TYPE]  JSTypeBitSet  typesInSet  typesRelatedToSet  [TYPE]  boolean  false  true  [CONTEXT]  public  boolean  isIndependentOf  (  Property  prop  )  {  if  (  typesRelatedToSet  .  intersects  (  prop  .  typesSet  )  )  {  return  false  ;  }  [BUGGY]  return  !getRelated  (  prop  .  type  )  .  intersects  (  typesInSet  )  ;  }  	Closure_134_AmbiguateProperties_6_2	356	1	src/com/google/javascript/jscomp/AmbiguateProperties.java
514	typesRelatedToSet.or(prop.relatedTypesSet);  	[BUGGY]  typesRelatedToSet  .  or  (  getRelated  (  prop  .  type  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  addNode  [TYPE]  void  [PARAMETER]  Property  prop  [CLASS]  PropertySubGraph  [TYPE]  Property  prop  [TYPE]  JSTypeBitSet  typesInSet  typesRelatedToSet  [TYPE]  boolean  false  true  [CONTEXT]  public  void  addNode  (  Property  prop  )  {  typesInSet  .  or  (  prop  .  typesSet  )  ;  [BUGGY]  typesRelatedToSet  .  or  (  getRelated  (  prop  .  type  )  )  ;  }  	Closure_134_AmbiguateProperties_6_3	366	1	src/com/google/javascript/jscomp/AmbiguateProperties.java
515		[BUGGY]  JSType  type  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_134_AmbiguateProperties_6_4	553	1	src/com/google/javascript/jscomp/AmbiguateProperties.java
516	JSTypeBitSet  relatedTypesSet  =  new  JSTypeBitSet(intForType.size());  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_134_AmbiguateProperties_6_5	558	0	src/com/google/javascript/jscomp/AmbiguateProperties.java
517	int  typeInt  =  getIntForType(newType);  if  (!typesSet.get(typeInt))  {  computeRelatedTypes(newType);  typesSet.set(typeInt);  relatedTypesSet.or(getRelatedTypesOnNonUnion(newType));  	[BUGGY]  if  (  type  =  =  null  )  {  type  =  newType  ;  }  else  {  type  =  type  .  getLeastSupertype  (  newType  )  ;  typesSet  .  set  (  getIntForType  (  newType  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  addNonUnionType  [TYPE]  void  [PARAMETER]  JSType  newType  [CLASS]  Property  [TYPE]  JSType  newType  type  [TYPE]  boolean  false  skipAmbiguating  true  [TYPE]  String  newName  oldName  [TYPE]  int  numOccurrences  [TYPE]  JSTypeBitSet  typesSet  [CONTEXT]  private  void  addNonUnionType  (  JSType  newType  )  {  if  (  skipAmbiguating  ||  isInvalidatingType  (  newType  )  )  {  skipAmbiguating  =  true  ;  return  ;  }  [BUGGY]  if  (  type  =  =  null  )  {  type  =  newType  ;  }  else  {  type  =  type  .  getLeastSupertype  (  newType  )  ;  }  typesSet  .  set  (  getIntForType  (  newType  )  )  ;  }  	Closure_134_AmbiguateProperties_6_6	594	5	src/com/google/javascript/jscomp/AmbiguateProperties.java
518	}  else  {\n', "    for  (ObjectType  iface  :  ownerType.getCtorImplementedInterfaces())  {  propType  =  iface.getPropertyType(propName);  if  (propType  instanceof  FunctionType)  {  return  (FunctionType)  propType;  }  }  }  	[BUGGY]  }  [FE]  AssertionFailedError:  [METHOD]  findOverriddenFunction  [TYPE]  FunctionType  [PARAMETER]  ObjectType  ownerType  String  propName  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  ownerType  [TYPE]  String  propName  sourceName  [TYPE]  JSType  propType  [TYPE]  boolean  false  true  [TYPE]  Scope  scope  [CONTEXT]  private  FunctionType  findOverriddenFunction  (  ObjectType  ownerType  ,  String  propName  )  {  JSType  propType  =  ownerType  .  getPropertyType  (  propName  )  ;  if  (  propType  instanceof  FunctionType  )  {  return  (  FunctionType  )  propType  ;  [BUGGY]  }  return  null  ;  }  	Closure_134_TypedScopeCreator_1_1	560	1	src/com/google/javascript/jscomp/TypedScopeCreator.java
519	newName.setJSType(child.getJSType());  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[FUNCTION  a  =  function  (  this:a  )  :  ?  ,  NAME  JSCompiler_StaticMethods_foo$self  =  a  ,  FUNCTION  JSCompiler_StaticMethods_foo  =  function  (  a  )  :  number  ,  NAME  JSCompiler_StaticMethods_bar$self  =  a  ,  FUNCTION  JSCompiler_StaticMethods_bar  =  function  (  a  ,  number  )  :  number  ,  FUNCTION  JSCompiler_StaticMethods_baz  =  function  (  a  )  :  ?  ,  NEW  a  =  a  ,  CALL  JSCompiler_StaticMethods_foo  =  number  ,  CALL  JSCompiler_StaticMethods_bar  =  number  ,  CALL  JSCompiler_StaticMethods_baz  =  ?]>  but  was:<[FUNCTION  a  =  function  (  this:a  )  :  ?  ,  NAME  JSCompiler_StaticMethods_foo$self  =  null  ,  FUNCTION  JSCompiler_StaticMethods_foo  =  function  (  a  )  :  number  ,  NAME  JSCompiler_StaticMethods_bar$self  =  null  ,  FUNCTION  JSCompiler_StaticMethods_bar  =  function  (  a  ,  number  )  :  number  ,  FUNCTION  JSCompiler_StaticMethods_baz  =  function  (  a  )  :  ?  ,  NEW  a  =  a  ,  CALL  JSCompiler_StaticMethods_foo  =  number  ,  CALL  JSCompiler_StaticMethods_bar  =  number  ,  CALL  JSCompiler_StaticMethods_baz  =  ?]>  [METHOD]  replaceReferencesToThis  [TYPE]  void  [PARAMETER]  Node  node  String  name  [CLASS]  DevirtualizePrototypeMethods  [TYPE]  AbstractCompiler  compiler  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  Node  child  newName  node  [CONTEXT]  private  void  replaceReferencesToThis  (  Node  node  ,  String  name  )  {  if  (  NodeUtil  .  isFunction  (  node  )  )  {  return  ;  }  for  (  Node  child  :  node  .  children  (  )  )  {  if  (  NodeUtil  .  isThis  (  child  )  )  {  Node  newName  =  Node  .  newString  (  Token  .  NAME  ,  name  )  ;  [BUGGY]  node  .  replaceChild  (  child  ,  newName  )  ;  }  else  {  replaceReferencesToThis  (  child  ,  name  )  ;  }  }  }  	Closure_135_DevirtualizePrototypeMethods_1_1	362	0	src/com/google/javascript/jscomp/DevirtualizePrototypeMethods.java
520	@Override  public  boolean  hasOwnProperty(String  name)  {  return  super.hasOwnProperty(name)  || "prototype ".equals(name);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[FUNCTION  a  =  function  (  this:a  )  :  ?  ,  NAME  JSCompiler_StaticMethods_foo$self  =  a  ,  FUNCTION  JSCompiler_StaticMethods_foo  =  function  (  a  )  :  number  ,  NAME  JSCompiler_StaticMethods_bar$self  =  a  ,  FUNCTION  JSCompiler_StaticMethods_bar  =  function  (  a  ,  number  )  :  number  ,  FUNCTION  JSCompiler_StaticMethods_baz  =  function  (  a  )  :  ?  ,  NEW  a  =  a  ,  CALL  JSCompiler_StaticMethods_foo  =  number  ,  CALL  JSCompiler_StaticMethods_bar  =  number  ,  CALL  JSCompiler_StaticMethods_baz  =  ?]>  but  was:<[FUNCTION  a  =  function  (  this:a  )  :  ?  ,  NAME  JSCompiler_StaticMethods_foo$self  =  null  ,  FUNCTION  JSCompiler_StaticMethods_foo  =  function  (  a  )  :  number  ,  NAME  JSCompiler_StaticMethods_bar$self  =  null  ,  FUNCTION  JSCompiler_StaticMethods_bar  =  function  (  a  ,  number  )  :  number  ,  FUNCTION  JSCompiler_StaticMethods_baz  =  function  (  a  )  :  ?  ,  NEW  a  =  a  ,  CALL  JSCompiler_StaticMethods_foo  =  number  ,  CALL  JSCompiler_StaticMethods_bar  =  number  ,  CALL  JSCompiler_StaticMethods_baz  =  ?]>  [CLASS]  [CONTEXT]  	Closure_135_FunctionType_2_1	412	0	src/com/google/javascript/rhino/jstype/FunctionType.java
521	if  (objType.equals(prototype))  {  return  true;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[FUNCTION  a  =  function  (  this:a  )  :  ?  ,  NAME  JSCompiler_StaticMethods_foo$self  =  a  ,  FUNCTION  JSCompiler_StaticMethods_foo  =  function  (  a  )  :  number  ,  NAME  JSCompiler_StaticMethods_bar$self  =  a  ,  FUNCTION  JSCompiler_StaticMethods_bar  =  function  (  a  ,  number  )  :  number  ,  FUNCTION  JSCompiler_StaticMethods_baz  =  function  (  a  )  :  ?  ,  NEW  a  =  a  ,  CALL  JSCompiler_StaticMethods_foo  =  number  ,  CALL  JSCompiler_StaticMethods_bar  =  number  ,  CALL  JSCompiler_StaticMethods_baz  =  ?]>  but  was:<[FUNCTION  a  =  function  (  this:a  )  :  ?  ,  NAME  JSCompiler_StaticMethods_foo$self  =  null  ,  FUNCTION  JSCompiler_StaticMethods_foo  =  function  (  a  )  :  number  ,  NAME  JSCompiler_StaticMethods_bar$self  =  null  ,  FUNCTION  JSCompiler_StaticMethods_bar  =  function  (  a  ,  number  )  :  number  ,  FUNCTION  JSCompiler_StaticMethods_baz  =  function  (  a  )  :  ?  ,  NEW  a  =  a  ,  CALL  JSCompiler_StaticMethods_foo  =  number  ,  CALL  JSCompiler_StaticMethods_bar  =  number  ,  CALL  JSCompiler_StaticMethods_baz  =  ?]>  [METHOD]  defineProperty  [TYPE]  boolean  [PARAMETER]  String  name  JSType  type  boolean  inferred  boolean  inExterns  [CLASS]  FunctionType  [TYPE]  ObjectType  objType  typeOfThis  [TYPE]  JSType  type  [TYPE]  boolean  false  inExterns  inferred  true  [TYPE]  FunctionPrototypeType  prototype  [TYPE]  Kind  CONSTRUCTOR  INTERFACE  ORDINARY  kind  [TYPE]  Node  source  [TYPE]  ArrowType  call  [TYPE]  List  implementedInterfaces  subTypes  [TYPE]  String  name  templateTypeName  [TYPE]  long  serialVersionUID  [CONTEXT]  boolean  defineProperty  (  String  name  ,  JSType  type  ,  boolean  inferred  ,  boolean  inExterns  )  {  if  ( "prototype "  .  equals  (  name  )  )  {  ObjectType  objType  =  type  .  toObjectType  (  )  ;  if  (  objType  !  =  null  )  {  [BUGGY]  return  setPrototype  (  new  FunctionPrototypeType  (  registry  ,  this  ,  objType  ,  isNativeObjectType  (  )  )  )  ;  }  else  {  return  false  ;  }  }  return  super  .  defineProperty  (  name  ,  type  ,  inferred  ,  inExterns  )  ;  }  	Closure_135_FunctionType_2_2	472	0	src/com/google/javascript/rhino/jstype/FunctionType.java
522		[BUGGY]  boolean  signatureAdded  =  false  ;  [FE]  ComparisonFailure:  expected:<[  (  {a:alert  ,  b:alert}  )  a  ( "a "  )  ]>  but  was:<[]>  [METHOD]  addPossibleSignature  [TYPE]  void  [PARAMETER]  String  name  Node  node  NodeTraversal  t  [CLASS]  MethodCompilerPass  [TYPE]  Multimap  methodDefinitions  [TYPE]  AbstractCompiler  compiler  [TYPE]  Set  externMethods  externMethodsWithoutSignatures  nonMethodProperties  [TYPE]  boolean  false  signatureAdded  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  function  node  [TYPE]  String  functionName  name  [CONTEXT]  private  void  addPossibleSignature  (  String  name  ,  Node  node  ,  NodeTraversal  t  )  {  [BUGGY]  boolean  signatureAdded  =  false  ;  if  (  node  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  addSignature  (  name  ,  node  ,  t  .  getSourceName  (  )  )  ;  signatureAdded  =  true  ;  }  else  if  (  node  .  getType  (  )  =  =  Token  .  NAME  )  {  String  functionName  =  node  .  getString  (  )  ;  Scope  .  Var  v  =  t  .  getScope  (  )  .  getVar  (  functionName  )  ;  if  (  v  =  =  null  )  {  if  (  compiler  .  isIdeMode  (  )  )  {  return  ;  }  else  {  throw  new  IllegalStateException  ( "VarCheck  should  have  caught  this  undefined  function "  )  ;  }  }  Node  function  =  v  .  getInitialValue  (  )  ;  if  (  function  !  =  null  &&  function  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  addSignature  (  name  ,  function  ,  v  .  getInputName  (  )  )  ;  signatureAdded  =  true  ;  }  }  if  (  !signatureAdded  )  {  nonMethodProperties  .  add  (  name  )  ;  }  }  	Closure_136_MethodCompilerPass_2_1	102	1	src/com/google/javascript/jscomp/MethodCompilerPass.java
523	}  else  {  	[BUGGY]  signatureAdded  =  true  ;  }  else  if  (  node  .  getType  (  )  =  =  Token  .  NAME  )  {  String  functionName  =  node  .  getString  (  )  ;  Scope  .  Var  v  =  t  .  getScope  (  )  .  getVar  (  functionName  )  ;  if  (  v  =  =  null  )  {  if  (  compiler  .  isIdeMode  (  )  )  {  return  ;  }  else  {  throw  new  IllegalStateException  ( "VarCheck  should  have  caught  this  undefined  function "  )  ;  }  }  Node  function  =  v  .  getInitialValue  (  )  ;  if  (  function  !  =  null  &&  function  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  addSignature  (  name  ,  function  ,  v  .  getInputName  (  )  )  ;  signatureAdded  =  true  ;  }  }  if  (  !signatureAdded  )  {  [FE]  ComparisonFailure:  expected:<[  (  {a:alert  ,  b:alert}  )  a  ( "a "  )  ]>  but  was:<[]>  [METHOD]  addPossibleSignature  [TYPE]  void  [PARAMETER]  String  name  Node  node  NodeTraversal  t  [CLASS]  MethodCompilerPass  [TYPE]  Multimap  methodDefinitions  [TYPE]  AbstractCompiler  compiler  [TYPE]  Set  externMethods  externMethodsWithoutSignatures  nonMethodProperties  [TYPE]  boolean  false  signatureAdded  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  function  node  [TYPE]  String  functionName  name  [CONTEXT]  private  void  addPossibleSignature  (  String  name  ,  Node  node  ,  NodeTraversal  t  )  {  boolean  signatureAdded  =  false  ;  if  (  node  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  addSignature  (  name  ,  node  ,  t  .  getSourceName  (  )  )  ;  [BUGGY]  signatureAdded  =  true  ;  }  else  if  (  node  .  getType  (  )  =  =  Token  .  NAME  )  {  String  functionName  =  node  .  getString  (  )  ;  Scope  .  Var  v  =  t  .  getScope  (  )  .  getVar  (  functionName  )  ;  if  (  v  =  =  null  )  {  if  (  compiler  .  isIdeMode  (  )  )  {  return  ;  }  else  {  throw  new  IllegalStateException  ( "VarCheck  should  have  caught  this  undefined  function "  )  ;  }  }  Node  function  =  v  .  getInitialValue  (  )  ;  if  (  function  !  =  null  &&  function  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  addSignature  (  name  ,  function  ,  v  .  getInputName  (  )  )  ;  signatureAdded  =  true  ;  }  }  if  (  !signatureAdded  )  {  nonMethodProperties  .  add  (  name  )  ;  }  }  	Closure_136_MethodCompilerPass_2_2	106	20	src/com/google/javascript/jscomp/MethodCompilerPass.java
524	if  (local)  {  String  newName  =  MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(  name);  if  (!newName.equals(name))  {  n.setString(newName);  }  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[  (  {a:alert  ,  b:alert}  )  a  ( "a "  )  ]>  but  was:<[]>  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ProcessVars  [TYPE]  boolean  false  isExternsPass_  local  true  [TYPE]  String  name  tempName  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  n  parent  [CONTEXT]  if  (  name  .  length  (  )  =  =  0  )  {  return  ;  }  Scope  .  Var  var  =  t  .  getScope  (  )  .  getVar  (  name  )  ;  boolean  local  =  (  var  !  =  null  )  &&  var  .  isLocal  (  )  ;  if  (  !local  &&  localRenamingOnly  )  {  reservedNames  .  add  (  name  )  ;  return  ;  }  if  (  preserveAnonymousFunctionNames  &&  var  !  =  null  &&  NodeUtil  .  isAnonymousFunction  (  var  .  getParentNode  (  )  )  )  {  reservedNames  .  add  (  name  )  ;  return  ;  }  if  (  !okToRenameVar  (  name  ,  local  )  )  {  [BUGGY]  return  ;  }  if  (  isExternsPass_  )  {  	Closure_136_RenameVars_1_1	203	0	src/com/google/javascript/jscomp/RenameVars.java
525		[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_MakeDeclaredNamesUnique_15_1	26	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
526	public  static  final  String  ARGUMENTS  = "arguments ";  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_MakeDeclaredNamesUnique_15_2	48	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
527	static  class  ContextualRenameInverter  implements  ScopedCallback,  CompilerPass  {  	[BUGGY]  static  class  ContextualRenameInverter  extends  AbstractPostOrderCallback  implements  CompilerPass  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_MakeDeclaredNamesUnique_15_3	235	2	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
528	private  Set<String>  referencedNames  =  ImmutableSet.of();  private  Deque<Set<String>>  referenceStack  =  new  ArrayDeque<Set<String>>();  private  Map<String,  List<Node>>  nameMap  =  Maps.newHashMap();  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_MakeDeclaredNamesUnique_15_4	240	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
529		[BUGGY]  private  static  String  getOrginalNameInternal  (  String  name  ,  int  index  )  {  return  name  .  substring  (  0  ,  index  )  ;  }  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_MakeDeclaredNamesUnique_15_5	266	3	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
530	public  void  enterScope(NodeTraversal  t)  {  if  (t.inGlobalScope())  {  return;  }  referenceStack.push(referencedNames);  referencedNames  =  Sets.newHashSet();  	[BUGGY]  private  static  String  getNameSuffix  (  String  name  ,  int  index  )  {  return  name  .  substring  (  index  +  ContextualRenamer  .  UNIQUE_ID_SEPARATOR  .  length  (  )  ,  name  .  length  (  )  )  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_MakeDeclaredNamesUnique_15_6	273	4	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
531	public  void  exitScope(NodeTraversal  t)  {  if  (t.inGlobalScope())  {  	[BUGGY]  @Override  public  void  visit  (  NodeTraversal  t  ,  Node  node  ,  Node  parent  )  {  if  (  node  .  getType  (  )  =  =  Token  .  NAME  )  {  String  oldName  =  node  .  getString  (  )  ;  if  (  containsSeparator  (  oldName  )  )  {  Scope  scope  =  t  .  getScope  (  )  ;  Var  var  =  t  .  getScope  (  )  .  getVar  (  oldName  )  ;  if  (  var  =  =  null  ||  var  .  isGlobal  (  )  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_MakeDeclaredNamesUnique_15_7	284	8	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
532	for  (Iterator<Var>  it  =  t.getScope().getVars();  it.hasNext();)  {  Var  v  =  it.next();  handleScopeVar(v);  }  	[BUGGY]  if  (  nameMap  .  containsKey  (  var  )  )  {  node  .  setString  (  nameMap  .  get  (  var  )  )  ;  }  else  {  int  index  =  indexOfSeparator  (  oldName  )  ;  String  newName  =  getOrginalNameInternal  (  oldName  ,  index  )  ;  String  suffix  =  getNameSuffix  (  oldName  ,  index  )  ;  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  node  Node  parent  [CLASS]  ContextualRenameInverter  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  recurseScopes  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  node  parent  parentNode  [TYPE]  String  newName  oldName  suffix  [TYPE]  Map  nameMap  [TYPE]  int  index  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  node  ,  Node  parent  )  {  if  (  node  .  getType  (  )  =  =  Token  .  NAME  )  {  String  oldName  =  node  .  getString  (  )  ;  if  (  containsSeparator  (  oldName  )  )  {  Scope  scope  =  t  .  getScope  (  )  ;  Var  var  =  t  .  getScope  (  )  .  getVar  (  oldName  )  ;  if  (  var  =  =  null  ||  var  .  isGlobal  (  )  )  {  return  ;  }  [BUGGY]  if  (  nameMap  .  containsKey  (  var  )  )  {  node  .  setString  (  nameMap  .  get  (  var  )  )  ;  }  else  {  int  index  =  indexOfSeparator  (  oldName  )  ;  String  newName  =  getOrginalNameInternal  (  oldName  ,  index  )  ;  String  suffix  =  getNameSuffix  (  oldName  ,  index  )  ;  	Closure_137_MakeDeclaredNamesUnique_15_8	295	6	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
533	Set<String>  current  =  referencedNames;  referencedNames  =  referenceStack.pop();\n', "  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  node  Node  parent  [CLASS]  ContextualRenameInverter  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  recurseScopes  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  node  parent  parentNode  [TYPE]  String  newName  oldName  suffix  [TYPE]  Map  nameMap  [TYPE]  int  index  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  node  ,  Node  parent  )  {  if  (  node  .  getType  (  )  =  =  Token  .  NAME  )  {  String  oldName  =  node  .  getString  (  )  ;  if  (  containsSeparator  (  oldName  )  )  {  Scope  scope  =  t  .  getScope  (  )  ;  Var  var  =  t  .  getScope  (  )  .  getVar  (  oldName  )  ;  if  (  var  =  =  null  ||  var  .  isGlobal  (  )  )  {  return  ;  }  if  (  nameMap  .  containsKey  (  var  )  )  {  node  .  setString  (  nameMap  .  get  (  var  )  )  ;  }  else  {  int  index  =  indexOfSeparator  (  oldName  )  ;  String  newName  =  getOrginalNameInternal  (  oldName  ,  index  )  ;  String  suffix  =  getNameSuffix  (  oldName  ,  index  )  ;  [BUGGY]  boolean  recurseScopes  =  false  ;  if  (  !suffix  .  matches  ( "\\d+ "  )  )  {  recurseScopes  =  true  ;  	Closure_137_MakeDeclaredNamesUnique_15_9	304	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
534	if  (!referenceStack.isEmpty())  {  referencedNames.addAll(current);  }  }  	[BUGGY]  boolean  recurseScopes  =  false  ;  if  (  !suffix  .  matches  ( "\\\\d+ "  )  )  {  recurseScopes  =  true  ;  }  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  node  Node  parent  [CLASS]  ContextualRenameInverter  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  recurseScopes  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  node  parent  parentNode  [TYPE]  String  newName  oldName  suffix  [TYPE]  Map  nameMap  [TYPE]  int  index  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  node  ,  Node  parent  )  {  if  (  node  .  getType  (  )  =  =  Token  .  NAME  )  {  String  oldName  =  node  .  getString  (  )  ;  if  (  containsSeparator  (  oldName  )  )  {  Scope  scope  =  t  .  getScope  (  )  ;  Var  var  =  t  .  getScope  (  )  .  getVar  (  oldName  )  ;  if  (  var  =  =  null  ||  var  .  isGlobal  (  )  )  {  return  ;  }  if  (  nameMap  .  containsKey  (  var  )  )  {  node  .  setString  (  nameMap  .  get  (  var  )  )  ;  }  else  {  int  index  =  indexOfSeparator  (  oldName  )  ;  String  newName  =  getOrginalNameInternal  (  oldName  ,  index  )  ;  String  suffix  =  getNameSuffix  (  oldName  ,  index  )  ;  [BUGGY]  boolean  recurseScopes  =  false  ;  if  (  !suffix  .  matches  ( "\\d+ "  )  )  {  recurseScopes  =  true  ;  }  	Closure_137_MakeDeclaredNamesUnique_15_10	307	4	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
535	void  handleScopeVar(Var  v)  {  String  name  =  v.getName();  if  (containsSeparator(name))  {  String  newName  =  getOrginalName(name);  if  (TokenStream.isJSIdentifier(newName)  &&  !referencedNames.contains(newName)  &&  !newName.equals(ARGUMENTS))  {  referencedNames.remove(name);  referencedNames.add(newName);  List<Node>  references  =  nameMap.get(name);  Preconditions.checkState(references  !=  null);  for  (Node  n  :  references)  {  Preconditions.checkState(n.getType()  ==  Token.NAME);  n.setString(newName);  }  nameMap.remove(name);  }  }  @Override  public  boolean  shouldTraverse(NodeTraversal  t,  Node  n,  Node  parent)  {  return  true;  }  @Override  public  void  visit(NodeTraversal  t,  Node  node,  Node  parent)  {  if  (t.inGlobalScope())  {  return;  if  (NodeUtil.isReferenceName(node))  {  String  name  =  node.getString();  referencedNames.add(name);  if  (containsSeparator(name))  {  addCandidateNameReference(name,  node);  	[BUGGY]  if  (  var  .  scope  .  isDeclared  (  newName  ,  recurseScopes  )  ||  !TokenStream  .  isJSIdentifier  (  newName  )  )  {  newName  =  oldName  ;  }  else  {  var  .  scope  .  declare  (  newName  ,  var  .  nameNode  ,  null  ,  null  )  ;  Node  parentNode  =  var  .  getParentNode  (  )  ;  if  (  parentNode  .  getType  (  )  =  =  Token  .  FUNCTION  &&  parentNode  =  =  var  .  scope  .  getRootNode  (  )  )  {  var  .  getNameNode  (  )  .  setString  (  newName  )  ;  }  node  .  setString  (  newName  )  ;  nameMap  .  put  (  var  ,  newName  )  ;  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  node  Node  parent  [CLASS]  ContextualRenameInverter  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  recurseScopes  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  node  parent  parentNode  [TYPE]  String  newName  oldName  suffix  [TYPE]  Map  nameMap  [TYPE]  int  index  [CONTEXT]  return  ;  }  if  (  nameMap  .  containsKey  (  var  )  )  {  node  .  setString  (  nameMap  .  get  (  var  )  )  ;  }  else  {  int  index  =  indexOfSeparator  (  oldName  )  ;  String  newName  =  getOrginalNameInternal  (  oldName  ,  index  )  ;  String  suffix  =  getNameSuffix  (  oldName  ,  index  )  ;  boolean  recurseScopes  =  false  ;  if  (  !suffix  .  matches  ( "\\d+ "  )  )  {  recurseScopes  =  true  ;  }  [BUGGY]  if  (  var  .  scope  .  isDeclared  (  newName  ,  recurseScopes  )  ||  !TokenStream  .  isJSIdentifier  (  newName  )  )  {  newName  =  oldName  ;  }  else  {  var  .  scope  .  declare  (  newName  ,  var  .  nameNode  ,  null  ,  null  )  ;  	Closure_137_MakeDeclaredNamesUnique_15_11	317	13	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
536	private  void  addCandidateNameReference(String  name,  Node  n)  {  List<Node>  nodes  =  nameMap.get(name);  if  (null  ==  nodes)  {  nodes  =  Lists.newLinkedList();  nameMap.put(name,  nodes);  }  nodes.add(n);  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_MakeDeclaredNamesUnique_15_12	346	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
537	if  (!name.equals(ARGUMENTS))  {  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  addDeclaredName  [TYPE]  void  [PARAMETER]  String  name  [CLASS]  ContextualRenamer  [TYPE]  Multiset  nameUsage  [TYPE]  boolean  false  global  true  [TYPE]  String  UNIQUE_ID_SEPARATOR  name  newName  [TYPE]  Map  declarations  [TYPE]  int  id  [CONTEXT]  public  void  addDeclaredName  (  String  name  )  {  [BUGGY]  if  (  global  )  {  reserveName  (  name  )  ;  }  else  {  if  (  !declarations  .  containsKey  (  name  )  )  {  int  id  =  incrementNameCount  (  name  )  ;  String  newName  =  null  ;  if  (  id  !  =  0  )  {  newName  =  getUniqueName  (  name  ,  id  )  ;  }  declarations  .  put  (  name  ,  newName  )  ;  }  }  }  	Closure_137_MakeDeclaredNamesUnique_15_13	392	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
538	}  declarations.put(name,  newName);  	[BUGGY]  declarations  .  put  (  name  ,  newName  )  ;  [FE]  AssertionFailedError:  [METHOD]  addDeclaredName  [TYPE]  void  [PARAMETER]  String  name  [CLASS]  ContextualRenamer  [TYPE]  Multiset  nameUsage  [TYPE]  boolean  false  global  true  [TYPE]  String  UNIQUE_ID_SEPARATOR  name  newName  [TYPE]  Map  declarations  [TYPE]  int  id  [CONTEXT]  public  void  addDeclaredName  (  String  name  )  {  if  (  global  )  {  reserveName  (  name  )  ;  }  else  {  if  (  !declarations  .  containsKey  (  name  )  )  {  int  id  =  incrementNameCount  (  name  )  ;  String  newName  =  null  ;  if  (  id  !  =  0  )  {  newName  =  getUniqueName  (  name  ,  id  )  ;  [BUGGY]  }  declarations  .  put  (  name  ,  newName  )  ;  }  }  }  	Closure_137_MakeDeclaredNamesUnique_15_14	401	1	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
539	Preconditions.checkState(!name.equals(ARGUMENTS));  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  addDeclaredName  [TYPE]  void  [PARAMETER]  String  name  [CLASS]  InlineRenamer  [TYPE]  Supplier  uniqueIdSupplier  [TYPE]  boolean  false  removeConstness  true  [TYPE]  String  idPrefix  name  [TYPE]  Map  declarations  [CONTEXT]  public  void  addDeclaredName  (  String  name  )  {  [BUGGY]  if  (  !declarations  .  containsKey  (  name  )  )  {  declarations  .  put  (  name  ,  getUniqueName  (  name  )  )  ;  }  }  	Closure_137_MakeDeclaredNamesUnique_15_15	462	0	src/com/google/javascript/jscomp/MakeDeclaredNamesUnique.java
540	static  boolean  isReferenceName(Node  n)  {  return  isName(n)  &&  !n.getString().isEmpty()  &&  !isLabelName(n);  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_137_NodeUtil_1_1	1043	0	src/com/google/javascript/jscomp/NodeUtil.java
541		[BUGGY]  removeDuplicateDeclarations  (  root  )  ;  [FE]  AssertionFailedError:  [METHOD]  process  [TYPE]  void  [PARAMETER]  Node  externs  Node  root  [CLASS]  Normalize  [TYPE]  AbstractCompiler  compiler  [TYPE]  MakeDeclaredNamesUnique  renamer  [TYPE]  boolean  CONVERT_WHILE_TO_FOR  MAKE_LOCAL_NAMES_UNIQUE  assertOnChange  checkUserDeclarations  false  true  [TYPE]  Map  constantMap  [TYPE]  NodeTraversal  t  [TYPE]  Node  externs  root  [CONTEXT]  public  void  process  (  Node  externs  ,  Node  root  )  {  NodeTraversal  .  traverse  (  compiler  ,  root  ,  new  NormalizeStatements  (  compiler  ,  assertOnChange  )  )  ;  [BUGGY]  removeDuplicateDeclarations  (  root  )  ;  if  (  MAKE_LOCAL_NAMES_UNIQUE  )  {  MakeDeclaredNamesUnique  renamer  =  new  MakeDeclaredNamesUnique  (  )  ;  NodeTraversal  t  =  new  NodeTraversal  (  compiler  ,  renamer  )  ;  t  .  traverseRoots  (  externs  ,  root  )  ;  }  new  PropogateConstantAnnotations  (  compiler  ,  assertOnChange  )  .  process  (  externs  ,  root  )  ;  }  	Closure_137_Normalize_2_1	82	1	src/com/google/javascript/jscomp/Normalize.java
542	removeDuplicateDeclarations(root);  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  process  [TYPE]  void  [PARAMETER]  Node  externs  Node  root  [CLASS]  Normalize  [TYPE]  AbstractCompiler  compiler  [TYPE]  MakeDeclaredNamesUnique  renamer  [TYPE]  boolean  CONVERT_WHILE_TO_FOR  MAKE_LOCAL_NAMES_UNIQUE  assertOnChange  checkUserDeclarations  false  true  [TYPE]  Map  constantMap  [TYPE]  NodeTraversal  t  [TYPE]  Node  externs  root  [CONTEXT]  public  void  process  (  Node  externs  ,  Node  root  )  {  NodeTraversal  .  traverse  (  compiler  ,  root  ,  new  NormalizeStatements  (  compiler  ,  assertOnChange  )  )  ;  removeDuplicateDeclarations  (  root  )  ;  if  (  MAKE_LOCAL_NAMES_UNIQUE  )  {  MakeDeclaredNamesUnique  renamer  =  new  MakeDeclaredNamesUnique  (  )  ;  NodeTraversal  t  =  new  NodeTraversal  (  compiler  ,  renamer  )  ;  t  .  traverseRoots  (  externs  ,  root  )  ;  }  [BUGGY]  new  PropogateConstantAnnotations  (  compiler  ,  assertOnChange  )  .  process  (  externs  ,  root  )  ;  }  	Closure_137_Normalize_2_2	102	0	src/com/google/javascript/jscomp/Normalize.java
543		[BUGGY]  if  (  paramType  !  =  null  )  {  [FE]  AssertionFailedError:  expected:<Array>  but  was:<null>  [METHOD]  getPreciserScopeKnowingConditionOutcome  [TYPE]  FlowScope  [PARAMETER]  Node  condition  FlowScope  blindScope  boolean  outcome  [CLASS]  ClosureReverseAbstractInterpreter  [TYPE]  Function  restricter  [TYPE]  JSType  paramType  type  [TYPE]  boolean  false  outcome  true  [TYPE]  Visitor  restrictToArrayVisitor  restrictToNotArrayVisitor  restrictToNotObjectVisitor  restrictToObjectVisitor  [TYPE]  Node  callee  condition  left  param  right  [TYPE]  Map  restricters  [TYPE]  FlowScope  blindScope  [CONTEXT]  public  FlowScope  getPreciserScopeKnowingConditionOutcome  (  Node  condition  ,  FlowScope  blindScope  ,  boolean  outcome  )  {  if  (  condition  .  getType  (  )  =  =  CALL  &&  condition  .  getChildCount  (  )  =  =  2  )  {  Node  callee  =  condition  .  getFirstChild  (  )  ;  Node  param  =  condition  .  getLastChild  (  )  ;  if  (  callee  .  getType  (  )  =  =  GETPROP  &&  param  .  isQualifiedName  (  )  )  {  JSType  paramType  =  getTypeIfRefinable  (  param  ,  blindScope  )  ;  [BUGGY]  if  (  paramType  !  =  null  )  {  Node  left  =  callee  .  getFirstChild  (  )  ;  Node  right  =  callee  .  getLastChild  (  )  ;  if  (  left  .  getType  (  )  =  =  NAME  && "goog "  .  equals  (  left  .  getString  (  )  )  &&  right  .  getType  (  )  =  =  STRING  )  {  Function<TypeRestriction  ,  JSType>  restricter  =  restricters  .  get  (  right  .  getString  (  )  )  ;  if  (  restricter  !  =  null  )  {  return  restrictParameter  (  param  ,  paramType  ,  blindScope  ,  restricter  ,  outcome  )  ;  }  }  }  }  }  return  nextPreciserScopeKnowingConditionOutcome  (  condition  ,  blindScope  ,  outcome  )  ;  }  	Closure_138_ClosureReverseAbstractInterpreter_2_1	208	1	src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java
544		[BUGGY]  }  [FE]  AssertionFailedError:  expected:<Array>  but  was:<null>  [METHOD]  getPreciserScopeKnowingConditionOutcome  [TYPE]  FlowScope  [PARAMETER]  Node  condition  FlowScope  blindScope  boolean  outcome  [CLASS]  ClosureReverseAbstractInterpreter  [TYPE]  Function  restricter  [TYPE]  JSType  paramType  type  [TYPE]  boolean  false  outcome  true  [TYPE]  Visitor  restrictToArrayVisitor  restrictToNotArrayVisitor  restrictToNotObjectVisitor  restrictToObjectVisitor  [TYPE]  Node  callee  condition  left  param  right  [TYPE]  Map  restricters  [TYPE]  FlowScope  blindScope  [CONTEXT]  public  FlowScope  getPreciserScopeKnowingConditionOutcome  (  Node  condition  ,  FlowScope  blindScope  ,  boolean  outcome  )  {  if  (  condition  .  getType  (  )  =  =  CALL  &&  condition  .  getChildCount  (  )  =  =  2  )  {  Node  callee  =  condition  .  getFirstChild  (  )  ;  Node  param  =  condition  .  getLastChild  (  )  ;  if  (  callee  .  getType  (  )  =  =  GETPROP  &&  param  .  isQualifiedName  (  )  )  {  JSType  paramType  =  getTypeIfRefinable  (  param  ,  blindScope  )  ;  if  (  paramType  !  =  null  )  {  Node  left  =  callee  .  getFirstChild  (  )  ;  Node  right  =  callee  .  getLastChild  (  )  ;  if  (  left  .  getType  (  )  =  =  NAME  && "goog "  .  equals  (  left  .  getString  (  )  )  &&  right  .  getType  (  )  =  =  STRING  )  {  Function<TypeRestriction  ,  JSType>  restricter  =  restricters  .  get  (  right  .  getString  (  )  )  ;  if  (  restricter  !  =  null  )  {  return  restrictParameter  (  param  ,  paramType  ,  blindScope  ,  restricter  ,  outcome  )  ;  [BUGGY]  }  }  }  }  }  return  nextPreciserScopeKnowingConditionOutcome  (  condition  ,  blindScope  ,  outcome  )  ;  }  	Closure_138_ClosureReverseAbstractInterpreter_2_2	218	1	src/com/google/javascript/jscomp/ClosureReverseAbstractInterpreter.java
545	if  (var  !=  null)  {\n', "    	[BUGGY]  if  (  var  !  =  null  &&  !  (  var  .  isTypeInferred  (  )  &&  unflowableVarNames  .  contains  (  varName  )  )  )  {  [FE]  AssertionFailedError:  expected:<Array>  but  was:<null>  [METHOD]  traverseName  [TYPE]  FlowScope  [PARAMETER]  Node  n  FlowScope  scope  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  Set  unflowableVarNames  [TYPE]  JSType  type  [TYPE]  Node  n  value  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  varName  [TYPE]  Multimap  assignedOuterLocalVars  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  StaticSlot  var  [TYPE]  boolean  false  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  FlowScope  traverseName  (  Node  n  ,  FlowScope  scope  )  {  String  varName  =  n  .  getString  (  )  ;  Node  value  =  n  .  getFirstChild  (  )  ;  JSType  type  =  n  .  getJSType  (  )  ;  if  (  value  !  =  null  )  {  scope  =  traverse  (  value  ,  scope  )  ;  updateScopeForTypeChange  (  scope  ,  n  ,  n  .  getJSType  (  )  /*  could  be  null  */  ,  getJSType  (  value  )  )  ;  return  scope  ;  }  else  {  StaticSlot<JSType>  var  =  scope  .  getSlot  (  varName  )  ;  [BUGGY]  if  (  var  !  =  null  &&  !  (  var  .  isTypeInferred  (  )  &&  unflowableVarNames  .  contains  (  varName  )  )  )  {  	Closure_138_TypeInference_4_1	632	2	src/com/google/javascript/jscomp/TypeInference.java
546	boolean  isInferred  =  var.isTypeInferred();  boolean  unflowable  =  isInferred  &&  unflowableVarNames.contains(varName);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Array>  but  was:<null>  [METHOD]  traverseName  [TYPE]  FlowScope  [PARAMETER]  Node  n  FlowScope  scope  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  Set  unflowableVarNames  [TYPE]  JSType  type  [TYPE]  Node  n  value  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  varName  [TYPE]  Multimap  assignedOuterLocalVars  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  StaticSlot  var  [TYPE]  boolean  false  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  FlowScope  traverseName  (  Node  n  ,  FlowScope  scope  )  {  String  varName  =  n  .  getString  (  )  ;  Node  value  =  n  .  getFirstChild  (  )  ;  JSType  type  =  n  .  getJSType  (  )  ;  if  (  value  !  =  null  )  {  scope  =  traverse  (  value  ,  scope  )  ;  updateScopeForTypeChange  (  scope  ,  n  ,  n  .  getJSType  (  )  /*  could  be  null  */  ,  getJSType  (  value  )  )  ;  return  scope  ;  }  else  {  StaticSlot<JSType>  var  =  scope  .  getSlot  (  varName  )  ;  if  (  var  !  =  null  &&  !  (  var  .  isTypeInferred  (  )  &&  unflowableVarNames  .  contains  (  varName  )  )  )  {  [BUGGY]  type  =  var  .  getType  (  )  ;  	Closure_138_TypeInference_4_2	639	0	src/com/google/javascript/jscomp/TypeInference.java
547	boolean  nonLocalInferredSlot  =  isInferred  &&  syntacticScope.getParent()  !=  null  &&  var  ==  syntacticScope.getParent().getSlot(varName);  if  (!unflowable  &&  !nonLocalInferredSlot)  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Array>  but  was:<null>  [METHOD]  traverseName  [TYPE]  FlowScope  [PARAMETER]  Node  n  FlowScope  scope  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  Set  unflowableVarNames  [TYPE]  JSType  type  [TYPE]  Node  n  value  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  varName  [TYPE]  Multimap  assignedOuterLocalVars  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  StaticSlot  var  [TYPE]  boolean  false  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  FlowScope  traverseName  (  Node  n  ,  FlowScope  scope  )  {  String  varName  =  n  .  getString  (  )  ;  Node  value  =  n  .  getFirstChild  (  )  ;  JSType  type  =  n  .  getJSType  (  )  ;  if  (  value  !  =  null  )  {  scope  =  traverse  (  value  ,  scope  )  ;  updateScopeForTypeChange  (  scope  ,  n  ,  n  .  getJSType  (  )  /*  could  be  null  */  ,  getJSType  (  value  )  )  ;  return  scope  ;  }  else  {  StaticSlot<JSType>  var  =  scope  .  getSlot  (  varName  )  ;  if  (  var  !  =  null  &&  !  (  var  .  isTypeInferred  (  )  &&  unflowableVarNames  .  contains  (  varName  )  )  )  {  [BUGGY]  type  =  var  .  getType  (  )  ;  if  (  type  =  =  null  )  {  type  =  getNativeType  (  UNKNOWN_TYPE  )  ;  }  }  	Closure_138_TypeInference_4_3	643	0	src/com/google/javascript/jscomp/TypeInference.java
548	}  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Array>  but  was:<null>  [METHOD]  traverseName  [TYPE]  FlowScope  [PARAMETER]  Node  n  FlowScope  scope  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  Set  unflowableVarNames  [TYPE]  JSType  type  [TYPE]  Node  n  value  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  varName  [TYPE]  Multimap  assignedOuterLocalVars  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  StaticSlot  var  [TYPE]  boolean  false  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  TEMPLATE_TYPE_NOT_OBJECT_TYPE  TEMPLATE_TYPE_OF_THIS_EXPECTED  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  String  varName  =  n  .  getString  (  )  ;  Node  value  =  n  .  getFirstChild  (  )  ;  JSType  type  =  n  .  getJSType  (  )  ;  if  (  value  !  =  null  )  {  scope  =  traverse  (  value  ,  scope  )  ;  updateScopeForTypeChange  (  scope  ,  n  ,  n  .  getJSType  (  )  /*  could  be  null  */  ,  getJSType  (  value  )  )  ;  return  scope  ;  }  else  {  StaticSlot<JSType>  var  =  scope  .  getSlot  (  varName  )  ;  if  (  var  !  =  null  &&  !  (  var  .  isTypeInferred  (  )  &&  unflowableVarNames  .  contains  (  varName  )  )  )  {  type  =  var  .  getType  (  )  ;  if  (  type  =  =  null  )  {  type  =  getNativeType  (  UNKNOWN_TYPE  )  ;  [BUGGY]  }  }  }  n  .  setJSType  (  type  )  ;  return  scope  ;  }  	Closure_138_TypeInference_4_4	647	0	src/com/google/javascript/jscomp/TypeInference.java
549	case  Token.FUNCTION:  normalizeFunctionDeclaration(n);  break;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  NormalizeStatements  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  assertOnChange  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  expr  n  parent  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  WHILE:  if  (  CONVERT_WHILE_TO_FOR  )  {  Node  expr  =  n  .  getFirstChild  (  )  ;  n  .  setType  (  Token  .  FOR  )  ;  n  .  addChildBefore  (  new  Node  (  Token  .  EMPTY  )  ,  expr  )  ;  n  .  addChildAfter  (  new  Node  (  Token  .  EMPTY  )  ,  expr  )  ;  reportCodeChange  ( "WHILE  node "  )  ;  }  break  ;  [BUGGY]  }  }  	Closure_139_Normalize_4_1	281	0	src/com/google/javascript/jscomp/Normalize.java
550	private  void  normalizeFunctionDeclaration(Node  n)  {  Preconditions.checkState(n.getType()  ==  Token.FUNCTION);  if  (!NodeUtil.isFunctionAnonymous(n)  &&  !NodeUtil.isHoistedFunctionDeclaration(n))  {  rewriteFunctionDeclaration(n);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_139_Normalize_4_2	292	0	src/com/google/javascript/jscomp/Normalize.java
551	private  void  rewriteFunctionDeclaration(Node  n)  {  Node  oldNameNode  =  n.getFirstChild();  Node  fnNameNode  =  oldNameNode.cloneNode();  Node  var  =  new  Node(Token.VAR,  fnNameNode,  n.getLineno(),  n.getCharno());  var.copyInformationFrom(n);  oldNameNode.setString( " ");  Node  parent  =  n.getParent();  parent.replaceChild(n,  var);  fnNameNode.addChildToFront(n);  reportCodeChange( "Function  declaration ");  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_139_Normalize_4_3	309	0	src/com/google/javascript/jscomp/Normalize.java
552	Var  v  =  s.getVar(name);  Preconditions.checkState(  v  ==  null  ||  v.getParentNode().getType()  !=  Token.CATCH);  if  (v  !=  null  &&  parent.getType()  ==  Token.FUNCTION)  {  if  (v.getParentNode().getType()  ==  Token.VAR)  {  s.undeclare(v);  s.declare(name,  n,  n.getJSType(),  v.input);  replaceVarWithAssignment(v.getNameNode(),  v.getParentNode(),  v.getParentNode().getParent());  }  }  else  if  (parent.getType()  ==  Token.VAR)  {  	[BUGGY]  if  (  parent  .  getType  (  )  =  =  Token  .  VAR  )  {  [FE]  AssertionFailedError:  [METHOD]  onRedeclaration  [TYPE]  void  [PARAMETER]  Scope  s  String  name  Node  n  Node  parent  Node  gramps  Node  nodeWithLineNumber  [CLASS]  DuplicateDeclarationHandler  [TYPE]  boolean  false  true  [TYPE]  Scope  s  [TYPE]  Node  gramps  n  nodeWithLineNumber  parent  [TYPE]  String  name  [CONTEXT]  public  void  onRedeclaration  (  Scope  s  ,  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  Node  nodeWithLineNumber  )  {  Preconditions  .  checkState  (  n  .  getType  (  )  =  =  Token  .  NAME  )  ;  [BUGGY]  if  (  parent  .  getType  (  )  =  =  Token  .  VAR  )  {  Preconditions  .  checkState  (  parent  .  hasOneChild  (  )  )  ;  replaceVarWithAssignment  (  n  ,  parent  ,  gramps  )  ;  }  }  	Closure_139_Normalize_4_4	521	1	src/com/google/javascript/jscomp/Normalize.java
553	fillEmptyModules(modules);  	[BUGGY]  [FE]  AssertionFailedError:  compilerreportCodeChange  (  )  was  called  even  though  nothing  changed  [METHOD]  init  [TYPE]  void  [PARAMETER]  JSSourceFile[]  externs  JSModule[]  modules  CompilerOptions  options  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  [TYPE]  CompilerInput[]  externs  inputs  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  DUPLICATE_INPUT_IN_MODULES  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  SymbolTable  symbolTable  [TYPE]  JSModuleGraph  e  moduleGraph  [TYPE]  int  lineCount  uniqueNameId  [TYPE]  boolean  false  normalized  true  useThreads  [TYPE]  State  passConfigState  [TYPE]  JSModule[]  modules  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  JSSourceFile[]  externs  [TYPE]  Map  inputsByName  [CONTEXT]  public  void  init  (  JSSourceFile[]  externs  ,  JSModule[]  modules  ,  CompilerOptions  options  )  {  initOptions  (  options  )  ;  checkFirstModule  (  modules  )  ;  [BUGGY]  this  .  externs  =  makeCompilerInput  (  externs  ,  true  )  ;  this  .  modules  =  modules  ;  try  {  this  .  moduleGraph  =  new  JSModuleGraph  (  modules  )  ;  }  catch  (  JSModuleGraph  .  ModuleDependenceException  e  )  {  report  (  JSError  .  make  (  MODULE_DEPENDENCY_ERROR  ,  e  .  getModule  (  )  .  getName  (  )  ,  e  .  getDependentModule  (  )  .  getName  (  )  )  )  ;  return  ;  }  this  .  inputs  =  getAllInputsFromModules  (  )  ;  initBasedOnOptions  (  )  ;  initInputsByNameMap  (  )  ;  }  	Closure_140_Compiler_3_1	264	0	src/com/google/javascript/jscomp/Compiler.java
554	private  void  fillEmptyModules(JSModule[]  modules)  {  for  (int  i  =  1;  i  <  modules.length;  i  ++)  {  JSModule  module  =  modules[i];  if  (module.getInputs().isEmpty())  {  module.add(JSSourceFile.fromCode( "[ "  +  module.getName()  + "] ", " "));  }  }  }  	[BUGGY]  [FE]  AssertionFailedError:  compilerreportCodeChange  (  )  was  called  even  though  nothing  changed  [CLASS]  [CONTEXT]  	Closure_140_Compiler_3_2	328	0	src/com/google/javascript/jscomp/Compiler.java
555		[BUGGY]  for  (  JSModule  m  :  getModuleGraph  (  )  .  getTransitiveDepsDeepestFirst  (  module  )  )  {  inputs  =  m  .  getInputs  (  )  ;  if  (  inputs  .  size  (  )  >  0  )  {  return  inputs  .  get  (  0  )  .  getAstRoot  (  this  )  ;  }  }  [FE]  AssertionFailedError:  compilerreportCodeChange  (  )  was  called  even  though  nothing  changed  [METHOD]  getNodeForCodeInsertion  [TYPE]  Node  [PARAMETER]  JSModule  module  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  [TYPE]  CompilerInput[]  externs  inputs  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  DUPLICATE_INPUT_IN_MODULES  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  inputs  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  SymbolTable  symbolTable  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  lineCount  uniqueNameId  [TYPE]  boolean  false  normalized  true  useThreads  [TYPE]  State  passConfigState  [TYPE]  JSModule[]  modules  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  JSModule  m  module  [TYPE]  Map  inputsByName  [CONTEXT]  Node  getNodeForCodeInsertion  (  JSModule  module  )  {  if  (  module  =  =  null  )  {  if  (  inputs  .  length  =  =  0  )  {  throw  new  IllegalStateException  ( "No  inputs "  )  ;  }  return  inputs[0]  .  getAstRoot  (  this  )  ;  }  List<CompilerInput>  inputs  =  module  .  getInputs  (  )  ;  if  (  inputs  .  size  (  )  >  0  )  {  return  inputs  .  get  (  0  )  .  getAstRoot  (  this  )  ;  }  [BUGGY]  for  (  JSModule  m  :  getModuleGraph  (  )  .  getTransitiveDepsDeepestFirst  (  module  )  )  {  inputs  =  m  .  getInputs  (  )  ;  if  (  inputs  .  size  (  )  >  0  )  {  return  inputs  .  get  (  0  )  .  getAstRoot  (  this  )  ;  }  }  throw  new  IllegalStateException  ( "Root  module  has  no  inputs "  )  ;  }  	Closure_140_Compiler_3_3	1582	6	src/com/google/javascript/jscomp/Compiler.java
556	case  Token.FUNCTION:  Preconditions.checkState(NodeUtil.isAnonymousFunction(n));  return  false;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<MOVABLE>  but  was:<DECOMPOSABLE>  [METHOD]  canBeSideEffected  [TYPE]  boolean  [PARAMETER]  Node  n  String>  knownConstants  [CLASS]  NodeUtil  [TYPE]  Set  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  knownConstants  [TYPE]  String  CONSTANT_MARKER  name  [TYPE]  boolean  false  true  [TYPE]  Map  vars  [TYPE]  int  type  [TYPE]  Node  c  n  [CONTEXT]  static  boolean  canBeSideEffected  (  Node  n  ,  Set<String>  knownConstants  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  CALL:  case  Token  .  NEW:  return  true  ;  case  Token  .  NAME:  return  !NodeUtil  .  isConstantName  (  n  )  &&  !knownConstants  .  contains  (  n  .  getString  (  )  )  ;  case  Token  .  GETPROP:  case  Token  .  GETELEM:  return  true  ;  [BUGGY]  }  for  (  Node  c  =  n  .  getFirstChild  (  )  ;  c  !  =  null  ;  c  =  c  .  getNext  (  )  )  {  if  (  canBeSideEffected  (  c  ,  knownConstants  )  )  {  return  true  ;  }  }  return  false  ;  }  	Closure_141_NodeUtil_1_1	602	0	src/com/google/javascript/jscomp/NodeUtil.java
557	if  (NodeUtil.isGetProp(name)  ||  NodeUtil.isName(name))  {  	[BUGGY]  if  (  !NodeUtil  .  isGetProp  (  name  )  &&  !NodeUtil  .  isName  (  name  )  )  {  return  null  ;  }  [FE]  AssertionFailedError:  expected:<MOVABLE>  but  was:<DECOMPOSABLE>  [METHOD]  getCallableDefinitions  [TYPE]  Collection  [PARAMETER]  DefinitionProvider  definitionProvider  Node  name  [CLASS]  PureFunctionIdentifier  [TYPE]  AbstractCompiler  compiler  [TYPE]  DefinitionProvider  definitionProvider  [TYPE]  boolean  extern  false  functionThrows  inExterns  pureFunction  taintsGlobalState  taintsThis  taintsUnknown  true  [TYPE]  DiagnosticType  INVALID_NO_SIDE_EFFECT_ANNOTATION  [TYPE]  Node  externs  name  rValue  root  [TYPE]  Definition  current  [TYPE]  Collection  decls  [TYPE]  List  allFunctionCalls  callsInFunctionBody  result  [TYPE]  Map  functionSideEffectMap  [CONTEXT]  private  static  Collection<Definition>  getCallableDefinitions  (  DefinitionProvider  definitionProvider  ,  Node  name  )  {  [BUGGY]  List<Definition>  result  =  Lists  .  newArrayList  (  )  ;  if  (  !NodeUtil  .  isGetProp  (  name  )  &&  !NodeUtil  .  isName  (  name  )  )  {  return  null  ;  }  Collection<Definition>  decls  =  definitionProvider  .  getDefinitionsReferencedAt  (  name  )  ;  if  (  decls  =  =  null  )  {  return  null  ;  }  for  (  Definition  current  :  decls  )  {  Node  rValue  =  current  .  getRValue  (  )  ;  if  (  (  rValue  !  =  null  )  &&  NodeUtil  .  isFunction  (  rValue  )  )  {  result  .  add  (  current  )  ;  }  else  {  return  null  ;  }  }  return  result  ;  }  	Closure_141_PureFunctionIdentifier_2_1	177	3	src/com/google/javascript/jscomp/PureFunctionIdentifier.java
558	}  else  if  (name.getType()  ==  Token.OR  ||  name.getType()  ==  Token.HOOK)  {  Node  firstVal;  if  (name.getType()  ==  Token.HOOK)  {  firstVal  =  name.getFirstChild().getNext();  }  else  {  firstVal  =  name.getFirstChild();  }  Collection<Definition>  defs1  =  getCallableDefinitions(definitionProvider,  firstVal);  Collection<Definition>  defs2  =  getCallableDefinitions(definitionProvider,  firstVal.getNext());  if  (defs1  !=  null  &&  defs2  !=  null)  {  defs1.addAll(defs2);  return  defs1;  }  else  {  return  null;  }  }  else  {  return  null;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<MOVABLE>  but  was:<DECOMPOSABLE>  [CLASS]  [CONTEXT]  	Closure_141_PureFunctionIdentifier_2_2	198	0	src/com/google/javascript/jscomp/PureFunctionIdentifier.java
559	if  (scope.getRootNode().getFirstChild().getNext().getChildCount()  ==  2)  {  liveness.markAllParametersEscaped();  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  enterScope  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  CoalesceVariableNames  [TYPE]  UndiGraph  interferenceGraph  [TYPE]  NodeTraversal  t  [TYPE]  GraphColoring  coloring  [TYPE]  Var  def  use  [TYPE]  ArrayList  callbacks  [TYPE]  LiveRangeChecker  callback1  callback2  [TYPE]  Deque  colorings  [TYPE]  Comparator  coloringTieBreaker  [TYPE]  LiveVariablesAnalysis  liveness  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  crossed  defFound  false  true  usePseudoNames  [TYPE]  Scope  scope  [TYPE]  ControlFlowGraph  cfg  [CONTEXT]  public  void  enterScope  (  NodeTraversal  t  )  {  Scope  scope  =  t  .  getScope  (  )  ;  if  (  scope  .  isGlobal  (  )  )  {  return  ;  }  ControlFlowGraph<Node>  cfg  =  t  .  getControlFlowGraph  (  )  ;  LiveVariablesAnalysis  liveness  =  new  LiveVariablesAnalysis  (  cfg  ,  scope  ,  compiler  )  ;  [BUGGY]  liveness  .  analyze  (  )  ;  UndiGraph<Var  ,  Void>  interferenceGraph  =  computeVariableNamesInterferenceGraph  (  t  ,  cfg  ,  liveness  .  getEscapedLocals  (  )  )  ;  GraphColoring<Var  ,  Void>  coloring  =  new  GreedyGraphColoring<Var  ,  Void>  (  interferenceGraph  ,  coloringTieBreaker  )  ;  coloring  .  color  (  )  ;  colorings  .  push  (  coloring  )  ;  }  	Closure_142_CoalesceVariableNames_1_1	108	0	src/com/google/javascript/jscomp/CoalesceVariableNames.java
560	if  (!(option  ==  WhitespaceOption.PRESERVE  &&  token  ==  JsDocToken.ANNOTATION))  {  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  extractMultilineTextualBlock  [TYPE]  JsDocInfoParser$ExtractionInfo  [PARAMETER]  JsDocToken  token  WhitespaceOption  option  [CLASS]  JsDocInfoParser  [TYPE]  StringBuilder  builder  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  line  multilineText  sourceName  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  endCharno  endLineno  startCharno  startLineno  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  ignoreStar  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  Map  annotationNames  [CONTEXT]  if  (  !ignoreStar  )  {  if  (  builder  .  length  (  )  >  0  )  {  builder  .  append  (  '  '  )  ;  }  builder  .  append  (  '*'  )  ;  }  token  =  next  (  )  ;  continue  ;  case  EOL:  if  (  option  !  =  WhitespaceOption  .  SINGLE_LINE  )  {  builder  .  append  ( "\n "  )  ;  }  ignoreStar  =  true  ;  token  =  next  (  )  ;  continue  ;  case  ANNOTATION:  case  EOC:  case  EOF:  [BUGGY]  String  multilineText  =  builder  .  toString  (  )  ;  if  (  option  !  =  WhitespaceOption  .  PRESERVE  )  {  multilineText  =  multilineText  .  trim  (  )  ;  }  	Closure_142_JsDocInfoParser_2_1	1168	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
561	}  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  extractMultilineTextualBlock  [TYPE]  JsDocInfoParser$ExtractionInfo  [PARAMETER]  JsDocToken  token  WhitespaceOption  option  [CLASS]  JsDocInfoParser  [TYPE]  StringBuilder  builder  [TYPE]  JsDocTokenStream  stream  [TYPE]  FileLevelJsDocBuilder  fileLevelJsDocBuilder  [TYPE]  String  line  multilineText  sourceName  string  [TYPE]  JSDocInfo  fileOverviewJSDocInfo  [TYPE]  int  endCharno  endLineno  startCharno  startLineno  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  errorReporter  [TYPE]  boolean  false  ignoreStar  true  [TYPE]  JsDocToken  NO_UNREAD_TOKEN  token  unreadToken  [TYPE]  WhitespaceOption  PRESERVE  SINGLE_LINE  TRIM  option  [TYPE]  ErrorReporterParser  parser  [TYPE]  State  NEXT_IS_ANNOTATION  SEARCHING_ANNOTATION  SEARCHING_NEWLINE  state  [TYPE]  JSDocInfoBuilder  jsdocBuilder  [TYPE]  Map  annotationNames  [CONTEXT]  ignoreStar  =  true  ;  token  =  next  (  )  ;  continue  ;  case  ANNOTATION:  case  EOC:  case  EOF:  String  multilineText  =  builder  .  toString  (  )  ;  if  (  option  !  =  WhitespaceOption  .  PRESERVE  )  {  multilineText  =  multilineText  .  trim  (  )  ;  }  int  endLineno  =  stream  .  getLineno  (  )  ;  int  endCharno  =  stream  .  getCharno  (  )  ;  if  (  multilineText  .  length  (  )  >  0  )  {  jsdocBuilder  .  markText  (  multilineText  ,  startLineno  ,  startCharno  ,  endLineno  ,  endCharno  )  ;  }  return  new  ExtractionInfo  (  multilineText  ,  token  )  ;  [BUGGY]  default:  ignoreStar  =  false  ;  state  =  State  .  SEARCHING_ANNOTATION  ;  	Closure_142_JsDocInfoParser_2_2	1183	0	src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java
562	||  (defValue.charAt(0)  ==  \'\\ "\'  &&  defValue.charAt(defValue.length()  -  1)  ==  \'\\ "\')))  {  	[BUGGY]  [FE]  RuntimeException:  --define  flag  syntax  invalid:  FOO  = "x  [METHOD]  createDefineReplacements  [TYPE]  void  [PARAMETER]  String>  definitions  CompilerOptions  options  [CLASS]  AbstractCommandLineRunner  [TYPE]  PrintStream  err  out  [TYPE]  A  compiler  [TYPE]  Charset  inputCharset  [TYPE]  NumberFormatException  e  [TYPE]  String  charset  createSourceMap  defName  defValue  jsOutputFile  loggingLevel  maybeStringVal  moduleOutputPathPrefix  outputWrapper  outputWrapperMarker  override  propertyMapInputFile  propertyMapOutputFile  variableMapInputFile  variableMapOutputFile  [TYPE]  String[]  assignment  [TYPE]  int  NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER  summaryDetailLevel  [TYPE]  long  bestRunTime  lastStartTime  serialVersionUID  worstRunTime  [TYPE]  boolean  computePhaseOrdering  createNameMapFiles  false  printAst  printPassGraph  printTree  true  [TYPE]  RunTimeStats  runTimeStats  [TYPE]  CodingConvention  codingConvention  [TYPE]  CommandLineConfig  config  [TYPE]  CompilerOptions  options  [TYPE]  List  define  definitions  externs  js  jscompError  jscompOff  jscompWarning  loopedPassesInBestRun  module  moduleWrapper  [TYPE]  DevMode  jscompDevMode  [CONTEXT]  static  void  createDefineReplacements  (  List<String>  definitions  ,  CompilerOptions  options  )  {  for  (  String  override  :  definitions  )  {  String[]  assignment  =  override  .  split  ( "  = "  ,  2  )  ;  String  defName  =  assignment[0]  ;  if  (  defName  .  length  (  )  >  0  )  {  if  (  assignment  .  length  =  =  1  )  {  options  .  setDefineToBooleanLiteral  (  defName  ,  true  )  ;  continue  ;  }  else  {  String  defValue  =  assignment[1]  ;  if  (  defValue  .  equals  ( "true "  )  )  {  options  .  setDefineToBooleanLiteral  (  defName  ,  true  )  ;  continue  ;  }  else  if  (  defValue  .  equals  ( "false "  )  )  {  options  .  setDefineToBooleanLiteral  (  defName  ,  false  )  ;  continue  ;  }  else  if  (  defValue  .  length  (  )  >  1  &&  (  (  defValue  .  charAt  (  0  )  =  =  '\''  &&  defValue  .  charAt  (  defValue  .  length  (  )  -  1  )  =  =  '\''  )  [BUGGY]  )  )  {  String  maybeStringVal  =  defValue  .  substring  (  1  ,  defValue  .  length  (  )  -  1  )  ;  if  (  maybeStringVal  .  indexOf  (  defValue  .  charAt  (  0  )  )  =  =  -1  )  {  	Closure_143_AbstractCommandLineRunner_1_1	871	0	src/com/google/javascript/jscomp/AbstractCommandLineRunner.java
563	||  exprBody.getType()  ==  Token.NEW  ||  exprBody.getType()  ==  Token.CALL)  {  	[BUGGY]  )  {  [FE]  RuntimeException:  --define  flag  syntax  invalid:  FOO  = "x  [METHOD]  trySimplify  [TYPE]  void  [PARAMETER]  Node  parent  Node  node  [CLASS]  RemoveConstantRValuesCallback  [TYPE]  boolean  false  true  [TYPE]  AstChangeProxy  changeProxy  [TYPE]  Result  result  [TYPE]  Node  exprBody  node  parent  [CONTEXT]  private  void  trySimplify  (  Node  parent  ,  Node  node  )  {  if  (  node  .  getType  (  )  !  =  Token  .  EXPR_RESULT  )  {  return  ;  }  Node  exprBody  =  node  .  getFirstChild  (  )  ;  if  (  !NodeUtil  .  nodeTypeMayHaveSideEffects  (  exprBody  )  [BUGGY]  )  {  changeProxy  .  replaceWith  (  parent  ,  node  ,  getSideEffectNodes  (  exprBody  )  )  ;  }  }  	Closure_143_RemoveConstantExpressions_1_1	91	1	src/com/google/javascript/jscomp/RemoveConstantExpressions.java
564	private  boolean  returnTypeInferred  =  false;  	[BUGGY]  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [CLASS]  [CONTEXT]  	Closure_144_FunctionTypeBuilder_4_1	74	0	src/com/google/javascript/jscomp/FunctionTypeBuilder.java
565	info.getReturnType().evaluate(scope,  typeRegistry)  :  null;  returnType  !=  null  &&  	[BUGGY]  info  .  getReturnType  (  )  .  evaluate  (  scope  ,  typeRegistry  )  :  typeRegistry  .  getNativeType  (  UNKNOWN_TYPE  )  ;  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [METHOD]  inferReturnType  [TYPE]  FunctionTypeBuilder  [PARAMETER]  JSDocInfo  info  [CLASS]  FunctionTypeBuilder  [TYPE]  ObjectType  baseType  thisType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  JSType  returnType  [TYPE]  boolean  false  isConstructor  isInterface  true  [TYPE]  Scope  scope  [TYPE]  DiagnosticType  EXTENDS_NON_OBJECT  EXTENDS_WITHOUT_TYPEDEF  IMPLEMENTS_WITHOUT_CONSTRUCTOR  INEXISTANT_PARAM  OPTIONAL_ARG_AT_END  TEMPLATE_TYPE_DUPLICATED  TEMPLATE_TYPE_EXPECTED  TYPE_REDEFINITION  VAR_ARGS_MUST_BE_LAST  [TYPE]  CodingConvention  codingConvention  [TYPE]  Node  errorRoot  parametersNode  sourceNode  [TYPE]  List  implementedInterfaces  [TYPE]  String  fnName  sourceName  templateTypeName  [TYPE]  JSDocInfo  info  [CONTEXT]  FunctionTypeBuilder  inferReturnType  (  @Nullable  JSDocInfo  info  )  {  returnType  =  info  !  =  null  &&  info  .  hasReturnType  (  )  ?  [BUGGY]  info  .  getReturnType  (  )  .  evaluate  (  scope  ,  typeRegistry  )  :  typeRegistry  .  getNativeType  (  UNKNOWN_TYPE  )  ;  if  (  templateTypeName  !  =  null  &&  returnType  .  restrictByNotNullOrUndefined  (  )  .  isTemplateType  (  )  )  {  reportError  (  TEMPLATE_TYPE_EXPECTED  ,  fnName  )  ;  }  return  this  ;  }  	Closure_144_FunctionTypeBuilder_4_2	200	2	src/com/google/javascript/jscomp/FunctionTypeBuilder.java
566	FunctionTypeBuilder  inferReturnStatements(@Nullable  Node  functionBlock)  {  if  (functionBlock  ==  null  ||  compiler.getInput(sourceName).isExtern())  {  return  this;  }  Preconditions.checkArgument(functionBlock.getType()  ==  Token.BLOCK);  if  (returnType  ==  null)  {  boolean  hasNonEmptyReturns  =  false;  List<Node>  worklist  =  Lists.newArrayList(functionBlock);  while  (!worklist.isEmpty())  {  Node  current  =  worklist.remove(worklist.size()  -  1);  int  cType  =  current.getType();  if  (cType  ==  Token.RETURN  &&  current.getFirstChild()  !=  null  ||  cType  ==  Token.THROW)  {  hasNonEmptyReturns  =  true;  break;  }  else  if  (NodeUtil.isStatementBlock(current)  ||  NodeUtil.isControlStructure(current))  {  for  (Node  child  =  current.getFirstChild();  child  !=  null;  child  =  child.getNext())  {  worklist.add(child);  }  }  }  if  (!hasNonEmptyReturns)  {  returnType  =  typeRegistry.getNativeType(VOID_TYPE);  returnTypeInferred  =  true;  }  }  return  this;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [CLASS]  [CONTEXT]  	Closure_144_FunctionTypeBuilder_4_3	213	0	src/com/google/javascript/jscomp/FunctionTypeBuilder.java
567	.withReturnType(returnType,  returnTypeInferred)  	[BUGGY]  .  withReturnType  (  returnType  )  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [METHOD]  buildAndRegister  [TYPE]  FunctionType  [PARAMETER]  [CLASS]  FunctionTypeBuilder  [TYPE]  ObjectType  baseType  thisType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  JSType  returnType  [TYPE]  boolean  false  isConstructor  isInterface  true  [TYPE]  Scope  scope  [TYPE]  DiagnosticType  EXTENDS_NON_OBJECT  EXTENDS_WITHOUT_TYPEDEF  IMPLEMENTS_WITHOUT_CONSTRUCTOR  INEXISTANT_PARAM  OPTIONAL_ARG_AT_END  TEMPLATE_TYPE_DUPLICATED  TEMPLATE_TYPE_EXPECTED  TYPE_REDEFINITION  VAR_ARGS_MUST_BE_LAST  [TYPE]  CodingConvention  codingConvention  [TYPE]  Node  errorRoot  parametersNode  sourceNode  [TYPE]  FunctionType  fnType  [TYPE]  List  implementedInterfaces  [TYPE]  String  fnName  sourceName  templateTypeName  [CONTEXT]  FunctionType  buildAndRegister  (  )  {  if  (  returnType  =  =  null  )  {  returnType  =  typeRegistry  .  getNativeType  (  UNKNOWN_TYPE  )  ;  }  if  (  parametersNode  =  =  null  )  {  throw  new  IllegalStateException  ( "All  Function  types  must  have  params  and  a  return  type "  )  ;  }  FunctionType  fnType  ;  if  (  isConstructor  )  {  fnType  =  getOrCreateConstructor  (  )  ;  }  else  if  (  isInterface  )  {  fnType  =  typeRegistry  .  createInterfaceType  (  fnName  ,  sourceNode  )  ;  if  (  scope  .  isGlobal  (  )  &&  !fnName  .  isEmpty  (  )  )  {  typeRegistry  .  declareType  (  fnName  ,  fnType  .  getInstanceType  (  )  )  ;  }  maybeSetBaseType  (  fnType  )  ;  }  else  {  fnType  =  new  FunctionBuilder  (  typeRegistry  )  .  withName  (  fnName  )  .  withSourceNode  (  sourceNode  )  .  withParamsNode  (  parametersNode  )  [BUGGY]  .  withReturnType  (  returnType  )  .  withTypeOfThis  (  thisType  )  .  withTemplateName  (  templateTypeName  )  .  build  (  )  ;  maybeSetBaseType  (  fnType  )  ;  }  	Closure_144_FunctionTypeBuilder_4_4	496	1	src/com/google/javascript/jscomp/FunctionTypeBuilder.java
568	Node  fnBlock  =  isFnLiteral  ?  parametersNode.getNext()  :  null;  	[BUGGY]  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [METHOD]  getFunctionType  [TYPE]  FunctionType  [PARAMETER]  String  name  Node  rValue  JSDocInfo  info  Node  lvalueNode  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  ownerType  [TYPE]  boolean  false  isFnLiteral  true  [TYPE]  JSType  type  [TYPE]  Scope  scope  [TYPE]  Var  var  [TYPE]  Node  errorRoot  fnRoot  lvalueNode  owner  parametersNode  rValue  [TYPE]  FunctionType  functionType  propType  [TYPE]  List  deferredSetTypes  [TYPE]  String  name  propName  sourceName  [TYPE]  JSDocInfo  info  [CONTEXT]  FunctionType  functionType  =  null  ;  if  (  rValue  !  =  null  &&  rValue  .  isQualifiedName  (  )  )  {  Var  var  =  scope  .  getVar  (  rValue  .  getQualifiedName  (  )  )  ;  if  (  var  !  =  null  &&  var  .  getType  (  )  instanceof  FunctionType  )  {  functionType  =  (  FunctionType  )  var  .  getType  (  )  ;  if  (  functionType  !  =  null  &&  functionType  .  isConstructor  (  )  )  {  typeRegistry  .  declareType  (  name  ,  functionType  .  getInstanceType  (  )  )  ;  }  }  return  functionType  ;  }  Node  owner  =  null  ;  if  (  lvalueNode  !  =  null  )  {  owner  =  getPrototypePropertyOwner  (  lvalueNode  )  ;  }  Node  errorRoot  =  rValue  =  =  null  ?  lvalueNode  :  rValue  ;  boolean  isFnLiteral  =  rValue  !  =  null  &&  rValue  .  getType  (  )  =  =  Token  .  FUNCTION  ;  Node  fnRoot  =  isFnLiteral  ?  rValue  :  null  ;  Node  parametersNode  =  isFnLiteral  ?  rValue  .  getFirstChild  (  )  .  getNext  (  )  :  null  ;  [BUGGY]  if  (  functionType  =  =  null  &&  info  !  =  null  &&  info  .  hasType  (  )  )  {  JSType  type  =  info  .  getType  (  )  .  evaluate  (  scope  ,  typeRegistry  )  ;  type  =  type  .  restrictByNotNullOrUndefined  (  )  ;  	Closure_144_TypedScopeCreator_3_1	577	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
569	.inferReturnStatements(fnBlock)  	[BUGGY]  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [METHOD]  getFunctionType  [TYPE]  FunctionType  [PARAMETER]  String  name  Node  rValue  JSDocInfo  info  Node  lvalueNode  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  ownerType  [TYPE]  boolean  false  isFnLiteral  true  [TYPE]  JSType  type  [TYPE]  Scope  scope  [TYPE]  Var  var  [TYPE]  Node  errorRoot  fnRoot  lvalueNode  owner  parametersNode  rValue  [TYPE]  FunctionType  functionType  propType  [TYPE]  List  deferredSetTypes  [TYPE]  String  name  propName  sourceName  [TYPE]  JSDocInfo  info  [CONTEXT]  if  (  lvalueNode  !  =  null  &&  lvalueNode  .  getType  (  )  =  =  Token  .  GETPROP  &&  lvalueNode  .  isQualifiedName  (  )  )  {  Var  var  =  scope  .  getVar  (  lvalueNode  .  getFirstChild  (  )  .  getQualifiedName  (  )  )  ;  if  (  var  !  =  null  )  {  ObjectType  ownerType  =  ObjectType  .  cast  (  var  .  getType  (  )  )  ;  FunctionType  propType  =  null  ;  if  (  ownerType  !  =  null  )  {  String  propName  =  lvalueNode  .  getLastChild  (  )  .  getString  (  )  ;  propType  =  findOverriddenFunction  (  ownerType  ,  propName  )  ;  }  if  (  propType  !  =  null  )  {  functionType  =  new  FunctionTypeBuilder  (  name  ,  compiler  ,  errorRoot  ,  sourceName  ,  scope  )  .  setSourceNode  (  fnRoot  )  .  inferFromOverriddenFunction  (  propType  ,  parametersNode  )  .  inferThisType  (  info  ,  owner  )  [BUGGY]  .  buildAndRegister  (  )  ;  }  }  }  }  }  //  end  if  (  functionType  =  =  null  )  	Closure_144_TypedScopeCreator_3_2	617	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
570	.inferReturnStatements(fnBlock)  	[BUGGY]  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [METHOD]  getFunctionType  [TYPE]  FunctionType  [PARAMETER]  String  name  Node  rValue  JSDocInfo  info  Node  lvalueNode  [CLASS]  AbstractScopeBuilder  [TYPE]  ObjectType  ownerType  [TYPE]  boolean  false  isFnLiteral  true  [TYPE]  JSType  type  [TYPE]  Scope  scope  [TYPE]  Var  var  [TYPE]  Node  errorRoot  fnRoot  lvalueNode  owner  parametersNode  rValue  [TYPE]  FunctionType  functionType  propType  [TYPE]  List  deferredSetTypes  [TYPE]  String  name  propName  sourceName  [TYPE]  JSDocInfo  info  [CONTEXT]  if  (  propType  !  =  null  )  {  functionType  =  new  FunctionTypeBuilder  (  name  ,  compiler  ,  errorRoot  ,  sourceName  ,  scope  )  .  setSourceNode  (  fnRoot  )  .  inferFromOverriddenFunction  (  propType  ,  parametersNode  )  .  inferThisType  (  info  ,  owner  )  .  buildAndRegister  (  )  ;  }  }  }  }  }  //  end  if  (  functionType  =  =  null  )  if  (  functionType  =  =  null  )  {  functionType  =  new  FunctionTypeBuilder  (  name  ,  compiler  ,  errorRoot  ,  sourceName  ,  scope  )  .  setSourceNode  (  fnRoot  )  .  inferTemplateTypeName  (  info  )  .  inferReturnType  (  info  )  .  inferInheritance  (  info  )  .  inferThisType  (  info  ,  owner  )  .  inferParameterTypes  (  parametersNode  ,  info  )  [BUGGY]  .  buildAndRegister  (  )  ;  }  if  (  rValue  !  =  null  )  {  setDeferredType  (  rValue  ,  functionType  )  ;  	Closure_144_TypedScopeCreator_3_3	634	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
571	this.returnType  =  returnType;  this.inferredReturnType  =  inferred;  return  this;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [CLASS]  [CONTEXT]  	Closure_144_FunctionBuilder_1_1	101	0	src/com/google/javascript/rhino/jstype/FunctionBuilder.java
572	registry,  null,  source,  	[BUGGY]  registry  ,  null  ,  null  ,  [FE]  ComparisonFailure:  expected:</**  assertTypeAnnotations  ( "/**  @constructor  */  var  Foo  =  function  (  )  {} "  ,  [METHOD]  cloneWithNewReturnType  [TYPE]  FunctionType  [PARAMETER]  JSType  newReturnType  boolean  inferred  [CLASS]  FunctionType  [TYPE]  ObjectType  typeOfThis  [TYPE]  JSType  newReturnType  [TYPE]  boolean  false  inferred  true  [TYPE]  FunctionPrototypeType  prototype  [TYPE]  Kind  CONSTRUCTOR  INTERFACE  ORDINARY  kind  [TYPE]  Node  source  [TYPE]  ArrowType  call  [TYPE]  List  implementedInterfaces  subTypes  [TYPE]  String  templateTypeName  [TYPE]  long  serialVersionUID  [CONTEXT]  FunctionType  cloneWithNewReturnType  (  JSType  newReturnType  ,  boolean  inferred  )  {  return  new  FunctionType  (  [BUGGY]  registry  ,  null  ,  null  ,  new  ArrowType  (  registry  ,  call  .  parameters  ,  newReturnType  ,  inferred  )  ,  typeOfThis  ,  null  ,  false  ,  false  )  ;  }  	Closure_144_FunctionType_1_1	517	1	src/com/google/javascript/rhino/jstype/FunctionType.java
573	if  (n.getType()  ==  Token.LABEL)  {  Node  labeledStatement  =  n.getLastChild();  if  (labeledStatement.getType()  !=  Token.BLOCK)  {  return  isOneExactlyFunctionOrDo(labeledStatement);  }  else  {  	[BUGGY]  [FE]  ComparisonFailure:  expected:<if  (  e1  )  [{A:function  goo  (  )  {return  true}]}>  but  was:<if  (  e1  )  [A:function  goo  (  )  {return  true]}>  assertPrint  ( "if  (  e1  )  A:function  goo  (  )  {return  true} "  ,  [METHOD]  isOneExactlyFunctionOrDo  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  [TYPE]  CodeConsumer  cc  [TYPE]  boolean  false  true  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  char[]  HEX_CHARS  [TYPE]  Node  n  [CONTEXT]  private  boolean  isOneExactlyFunctionOrDo  (  Node  n  )  {  [BUGGY]  return  (  n  .  getType  (  )  =  =  Token  .  FUNCTION  ||  n  .  getType  (  )  =  =  Token  .  DO  )  ;  }  	Closure_145_CodeGenerator_2_1	709	0	src/com/google/javascript/jscomp/CodeGenerator.java
574	if  (getNonEmptyChildCount(n,  2)  ==  1)  {  return  isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));  }  else  {  }  }  }  else  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<if  (  e1  )  [{A:function  goo  (  )  {return  true}]}>  but  was:<if  (  e1  )  [A:function  goo  (  )  {return  true]}>  assertPrint  ( "if  (  e1  )  A:function  goo  (  )  {return  true} "  ,  [METHOD]  isOneExactlyFunctionOrDo  [TYPE]  boolean  [PARAMETER]  Node  n  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  [TYPE]  CodeConsumer  cc  [TYPE]  boolean  false  true  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  char[]  HEX_CHARS  [TYPE]  Node  n  [CONTEXT]  private  boolean  isOneExactlyFunctionOrDo  (  Node  n  )  {  [BUGGY]  return  (  n  .  getType  (  )  =  =  Token  .  FUNCTION  ||  n  .  getType  (  )  =  =  Token  .  DO  )  ;  }  	Closure_145_CodeGenerator_2_2	712	0	src/com/google/javascript/jscomp/CodeGenerator.java
575	JSType  noType  =  getNativeType(JSTypeNative.NO_TYPE);  return  new  TypePair(noType,  noType);  	[BUGGY]  return  new  TypePair  (  null  ,  null  )  ;  [FE]  AssertionFailedError:  expected:<None>  but  was:<undefined>  [METHOD]  getTypesUnderInequality  [TYPE]  JSType$TypePair  [PARAMETER]  JSType  that  [CLASS]  JSType  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  resolved  true  [TYPE]  JSType  resolveResult  that  typeA  typeB  [TYPE]  String  EMPTY_TYPE_COMPONENT  NOT_A_CLASS  NOT_A_TYPE  UNKNOWN_NAME  [TYPE]  TypePair  p  [TYPE]  long  serialVersionUID  [TYPE]  int  ENUMDECL  NOT_ENUMDECL  [TYPE]  Comparator  ALPHA  [CONTEXT]  public  TypePair  getTypesUnderInequality  (  JSType  that  )  {  if  (  that  instanceof  UnionType  )  {  TypePair  p  =  that  .  getTypesUnderInequality  (  this  )  ;  return  new  TypePair  (  p  .  typeB  ,  p  .  typeA  )  ;  }  switch  (  this  .  testForEquality  (  that  )  )  {  case  TRUE:  [BUGGY]  return  new  TypePair  (  null  ,  null  )  ;  case  FALSE:  case  UNKNOWN:  return  new  TypePair  (  this  ,  that  )  ;  }  throw  new  IllegalStateException  (  )  ;  }  	Closure_146_JSType_1_1	706	1	src/com/google/javascript/rhino/jstype/JSType.java
576	pType  ==  Token.ASSIGN  ||  pType  ==  Token.OBJECTLIT))  {  	[BUGGY]  pType  =  =  Token  .  ASSIGN  )  )  {  [FE]  AssertionFailedError:  There  should  be  one  error  expected:<1>  but  was:<0>  [METHOD]  shouldTraverse  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  CheckGlobalThis  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  GLOBAL_THIS  [TYPE]  CheckLevel  level  [TYPE]  Node  assignLhsChild  lhs  llhs  n  parent  rhs  [TYPE]  JSDocInfo  jsDoc  [TYPE]  int  pType  [CONTEXT]  public  boolean  shouldTraverse  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  JSDocInfo  jsDoc  =  getFunctionJsDocInfo  (  n  )  ;  if  (  jsDoc  !  =  null  &&  (  jsDoc  .  isConstructor  (  )  ||  jsDoc  .  isInterface  (  )  ||  jsDoc  .  hasThisType  (  )  ||  jsDoc  .  isOverride  (  )  )  )  {  return  false  ;  }  int  pType  =  parent  .  getType  (  )  ;  if  (  !  (  pType  =  =  Token  .  BLOCK  ||  pType  =  =  Token  .  SCRIPT  ||  pType  =  =  Token  .  NAME  ||  [BUGGY]  pType  =  =  Token  .  ASSIGN  )  )  {  return  false  ;  }  }  if  (  parent  !  =  null  &&  parent  .  getType  (  )  =  =  Token  .  ASSIGN  )  {  	Closure_147_CheckGlobalThis_1_1	108	1	src/com/google/javascript/jscomp/CheckGlobalThis.java
577	for  (Node  next  =  block.getFirstChild();  next  !=  null  &&  NodeUtil.isFunctionDeclaration(next);  next  =  next.getNext())  {  insertionPoint  =  next;  }  	[BUGGY]  [FE]  AssertionFailedError:  There  should  be  one  error  expected:<1>  but  was:<0>  [METHOD]  visitFunction  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  AddChecks  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  block  checkNode  insertionPoint  n  paramName  paramType  [TYPE]  FunctionType  funType  [CONTEXT]  private  void  visitFunction  (  NodeTraversal  t  ,  Node  n  )  {  FunctionType  funType  =  (  FunctionType  )  n  .  getJSType  (  )  ;  Node  block  =  n  .  getLastChild  (  )  ;  Node  paramName  =  NodeUtil  .  getFnParameters  (  n  )  .  getFirstChild  (  )  ;  Node  insertionPoint  =  null  ;  [BUGGY]  for  (  Node  paramType  :  funType  .  getParameters  (  )  )  {  if  (  paramName  =  =  null  )  {  return  ;  }  	Closure_147_RuntimeTypeCheck_1_1	247	0	src/com/google/javascript/jscomp/RuntimeTypeCheck.java
578	case  Token.VOID:  typeNameString  = "undefined ";  break;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  tryFoldTypeof  [TYPE]  Node  [PARAMETER]  Node  originalTypeofNode  [CLASS]  PeepholeFoldConstants  [TYPE]  String  typeNameString  [TYPE]  boolean  false  true  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  DIVIDE_BY_0_ERROR  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double  MAX_FOLD_NUMBER  [TYPE]  Node  argumentNode  newNode  originalTypeofNode  [CONTEXT]  Preconditions  .  checkArgument  (  originalTypeofNode  .  getType  (  )  =  =  Token  .  TYPEOF  )  ;  Node  argumentNode  =  originalTypeofNode  .  getFirstChild  (  )  ;  if  (  argumentNode  =  =  null  ||  !NodeUtil  .  isLiteralValue  (  argumentNode  )  )  {  return  originalTypeofNode  ;  }  String  typeNameString  =  null  ;  switch  (  argumentNode  .  getType  (  )  )  {  case  Token  .  STRING:  typeNameString  = "string "  ;  break  ;  case  Token  .  NUMBER:  typeNameString  = "number "  ;  break  ;  case  Token  .  TRUE:  case  Token  .  FALSE:  typeNameString  = "boolean "  ;  break  ;  case  Token  .  NULL:  case  Token  .  OBJECTLIT:  case  Token  .  ARRAYLIT:  typeNameString  = "object "  ;  break  ;  [BUGGY]  case  Token  .  NAME:  if  ( "undefined "  .  equals  (  argumentNode  .  getString  (  )  )  )  {  typeNameString  = "undefined "  ;  }  	Closure_148_PeepholeFoldConstants_1_1	182	0	src/com/google/javascript/jscomp/PeepholeFoldConstants.java
579	private  final  static  int  UNMAPPED  =  -1;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_1	41	0	src/com/google/javascript/jscomp/SourceMap.java
580	int  id  =  UNMAPPED;  	[BUGGY]  int  id  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_2	50	1	src/com/google/javascript/jscomp/SourceMap.java
581	boolean  used  =  false;  }  private  class  MappingWriter  {  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_3	85	0	src/com/google/javascript/jscomp/SourceMap.java
582	private  String  lastSourceFile  =  null;  private  String  lastSourceFileEscaped  =  null;  private  int  lastLine  =  0;  private  String  lastLineString  =  String.valueOf(0);  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_4	89	0	src/com/google/javascript/jscomp/SourceMap.java
583	private  void  appendMappingTo(  Mapping  m,  Appendable  out)  throws  IOException  {  String  sourceFile  =  m.sourceFile;  String  escapedSourceFile;  if  (lastSourceFile  !=  sourceFile)  {  lastSourceFile  =  sourceFile;  lastSourceFileEscaped  =  escapeString(sourceFile);  }  escapedSourceFile  =  lastSourceFileEscaped;  out.append(escapedSourceFile);  int  line  =  m.originalPosition.getLineNumber();  if  (line  !=  lastLine)  {  lastLineString  =  String.valueOf(line);  }  String  lineValue  =  lastLineString;  out.append(lineValue);  out.append(String.valueOf(  m.originalPosition.getCharacterIndex()));  if  (m.originalName  !=  null)  {  out.append(escapeString(m.originalName));  out.append( "]\\n ");  	[BUGGY]  void  appendTo  (  Appendable  out  )  throws  IOException  {  out  .  append  (  sourceFile  )  ;  out  .  append  (  String  .  valueOf  (  originalPosition  .  getLineNumber  (  )  )  )  ;  out  .  append  (  String  .  valueOf  (  originalPosition  .  getCharacterIndex  (  )  )  )  ;  if  (  originalName  !  =  null  )  {  out  .  append  (  originalName  )  ;  out  .  append  ( "] "  )  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_5	93	7	src/com/google/javascript/jscomp/SourceMap.java
584	void  appendMappings(Appendable  out)  throws  IOException  {  for  (Mapping  m  :  mappings)  {  if  (m.used)  {  appendMappingTo(m,  out);  }  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_6	117	0	src/com/google/javascript/jscomp/SourceMap.java
585		[BUGGY]  private  String  lastSourceFile  =  null  ;  private  String  lastSourceFileEscaped  =  null  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_7	143	2	src/com/google/javascript/jscomp/SourceMap.java
586	mapping.sourceFile  =  sourceFile;  	[BUGGY]  String  escapedSourceFile  ;  if  (  lastSourceFile  !  =  sourceFile  )  {  lastSourceFile  =  sourceFile  ;  lastSourceFileEscaped  =  escapeString  (  sourceFile  )  ;  }  escapedSourceFile  =  lastSourceFileEscaped  ;  mapping  .  id  =  mappings  .  size  (  )  ;  mapping  .  sourceFile  =  escapedSourceFile  ;  [FE]  AssertionFailedError:  [METHOD]  addMapping  [TYPE]  void  [PARAMETER]  Node  node  Position  startPosition  Position  endPosition  [CLASS]  SourceMap  [TYPE]  boolean  false  firstChar  true  [TYPE]  Position  endPosition  offsetPosition  originalPosition  prefixPosition  startPosition  [TYPE]  Appendable  out  [TYPE]  Node  node  [TYPE]  List  mappings  [TYPE]  Mapping  mapping  [TYPE]  String  UNMAPPED_STRING  escapedSourceFile  lastSourceFile  lastSourceFileEscaped  originalName  sourceFile  [TYPE]  int  UNMAPPED  col  endOffsetPosition  id  line  offsetLine  startOffsetPosition  [CONTEXT]  void  addMapping  (  Node  node  ,  Position  startPosition  ,  Position  endPosition  )  {  String  sourceFile  =  (  String  )  node  .  getProp  (  Node  .  SOURCEFILE_PROP  )  ;  if  (  sourceFile  =  =  null  ||  node  .  getLineno  (  )  <  0  )  {  return  ;  }  [BUGGY]  String  escapedSourceFile  ;  if  (  lastSourceFile  !  =  sourceFile  )  {//  yes  , "s1  !  =  s2 "  not "!s1  .  equals  (  s2  ) "  lastSourceFile  =  sourceFile  ;  lastSourceFileEscaped  =  escapeString  (  sourceFile  )  ;  }  escapedSourceFile  =  lastSourceFileEscaped  ;  	Closure_148_SourceMap_33_8	163	8	src/com/google/javascript/jscomp/SourceMap.java
587	mapping.originalName  =  originalName;  if  (offsetPosition.getLineNumber()  ==  0  &&  offsetPosition.getCharacterIndex()  ==  0)  {  mapping.startPosition  =  startPosition;  mapping.endPosition  =  endPosition;  }  else  {  	[BUGGY]  mapping  .  originalName  =  escapeString  (  originalName  )  ;  [FE]  AssertionFailedError:  [METHOD]  addMapping  [TYPE]  void  [PARAMETER]  Node  node  Position  startPosition  Position  endPosition  [CLASS]  SourceMap  [TYPE]  boolean  false  firstChar  true  [TYPE]  Position  endPosition  offsetPosition  originalPosition  prefixPosition  startPosition  [TYPE]  Appendable  out  [TYPE]  Node  node  [TYPE]  List  mappings  [TYPE]  Mapping  mapping  [TYPE]  String  UNMAPPED_STRING  escapedSourceFile  lastSourceFile  lastSourceFileEscaped  originalName  sourceFile  [TYPE]  int  UNMAPPED  col  endOffsetPosition  id  line  offsetLine  startOffsetPosition  [CONTEXT]  void  addMapping  (  Node  node  ,  Position  startPosition  ,  Position  endPosition  )  {  String  sourceFile  =  (  String  )  node  .  getProp  (  Node  .  SOURCEFILE_PROP  )  ;  if  (  sourceFile  =  =  null  ||  node  .  getLineno  (  )  <  0  )  {  return  ;  }  String  escapedSourceFile  ;  if  (  lastSourceFile  !  =  sourceFile  )  {//  yes  , "s1  !  =  s2 "  not "!s1  .  equals  (  s2  ) "  lastSourceFile  =  sourceFile  ;  lastSourceFileEscaped  =  escapeString  (  sourceFile  )  ;  }  escapedSourceFile  =  lastSourceFileEscaped  ;  Mapping  mapping  =  new  Mapping  (  )  ;  mapping  .  id  =  mappings  .  size  (  )  ;  mapping  .  sourceFile  =  escapedSourceFile  ;  mapping  .  originalPosition  =  new  Position  (  node  .  getLineno  (  )  ,  node  .  getCharno  (  )  )  ;  String  originalName  =  (  String  )  node  .  getProp  (  Node  .  ORIGINALNAME_PROP  )  ;  if  (  originalName  !  =  null  )  {  [BUGGY]  mapping  .  originalName  =  escapeString  (  originalName  )  ;  }  	Closure_148_SourceMap_33_9	177	1	src/com/google/javascript/jscomp/SourceMap.java
588	}  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  addMapping  [TYPE]  void  [PARAMETER]  Node  node  Position  startPosition  Position  endPosition  [CLASS]  SourceMap  [TYPE]  boolean  false  firstChar  true  [TYPE]  Position  endPosition  offsetPosition  originalPosition  prefixPosition  startPosition  [TYPE]  Appendable  out  [TYPE]  Node  node  [TYPE]  List  mappings  [TYPE]  Mapping  mapping  [TYPE]  String  UNMAPPED_STRING  escapedSourceFile  lastSourceFile  lastSourceFileEscaped  originalName  sourceFile  [TYPE]  int  UNMAPPED  col  endOffsetPosition  id  line  offsetLine  startOffsetPosition  [CONTEXT]  }  int  offsetLine  =  offsetPosition  .  getLineNumber  (  )  ;  int  startOffsetPosition  =  offsetPosition  .  getCharacterIndex  (  )  ;  int  endOffsetPosition  =  offsetPosition  .  getCharacterIndex  (  )  ;  if  (  startPosition  .  getLineNumber  (  )  >  0  )  {  startOffsetPosition  =  0  ;  }  if  (  endPosition  .  getLineNumber  (  )  >  0  )  {  endOffsetPosition  =  0  ;  }  mapping  .  startPosition  =  new  Position  (  startPosition  .  getLineNumber  (  )  +  offsetLine  ,  startPosition  .  getCharacterIndex  (  )  +  startOffsetPosition  )  ;  mapping  .  endPosition  =  new  Position  (  endPosition  .  getLineNumber  (  )  +  offsetLine  ,  endPosition  .  getCharacterIndex  (  )  +  endOffsetPosition  )  ;  [BUGGY]  mappings  .  add  (  mapping  )  ;  }  	Closure_148_SourceMap_33_10	203	0	src/com/google/javascript/jscomp/SourceMap.java
589		[BUGGY]  private  int  findLastLine  (  )  {  int  maxLine  =  0  ;  for  (  Mapping  mapping  :  mappings  )  {  int  endPositionLine  =  mapping  .  endPosition  .  getLineNumber  (  )  ;  maxLine  =  Math  .  max  (  maxLine  ,  endPositionLine  )  ;  }  return  maxLine  +  prefixPosition  .  getLineNumber  (  )  ;  }  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_11	257	8	src/com/google/javascript/jscomp/SourceMap.java
590	int  maxLine  =  prepMappings();  	[BUGGY]  int  maxLine  =  findLastLine  (  )  ;  [FE]  AssertionFailedError:  [METHOD]  appendTo  [TYPE]  void  [PARAMETER]  Appendable  out  String  name  [CLASS]  SourceMap  [TYPE]  boolean  false  firstChar  true  [TYPE]  Position  endPosition  offsetPosition  originalPosition  prefixPosition  startPosition  [TYPE]  Appendable  out  [TYPE]  List  mappings  [TYPE]  Mapping  mapping  [TYPE]  String  UNMAPPED_STRING  lastSourceFile  lastSourceFileEscaped  name  originalName  sourceFile  [TYPE]  int  UNMAPPED  col  i  id  line  maxLine  [CONTEXT]    [BUGGY]  int  maxLine  =  findLastLine  (  )  ;  out  .  append  ( "/**  Begin  line  maps  .  **/{  \ "file\ "  : "  )  ;  out  .  append  (  escapeString  (  name  )  )  ;  out  .  append  ( "  ,  \ "count\ ": "  )  ;  	Closure_148_SourceMap_33_12	304	1	src/com/google/javascript/jscomp/SourceMap.java
591	(new  MappingWriter()).appendMappings(out);  	[BUGGY]  for  (  Mapping  mapping  :  mappings  )  {  mapping  .  appendTo  (  out  )  ;  out  .  append  ( "\\n "  )  ;  }  [FE]  AssertionFailedError:  [METHOD]  appendTo  [TYPE]  void  [PARAMETER]  Appendable  out  String  name  [CLASS]  SourceMap  [TYPE]  boolean  false  firstChar  true  [TYPE]  Position  endPosition  offsetPosition  originalPosition  prefixPosition  startPosition  [TYPE]  Appendable  out  [TYPE]  List  mappings  [TYPE]  Mapping  mapping  [TYPE]  String  UNMAPPED_STRING  lastSourceFile  lastSourceFileEscaped  name  originalName  sourceFile  [TYPE]  int  UNMAPPED  col  i  id  line  maxLine  [CONTEXT]  int  maxLine  =  findLastLine  (  )  ;  out  .  append  ( "/**  Begin  line  maps  .  **/{  \ "file\ "  : "  )  ;  out  .  append  (  escapeString  (  name  )  )  ;  out  .  append  ( "  ,  \ "count\ ": "  )  ;  out  .  append  (  String  .  valueOf  (  maxLine  +  1  )  )  ;  out  .  append  ( "  }\n "  )  ;  (  new  LineMapper  (  out  )  )  .  appendLineMappings  (  )  ;  out  .  append  ( "/**  Begin  file  information  .  **/\n "  )  ;  for  (  int  i  =  0  ;  i  <  =  maxLine  ;  ++i  )  {  out  .  append  ( "[]\n "  )  ;  }  out  .  append  ( "/**  Begin  mapping  definitions  .  **/\n "  )  ;  [BUGGY]  for  (  Mapping  mapping  :  mappings  )  {  mapping  .  appendTo  (  out  )  ;  out  .  append  ( "\n "  )  ;  }  }  	Closure_148_SourceMap_33_13	326	4	src/com/google/javascript/jscomp/SourceMap.java
592	private  int  prepMappings()  throws  IOException  {  (new  MappingTraversal()).traverse(new  UsedMappingCheck());  int  id  =  0;  int  maxLine  =  0;  for  (Mapping  m  :  mappings)  {  if  (m.used)  {  m.id  =  id++;  int  endPositionLine  =  m.endPosition.getLineNumber();  maxLine  =  Math.max(maxLine,  endPositionLine);  }  }  return  maxLine  +  prefixPosition.getLineNumber();  }  private  class  LineMapper  implements  MappingVisitor  {  	[BUGGY]  private  class  LineMapper  {  private  int  line  ;  private  int  col  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_14	335	3	src/com/google/javascript/jscomp/SourceMap.java
593	private  int  lastId  =  UNMAPPED;  private  String  lastIdString  =  UNMAPPED_STRING;  	[BUGGY]  private  final  static  int  UNMAPPED  =  -1  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_15	351	1	src/com/google/javascript/jscomp/SourceMap.java
594	public  void  visit(Mapping  m,  int  line,  int  col,  int  nextLine,  int  nextCol)  throws  IOException  {  int  id  =  (m  !=  null)  ?  m.id  :  UNMAPPED;  if  (lastId  !=  id)  {  lastIdString  =  (id  ==  UNMAPPED)  ?  UNMAPPED_STRING  :  String.valueOf(id);  lastId  =  id;  }  String  idString  =  lastIdString;  for  (int  i  =  line;  i  <=  nextLine;  i++)  {  if  (i  ==  nextLine)  {  for  (int  j  =  col;  j  <  nextCol;  j++)  {  addCharEntry(idString);  }  break;  }  closeLine();  openLine();  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_16	360	0	src/com/google/javascript/jscomp/SourceMap.java
595	(new  MappingTraversal()).traverse(this);  closeLine();  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  void  appendLineMappings  (  )  throws  IOException  {  Preconditions  .  checkState  (  !mappings  .  isEmpty  (  )  )  ;  openLine  (  )  ;  [BUGGY]  	Closure_148_SourceMap_33_17	373	0	src/com/google/javascript/jscomp/SourceMap.java
596	private  void  openLine()  throws  IOException  {  if  (out  !=  null)  {  out.append( "[ ");  this.firstChar  =  true;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  void  appendLineMappings  (  )  throws  IOException  {  Preconditions  .  checkState  (  !mappings  .  isEmpty  (  )  )  ;  openLine  (  )  ;  [BUGGY]  	Closure_148_SourceMap_33_18	379	0	src/com/google/javascript/jscomp/SourceMap.java
597	private  void  closeLine()  throws  IOException  {  if  (out  !=  null)  {  out.append( "]\\n ");  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  void  appendLineMappings  (  )  throws  IOException  {  Preconditions  .  checkState  (  !mappings  .  isEmpty  (  )  )  ;  openLine  (  )  ;  [BUGGY]  	Closure_148_SourceMap_33_19	383	0	src/com/google/javascript/jscomp/SourceMap.java
598	private  void  addCharEntry(String  id)  throws  IOException  {  if  (out  !=  null)  {  if  (firstChar)  {  firstChar  =  false;  }  else  {  out.append( ", ");  }  out.append(id);  }  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  void  appendLineMappings  (  )  throws  IOException  {  Preconditions  .  checkState  (  !mappings  .  isEmpty  (  )  )  ;  openLine  (  )  ;  [BUGGY]  	Closure_148_SourceMap_33_20	388	0	src/com/google/javascript/jscomp/SourceMap.java
599	private  class  UsedMappingCheck  implements  MappingVisitor  {  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  void  appendLineMappings  (  )  throws  IOException  {  Preconditions  .  checkState  (  !mappings  .  isEmpty  (  )  )  ;  openLine  (  )  ;  [BUGGY]  	Closure_148_SourceMap_33_21	392	0	src/com/google/javascript/jscomp/SourceMap.java
600	@Override  public  void  visit(Mapping  m,  int  line,  int  col,  int  nextLine,  int  nextCol)  throws  IOException  {  if  (m  !=  null)  {  m.used  =  true;  }  }  }  private  interface  MappingVisitor  {  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  openLine  (  )  ;    [BUGGY]  	Closure_148_SourceMap_33_22	395	0	src/com/google/javascript/jscomp/SourceMap.java
601	void  visit(Mapping  m,  int  line,  int  col,  int  endLine,  int  endCol)  throws  IOException;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]    [BUGGY]  	Closure_148_SourceMap_33_23	405	0	src/com/google/javascript/jscomp/SourceMap.java
602	private  class  MappingTraversal  {  private  int  line;  private  int  col;  MappingTraversal()  {  }  void  traverse(MappingVisitor  v)  throws  IOException  {  Preconditions.checkState(!mappings.isEmpty());  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]    [BUGGY]  	Closure_148_SourceMap_33_24	410	0	src/com/google/javascript/jscomp/SourceMap.java
603	maybeVisit(v,  previous);  	[BUGGY]  writeClosedMapping  (  previous  )  ;  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  Deque<Mapping>  stack  =  new  ArrayDeque<Mapping>  (  )  ;  for  (  Mapping  m  :  mappings  )  {  while  (  !stack  .  isEmpty  (  )  &&  !isOverlapped  (  stack  .  peek  (  )  ,  m  )  )  {  Mapping  previous  =  stack  .  pop  (  )  ;  [BUGGY]  writeClosedMapping  (  previous  )  ;  }  Mapping  parent  =  stack  .  peek  (  )  ;  	Closure_148_SourceMap_33_25	426	1	src/com/google/javascript/jscomp/SourceMap.java
604	maybeVisitParent(v,  parent,  m);  	[BUGGY]  writeCharsBetween  (  parent  ,  m  )  ;  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  Deque<Mapping>  stack  =  new  ArrayDeque<Mapping>  (  )  ;  for  (  Mapping  m  :  mappings  )  {  while  (  !stack  .  isEmpty  (  )  &&  !isOverlapped  (  stack  .  peek  (  )  ,  m  )  )  {  Mapping  previous  =  stack  .  pop  (  )  ;  writeClosedMapping  (  previous  )  ;  }  Mapping  parent  =  stack  .  peek  (  )  ;  [BUGGY]  writeCharsBetween  (  parent  ,  m  )  ;  stack  .  push  (  m  )  ;  }  	Closure_148_SourceMap_33_26	432	1	src/com/google/javascript/jscomp/SourceMap.java
605	maybeVisit(v,  m);  	[BUGGY]  writeClosedMapping  (  m  )  ;  }  closeLine  (  )  ;  }  private  void  openLine  (  )  throws  IOException  {  out  .  append  ( "[ "  )  ;  this  .  firstChar  =  true  ;  }  private  void  closeLine  (  )  throws  IOException  {  out  .  append  ( "]\\n "  )  ;  }  private  void  addCharEntry  (  String  id  )  throws  IOException  {  if  (  firstChar  )  {  firstChar  =  false  ;  }  else  {  out  .  append  ( "  , "  )  ;  out  .  append  (  id  )  ;  [FE]  AssertionFailedError:  [METHOD]  appendLineMappings  [TYPE]  void  [PARAMETER]  [CLASS]  LineMapper  [TYPE]  Mapping  m  parent  previous  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  Deque  stack  [TYPE]  int  UNMAPPED  col  line  [TYPE]  Appendable  out  [CONTEXT]  Deque<Mapping>  stack  =  new  ArrayDeque<Mapping>  (  )  ;  for  (  Mapping  m  :  mappings  )  {  while  (  !stack  .  isEmpty  (  )  &&  !isOverlapped  (  stack  .  peek  (  )  ,  m  )  )  {  Mapping  previous  =  stack  .  pop  (  )  ;  writeClosedMapping  (  previous  )  ;  }  Mapping  parent  =  stack  .  peek  (  )  ;  writeCharsBetween  (  parent  ,  m  )  ;  stack  .  push  (  m  )  ;  }  while  (  !stack  .  isEmpty  (  )  )  {  Mapping  m  =  stack  .  pop  (  )  ;  [BUGGY]  writeClosedMapping  (  m  )  ;  }  closeLine  (  )  ;  }  private  void  openLine  (  )  throws  IOException  {  out  .  append  ( "[ "  )  ;  	Closure_148_SourceMap_33_27	441	17	src/com/google/javascript/jscomp/SourceMap.java
606	private  void  maybeVisit(MappingVisitor  v,  Mapping  m)  throws  IOException  {  	[BUGGY]  private  void  writeClosedMapping  (  Mapping  m  )  throws  IOException  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_28	496	1	src/com/google/javascript/jscomp/SourceMap.java
607	visit(v,  m,  nextLine,  nextCol);  	[BUGGY]  writeCharsUpTo  (  nextLine  ,  nextCol  ,  m  .  id  )  ;  [FE]  AssertionFailedError:  [METHOD]  writeClosedMapping  [TYPE]  void  [PARAMETER]  Mapping  m  [CLASS]  LineMapper  [TYPE]  Mapping  m  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  [TYPE]  int  UNMAPPED  col  line  nextCol  nextLine  [TYPE]  Appendable  out  [CONTEXT]  private  void  writeClosedMapping  (  Mapping  m  )  throws  IOException  {  int  nextLine  =  getAdjustedLine  (  m  .  endPosition  )  ;  int  nextCol  =  getAdjustedCol  (  m  .  endPosition  )  ;  if  (  line  <  nextLine  ||  (  line  =  =  nextLine  &&  col  <  nextCol  )  )  {  [BUGGY]  writeCharsUpTo  (  nextLine  ,  nextCol  ,  m  .  id  )  ;  }  }  	Closure_148_SourceMap_33_29	502	1	src/com/google/javascript/jscomp/SourceMap.java
608	private  void  maybeVisitParent(MappingVisitor  v,  Mapping  parent,  Mapping  m)  int  nextLine  =  getAdjustedLine(m.startPosition);  int  nextCol  =  getAdjustedCol(m.startPosition);  Preconditions.checkState(line  <  nextLine  ||  col  <=  nextCol);  if  (line  <  nextLine  ||  (line  ==  nextLine  &&  col  <  nextCol))  {  visit(v,  parent,  nextLine,  nextCol);  }  	[BUGGY]  private  void  writeCharsBetween  (  Mapping  prev  ,  Mapping  next  )  int  nextLine  =  getAdjustedLine  (  next  .  startPosition  )  ;  int  nextCol  =  getAdjustedCol  (  next  .  startPosition  )  ;  int  id  =  (  prev  !  =  null  )  ?  prev  .  id  :  UNMAPPED  ;  writeCharsUpTo  (  nextLine  ,  nextCol  ,  id  )  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_30	509	5	src/com/google/javascript/jscomp/SourceMap.java
609	private  void  visit(MappingVisitor  v,  Mapping  m,  int  nextLine,  int  nextCol)  Preconditions.checkState(line  <=  nextLine);  Preconditions.checkState(line  <  nextLine  ||  col  <  nextCol);  	[BUGGY]  private  void  writeCharsUpTo  (  int  nextLine  ,  int  nextCol  ,  int  id  )  Preconditions  .  checkState  (  line  <  =  nextLine  , " "  )  ;  Preconditions  .  checkState  (  line  <  nextLine  ||  col  <  =  nextCol  )  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_148_SourceMap_33_31	522	4	src/com/google/javascript/jscomp/SourceMap.java
610	Preconditions.checkState(false);  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  writeCharsUpTo  [TYPE]  void  [PARAMETER]  int  nextLine  int  nextCol  int  id  [CLASS]  LineMapper  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  idString  [TYPE]  int  UNMAPPED  col  i  id  j  line  nextCol  nextLine  [TYPE]  Appendable  out  [CONTEXT]  private  void  writeCharsUpTo  (  int  nextLine  ,  int  nextCol  ,  int  id  )  throws  IOException  {  Preconditions  .  checkState  (  line  <  =  nextLine  , " "  )  ;  Preconditions  .  checkState  (  line  <  nextLine  ||  col  <  =  nextCol  )  ;  if  (  line  =  =  nextLine  &&  col  =  =  nextCol  )  {  [BUGGY]  return  ;  }  String  idString  =  (  id  =  =  UNMAPPED  )  ?  UNMAPPED_STRING  :  String  .  valueOf  (  id  )  ;  for  (  int  i  =  line  ;  i  <  =  nextLine  ;  i++  )  {  if  (  i  =  =  nextLine  )  {  for  (  int  j  =  col  ;  j  <  nextCol  ;  j++  )  {  addCharEntry  (  idString  )  ;  }  break  ;  }  closeLine  (  )  ;  openLine  (  )  ;  }  line  =  nextLine  ;  col  =  nextCol  ;  }  	Closure_148_SourceMap_33_32	530	0	src/com/google/javascript/jscomp/SourceMap.java
611	v.visit(m,  line,  col,  nextLine,  nextCol);  	[BUGGY]  String  idString  =  (  id  =  =  UNMAPPED  )  ?  UNMAPPED_STRING  :  String  .  valueOf  (  id  )  ;  for  (  int  i  =  line  ;  i  <  =  nextLine  ;  i++  )  {  if  (  i  =  =  nextLine  )  {  for  (  int  j  =  col  ;  j  <  nextCol  ;  j++  )  {  addCharEntry  (  idString  )  ;  }  break  ;  }  closeLine  (  )  ;  openLine  (  )  ;  }  [FE]  AssertionFailedError:  [METHOD]  writeCharsUpTo  [TYPE]  void  [PARAMETER]  int  nextLine  int  nextCol  int  id  [CLASS]  LineMapper  [TYPE]  boolean  false  firstChar  true  [TYPE]  String  UNMAPPED_STRING  idString  [TYPE]  int  UNMAPPED  col  i  id  j  line  nextCol  nextLine  [TYPE]  Appendable  out  [CONTEXT]  private  void  writeCharsUpTo  (  int  nextLine  ,  int  nextCol  ,  int  id  )  throws  IOException  {  Preconditions  .  checkState  (  line  <  =  nextLine  , " "  )  ;  Preconditions  .  checkState  (  line  <  nextLine  ||  col  <  =  nextCol  )  ;  if  (  line  =  =  nextLine  &&  col  =  =  nextCol  )  {  return  ;  }  [BUGGY]  String  idString  =  (  id  =  =  UNMAPPED  )  ?  UNMAPPED_STRING  :  String  .  valueOf  (  id  )  ;  for  (  int  i  =  line  ;  i  <  =  nextLine  ;  i++  )  {  if  (  i  =  =  nextLine  )  {  for  (  int  j  =  col  ;  j  <  nextCol  ;  j++  )  {  addCharEntry  (  idString  )  ;  }  break  ;  }  closeLine  (  )  ;  openLine  (  )  ;  }  line  =  nextLine  ;  col  =  nextCol  ;  }  	Closure_148_SourceMap_33_33	533	11	src/com/google/javascript/jscomp/SourceMap.java
612	options.outputCharset  =  getOutputCharset();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<US-ASCII>  but  was:<null>  assertEquals  ( "UTF-8 "  ,  lastCompiler  .  getOptions  (  )  .  outputCharset  )  ;  [METHOD]  setRunOptions  [TYPE]  void  [PARAMETER]  CompilerOptions  options  [CLASS]  AbstractCommandLineRunner  [TYPE]  PrintStream  err  [TYPE]  A  compiler  [TYPE]  Appendable  out  [TYPE]  Charset  inputCharset  [TYPE]  String  charset  createSourceMap  jsOutputFile  loggingLevel  moduleOutputPathPrefix  outputManifest  outputWrapper  outputWrapperMarker  propertyMapInputFile  propertyMapOutputFile  variableMapInputFile  variableMapOutputFile  [TYPE]  int  NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER  summaryDetailLevel  [TYPE]  long  bestRunTime  lastStartTime  serialVersionUID  worstRunTime  [TYPE]  boolean  computePhaseOrdering  createNameMapFiles  false  manageClosureDependencies  printAst  printPassGraph  printTree  true  [TYPE]  RunTimeStats  runTimeStats  [TYPE]  DetailLevel  sourceMapDetailLevel  [TYPE]  CodingConvention  codingConvention  [TYPE]  CommandLineConfig  config  [TYPE]  CompilerOptions  options  [TYPE]  List  define  externs  js  jscompError  jscompOff  jscompWarning  loopedPassesInBestRun  module  moduleWrapper  [TYPE]  DevMode  jscompDevMode  [TYPE]  DiagnosticGroups  diagnosticGroups  [CONTEXT]  final  protected  void  setRunOptions  (  CompilerOptions  options  )  throws  FlagUsageException  ,  IOException  {  DiagnosticGroups  diagnosticGroups  =  getDiagnosticGroups  (  )  ;  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompError  ,  CheckLevel  .  ERROR  )  ;  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompWarning  ,  CheckLevel  .  WARNING  )  ;  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompOff  ,  CheckLevel  .  OFF  )  ;  createDefineReplacements  (  config  .  define  ,  options  )  ;  options  .  manageClosureDependencies  =  config  .  manageClosureDependencies  ;  options  .  devMode  =  config  .  jscompDevMode  ;  options  .  setCodingConvention  (  config  .  codingConvention  )  ;  options  .  setSummaryDetailLevel  (  config  .  summaryDetailLevel  )  ;  [BUGGY]  inputCharset  =  getInputCharset  (  )  ;  if  (  config  .  jsOutputFile  .  length  (  )  >  0  )  {  options  .  jsOutputFile  =  config  .  jsOutputFile  ;  }  	Closure_149_AbstractCommandLineRunner_3_1	159	0	src/com/google/javascript/jscomp/AbstractCommandLineRunner.java
613		[BUGGY]  if  (  inputCharset  =  =  Charsets  .  UTF_8  )  {  options  .  outputCharset  =  Charsets  .  US_ASCII  ;  }  else  {  options  .  outputCharset  =  inputCharset  ;  }  [FE]  AssertionFailedError:  expected:<US-ASCII>  but  was:<null>  assertEquals  ( "UTF-8 "  ,  lastCompiler  .  getOptions  (  )  .  outputCharset  )  ;  [METHOD]  doRun  [TYPE]  int  [PARAMETER]  [CLASS]  AbstractCommandLineRunner  [TYPE]  PrintStream  err  [TYPE]  A  compiler  [TYPE]  B  options  [TYPE]  Appendable  out  [TYPE]  Charset  inputCharset  [TYPE]  String  charset  createSourceMap  jsOutputFile  loggingLevel  moduleOutputPathPrefix  outputManifest  outputWrapper  outputWrapperMarker  propertyMapInputFile  propertyMapOutputFile  variableMapInputFile  variableMapOutputFile  [TYPE]  int  NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER  errCode  summaryDetailLevel  [TYPE]  long  bestRunTime  lastStartTime  serialVersionUID  worstRunTime  [TYPE]  Result  result  [TYPE]  boolean  computePhaseOrdering  createNameMapFiles  false  manageClosureDependencies  printAst  printPassGraph  printTree  true  writeOutputToFile  [TYPE]  RunTimeStats  runTimeStats  [TYPE]  DetailLevel  sourceMapDetailLevel  [TYPE]  CodingConvention  codingConvention  [TYPE]  JSModule[]  modules  [TYPE]  CommandLineConfig  config  [TYPE]  JSSourceFile[]  externs  inputs  [TYPE]  List  define  externs  externsList  inputList  js  jsFiles  jscompError  jscompOff  jscompWarning  loopedPassesInBestRun  module  moduleSpecs  moduleWrapper  [TYPE]  DevMode  jscompDevMode  [CONTEXT]  protected  int  doRun  (  )  throws  FlagUsageException  ,  IOException  {  Compiler  .  setLoggingLevel  (  Level  .  parse  (  config  .  loggingLevel  )  )  ;  List<JSSourceFile>  externsList  =  createExterns  (  )  ;  JSSourceFile[]  externs  =  new  JSSourceFile[externsList  .  size  (  )  ]  ;  externsList  .  toArray  (  externs  )  ;  compiler  =  createCompiler  (  )  ;  B  options  =  createOptions  (  )  ;  JSModule[]  modules  =  null  ;  Result  result  ;  setRunOptions  (  options  )  ;  [BUGGY]  if  (  inputCharset  =  =  Charsets  .  UTF_8  )  {  options  .  outputCharset  =  Charsets  .  US_ASCII  ;  }  else  {  options  .  outputCharset  =  inputCharset  ;  }  	Closure_149_AbstractCommandLineRunner_3_2	518	5	src/com/google/javascript/jscomp/AbstractCommandLineRunner.java
614	private  String  getOutputCharset()  throws  FlagUsageException  {  if  (!config.charset.isEmpty())  {  if  (!Charset.isSupported(config.charset))  {  throw  new  FlagUsageException(config.charset  + "  is  not  a  valid  charset  name. ");  }  return  config.charset;  }  return "US-ASCII ";  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<US-ASCII>  but  was:<null>  assertEquals  ( "UTF-8 "  ,  lastCompiler  .  getOptions  (  )  .  outputCharset  )  ;  [CLASS]  [CONTEXT]  	Closure_149_AbstractCommandLineRunner_3_3	693	0	src/com/google/javascript/jscomp/AbstractCommandLineRunner.java
615		[BUGGY]  initOptionsFromFlags  (  options  )  ;  [FE]  AssertionFailedError:  expected:<US-ASCII>  but  was:<null>  assertEquals  ( "UTF-8 "  ,  lastCompiler  .  getOptions  (  )  .  outputCharset  )  ;  [METHOD]  createOptions  [TYPE]  CompilerOptions  [PARAMETER]  [CLASS]  CommandLineRunner  [TYPE]  CompilationLevel  compilation_level  level  [TYPE]  boolean  compute_phase_ordering  create_name_map_files  debug  display_help  false  isConfigValid  manage_closure_dependencies  print_ast  print_pass_graph  print_tree  process_closure_primitives  third_party  true  use_only_custom_externs  [TYPE]  Set  FALSES  TRUES  [TYPE]  WarningLevel  wLevel  warning_level  [TYPE]  FormattingOption  PRETTY_PRINT  PRINT_INPUT_DELIMITER  formattingOption  [TYPE]  CompilerOptions  options  [TYPE]  List  DEFAULT_EXTERNS_NAMES  define  externs  formatting  js  jscomp_error  jscomp_off  jscomp_warning  module  module_wrapper  [TYPE]  String  charset  create_source_map  js_output_file  logging_level  module_output_path_prefix  output_manifest  output_wrapper  output_wrapper_marker  property_map_input_file  property_map_output_file  variable_map_input_file  variable_map_output_file  [TYPE]  Flags  flags  [TYPE]  DevMode  jscomp_dev_mode  [TYPE]  int  summary_detail_level  [CONTEXT]  protected  CompilerOptions  createOptions  (  )  {  CompilerOptions  options  =  new  CompilerOptions  (  )  ;  options  .  setCodingConvention  (  new  ClosureCodingConvention  (  )  )  ;  CompilationLevel  level  =  flags  .  compilation_level  ;  level  .  setOptionsForCompilationLevel  (  options  )  ;  if  (  flags  .  debug  )  {  level  .  setDebugOptionsForCompilationLevel  (  options  )  ;  }  WarningLevel  wLevel  =  flags  .  warning_level  ;  wLevel  .  setOptionsForWarningLevel  (  options  )  ;  for  (  FormattingOption  formattingOption  :  flags  .  formatting  )  {  formattingOption  .  applyToOptions  (  options  )  ;  }  options  .  closurePass  =  flags  .  process_closure_primitives  ;  [BUGGY]  initOptionsFromFlags  (  options  )  ;  return  options  ;  }  	Closure_149_CommandLineRunner_1_1	471	1	src/com/google/javascript/jscomp/CommandLineRunner.java
616	Charset  charset  =  options.outputCharset  !=  null  ?  Charset.forName(options.outputCharset)  :  null;  	[BUGGY]  Charset  charset  =  options  .  outputCharset  ;  [FE]  AssertionFailedError:  expected:<US-ASCII>  but  was:<null>  assertEquals  ( "UTF-8 "  ,  lastCompiler  .  getOptions  (  )  .  outputCharset  )  ;  [METHOD]  toSource  [TYPE]  String  [PARAMETER]  Node  n  SourceMap  sourceMap  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  n  [TYPE]  Builder  builder  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  inputs  modules  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  Charset  charset  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  uniqueNameId  [TYPE]  boolean  false  hasRegExpGlobalReferences  normalized  true  useThreads  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  inputsByName  [CONTEXT]  private  String  toSource  (  Node  n  ,  SourceMap  sourceMap  )  {  CodePrinter  .  Builder  builder  =  new  CodePrinter  .  Builder  (  n  )  ;  builder  .  setPrettyPrint  (  options  .  prettyPrint  )  ;  builder  .  setLineBreak  (  options  .  lineBreak  )  ;  builder  .  setSourceMap  (  sourceMap  )  ;  builder  .  setSourceMapDetailLevel  (  options  .  sourceMapDetailLevel  )  ;  [BUGGY]  Charset  charset  =  options  .  outputCharset  ;  builder  .  setOutputCharset  (  charset  )  ;  return  builder  .  build  (  )  ;  }  	Closure_149_Compiler_1_1	1362	1	src/com/google/javascript/jscomp/Compiler.java
617	String  outputCharset;  	[BUGGY]  public  Charset  outputCharset  ;  [FE]  AssertionFailedError:  expected:<US-ASCII>  but  was:<null>  assertEquals  ( "UTF-8 "  ,  lastCompiler  .  getOptions  (  )  .  outputCharset  )  ;  [CLASS]  [CONTEXT]  	Closure_149_CompilerOptions_2_1	588	1	src/com/google/javascript/jscomp/CompilerOptions.java
618	public  void  setOutputCharset(String  charsetName)  {  this.outputCharset  =  charsetName;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<US-ASCII>  but  was:<null>  assertEquals  ( "UTF-8 "  ,  lastCompiler  .  getOptions  (  )  .  outputCharset  )  ;  [CLASS]  [CONTEXT]  	Closure_149_CompilerOptions_2_2	960	0	src/com/google/javascript/jscomp/CompilerOptions.java
619	super.visit(t,  n,  parent);  	[BUGGY]  attachLiteralTypes  (  n  )  ;  switch  (  n  .  getType  (  )  )  {  case  Token  .  FUNCTION:  if  (  parent  .  getType  (  )  =  =  Token  .  NAME  )  {  return  ;  }  defineDeclaredFunction  (  n  ,  parent  )  ;  break  ;  case  Token  .  CATCH:  defineCatch  (  n  ,  parent  )  ;  break  ;  case  Token  .  VAR:  defineVar  (  n  ,  parent  )  ;  break  ;  }  [FE]  AssertionFailedError  assertEquals  (  lastLocalScope  .  getVar  ( "goog  .  foo "  )  .  getType  (  )  ,  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  LocalScopeBuilder  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  parent  [CONTEXT]  @Override  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  =  =  scope  .  getRootNode  (  )  )  return  ;  if  (  n  .  getType  (  )  =  =  Token  .  LP  &&  parent  =  =  scope  .  getRootNode  (  )  )  {  handleFunctionInputs  (  parent  )  ;  return  ;  }  [BUGGY]  attachLiteralTypes  (  n  )  ;  switch  (  n  .  getType  (  )  )  {  case  Token  .  FUNCTION:  if  (  parent  .  getType  (  )  =  =  Token  .  NAME  )  {  return  ;  }  defineDeclaredFunction  (  n  ,  parent  )  ;  break  ;  case  Token  .  CATCH:  defineCatch  (  n  ,  parent  )  ;  break  ;  case  Token  .  VAR:  defineVar  (  n  ,  parent  )  ;  break  ;  }  }  	Closure_150_TypedScopeCreator_1_1	1451	15	src/com/google/javascript/jscomp/TypedScopeCreator.java
620	@Option(name  = "--version ",  usage  = "Prints  the  compiler  version  to  stderr. ")  private  boolean  version  =  false;  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [CLASS]  [CONTEXT]  	Closure_151_CommandLineRunner_3_1	301	0	src/com/google/javascript/jscomp/CommandLineRunner.java
621	private  static  final  String  configResource  = "com.google.javascript.jscomp.parsing.ParserConfig ";  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [CLASS]  [CONTEXT]  	Closure_151_CommandLineRunner_3_2	367	0	src/com/google/javascript/jscomp/CommandLineRunner.java
622	if  (flags.version)  {  ResourceBundle  config  =  ResourceBundle.getBundle(configResource);  err.println( "Closure  Compiler  (http: "Version: "  +  config.getString( "compiler.version ")  + "\\n "  + "Built  on: "  +  config.getString( "compiler.date "));  err.flush();  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  runner  .  shouldRunCompiler  (  )  )  ;  [METHOD]  initConfigFromFlags  [TYPE]  void  [PARAMETER]  String[]  args  PrintStream  err  [CLASS]  CommandLineRunner  [TYPE]  PrintStream  err  [TYPE]  Pattern  argPattern  quotesPattern  [TYPE]  CompilationLevel  compilation_level  [TYPE]  Set  FALSES  TRUES  [TYPE]  CmdLineParser  parser  [TYPE]  WarningLevel  warning_level  [TYPE]  Matcher  matcher  quotesMatcher  [TYPE]  String  arg  charset  create_source_map  js_output_file  logging_level  module_output_path_prefix  output_manifest  output_wrapper  output_wrapper_marker  property_map_input_file  property_map_output_file  value  variable_map_input_file  variable_map_output_file  [TYPE]  Flags  flags  [TYPE]  String[]  args  [TYPE]  int  summary_detail_level  [TYPE]  boolean  compute_phase_ordering  create_name_map_files  debug  display_help  false  isConfigValid  manage_closure_dependencies  print_ast  print_pass_graph  print_tree  process_closure_primitives  third_party  true  use_only_custom_externs  [TYPE]  FormattingOption  PRETTY_PRINT  PRINT_INPUT_DELIMITER  [TYPE]  List  DEFAULT_EXTERNS_NAMES  define  externs  formatting  js  jscomp_error  jscomp_off  jscomp_warning  module  module_wrapper  processedArgs  [TYPE]  DevMode  jscomp_dev_mode  [TYPE]  CmdLineException  e  [CONTEXT]  Matcher  matcher  =  argPattern  .  matcher  (  arg  )  ;  if  (  matcher  .  matches  (  )  )  {  processedArgs  .  add  (  matcher  .  group  (  1  )  )  ;  String  value  =  matcher  .  group  (  2  )  ;  Matcher  quotesMatcher  =  quotesPattern  .  matcher  (  value  )  ;  if  (  quotesMatcher  .  matches  (  )  )  {  processedArgs  .  add  (  quotesMatcher  .  group  (  1  )  )  ;  }  else  {  processedArgs  .  add  (  value  )  ;  }  }  else  {  processedArgs  .  add  (  arg  )  ;  }  }  CmdLineParser  parser  =  new  CmdLineParser  (  flags  )  ;  isConfigValid  =  true  ;  try  {  parser  .  parseArgument  (  processedArgs  .  toArray  (  new  String[]  {}  )  )  ;  }  catch  (  CmdLineException  e  )  {  err  .  println  (  e  .  getMessage  (  )  )  ;  isConfigValid  =  false  ;  }  [BUGGY]  if  (  !isConfigValid  ||  flags  .  display_help  )  {  isConfigValid  =  false  ;  parser  .  printUsage  (  err  )  ;  }  else  {  getCommandLineConfig  (  )  	Closure_151_CommandLineRunner_3_3	418	0	src/com/google/javascript/jscomp/CommandLineRunner.java
623	JSType  maybeTypeOfThis  =  safeResolve(typeOfThis,  t,  scope);  if  (maybeTypeOfThis  instanceof  ObjectType)  {  typeOfThis  =  (ObjectType)  maybeTypeOfThis;  }  	[BUGGY]  typeOfThis  =  (  ObjectType  )  safeResolve  (  typeOfThis  ,  t  ,  scope  )  ;  [FE]  ClassCastException:  comgooglejavascriptrhinojstypeStringType  cannot  be  cast  to  comgooglejavascriptrhinojstypeObjectType  [METHOD]  resolveInternal  [TYPE]  JSType  [PARAMETER]  ErrorReporter  t  JSType>  scope  [CLASS]  FunctionType  [TYPE]  FunctionPrototypeType  prototype  [TYPE]  Node  source  [TYPE]  StaticScope  scope  [TYPE]  Builder  resolvedInterfaces  [TYPE]  ArrowType  call  [TYPE]  String  templateTypeName  [TYPE]  long  serialVersionUID  [TYPE]  int  i  [TYPE]  ObjectType  iface  resolvedIface  typeOfThis  [TYPE]  ErrorReporter  t  [TYPE]  boolean  changed  false  true  [TYPE]  Kind  CONSTRUCTOR  INTERFACE  ORDINARY  kind  [TYPE]  List  implementedInterfaces  subTypes  [CONTEXT]  JSType  resolveInternal  (  ErrorReporter  t  ,  StaticScope<JSType>  scope  )  {  setResolvedTypeInternal  (  this  )  ;  call  =  (  ArrowType  )  safeResolve  (  call  ,  t  ,  scope  )  ;  prototype  =  (  FunctionPrototypeType  )  safeResolve  (  prototype  ,  t  ,  scope  )  ;  [BUGGY]  typeOfThis  =  (  ObjectType  )  safeResolve  (  typeOfThis  ,  t  ,  scope  )  ;  boolean  changed  =  false  ;  ImmutableList  .  Builder<ObjectType>  resolvedInterfaces  =  ImmutableList  .  builder  (  )  ;  for  (  ObjectType  iface  :  implementedInterfaces  )  {  	Closure_152_FunctionType_1_1	871	1	src/com/google/javascript/rhino/jstype/FunctionType.java
624	private  Set<Var>  hasOkDuplicateDeclaration  =  Sets.newHashSet();  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_153_Normalize_5_1	631	0	src/com/google/javascript/jscomp/Normalize.java
625	Scope  s,  String  name,  Node  n,  CompilerInput  input)  {  Node  parent  =  n.getParent();  if  (v  !=  null  &&  s.isGlobal())  {  	[BUGGY]  Scope  s  ,  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  Node  nodeWithLineNumber  )  {  [FE]  AssertionFailedError:  [METHOD]  onRedeclaration  [TYPE]  void  [PARAMETER]  Scope  s  String  name  Node  n  Node  parent  Node  gramps  Node  nodeWithLineNumber  [CLASS]  DuplicateDeclarationHandler  [TYPE]  boolean  false  true  [TYPE]  Scope  s  [TYPE]  Var  v  [TYPE]  Node  gramps  n  nodeWithLineNumber  parent  [TYPE]  String  name  [CONTEXT]  public  void  onRedeclaration  (  [BUGGY]  Scope  s  ,  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  Node  nodeWithLineNumber  )  {  Preconditions  .  checkState  (  n  .  getType  (  )  =  =  Token  .  NAME  )  ;  Var  v  =  s  .  getVar  (  name  )  ;  	Closure_153_Normalize_5_2	638	2	src/com/google/javascript/jscomp/Normalize.java
626	if  (v.isExtern()  &&  !input.isExtern())  {  if  (hasOkDuplicateDeclaration.add(v))  {  return;  }  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  onRedeclaration  [TYPE]  void  [PARAMETER]  Scope  s  String  name  Node  n  Node  parent  Node  gramps  Node  nodeWithLineNumber  [CLASS]  DuplicateDeclarationHandler  [TYPE]  boolean  false  true  [TYPE]  Scope  s  [TYPE]  Var  v  [TYPE]  Node  gramps  n  nodeWithLineNumber  parent  [TYPE]  String  name  [CONTEXT]  public  void  onRedeclaration  (  Scope  s  ,  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  Node  nodeWithLineNumber  )  {  Preconditions  .  checkState  (  n  .  getType  (  )  =  =  Token  .  NAME  )  ;  Var  v  =  s  .  getVar  (  name  )  ;  [BUGGY]  if  (  v  !  =  null  &&  v  .  getParentNode  (  )  .  getType  (  )  =  =  Token  .  CATCH  )  {  	Closure_153_Normalize_5_3	647	0	src/com/google/javascript/jscomp/Normalize.java
627	input.getName(),  n,  	[BUGGY]  NodeUtil  .  getSourceName  (  nodeWithLineNumber  )  ,  nodeWithLineNumber  ,  [FE]  AssertionFailedError:  [METHOD]  onRedeclaration  [TYPE]  void  [PARAMETER]  Scope  s  String  name  Node  n  Node  parent  Node  gramps  Node  nodeWithLineNumber  [CLASS]  DuplicateDeclarationHandler  [TYPE]  boolean  false  true  [TYPE]  Scope  s  [TYPE]  Var  v  [TYPE]  Node  gramps  n  nodeWithLineNumber  parent  [TYPE]  String  name  [CONTEXT]  if  (  v  !  =  null  &&  v  .  getParentNode  (  )  .  getType  (  )  =  =  Token  .  CATCH  )  {  name  =  MakeDeclaredNamesUnique  .  ContextualRenameInverter  .  getOrginalName  (  name  )  ;  compiler  .  report  (  JSError  .  make  (  [BUGGY]  NodeUtil  .  getSourceName  (  nodeWithLineNumber  )  ,  nodeWithLineNumber  ,  CATCH_BLOCK_VAR_ERROR  ,  name  )  )  ;  }  else  if  (  v  !  =  null  &&  parent  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  if  (  v  .  getParentNode  (  )  .  getType  (  )  =  =  Token  .  VAR  )  {  s  .  undeclare  (  v  )  ;  s  .  declare  (  name  ,  n  ,  n  .  getJSType  (  )  ,  v  .  input  )  ;  	Closure_153_Normalize_5_4	669	1	src/com/google/javascript/jscomp/Normalize.java
628	replaceVarWithAssignment(n,  parent,  parent.getParent());  	[BUGGY]  replaceVarWithAssignment  (  n  ,  parent  ,  gramps  )  ;  [FE]  AssertionFailedError:  [METHOD]  onRedeclaration  [TYPE]  void  [PARAMETER]  Scope  s  String  name  Node  n  Node  parent  Node  gramps  Node  nodeWithLineNumber  [CLASS]  DuplicateDeclarationHandler  [TYPE]  boolean  false  true  [TYPE]  Scope  s  [TYPE]  Var  v  [TYPE]  Node  gramps  n  nodeWithLineNumber  parent  [TYPE]  String  name  [CONTEXT]  name  =  MakeDeclaredNamesUnique  .  ContextualRenameInverter  .  getOrginalName  (  name  )  ;  compiler  .  report  (  JSError  .  make  (  NodeUtil  .  getSourceName  (  nodeWithLineNumber  )  ,  nodeWithLineNumber  ,  CATCH_BLOCK_VAR_ERROR  ,  name  )  )  ;  }  else  if  (  v  !  =  null  &&  parent  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  if  (  v  .  getParentNode  (  )  .  getType  (  )  =  =  Token  .  VAR  )  {  s  .  undeclare  (  v  )  ;  s  .  declare  (  name  ,  n  ,  n  .  getJSType  (  )  ,  v  .  input  )  ;  replaceVarWithAssignment  (  v  .  getNameNode  (  )  ,  v  .  getParentNode  (  )  ,  v  .  getParentNode  (  )  .  getParent  (  )  )  ;  }  }  else  if  (  parent  .  getType  (  )  =  =  Token  .  VAR  )  {  Preconditions  .  checkState  (  parent  .  hasOneChild  (  )  )  ;  [BUGGY]  replaceVarWithAssignment  (  n  ,  parent  ,  gramps  )  ;  }  }  	Closure_153_Normalize_5_5	681	1	src/com/google/javascript/jscomp/Normalize.java
629		[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_153_SyntacticScopeCreator_10_1	23	0	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
630	declareVar(fnNameNode);  	[BUGGY]  declareVar  (  fnName  ,  fnNameNode  ,  n  ,  null  ,  null  ,  n  )  ;  [FE]  AssertionFailedError:  [METHOD]  scanRoot  [TYPE]  void  [PARAMETER]  Node  n  Scope  parent  [CLASS]  SyntacticScopeCreator  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Scope  parent  scope  [TYPE]  DiagnosticType  VAR_ARGUMENTS_SHADOWED_ERROR  VAR_MULTIPLY_DECLARED_ERROR  [TYPE]  Node  a  args  body  fnNameNode  n  [TYPE]  String  ARGUMENTS  fnName  sourceName  [TYPE]  RedeclarationHandler  redeclarationHandler  [CONTEXT]  private  void  scanRoot  (  Node  n  ,  Scope  parent  )  {  if  (  n  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  sourceName  =  (  String  )  n  .  getProp  (  Node  .  SOURCENAME_PROP  )  ;  final  Node  fnNameNode  =  n  .  getFirstChild  (  )  ;  final  Node  args  =  fnNameNode  .  getNext  (  )  ;  final  Node  body  =  args  .  getNext  (  )  ;  String  fnName  =  fnNameNode  .  getString  (  )  ;  if  (  !fnName  .  isEmpty  (  )  &&  NodeUtil  .  isFunctionExpression  (  n  )  )  {  [BUGGY]  declareVar  (  fnName  ,  fnNameNode  ,  n  ,  null  ,  null  ,  n  )  ;  }  Preconditions  .  checkState  (  args  .  getType  (  )  =  =  Token  .  LP  )  ;  for  (  Node  a  =  args  .  getFirstChild  (  )  ;  a  !  =  null  ;  	Closure_153_SyntacticScopeCreator_10_2	95	1	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
631	declareVar(a);  	[BUGGY]  declareVar  (  a  .  getString  (  )  ,  a  ,  args  ,  n  ,  null  ,  n  )  ;  [FE]  AssertionFailedError:  [METHOD]  scanRoot  [TYPE]  void  [PARAMETER]  Node  n  Scope  parent  [CLASS]  SyntacticScopeCreator  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Scope  parent  scope  [TYPE]  DiagnosticType  VAR_ARGUMENTS_SHADOWED_ERROR  VAR_MULTIPLY_DECLARED_ERROR  [TYPE]  Node  a  args  body  fnNameNode  n  [TYPE]  String  ARGUMENTS  fnName  sourceName  [TYPE]  RedeclarationHandler  redeclarationHandler  [CONTEXT]  private  void  scanRoot  (  Node  n  ,  Scope  parent  )  {  if  (  n  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  sourceName  =  (  String  )  n  .  getProp  (  Node  .  SOURCENAME_PROP  )  ;  final  Node  fnNameNode  =  n  .  getFirstChild  (  )  ;  final  Node  args  =  fnNameNode  .  getNext  (  )  ;  final  Node  body  =  args  .  getNext  (  )  ;  String  fnName  =  fnNameNode  .  getString  (  )  ;  if  (  !fnName  .  isEmpty  (  )  &&  NodeUtil  .  isFunctionExpression  (  n  )  )  {  declareVar  (  fnName  ,  fnNameNode  ,  n  ,  null  ,  null  ,  n  )  ;  }  Preconditions  .  checkState  (  args  .  getType  (  )  =  =  Token  .  LP  )  ;  for  (  Node  a  =  args  .  getFirstChild  (  )  ;  a  !  =  null  ;  a  =  a  .  getNext  (  )  )  {  Preconditions  .  checkState  (  a  .  getType  (  )  =  =  Token  .  NAME  )  ;  [BUGGY]  declareVar  (  a  .  getString  (  )  ,  a  ,  args  ,  n  ,  null  ,  n  )  ;  }  scanVars  (  body  ,  n  )  ;  }  else  {  	Closure_153_SyntacticScopeCreator_10_3	103	1	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
632	declareVar(child);  	[BUGGY]  Preconditions  .  checkState  (  child  .  getType  (  )  =  =  Token  .  NAME  )  ;  String  name  =  child  .  getString  (  )  ;  declareVar  (  name  ,  child  ,  n  ,  parent  ,  null  ,  n  )  ;  [FE]  AssertionFailedError:  [METHOD]  scanVars  [TYPE]  void  [PARAMETER]  Node  n  Node  parent  [CLASS]  SyntacticScopeCreator  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Scope  scope  [TYPE]  DiagnosticType  VAR_ARGUMENTS_SHADOWED_ERROR  VAR_MULTIPLY_DECLARED_ERROR  [TYPE]  Node  block  child  n  next  parent  var  [TYPE]  String  ARGUMENTS  fnName  name  sourceName  [TYPE]  RedeclarationHandler  redeclarationHandler  [CONTEXT]  private  void  scanVars  (  Node  n  ,  Node  parent  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  VAR:  for  (  Node  child  =  n  .  getFirstChild  (  )  ;  child  !  =  null  ;  )  {  Node  next  =  child  .  getNext  (  )  ;  [BUGGY]  Preconditions  .  checkState  (  child  .  getType  (  )  =  =  Token  .  NAME  )  ;  String  name  =  child  .  getString  (  )  ;  declareVar  (  name  ,  child  ,  n  ,  parent  ,  null  ,  n  )  ;  child  =  next  ;  }  return  ;  	Closure_153_SyntacticScopeCreator_10_4	125	3	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
633	declareVar(n.getFirstChild());\n', "  return;  	[BUGGY]  declareVar  (  fnName  ,  n  .  getFirstChild  (  )  ,  n  ,  parent  ,  null  ,  n  )  ;  [FE]  AssertionFailedError:  [METHOD]  scanVars  [TYPE]  void  [PARAMETER]  Node  n  Node  parent  [CLASS]  SyntacticScopeCreator  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Scope  scope  [TYPE]  DiagnosticType  VAR_ARGUMENTS_SHADOWED_ERROR  VAR_MULTIPLY_DECLARED_ERROR  [TYPE]  Node  block  child  n  next  parent  var  [TYPE]  String  ARGUMENTS  fnName  name  sourceName  [TYPE]  RedeclarationHandler  redeclarationHandler  [CONTEXT]  private  void  scanVars  (  Node  n  ,  Node  parent  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  VAR:  for  (  Node  child  =  n  .  getFirstChild  (  )  ;  child  !  =  null  ;  )  {  Node  next  =  child  .  getNext  (  )  ;  Preconditions  .  checkState  (  child  .  getType  (  )  =  =  Token  .  NAME  )  ;  String  name  =  child  .  getString  (  )  ;  declareVar  (  name  ,  child  ,  n  ,  parent  ,  null  ,  n  )  ;  child  =  next  ;  }  return  ;  case  Token  .  FUNCTION:  if  (  NodeUtil  .  isFunctionExpression  (  n  )  )  {  return  ;  }  String  fnName  =  n  .  getFirstChild  (  )  .  getString  (  )  ;  if  (  fnName  .  isEmpty  (  )  )  {  return  ;  }  [BUGGY]  declareVar  (  fnName  ,  n  .  getFirstChild  (  )  ,  n  ,  parent  ,  null  ,  n  )  ;  return  ;  //  should  not  examine  function's  children  case  Token  .  CATCH:  Preconditions  .  checkState  (  n  .  getChildCount  (  )  =  =  2  )  ;  Preconditions  .  checkState  (  n  .  getFirstChild  (  )  .  getType  (  )  =  =  Token  .  NAME  )  ;  	Closure_153_SyntacticScopeCreator_10_5	142	1	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
634	declareVar(var);  	[BUGGY]  declareVar  (  var  .  getString  (  )  ,  var  ,  n  ,  parent  ,  null  ,  n  )  ;  [FE]  AssertionFailedError:  [METHOD]  scanVars  [TYPE]  void  [PARAMETER]  Node  n  Node  parent  [CLASS]  SyntacticScopeCreator  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Scope  scope  [TYPE]  DiagnosticType  VAR_ARGUMENTS_SHADOWED_ERROR  VAR_MULTIPLY_DECLARED_ERROR  [TYPE]  Node  block  child  n  next  parent  var  [TYPE]  String  ARGUMENTS  fnName  name  sourceName  [TYPE]  RedeclarationHandler  redeclarationHandler  [CONTEXT]  }  return  ;  case  Token  .  FUNCTION:  if  (  NodeUtil  .  isFunctionExpression  (  n  )  )  {  return  ;  }  String  fnName  =  n  .  getFirstChild  (  )  .  getString  (  )  ;  if  (  fnName  .  isEmpty  (  )  )  {  return  ;  }  declareVar  (  fnName  ,  n  .  getFirstChild  (  )  ,  n  ,  parent  ,  null  ,  n  )  ;  return  ;  //  should  not  examine  function's  children  case  Token  .  CATCH:  Preconditions  .  checkState  (  n  .  getChildCount  (  )  =  =  2  )  ;  Preconditions  .  checkState  (  n  .  getFirstChild  (  )  .  getType  (  )  =  =  Token  .  NAME  )  ;  final  Node  var  =  n  .  getFirstChild  (  )  ;  final  Node  block  =  var  .  getNext  (  )  ;  [BUGGY]  declareVar  (  var  .  getString  (  )  ,  var  ,  n  ,  parent  ,  null  ,  n  )  ;  scanVars  (  block  ,  n  )  ;  return  ;  //  only  one  child  to  scan  case  Token  .  SCRIPT:  sourceName  =  (  String  )  n  .  getProp  (  Node  .  SOURCENAME_PROP  )  ;  	Closure_153_SyntacticScopeCreator_10_6	154	1	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
635	Scope  s,  String  name,  Node  n,  CompilerInput  input);  	[BUGGY]  Scope  s  ,  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  Node  nodeWithLineNumber  )  ;  [FE]  AssertionFailedError:  [METHOD]  onRedeclaration  [TYPE]  void  [PARAMETER]  Scope  s  String  name  Node  n  Node  parent  Node  gramps  Node  nodeWithLineNumber  [CLASS]  SyntacticScopeCreator  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Scope  s  scope  [TYPE]  DiagnosticType  VAR_ARGUMENTS_SHADOWED_ERROR  VAR_MULTIPLY_DECLARED_ERROR  [TYPE]  Node  gramps  n  nodeWithLineNumber  parent  [TYPE]  String  ARGUMENTS  name  sourceName  [TYPE]  RedeclarationHandler  redeclarationHandler  [CONTEXT]  void  onRedeclaration  (  [BUGGY]  Scope  s  ,  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  Node  nodeWithLineNumber  )  ;  	Closure_153_SyntacticScopeCreator_10_7	180	2	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
636	Scope  s,  String  name,  Node  n,  CompilerInput  input)  {  Node  parent  =  n.getParent();  	[BUGGY]  Scope  s  ,  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  Node  nodeWithLineNumber  )  {  [FE]  AssertionFailedError:  [METHOD]  onRedeclaration  [TYPE]  void  [PARAMETER]  Scope  s  String  name  Node  n  Node  parent  Node  gramps  Node  nodeWithLineNumber  [CLASS]  DefaultRedeclarationHandler  [TYPE]  boolean  allowDupe  false  true  [TYPE]  Scope  s  [TYPE]  Var  origVar  [TYPE]  Node  gramps  n  nodeWithLineNumber  origParent  parent  [TYPE]  String  name  [TYPE]  JSDocInfo  info  [CONTEXT]  public  void  onRedeclaration  (  [BUGGY]  Scope  s  ,  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  Node  nodeWithLineNumber  )  {  if  (  scope  .  isGlobal  (  )  )  {  Scope  .  Var  origVar  =  scope  .  getVar  (  name  )  ;  	Closure_153_SyntacticScopeCreator_10_8	189	2	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
637	private  void  declareVar(Node  n)  {  Preconditions.checkState(n.getType()  ==  Token.NAME);  CompilerInput  input  =  compiler.getInput(sourceName);  String  name  =  n.getString();  	[BUGGY]  private  void  declareVar  (  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  JSType  declaredType  ,  Node  nodeWithLineNumber  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_153_SyntacticScopeCreator_10_9	235	3	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
638	scope,  name,  n,  input);  scope.declare(name,  n,  null,  input);  	[BUGGY]  scope  ,  name  ,  n  ,  parent  ,  gramps  ,  nodeWithLineNumber  )  ;  scope  .  declare  (  name  ,  n  ,  declaredType  ,  compiler  .  getInput  (  sourceName  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  declareVar  [TYPE]  void  [PARAMETER]  String  name  Node  n  Node  parent  Node  gramps  JSType  declaredType  Node  nodeWithLineNumber  [CLASS]  SyntacticScopeCreator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSType  declaredType  [TYPE]  boolean  false  true  [TYPE]  Scope  scope  [TYPE]  DiagnosticType  VAR_ARGUMENTS_SHADOWED_ERROR  VAR_MULTIPLY_DECLARED_ERROR  [TYPE]  Node  gramps  n  nodeWithLineNumber  parent  [TYPE]  String  ARGUMENTS  name  sourceName  [TYPE]  RedeclarationHandler  redeclarationHandler  [CONTEXT]  private  void  declareVar  (  String  name  ,  Node  n  ,  Node  parent  ,  Node  gramps  ,  JSType  declaredType  ,  Node  nodeWithLineNumber  )  {  if  (  scope  .  isDeclared  (  name  ,  false  )  ||  (  scope  .  isLocal  (  )  &&  name  .  equals  (  ARGUMENTS  )  )  )  {  redeclarationHandler  .  onRedeclaration  (  [BUGGY]  scope  ,  name  ,  n  ,  parent  ,  gramps  ,  nodeWithLineNumber  )  ;  }  else  {  scope  .  declare  (  name  ,  n  ,  declaredType  ,  compiler  .  getInput  (  sourceName  )  )  ;  }  }  	Closure_153_SyntacticScopeCreator_10_10	242	2	src/com/google/javascript/jscomp/SyntacticScopeCreator.java
639		[BUGGY]  static  final  DiagnosticType  HIDDEN_INTERFACE_PROPERTY_MISMATCH  =  DiagnosticType  .  warning  ( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH "  , "mismatch  of  the  {0}  property  type  and  the  type "  + "of  the  property  it  overrides  from  interface  {1}\\n "  + "original:  {2}\\n "  + "override:  {3} "  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_154_TypeCheck_3_1	185	7	src/com/google/javascript/jscomp/TypeCheck.java
640		[BUGGY]  HIDDEN_INTERFACE_PROPERTY_MISMATCH  ,  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_154_TypeCheck_3_2	242	1	src/com/google/javascript/jscomp/TypeCheck.java
641		[BUGGY]  if  (  interfaceHasProperty  )  {  JSType  interfacePropType  =  interfaceType  .  getPrototype  (  )  .  getPropertyType  (  propertyName  )  ;  if  (  !propertyType  .  canAssignTo  (  interfacePropType  )  )  {  compiler  .  report  (  t  .  makeError  (  n  ,  HIDDEN_INTERFACE_PROPERTY_MISMATCH  ,  propertyName  ,  interfaceType  .  getTopMostDefiningType  (  propertyName  )  .  toString  (  )  ,  interfacePropType  .  toString  (  )  ,  propertyType  .  toString  (  )  )  )  ;  }  }  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  checkDeclaredPropertyInheritance  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  FunctionType  ctorType  String  propertyName  JSDocInfo  info  JSType  propertyType  [CLASS]  TypeCheck  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  implementedInterface  interfacePropType  propertyType  superClassPropType  topInstanceType  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  CheckLevel  reportMissingOverride  reportUnknownTypes  [TYPE]  Node  n  [TYPE]  FunctionType  ctorType  interfaceType  superClass  [TYPE]  ScopeCreator  scopeCreator  [TYPE]  String  OVERRIDING_PROTOTYPE_WITH_NON_OBJECT  propertyName  [TYPE]  JSDocInfo  info  [TYPE]  int  noTypeCheckSection  nullCount  typedCount  unknownCount  [TYPE]  TypeValidator  validator  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  boolean  declaredOverride  false  foundInterfaceProperty  inExterns  interfaceHasProperty  reportMissingProperties  superClassHasProperty  true  [TYPE]  Scope  topScope  [TYPE]  DiagnosticType  BAD_DELETE  BAD_IMPLEMENTED_TYPE  BIT_OPERATION  CONFLICTING_EXTENDED_TYPE  CONSTRUCTOR_NOT_CALLABLE  DETERMINISTIC_TEST  DETERMINISTIC_TEST_NO_RESULT  ENUM_DUP  ENUM_NOT_CONSTANT  FUNCTION_MASKS_VARIABLE  HIDDEN_INTERFACE_PROPERTY  HIDDEN_INTERFACE_PROPERTY_MISMATCH  HIDDEN_SUPERCLASS_PROPERTY  HIDDEN_SUPERCLASS_PROPERTY_MISMATCH  ILLEGAL_IMPLICIT_CAST  INEXISTENT_ENUM_ELEMENT  INEXISTENT_PROPERTY  INTERFACE_FUNCTION_NOT_EMPTY  INTERFACE_METHOD_OVERRIDE  INVALID_INTERFACE_MEMBER_DECLARATION  MULTIPLE_VAR_DEF  NOT_A_CONSTRUCTOR  NOT_CALLABLE  UNEXPECTED_TOKEN  UNKNOWN_EXPR_TYPE  UNKNOWN_OVERRIDE  UNRESOLVED_TYPE  WRONG_ARGUMENT_COUNT  [TYPE]  InferJSDocInfo  inferJSDocInfo  [CONTEXT]  boolean  superClassHasProperty  =  superClass  !  =  null  &&  superClass  .  getPrototype  (  )  .  hasProperty  (  propertyName  )  ;  boolean  declaredOverride  =  info  !  =  null  &&  info  .  isOverride  (  )  ;  boolean  foundInterfaceProperty  =  false  ;  if  (  ctorType  .  isConstructor  (  )  )  {  for  (  JSType  implementedInterface  :  ctorType  .  getImplementedInterfaces  (  )  )  {  if  (  implementedInterface  .  isUnknownType  (  )  ||  implementedInterface  .  isEmptyType  (  )  )  {  continue  ;  }  FunctionType  interfaceType  =  implementedInterface  .  toObjectType  (  )  .  getConstructor  (  )  ;  Preconditions  .  checkNotNull  (  interfaceType  )  ;  boolean  interfaceHasProperty  =  interfaceType  .  getPrototype  (  )  .  hasProperty  (  propertyName  )  ;  foundInterfaceProperty  =  foundInterfaceProperty  ||  interfaceHasProperty  ;  if  (  reportMissingOverride  .  isOn  (  )  &&  !declaredOverride  &&  interfaceHasProperty  )  {  compiler  .  report  (  t  .  makeError  (  n  ,  reportMissingOverride  ,  HIDDEN_INTERFACE_PROPERTY  ,  propertyName  ,  interfaceType  .  getTopMostDefiningType  (  propertyName  )  .  toString  (  )  )  )  ;  }  [BUGGY]  if  (  interfaceHasProperty  )  {  JSType  interfacePropType  =  interfaceType  .  getPrototype  (  )  .  getPropertyType  (  propertyName  )  ;  if  (  !propertyType  .  canAssignTo  (  interfacePropType  )  )  {  compiler  .  report  (  t  .  makeError  (  n  ,  HIDDEN_INTERFACE_PROPERTY_MISMATCH  ,  propertyName  ,  	Closure_154_TypeCheck_3_3	1049	10	src/com/google/javascript/jscomp/TypeCheck.java
642	static  final  DiagnosticType  HIDDEN_INTERFACE_PROPERTY_MISMATCH  =  DiagnosticType.warning( "JSC_HIDDEN_INTERFACE_PROPERTY_MISMATCH ", "mismatch  of  the  {0}  property  type  and  the  type "  + "of  the  property  it  overrides  from  interface  {1}\\n "  + "original:  {2}\\n "  + "override:  {3} ");  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_154_TypeValidator_3_1	110	0	src/com/google/javascript/jscomp/TypeValidator.java
643	INTERFACE_METHOD_NOT_IMPLEMENTED,  HIDDEN_INTERFACE_PROPERTY_MISMATCH);  	[BUGGY]  INTERFACE_METHOD_NOT_IMPLEMENTED  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_154_TypeValidator_3_2	117	1	src/com/google/javascript/jscomp/TypeValidator.java
644	}  else  {  JSType  found  =  instance.getPropertyType(prop);  JSType  required  =  implementedInterface.getImplicitPrototype().getPropertyType(prop);  found  =  found.restrictByNotNullOrUndefined();  required  =  required.restrictByNotNullOrUndefined();  if  (!found.canAssignTo(required))  {  if  (shouldReport)  {  FunctionType  constructor  =  implementedInterface.toObjectType().getConstructor();  compiler.report(t.makeError(n,  HIDDEN_INTERFACE_PROPERTY_MISMATCH,  prop,  constructor.getTopMostDefiningType(prop).toString(),  required.toString(),  found.toString()));  }  registerMismatch(found,  required);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  expectInterfaceProperty  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  ObjectType  instance  ObjectType  implementedInterface  String  prop  [CLASS]  TypeValidator  [TYPE]  ObjectType  implementedInterface  instance  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  JSType  allValueTypes  nullOrUndefined  typeA  typeB  [TYPE]  boolean  false  shouldReport  true  [TYPE]  NodeTraversal  t  [TYPE]  DiagnosticType  DUP_VAR_DECLARATION  HIDDEN_PROPERTY_MISMATCH  INTERFACE_METHOD_NOT_IMPLEMENTED  INVALID_CAST  MISSING_EXTENDS_TAG_WARNING  TYPE_MISMATCH_WARNING  [TYPE]  DiagnosticGroup  ALL_DIAGNOSTICS  [TYPE]  Node  n  [TYPE]  List  mismatches  [TYPE]  String  FOUND_REQUIRED  prop  sourceName  [CONTEXT]  private  void  expectInterfaceProperty  (  NodeTraversal  t  ,  Node  n  ,  ObjectType  instance  ,  ObjectType  implementedInterface  ,  String  prop  )  {  if  (  !instance  .  hasProperty  (  prop  )  )  {  String  sourceName  =  (  String  )  n  .  getProp  (  Node  .  SOURCENAME_PROP  )  ;  sourceName  =  sourceName  =  =  null  ? " "  :  sourceName  ;  if  (  shouldReport  )  {  compiler  .  report  (  JSError  .  make  (  sourceName  ,  n  ,  INTERFACE_METHOD_NOT_IMPLEMENTED  ,  prop  ,  implementedInterface  .  toString  (  )  ,  instance  .  toString  (  )  )  )  ;  }  registerMismatch  (  instance  ,  implementedInterface  )  ;  [BUGGY]  }  }  	Closure_154_TypeValidator_3_3	588	0	src/com/google/javascript/jscomp/TypeValidator.java
645	boolean  maybeModifiedArguments  =  maybeEscapedOrModifiedArguments(t.getScope(),  referenceMap);  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  doInlinesForScope  [TYPE]  void  [PARAMETER]  NodeTraversal  t  ReferenceCollection>  referenceMap  [CLASS]  InliningBehavior  [TYPE]  Set  staleVars  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Reference  init  [TYPE]  Node  value  [TYPE]  Iterator  it  [TYPE]  Map  aliasCandidates  referenceMap  [TYPE]  ReferenceCollection  referenceInfo  [CONTEXT]  private  void  doInlinesForScope  (  NodeTraversal  t  ,  Map<Var  ,  ReferenceCollection>  referenceMap  )  {  [BUGGY]  for  (  Iterator<Var>  it  =  t  .  getScope  (  )  .  getVars  (  )  ;  it  .  hasNext  (  )  ;  )  {  Var  v  =  it  .  next  (  )  ;  ReferenceCollection  referenceInfo  =  referenceMap  .  get  (  v  )  ;  if  (  referenceInfo  =  =  null  ||  isVarInlineForbidden  (  v  )  )  {  continue  ;  }  else  if  (  isInlineableDeclaredConstant  (  v  ,  referenceInfo  )  )  {  Reference  init  =  referenceInfo  .  getInitializingReferenceForConstants  (  )  ;  Node  value  =  init  .  getAssignedValue  (  )  ;  inlineDeclaredConstant  (  v  ,  value  ,  referenceInfo  .  references  )  ;  staleVars  .  add  (  v  )  ;  }  else  if  (  mode  =  =  Mode  .  CONSTANTS_ONLY  )  {  continue  ;  }  else  {  inlineNonConstants  (  v  ,  referenceInfo  )  ;  }  }  }  	Closure_155_InlineVariables_4_1	199	0	src/com/google/javascript/jscomp/InlineVariables.java
646	inlineNonConstants(v,  referenceInfo,  maybeModifiedArguments);  	[BUGGY]  inlineNonConstants  (  v  ,  referenceInfo  )  ;  [FE]  AssertionFailedError:  [METHOD]  doInlinesForScope  [TYPE]  void  [PARAMETER]  NodeTraversal  t  ReferenceCollection>  referenceMap  [CLASS]  InliningBehavior  [TYPE]  Set  staleVars  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Reference  init  [TYPE]  Node  value  [TYPE]  Iterator  it  [TYPE]  Map  aliasCandidates  referenceMap  [TYPE]  ReferenceCollection  referenceInfo  [CONTEXT]  private  void  doInlinesForScope  (  NodeTraversal  t  ,  Map<Var  ,  ReferenceCollection>  referenceMap  )  {  for  (  Iterator<Var>  it  =  t  .  getScope  (  )  .  getVars  (  )  ;  it  .  hasNext  (  )  ;  )  {  Var  v  =  it  .  next  (  )  ;  ReferenceCollection  referenceInfo  =  referenceMap  .  get  (  v  )  ;  if  (  referenceInfo  =  =  null  ||  isVarInlineForbidden  (  v  )  )  {  continue  ;  }  else  if  (  isInlineableDeclaredConstant  (  v  ,  referenceInfo  )  )  {  Reference  init  =  referenceInfo  .  getInitializingReferenceForConstants  (  )  ;  Node  value  =  init  .  getAssignedValue  (  )  ;  inlineDeclaredConstant  (  v  ,  value  ,  referenceInfo  .  references  )  ;  staleVars  .  add  (  v  )  ;  }  else  if  (  mode  =  =  Mode  .  CONSTANTS_ONLY  )  {  continue  ;  }  else  {  [BUGGY]  inlineNonConstants  (  v  ,  referenceInfo  )  ;  }  }  }  	Closure_155_InlineVariables_4_2	220	1	src/com/google/javascript/jscomp/InlineVariables.java
647	private  boolean  maybeEscapedOrModifiedArguments(  Scope  scope,  Map<Var,  ReferenceCollection>  referenceMap)  {  if  (scope.isLocal())  {  Var  arguments  =  scope.getArgumentsVar();  ReferenceCollection  refs  =  referenceMap.get(arguments);  if  (refs  !=  null  &&  !refs.references.isEmpty())  {  for  (Reference  ref  :  refs.references)  {  Node  refNode  =  ref.getNameNode();  Node  refParent  =  ref.getParent();  if  (!(NodeUtil.isGet(refParent)  &&  refNode  ==  ref.getParent().getFirstChild()  &&  !isLValue(refParent)))  {  return  true;  }  }  }  }  return  false;  }  private  boolean  isLValue(Node  n)  {  Node  parent  =  n.getParent();  return  (parent.getType()  ==  Token.INC  ||  parent.getType()  ==  Token.DEC  ||  (NodeUtil.isAssignmentOp(parent)  &&  parent.getFirstChild()  ==  n));  }  Var  v,  ReferenceCollection  referenceInfo,  boolean  maybeModifiedArguments)  {  	[BUGGY]  Var  v  ,  ReferenceCollection  referenceInfo  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_155_InlineVariables_4_3	225	1	src/com/google/javascript/jscomp/InlineVariables.java
648	if  (!maybeModifiedArguments  &&  	[BUGGY]  if  (  [FE]  AssertionFailedError:  [METHOD]  inlineNonConstants  [TYPE]  void  [PARAMETER]  Var  v  ReferenceCollection  referenceInfo  [CLASS]  InliningBehavior  [TYPE]  Set  staleVars  [TYPE]  boolean  false  true  [TYPE]  Var  v  [TYPE]  Reference  aliasInit  declaration  init  reference  [TYPE]  Node  nameNode  srcLocation  value  [TYPE]  List  refs  [TYPE]  Map  aliasCandidates  [TYPE]  ReferenceCollection  referenceInfo  [TYPE]  int  firstRefAfterInit  i  refCount  [TYPE]  AliasCandidate  candidate  [CONTEXT]  staleVars  .  add  (  v  )  ;  }  else  if  (  refCount  =  =  firstRefAfterInit  )  {  Reference  reference  =  referenceInfo  .  references  .  get  (  firstRefAfterInit  -  1  )  ;  if  (  canInline  (  declaration  ,  init  ,  reference  )  )  {  inline  (  v  ,  declaration  ,  init  ,  reference  )  ;  staleVars  .  add  (  v  )  ;  }  }  else  if  (  declaration  !  =  init  &&  refCount  =  =  2  )  {  if  (  isValidDeclaration  (  declaration  )  &&  isValidInitialization  (  init  )  )  {  Node  value  =  init  .  getAssignedValue  (  )  ;  Preconditions  .  checkNotNull  (  value  )  ;  inlineWellDefinedVariable  (  v  ,  value  ,  referenceInfo  .  references  )  ;  staleVars  .  add  (  v  )  ;  }  }  [BUGGY]  if  (  !staleVars  .  contains  (  v  )  &&  referenceInfo  .  isWellDefined  (  )  &&  referenceInfo  .  isAssignedOnceInLifetime  (  )  )  {  List<Reference>  refs  =  referenceInfo  .  references  ;  for  (  int  i  =  1  /*  start  from  a  read  */  ;  i  <  refs  .  size  (  )  ;  i++  )  {  Node  nameNode  =  refs  .  get  (  i  )  .  getNameNode  (  )  ;  	Closure_155_InlineVariables_4_4	275	1	src/com/google/javascript/jscomp/InlineVariables.java
649	Var  v;  if  (n.getString().equals( "arguments "))  {  v  =  t.getScope().getArgumentsVar();  }  else  {  v  =  t.getScope().getVar(n.getString());  }  	[BUGGY]  Var  v  =  t  .  getScope  (  )  .  getVar  (  n  .  getString  (  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ReferenceCollectingCallback  [TYPE]  Set  DECLARATION_PARENTS  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  grandparent  n  nameNode  parent  [TYPE]  BasicBlock  basicBlock  parent  [TYPE]  String  sourceName  [TYPE]  Deque  blockStack  [TYPE]  Predicate  varFilter  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  isFunction  isHoisted  isLoop  true  [TYPE]  Scope  scope  [TYPE]  List  references  [TYPE]  Behavior  DO_NOTHING_BEHAVIOR  behavior  [TYPE]  Map  referenceMap  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  getType  (  )  =  =  Token  .  NAME  )  {  [BUGGY]  Var  v  =  t  .  getScope  (  )  .  getVar  (  n  .  getString  (  )  )  ;  if  (  v  !  =  null  &&  varFilter  .  apply  (  v  )  )  {  addReference  (  t  ,  v  ,  new  Reference  (  n  ,  parent  ,  t  ,  blockStack  .  peek  (  )  )  )  ;  }  }  if  (  isBlockBoundary  (  n  ,  parent  )  )  {  blockStack  .  pop  (  )  ;  }  }  	Closure_155_ReferenceCollectingCallback_1_1	123	1	src/com/google/javascript/jscomp/ReferenceCollectingCallback.java
650	private  Var  arguments;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_155_Scope_3_1	63	0	src/com/google/javascript/jscomp/Scope.java
651	public  static  class  Arguments  extends  Var  {  Arguments(Scope  scope)  {  super(  false, "arguments ",  null,  null,  scope,  -1,  null,  false,  null  );  }  @Override  public  boolean  equals(Object  other)  {  if  (!(other  instanceof  Arguments))  {  return  false;  }  Arguments  otherVar  =  (Arguments)  other;  return  otherVar.scope.getRootNode()  ==  scope.getRootNode();  }  @Override  public  int  hashCode()  {  return  System.identityHashCode(this);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_155_Scope_3_2	290	0	src/com/google/javascript/jscomp/Scope.java
652	public  Var  getArgumentsVar()  {  if  (arguments  ==  null)  {  arguments  =  new  Arguments(this);  }  return  arguments;  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_155_Scope_3_3	459	0	src/com/google/javascript/jscomp/Scope.java
653	if  (n.canCollapse())  {  updateObjLitOrFunctionDeclaration(n,  alias,  canCollapseChildNames);  	[BUGGY]  if  (  n  .  canCollapse  (  )  &&  canCollapseChildNames  )  {  updateObjLitOrFunctionDeclaration  (  n  ,  alias  )  ;  [FE]  AssertionFailedError:  [METHOD]  collapseDeclarationOfNameAndDescendants  [TYPE]  void  [PARAMETER]  Name  n  String  alias  [CLASS]  CollapseProperties  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  canCollapseChildNames  collapsePropertiesOnExternTypes  false  inlineAliases  true  [TYPE]  DiagnosticType  NAMESPACE_REDEFINED_WARNING  UNSAFE_NAMESPACE_WARNING  UNSAFE_THIS  [TYPE]  List  globalNames  [TYPE]  String  alias  [TYPE]  Map  nameMap  [TYPE]  Name  n  p  [CONTEXT]  private  void  collapseDeclarationOfNameAndDescendants  (  Name  n  ,  String  alias  )  {  boolean  canCollapseChildNames  =  n  .  canCollapseUnannotatedChildNames  (  )  ;  [BUGGY]  if  (  n  .  canCollapse  (  )  &&  canCollapseChildNames  )  {  updateObjLitOrFunctionDeclaration  (  n  ,  alias  )  ;  }  if  (  n  .  props  !  =  null  )  {  for  (  Name  p  :  n  .  props  )  {  collapseDeclarationOfNameAndDescendants  (  p  ,  appendPropForAlias  (  alias  ,  p  .  name  )  )  ;  if  (  !p  .  inExterns  &&  canCollapseChildNames  &&  p  .  declaration  !  =  null  &&  p  .  declaration  .  node  !  =  null  &&  p  .  declaration  .  node  .  getParent  (  )  !  =  null  &&  p  .  declaration  .  node  .  getParent  (  )  .  getType  (  )  =  =  Token  .  ASSIGN  )  {  updateSimpleDeclaration  (  appendPropForAlias  (  alias  ,  p  .  name  )  ,  p  ,  p  .  declaration  )  ;  }  }  }  }  	Closure_156_CollapseProperties_8_1	455	2	src/com/google/javascript/jscomp/CollapseProperties.java
654	private  void  updateObjLitOrFunctionDeclaration(  Name  n,  String  alias,  boolean  canCollapseChildNames)  {  	[BUGGY]  private  void  updateObjLitOrFunctionDeclaration  (  Name  n  ,  String  alias  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_156_CollapseProperties_8_2	574	1	src/com/google/javascript/jscomp/CollapseProperties.java
655	updateObjLitOrFunctionDeclarationAtAssignNode(  n,  alias,  canCollapseChildNames);  updateObjLitOrFunctionDeclarationAtVarNode(n,  canCollapseChildNames);  updateFunctionDeclarationAtFunctionNode(n,  canCollapseChildNames);  	[BUGGY]  updateObjLitOrFunctionDeclarationAtAssignNode  (  n  ,  alias  )  ;  updateObjLitOrFunctionDeclarationAtVarNode  (  n  )  ;  updateFunctionDeclarationAtFunctionNode  (  n  )  ;  [FE]  AssertionFailedError:  [METHOD]  updateObjLitOrFunctionDeclaration  [TYPE]  void  [PARAMETER]  Name  n  String  alias  [CLASS]  CollapseProperties  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  collapsePropertiesOnExternTypes  false  inlineAliases  true  [TYPE]  DiagnosticType  NAMESPACE_REDEFINED_WARNING  UNSAFE_NAMESPACE_WARNING  UNSAFE_THIS  [TYPE]  List  globalNames  [TYPE]  String  alias  [TYPE]  Map  nameMap  [TYPE]  Name  n  [CONTEXT]  private  void  updateObjLitOrFunctionDeclaration  (  Name  n  ,  String  alias  )  {  if  (  n  .  declaration  =  =  null  )  {  return  ;  }  if  (  n  .  declaration  .  getTwin  (  )  !  =  null  )  {  return  ;  }  switch  (  n  .  declaration  .  node  .  getParent  (  )  .  getType  (  )  )  {  case  Token  .  ASSIGN:  [BUGGY]  updateObjLitOrFunctionDeclarationAtAssignNode  (  n  ,  alias  )  ;  break  ;  case  Token  .  VAR:  updateObjLitOrFunctionDeclarationAtVarNode  (  n  )  ;  break  ;  case  Token  .  FUNCTION:  updateFunctionDeclarationAtFunctionNode  (  n  )  ;  break  ;  }  }  	Closure_156_CollapseProperties_8_3	589	3	src/com/google/javascript/jscomp/CollapseProperties.java
656	Name  n,  String  alias,  boolean  canCollapseChildNames)  {\n', "  	[BUGGY]  Name  n  ,  String  alias  )  {  [FE]  AssertionFailedError:  [METHOD]  updateObjLitOrFunctionDeclarationAtAssignNode  [TYPE]  void  [PARAMETER]  Name  n  String  alias  [CLASS]  CollapseProperties  [TYPE]  AbstractCompiler  compiler  [TYPE]  Ref  ref  [TYPE]  boolean  collapsePropertiesOnExternTypes  false  inlineAliases  insertedVarNode  isObjLit  true  [TYPE]  DiagnosticType  NAMESPACE_REDEFINED_WARNING  UNSAFE_NAMESPACE_WARNING  UNSAFE_THIS  [TYPE]  Node  gramps  nameNode  rvalue  varNode  varParent  [TYPE]  List  globalNames  [TYPE]  String  alias  [TYPE]  Map  nameMap  [TYPE]  Name  n  [CONTEXT]  private  void  updateObjLitOrFunctionDeclarationAtAssignNode  (  [BUGGY]  Name  n  ,  String  alias  )  {  Ref  ref  =  n  .  declaration  ;  	Closure_156_CollapseProperties_8_4	609	1	src/com/google/javascript/jscomp/CollapseProperties.java
657	if  (canCollapseChildNames)  {  if  (isObjLit)  {  	[BUGGY]  if  (  isObjLit  )  {  [FE]  AssertionFailedError:  [METHOD]  updateObjLitOrFunctionDeclarationAtAssignNode  [TYPE]  void  [PARAMETER]  Name  n  String  alias  [CLASS]  CollapseProperties  [TYPE]  AbstractCompiler  compiler  [TYPE]  Ref  ref  [TYPE]  boolean  collapsePropertiesOnExternTypes  false  inlineAliases  insertedVarNode  isObjLit  true  [TYPE]  DiagnosticType  NAMESPACE_REDEFINED_WARNING  UNSAFE_NAMESPACE_WARNING  UNSAFE_THIS  [TYPE]  Node  gramps  nameNode  rvalue  varNode  varParent  [TYPE]  List  globalNames  [TYPE]  String  alias  [TYPE]  Map  nameMap  [TYPE]  Name  n  [CONTEXT]  }  else  if  (  !n  .  isSimpleName  (  )  )  {  if  (  rvalue  .  getType  (  )  =  =  Token  .  FUNCTION  )  {  checkForHosedThisReferences  (  rvalue  ,  n  .  docInfo  ,  n  )  ;  }  ref  .  node  .  getParent  (  )  .  removeChild  (  rvalue  )  ;  Node  nameNode  =  NodeUtil  .  newName  (  compiler  .  getCodingConvention  (  )  ,  alias  ,  ref  .  node  .  getAncestor  (  2  )  ,  n  .  fullName  (  )  )  ;  if  (  ref  .  node  .  getLastChild  (  )  .  getBooleanProp  (  Node  .  IS_CONSTANT_NAME  )  )  {  nameNode  .  putBooleanProp  (  Node  .  IS_CONSTANT_NAME  ,  true  )  ;  }  varNode  .  addChildToBack  (  nameNode  )  ;  nameNode  .  addChildToFront  (  rvalue  )  ;  varParent  .  replaceChild  (  gramps  ,  varNode  )  ;  ref  .  node  =  nameNode  ;  insertedVarNode  =  true  ;  }  [BUGGY]  if  (  isObjLit  )  {  declareVarsForObjLitValues  (  n  ,  alias  ,  rvalue  ,  varNode  ,  varParent  .  getChildBefore  (  varNode  )  ,  varParent  )  ;  }  	Closure_156_CollapseProperties_8_5	653	1	src/com/google/javascript/jscomp/CollapseProperties.java
658	}  }  	[BUGGY]  }  [FE]  AssertionFailedError:  [METHOD]  updateObjLitOrFunctionDeclarationAtAssignNode  [TYPE]  void  [PARAMETER]  Name  n  String  alias  [CLASS]  CollapseProperties  [TYPE]  AbstractCompiler  compiler  [TYPE]  Ref  ref  [TYPE]  boolean  collapsePropertiesOnExternTypes  false  inlineAliases  insertedVarNode  isObjLit  true  [TYPE]  DiagnosticType  NAMESPACE_REDEFINED_WARNING  UNSAFE_NAMESPACE_WARNING  UNSAFE_THIS  [TYPE]  Node  gramps  nameNode  rvalue  varNode  varParent  [TYPE]  List  globalNames  [TYPE]  String  alias  [TYPE]  Map  nameMap  [TYPE]  Name  n  [CONTEXT]  }  ref  .  node  .  getParent  (  )  .  removeChild  (  rvalue  )  ;  Node  nameNode  =  NodeUtil  .  newName  (  compiler  .  getCodingConvention  (  )  ,  alias  ,  ref  .  node  .  getAncestor  (  2  )  ,  n  .  fullName  (  )  )  ;  if  (  ref  .  node  .  getLastChild  (  )  .  getBooleanProp  (  Node  .  IS_CONSTANT_NAME  )  )  {  nameNode  .  putBooleanProp  (  Node  .  IS_CONSTANT_NAME  ,  true  )  ;  }  varNode  .  addChildToBack  (  nameNode  )  ;  nameNode  .  addChildToFront  (  rvalue  )  ;  varParent  .  replaceChild  (  gramps  ,  varNode  )  ;  ref  .  node  =  nameNode  ;  insertedVarNode  =  true  ;  }  if  (  isObjLit  )  {  declareVarsForObjLitValues  (  n  ,  alias  ,  rvalue  ,  varNode  ,  varParent  .  getChildBefore  (  varNode  )  ,  varParent  )  ;  [BUGGY]  }  addStubsForUndeclaredProperties  (  n  ,  alias  ,  varParent  ,  varNode  )  ;  if  (  insertedVarNode  )  {  if  (  !varNode  .  hasChildren  (  )  )  {  	Closure_156_CollapseProperties_8_6	657	1	src/com/google/javascript/jscomp/CollapseProperties.java
659	private  void  updateObjLitOrFunctionDeclarationAtVarNode(  Name  n,  boolean  canCollapseChildNames)  {  if  (!canCollapseChildNames)  {  return;  }  	[BUGGY]  private  void  updateObjLitOrFunctionDeclarationAtVarNode  (  Name  n  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_156_CollapseProperties_8_7	699	1	src/com/google/javascript/jscomp/CollapseProperties.java
660	private  void  updateFunctionDeclarationAtFunctionNode(  Name  n,  boolean  canCollapseChildNames)  {  if  (!canCollapseChildNames)  {  return;  }  	[BUGGY]  private  void  updateFunctionDeclarationAtFunctionNode  (  Name  n  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_156_CollapseProperties_8_8	742	1	src/com/google/javascript/jscomp/CollapseProperties.java
661	if  (!n.isQuotedString()  &&  TokenStream.isJSIdentifier(name)  &&  	[BUGGY]  if  (  TokenStream  .  isJSIdentifier  (  name  )  &&  [FE]  ComparisonFailure:  expected:<var  x  =  {[1]:1}>  but  was:<var  x  =  {[ "1 "]:1}>  assertPrint  ( "var  x  =  {1  .  5:1} "  , "var  x  =  {\ "1  .  5\ ":1} "  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  Node  n  Context  context  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  context  rhsContext  [TYPE]  boolean  ambiguousElseClause  false  funcNeedsParens  hasElse  needsParens  preferLineBreaks  preserveBlock  true  [TYPE]  Node  body  c  catchblock  first  fn  last  n  next  parameters  [TYPE]  CodeConsumer  cc  [TYPE]  String  name  o  opstr  regexp  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  childCount  p  postProp  precedence  type  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  case  Token  .  GET:  case  Token  .  SET:  Preconditions  .  checkState  (  n  .  getParent  (  )  .  getType  (  )  =  =  Token  .  OBJECTLIT  )  ;  Preconditions  .  checkState  (  childCount  =  =  1  )  ;  Preconditions  .  checkState  (  first  .  getType  (  )  =  =  Token  .  FUNCTION  )  ;  Preconditions  .  checkState  (  first  .  getFirstChild  (  )  .  getString  (  )  .  isEmpty  (  )  )  ;  if  (  type  =  =  Token  .  GET  )  {  Preconditions  .  checkState  (  !first  .  getChildAtIndex  (  1  )  .  hasChildren  (  )  )  ;  add  ( "get "  )  ;  }  else  {  Preconditions  .  checkState  (  first  .  getChildAtIndex  (  1  )  .  hasOneChild  (  )  )  ;  add  ( "set "  )  ;  }  String  name  =  n  .  getString  (  )  ;  Node  fn  =  first  ;  Node  parameters  =  fn  .  getChildAtIndex  (  1  )  ;  Node  body  =  fn  .  getLastChild  (  )  ;  [BUGGY]  if  (  TokenStream  .  isJSIdentifier  (  name  )  &&  NodeUtil  .  isLatin  (  name  )  )  {  add  (  name  )  ;  }  else  {  	Closure_157_CodeGenerator_4_1	343	1	src/com/google/javascript/jscomp/CodeGenerator.java
662	double  d  =  getSimpleNumber(name);  if  (!Double.isNaN(d))  {  cc.addNumber(d);  }  else  {  add(jsString(n.getString(),  outputCharsetEncoder));  }  	[BUGGY]  add  (  jsString  (  n  .  getString  (  )  ,  outputCharsetEncoder  )  )  ;  [FE]  ComparisonFailure:  expected:<var  x  =  {[1]:1}>  but  was:<var  x  =  {[ "1 "]:1}>  assertPrint  ( "var  x  =  {1  .  5:1} "  , "var  x  =  {\ "1  .  5\ ":1} "  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  Node  n  Context  context  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  context  rhsContext  [TYPE]  boolean  ambiguousElseClause  false  funcNeedsParens  hasElse  needsParens  preferLineBreaks  preserveBlock  true  [TYPE]  Node  body  c  catchblock  first  fn  last  n  next  parameters  [TYPE]  CodeConsumer  cc  [TYPE]  String  name  o  opstr  regexp  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  childCount  p  postProp  precedence  type  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  Preconditions  .  checkState  (  first  .  getFirstChild  (  )  .  getString  (  )  .  isEmpty  (  )  )  ;  if  (  type  =  =  Token  .  GET  )  {  Preconditions  .  checkState  (  !first  .  getChildAtIndex  (  1  )  .  hasChildren  (  )  )  ;  add  ( "get "  )  ;  }  else  {  Preconditions  .  checkState  (  first  .  getChildAtIndex  (  1  )  .  hasOneChild  (  )  )  ;  add  ( "set "  )  ;  }  String  name  =  n  .  getString  (  )  ;  Node  fn  =  first  ;  Node  parameters  =  fn  .  getChildAtIndex  (  1  )  ;  Node  body  =  fn  .  getLastChild  (  )  ;  if  (  TokenStream  .  isJSIdentifier  (  name  )  &&  NodeUtil  .  isLatin  (  name  )  )  {  add  (  name  )  ;  }  else  {  [BUGGY]  add  (  jsString  (  n  .  getString  (  )  ,  outputCharsetEncoder  )  )  ;  }  add  (  parameters  )  ;  add  (  body  ,  Context  .  PRESERVE_BLOCK  )  ;  break  ;  	Closure_157_CodeGenerator_4_2	350	1	src/com/google/javascript/jscomp/CodeGenerator.java
663	Preconditions.checkState(c.getType()  ==  Token.STRING);  String  key  =  c.getString();\n', "    if  (!c.isQuotedString()  &&  !TokenStream.isKeyword(key)  &&  TokenStream.isJSIdentifier(key)  &&  NodeUtil.isLatin(key))  {  add(key);  double  d  =  getSimpleNumber(key);  if  (!Double.isNaN(d))  {  cc.addNumber(d);  }  else  {  addExpr(c,  1);  }  	[BUGGY]  if  (  c  .  getType  (  )  =  =  Token  .  STRING  &&  !c  .  isQuotedString  (  )  &&  !TokenStream  .  isKeyword  (  c  .  getString  (  )  )  &&  TokenStream  .  isJSIdentifier  (  c  .  getString  (  )  )  &&  NodeUtil  .  isLatin  (  c  .  getString  (  )  )  )  {  add  (  c  .  getString  (  )  )  ;  addExpr  (  c  ,  1  )  ;  [FE]  ComparisonFailure:  expected:<var  x  =  {[1]:1}>  but  was:<var  x  =  {[ "1 "]:1}>  assertPrint  ( "var  x  =  {1  .  5:1} "  , "var  x  =  {\ "1  .  5\ ":1} "  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  Node  n  Context  context  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  context  rhsContext  [TYPE]  boolean  ambiguousElseClause  false  funcNeedsParens  hasElse  needsParens  preferLineBreaks  preserveBlock  true  [TYPE]  Node  body  c  catchblock  first  fn  last  n  next  parameters  [TYPE]  CodeConsumer  cc  [TYPE]  String  name  o  opstr  regexp  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  childCount  p  postProp  precedence  type  [TYPE]  char[]  HEX_CHARS  [CONTEXT] "Unexpected  String  children: "  +  n  .  getParent  (  )  .  toStringTree  (  )  )  ;  }  add  (  jsString  (  n  .  getString  (  )  ,  outputCharsetEncoder  )  )  ;  break  ;  case  Token  .  DELPROP:  Preconditions  .  checkState  (  childCount  =  =  1  )  ;  add  ( "delete "  )  ;  add  (  first  )  ;  break  ;  case  Token  .  OBJECTLIT:  {  boolean  needsParens  =  (  context  =  =  Context  .  START_OF_EXPR  )  ;  if  (  needsParens  )  {  add  ( "  ( "  )  ;  }  add  ( "{ "  )  ;  for  (  Node  c  =  first  ;  c  !  =  null  ;  c  =  c  .  getNext  (  )  )  {  if  (  c  !  =  first  )  {  cc  .  listSeparator  (  )  ;  }  if  (  c  .  getType  (  )  =  =  Token  .  GET  ||  c  .  getType  (  )  =  =  Token  .  SET  )  {  add  (  c  )  ;  }  else  {  [BUGGY]  if  (  c  .  getType  (  )  =  =  Token  .  STRING  &&  !c  .  isQuotedString  (  )  &&  !TokenStream  .  isKeyword  (  c  .  getString  (  )  )  &&  TokenStream  .  isJSIdentifier  (  c  .  getString  (  )  )  &&  	Closure_157_CodeGenerator_4_3	654	7	src/com/google/javascript/jscomp/CodeGenerator.java
664	static  boolean  isSimpleNumber(String  s)  {  int  len  =  s.length();  for  (int  index  =  0;  index  <  len;  index++)  {  char  c  =  s.charAt(index);   if  (c  <  '0'  ||  c  >  '9')  {  return  false;  }  }  return  len  >  0;  }  static  double  getSimpleNumber(String  s)  {  if  (isSimpleNumber(s))  {  long  l  =  Long.parseLong(s);  if  (l  <  NodeUtil.MAX_POSITIVE_INTEGER_NUMBER)  {  return  l;  }  }  return  Double.NaN;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<var  x  =  {[1]:1}>  but  was:<var  x  =  {[ "1 "]:1}>  assertPrint  ( "var  x  =  {1  .  5:1} "  , "var  x  =  {\ "1  .  5\ ":1} "  )  ;  [CLASS]  [CONTEXT]  	Closure_157_CodeGenerator_4_4	724	0	src/com/google/javascript/jscomp/CodeGenerator.java
665	private  Node  transformNumberAsString(NumberLiteral  literalNode)  {  JSDocInfo  jsDocInfo  =  handleJsDoc(literalNode);  Node  irNode  =  newStringNode(getStringValue(literalNode.getNumber()));  if  (jsDocInfo  !=  null)  {  irNode.setJSDocInfo(jsDocInfo);  }  setSourceInfo(irNode,  literalNode);  return  irNode;  }  private  static  String  getStringValue(double  value)  {  long  longValue  =  (long)  value;  if  (longValue  ==  value)  {  return  Long.toString(longValue);  }  else  {  return  Double.toString(value);  }  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<var  x  =  {[1]:1}>  but  was:<var  x  =  {[ "1 "]:1}>  assertPrint  ( "var  x  =  {1  .  5:1} "  , "var  x  =  {\ "1  .  5\ ":1} "  )  ;  [CLASS]  [CONTEXT]  	Closure_157_IRFactory_2_1	255	0	src/com/google/javascript/jscomp/parsing/IRFactory.java
666	}  else  if  (n  instanceof  NumberLiteral)  {  ret  =  transformNumberAsString((NumberLiteral)n);  ret.putBooleanProp(Node.QUOTED_PROP,  true);  Preconditions.checkState(ret.getType()  ==  Token.STRING);  	[BUGGY]  Preconditions  .  checkState  (  ret  .  getType  (  )  =  =  Token  .  NUMBER  ||  ret  .  getType  (  )  =  =  Token  .  STRING  )  ;  if  (  ret  .  getType  (  )  =  =  Token  .  STRING  )  {  }  [FE]  ComparisonFailure:  expected:<var  x  =  {[1]:1}>  but  was:<var  x  =  {[ "1 "]:1}>  assertPrint  ( "var  x  =  {1  .  5:1} "  , "var  x  =  {\ "1  .  5\ ":1} "  )  ;  [METHOD]  transformAsString  [TYPE]  Node  [PARAMETER]  AstNode  n  [CLASS]  TransformDispatcher  [TYPE]  boolean  false  true  [TYPE]  Node  ret  [TYPE]  AstNode  n  [CONTEXT]  private  Node  transformAsString  (  AstNode  n  )  {  Node  ret  ;  if  (  n  instanceof  Name  )  {  ret  =  transformNameAsString  (  (  Name  )  n  )  ;  [BUGGY]  }  else  {  ret  =  transform  (  n  )  ;  Preconditions  .  checkState  (  ret  .  getType  (  )  =  =  Token  .  NUMBER  ||  ret  .  getType  (  )  =  =  Token  .  STRING  )  ;  if  (  ret  .  getType  (  )  =  =  Token  .  STRING  )  {  ret  .  putBooleanProp  (  Node  .  QUOTED_PROP  ,  true  )  ;  }  }  return  ret  ;  }  	Closure_157_IRFactory_2_2	347	4	src/com/google/javascript/jscomp/parsing/IRFactory.java
667	if  (TokenStream.isJSIdentifier(child.getString()))  {  	[BUGGY]  if  (  child  .  getType  (  )  !  =  Token  .  NUMBER  )  {  [FE]  ComparisonFailure:  expected:<var  x  =  {[1]:1}>  but  was:<var  x  =  {[ "1 "]:1}>  assertPrint  ( "var  x  =  {1  .  5:1} "  , "var  x  =  {\ "1  .  5\ ":1} "  )  ;  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ProcessProperties  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  child  dest  n  parent  [TYPE]  String  s  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  GETPROP:  case  Token  .  GETELEM:  Node  dest  =  n  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  dest  .  getType  (  )  =  =  Token  .  STRING  )  {  String  s  =  dest  .  getString  (  )  ;  if  (  s  .  equals  ( "prototype "  )  )  {  processPrototypeParent  (  parent  ,  t  .  getInput  (  )  )  ;  }  else  {  markPropertyAccessCandidate  (  dest  ,  t  .  getInput  (  )  )  ;  }  }  break  ;  case  Token  .  OBJECTLIT:  if  (  !prototypeObjLits  .  contains  (  n  )  )  {  for  (  Node  child  =  n  .  getFirstChild  (  )  ;  child  !  =  null  ;  child  =  child  .  getNext  (  )  )  {  [BUGGY]  if  (  child  .  getType  (  )  !  =  Token  .  NUMBER  )  {  markObjLitPropertyCandidate  (  child  ,  t  .  getInput  (  )  )  ;  }  }  }  break  ;  	Closure_157_RenamePrototypes_2_1	336	1	src/com/google/javascript/jscomp/RenamePrototypes.java
668	if  (TokenStream.isJSIdentifier(key.getString()))  {  	[BUGGY]  if  (  key  .  getType  (  )  !  =  Token  .  NUMBER  )  {  [FE]  ComparisonFailure:  expected:<var  x  =  {[1]:1}>  but  was:<var  x  =  {[ "1 "]:1}>  assertPrint  ( "var  x  =  {1  .  5:1} "  , "var  x  =  {\ "1  .  5\ ":1} "  )  ;  [METHOD]  processPrototypeParent  [TYPE]  void  [PARAMETER]  Node  n  CompilerInput  input  [CLASS]  ProcessProperties  [TYPE]  CompilerInput  input  [TYPE]  boolean  false  true  [TYPE]  Node  dest  key  map  n  [CONTEXT]  case  Token  .  GETPROP:  case  Token  .  GETELEM:  Node  dest  =  n  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  dest  .  getType  (  )  =  =  Token  .  STRING  )  {  markPrototypePropertyCandidate  (  dest  ,  input  )  ;  }  break  ;  case  Token  .  ASSIGN:  case  Token  .  CALL:  Node  map  ;  if  (  n  .  getType  (  )  =  =  Token  .  ASSIGN  )  {  map  =  n  .  getFirstChild  (  )  .  getNext  (  )  ;  }  else  {  map  =  n  .  getLastChild  (  )  ;  }  if  (  map  .  getType  (  )  =  =  Token  .  OBJECTLIT  )  {  prototypeObjLits  .  add  (  map  )  ;  for  (  Node  key  =  map  .  getFirstChild  (  )  ;  key  !  =  null  ;  key  =  key  .  getNext  (  )  )  {  [BUGGY]  if  (  key  .  getType  (  )  !  =  Token  .  NUMBER  )  {  markPrototypePropertyCandidate  (  key  ,  input  )  ;  }  }  }  	Closure_157_RenamePrototypes_2_2	377	1	src/com/google/javascript/jscomp/RenamePrototypes.java
669	if  (config.warningGuards  !=  null)  {  for  (WarningGuardSpec.Entry  entry  :  config.warningGuards.entries)  {  diagnosticGroups.setWarningLevel(options,  entry.groupName,  entry.level);  }  }  	[BUGGY]  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompError  ,  CheckLevel  .  ERROR  )  ;  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompWarning  ,  CheckLevel  .  WARNING  )  ;  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompOff  ,  CheckLevel  .  OFF  )  ;  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [METHOD]  setRunOptions  [TYPE]  void  [PARAMETER]  CompilerOptions  options  [CLASS]  AbstractCommandLineRunner  [TYPE]  PrintStream  err  [TYPE]  A  compiler  [TYPE]  Appendable  out  [TYPE]  Charset  inputCharset  [TYPE]  String  OUTPUT_WRAPPER_MARKER  charset  createSourceMap  jsOutputFile  languageIn  loggingLevel  moduleOutputPathPrefix  outputCharset  outputManifest  outputWrapper  propertyMapInputFile  propertyMapOutputFile  variableMapInputFile  variableMapOutputFile  [TYPE]  int  NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER  summaryDetailLevel  [TYPE]  long  bestRunTime  lastStartTime  serialVersionUID  worstRunTime  [TYPE]  Function  exitCodeReceiverForTesting  [TYPE]  boolean  acceptConstKeyword  computePhaseOrdering  createNameMapFiles  false  manageClosureDependencies  printAst  printPassGraph  printTree  testMode  true  [TYPE]  Format  sourceMapFormat  [TYPE]  RunTimeStats  runTimeStats  [TYPE]  TweakProcessing  tweakProcessing  [TYPE]  DetailLevel  sourceMapDetailLevel  [TYPE]  CodingConvention  codingConvention  [TYPE]  CommandLineConfig  config  [TYPE]  CompilerOptions  options  [TYPE]  Supplier  externsSupplierForTesting  inputsSupplierForTesting  modulesSupplierForTesting  [TYPE]  List  closureEntryPoints  define  externs  js  jscompError  jscompOff  jscompWarning  loopedPassesInBestRun  module  moduleWrapper  tweak  [TYPE]  DevMode  jscompDevMode  [TYPE]  DiagnosticGroups  diagnosticGroups  [CONTEXT]  final  protected  void  setRunOptions  (  CompilerOptions  options  )  throws  FlagUsageException  ,  IOException  {  DiagnosticGroups  diagnosticGroups  =  getDiagnosticGroups  (  )  ;  [BUGGY]  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompError  ,  CheckLevel  .  ERROR  )  ;  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompWarning  ,  CheckLevel  .  WARNING  )  ;  diagnosticGroups  .  setWarningLevels  (  options  ,  config  .  jscompOff  ,  CheckLevel  .  OFF  )  ;  	Closure_158_AbstractCommandLineRunner_4_1	197	6	src/com/google/javascript/jscomp/AbstractCommandLineRunner.java
670	private  WarningGuardSpec  warningGuards  =  null;  	[BUGGY]  private  final  List<String>  jscompError  =  Lists  .  newArrayList  (  )  ;  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_AbstractCommandLineRunner_4_2	1497	1	src/com/google/javascript/jscomp/AbstractCommandLineRunner.java
671	CommandLineConfig  setWarningGuardSpec(WarningGuardSpec  spec)  {  this.warningGuards  =  spec;  	[BUGGY]  CommandLineConfig  setJscompError  (  List<String>  jscompError  )  {  this  .  jscompError  .  clear  (  )  ;  this  .  jscompError  .  addAll  (  jscompError  )  ;  return  this  ;  }  private  final  List<String>  jscompWarning  =  Lists  .  newArrayList  (  )  ;  CommandLineConfig  setJscompWarning  (  List<String>  jscompWarning  )  {  this  .  jscompWarning  .  clear  (  )  ;  this  .  jscompWarning  .  addAll  (  jscompWarning  )  ;  return  this  ;  }  private  final  List<String>  jscompOff  =  Lists  .  newArrayList  (  )  ;  CommandLineConfig  setJscompOff  (  List<String>  jscompOff  )  {  this  .  jscompOff  .  clear  (  )  ;  this  .  jscompOff  .  addAll  (  jscompOff  )  ;  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_AbstractCommandLineRunner_4_3	1502	15	src/com/google/javascript/jscomp/AbstractCommandLineRunner.java
672	protected  static  class  WarningGuardSpec  {  private  static  class  Entry  {  private  final  CheckLevel  level;  private  final  String  groupName;  private  Entry(CheckLevel  level,  String  groupName)  {  this.level  =  level;  this.groupName  =  groupName;  }  }  private  final  List<Entry>  entries  =  Lists.newArrayList();  protected  void  add(CheckLevel  level,  String  groupName)  {  entries.add(new  Entry(level,  groupName));  }  protected  void  clear()  {  entries.clear();  }  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_AbstractCommandLineRunner_4_4	1628	1	src/com/google/javascript/jscomp/AbstractCommandLineRunner.java
673		[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_CommandLineRunner_9_1	26	0	src/com/google/javascript/jscomp/CommandLineRunner.java
674	private  static  final  WarningGuardSpec  warningGuardSpec  =  new  WarningGuardSpec();  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_CommandLineRunner_9_2	94	0	src/com/google/javascript/jscomp/CommandLineRunner.java
675	handler  =  WarningGuardErrorOptionHandler.class,  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_CommandLineRunner_9_3	231	0	src/com/google/javascript/jscomp/CommandLineRunner.java
676	handler  =  WarningGuardWarningOptionHandler.class,  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_CommandLineRunner_9_4	236	0	src/com/google/javascript/jscomp/CommandLineRunner.java
677	handler  =  WarningGuardOffOptionHandler.class,  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_CommandLineRunner_9_5	241	0	src/com/google/javascript/jscomp/CommandLineRunner.java
678	public  static  class  WarningGuardErrorOptionHandler  extends  StringOptionHandler  {  public  WarningGuardErrorOptionHandler(  CmdLineParser  parser,  OptionDef  option,  Setter<?  super  String>  setter)  {  super(parser,  option,  new  WarningGuardSetter(setter,  CheckLevel.ERROR));  }  }  public  static  class  WarningGuardWarningOptionHandler  extends  StringOptionHandler  {  public  WarningGuardWarningOptionHandler(  CmdLineParser  parser,  OptionDef  option,  Setter<?  super  String>  setter)  {  super(parser,  option,  new  WarningGuardSetter(setter,  CheckLevel.WARNING));  }  }  public  static  class  WarningGuardOffOptionHandler  extends  StringOptionHandler  {  public  WarningGuardOffOptionHandler(  CmdLineParser  parser,  OptionDef  option,  Setter<?  super  String>  setter)  {  super(parser,  option,  new  WarningGuardSetter(setter,  CheckLevel.OFF));  }  }  private  static  class  WarningGuardSetter  implements  Setter  {  private  final  Setter  proxy;  private  final  CheckLevel  level;  private  WarningGuardSetter(Setter  proxy,  CheckLevel  level)  {  this.proxy  =  proxy;  this.level  =  level;  }  @Override  public  boolean  isMultiValued()  {  return  proxy.isMultiValued();  }  @Override  public  Class  getType()  {  return  proxy.getType();  }  @Override  public  void  addValue(Object  value)  throws  CmdLineException  {  proxy.addValue((String)  value);  warningGuardSpec.add(level,  (String)  value);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_CommandLineRunner_9_6	389	1	src/com/google/javascript/jscomp/CommandLineRunner.java
679	Flags.warningGuardSpec.clear();  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [METHOD]  processFlagFile  [TYPE]  void  [PARAMETER]  PrintStream  err  [CLASS]  CommandLineRunner  [TYPE]  PrintStream  err  [TYPE]  CompilationLevel  compilation_level  [TYPE]  Set  FALSES  TRUES  [TYPE]  CmdLineParser  parserFileArgs  [TYPE]  WarningLevel  warning_level  [TYPE]  String  charset  configResource  create_source_map  flag_file  js_output_file  language_in  logging_level  module_output_path_prefix  output_manifest  output_wrapper  property_map_input_file  property_map_output_file  variable_map_input_file  variable_map_output_file  [TYPE]  Flags  flags  [TYPE]  int  summary_detail_level  [TYPE]  StringTokenizer  tokenizer  [TYPE]  boolean  accept_const_keyword  compute_phase_ordering  create_name_map_files  debug  display_help  false  generate_exports  isConfigValid  manage_closure_dependencies  print_ast  print_pass_graph  print_tree  process_closure_primitives  third_party  true  use_only_custom_externs  version  [TYPE]  FormattingOption  PRETTY_PRINT  PRINT_INPUT_DELIMITER  [TYPE]  List  DEFAULT_EXTERNS_NAMES  argsInFile  closure_entry_point  define  externs  formatting  js  jscomp_error  jscomp_off  jscomp_warning  module  module_wrapper  processedFileArgs  [TYPE]  DevMode  jscomp_dev_mode  [TYPE]  File  flagFileInput  [CONTEXT]  private  void  processFlagFile  (  PrintStream  err  )  throws  CmdLineException  ,  IOException  {  List<String>  argsInFile  =  Lists  .  newArrayList  (  )  ;  File  flagFileInput  =  new  File  (  flags  .  flag_file  )  ;  StringTokenizer  tokenizer  =  new  StringTokenizer  (  Files  .  toString  (  flagFileInput  ,  Charset  .  defaultCharset  (  )  )  )  ;  while  (  tokenizer  .  hasMoreTokens  (  )  )  {  argsInFile  .  add  (  tokenizer  .  nextToken  (  )  )  ;  }  flags  .  flag_file  = " "  ;  List<String>  processedFileArgs  =  processArgs  (  argsInFile  .  toArray  (  new  String[]  {}  )  )  ;  CmdLineParser  parserFileArgs  =  new  CmdLineParser  (  flags  )  ;  [BUGGY]  parserFileArgs  .  parseArgument  (  processedFileArgs  .  toArray  (  new  String[]  {}  )  )  ;  if  (  !flags  .  flag_file  .  equals  ( " "  )  )  {  err  .  println  ( "ERROR  -  Arguments  in  the  file  cannot  contain "  + "--flagfile  option  . "  )  ;  isConfigValid  =  false  ;  }  }  	Closure_158_CommandLineRunner_9_7	485	0	src/com/google/javascript/jscomp/CommandLineRunner.java
680	Flags.warningGuardSpec.clear();  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [METHOD]  initConfigFromFlags  [TYPE]  void  [PARAMETER]  String[]  args  PrintStream  err  [CLASS]  CommandLineRunner  [TYPE]  PrintStream  err  [TYPE]  CompilationLevel  compilation_level  [TYPE]  Set  FALSES  TRUES  [TYPE]  CmdLineParser  parser  [TYPE]  WarningLevel  warning_level  [TYPE]  String  charset  configResource  create_source_map  flag_file  js_output_file  language_in  logging_level  module_output_path_prefix  output_manifest  output_wrapper  property_map_input_file  property_map_output_file  variable_map_input_file  variable_map_output_file  [TYPE]  Flags  flags  [TYPE]  String[]  args  [TYPE]  IOException  ioErr  [TYPE]  int  summary_detail_level  [TYPE]  boolean  accept_const_keyword  compute_phase_ordering  create_name_map_files  debug  display_help  false  generate_exports  isConfigValid  manage_closure_dependencies  print_ast  print_pass_graph  print_tree  process_closure_primitives  third_party  true  use_only_custom_externs  version  [TYPE]  FormattingOption  PRETTY_PRINT  PRINT_INPUT_DELIMITER  [TYPE]  List  DEFAULT_EXTERNS_NAMES  closure_entry_point  define  externs  formatting  js  jscomp_error  jscomp_off  jscomp_warning  module  module_wrapper  processedArgs  [TYPE]  ResourceBundle  config  [TYPE]  DevMode  jscomp_dev_mode  [TYPE]  CmdLineException  e  [CONTEXT]  private  void  initConfigFromFlags  (  String[]  args  ,  PrintStream  err  )  {  List<String>  processedArgs  =  processArgs  (  args  )  ;  CmdLineParser  parser  =  new  CmdLineParser  (  flags  )  ;  [BUGGY]  isConfigValid  =  true  ;  try  {  parser  .  parseArgument  (  processedArgs  .  toArray  (  new  String[]  {}  )  )  ;  if  (  !flags  .  flag_file  .  equals  ( " "  )  )  {  processFlagFile  (  err  )  ;  	Closure_158_CommandLineRunner_9_8	500	0	src/com/google/javascript/jscomp/CommandLineRunner.java
681	.setWarningGuardSpec(Flags.warningGuardSpec)  	[BUGGY]  .  setJscompError  (  flags  .  jscomp_error  )  .  setJscompWarning  (  flags  .  jscomp_warning  )  .  setJscompOff  (  flags  .  jscomp_off  )  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [METHOD]  initConfigFromFlags  [TYPE]  void  [PARAMETER]  String[]  args  PrintStream  err  [CLASS]  CommandLineRunner  [TYPE]  PrintStream  err  [TYPE]  CompilationLevel  compilation_level  [TYPE]  Set  FALSES  TRUES  [TYPE]  CmdLineParser  parser  [TYPE]  WarningLevel  warning_level  [TYPE]  String  charset  configResource  create_source_map  flag_file  js_output_file  language_in  logging_level  module_output_path_prefix  output_manifest  output_wrapper  property_map_input_file  property_map_output_file  variable_map_input_file  variable_map_output_file  [TYPE]  Flags  flags  [TYPE]  String[]  args  [TYPE]  IOException  ioErr  [TYPE]  int  summary_detail_level  [TYPE]  boolean  accept_const_keyword  compute_phase_ordering  create_name_map_files  debug  display_help  false  generate_exports  isConfigValid  manage_closure_dependencies  print_ast  print_pass_graph  print_tree  process_closure_primitives  third_party  true  use_only_custom_externs  version  [TYPE]  FormattingOption  PRETTY_PRINT  PRINT_INPUT_DELIMITER  [TYPE]  List  DEFAULT_EXTERNS_NAMES  closure_entry_point  define  externs  formatting  js  jscomp_error  jscomp_off  jscomp_warning  module  module_wrapper  processedArgs  [TYPE]  ResourceBundle  config  [TYPE]  DevMode  jscomp_dev_mode  [TYPE]  CmdLineException  e  [CONTEXT]  }  else  {  getCommandLineConfig  (  )  .  setPrintTree  (  flags  .  print_tree  )  .  setComputePhaseOrdering  (  flags  .  compute_phase_ordering  )  .  setPrintAst  (  flags  .  print_ast  )  .  setPrintPassGraph  (  flags  .  print_pass_graph  )  .  setJscompDevMode  (  flags  .  jscomp_dev_mode  )  .  setLoggingLevel  (  flags  .  logging_level  )  .  setExterns  (  flags  .  externs  )  .  setJs  (  flags  .  js  )  .  setJsOutputFile  (  flags  .  js_output_file  )  .  setModule  (  flags  .  module  )  .  setVariableMapInputFile  (  flags  .  variable_map_input_file  )  .  setPropertyMapInputFile  (  flags  .  property_map_input_file  )  .  setVariableMapOutputFile  (  flags  .  variable_map_output_file  )  .  setCreateNameMapFiles  (  flags  .  create_name_map_files  )  .  setPropertyMapOutputFile  (  flags  .  property_map_output_file  )  .  setCodingConvention  (  flags  .  third_party  ?  new  DefaultCodingConvention  (  )  :  new  ClosureCodingConvention  (  )  )  .  setSummaryDetailLevel  (  flags  .  summary_detail_level  )  .  setOutputWrapper  (  flags  .  output_wrapper  )  .  setModuleWrapper  (  flags  .  module_wrapper  )  .  setModuleOutputPathPrefix  (  flags  .  module_output_path_prefix  )  .  setCreateSourceMap  (  flags  .  create_source_map  )  [BUGGY]  .  setJscompError  (  flags  .  jscomp_error  )  .  setJscompWarning  (  flags  .  jscomp_warning  )  .  setJscompOff  (  flags  .  jscomp_off  )  .  setDefine  (  flags  .  define  )  .  setCharset  (  flags  .  charset  )  .  setManageClosureDependencies  (  flags  .  manage_closure_dependencies  )  	Closure_158_CommandLineRunner_9_9	552	3	src/com/google/javascript/jscomp/CommandLineRunner.java
682		[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_DiagnosticGroups_3_1	23	0	src/com/google/javascript/jscomp/DiagnosticGroups.java
683	void  setWarningLevel(CompilerOptions  options,  String  name,  CheckLevel  level)  {  	[BUGGY]  void  setWarningLevels  (  CompilerOptions  options  ,  List<String>  diagnosticGroups  ,  CheckLevel  level  )  {  for  (  String  name  :  diagnosticGroups  )  {  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [CLASS]  [CONTEXT]  	Closure_158_DiagnosticGroups_3_2	186	3	src/com/google/javascript/jscomp/DiagnosticGroups.java
684		[BUGGY]  }  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [METHOD]  setWarningLevels  [TYPE]  void  [PARAMETER]  CompilerOptions  options  String>  diagnosticGroups  CheckLevel  level  [CLASS]  DiagnosticGroups  [TYPE]  boolean  false  true  [TYPE]  DiagnosticGroup  ACCESS_CONTROLS  AMBIGUOUS_FUNCTION_DECL  CHECK_REGEXP  CHECK_TYPES  CHECK_USELESS_CODE  CHECK_VARIABLES  CONSTANT_PROPERTY  DEPRECATED  EXTERNS_VALIDATION  FILEOVERVIEW_JSDOC  GLOBAL_THIS  INTERNET_EXPLORER_CHECKS  INVALID_CASTS  MISSING_PROPERTIES  NON_STANDARD_JSDOC  STRICT_MODULE_DEP_CHECK  TWEAKS  TYPE_INVALIDATION  UNDEFINED_VARIABLES  UNKNOWN_DEFINES  VISIBILITY  group  [TYPE]  CheckLevel  level  [TYPE]  CompilerOptions  options  [TYPE]  List  diagnosticGroups  [TYPE]  String  DIAGNOSTIC_GROUP_NAMES  name  [TYPE]  Map  groupsByName  [CONTEXT]  void  setWarningLevels  (  CompilerOptions  options  ,  List<String>  diagnosticGroups  ,  CheckLevel  level  )  {  for  (  String  name  :  diagnosticGroups  )  {  DiagnosticGroup  group  =  forName  (  name  )  ;  Preconditions  .  checkNotNull  (  group  , "No  warning  class  for  name: "  +  name  )  ;  options  .  setWarningLevel  (  group  ,  level  )  ;  [BUGGY]  }  }  	Closure_158_DiagnosticGroups_3_3	192	1	src/com/google/javascript/jscomp/DiagnosticGroups.java
685	if  (node.getType()  ==  Token.NAME)  {  if  (isCandidateUsage(node))  {  changed.add(node.getString());  	[BUGGY]  if  (  node  .  getType  (  )  =  =  Token  .  CALL  )  {  Node  child  =  node  .  getFirstChild  (  )  ;  if  (  child  .  getType  (  )  =  =  Token  .  NAME  )  {  changed  .  add  (  child  .  getString  (  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  findCalledFunctions  [TYPE]  void  [PARAMETER]  Node  node  String>  changed  [CLASS]  InlineFunctions  [TYPE]  Set  changed  namesToAlias  [TYPE]  Node  c  child  fn  node  safeFnNode  var  [TYPE]  String  fakeName  [TYPE]  SpecializationState  specializationState  [TYPE]  int  callsSeen  [TYPE]  Function  fn  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  blockFunctionInliningEnabled  false  hasInnerFunctions  inline  inlineDirectly  inlineGlobalFunctions  inlineLocalFunctions  inlined  referencesThis  remove  requiresDecomposition  true  [TYPE]  CallVisitorCallback  callback  [TYPE]  JSModule  module  [TYPE]  Map  anonFns  anonFunctionMap  fns  functionMap  references  [TYPE]  FunctionInjector  injector  [CONTEXT]  private  void  findCalledFunctions  (  Node  node  ,  Set<String>  changed  )  {  Preconditions  .  checkArgument  (  changed  !  =  null  )  ;  [BUGGY]  if  (  node  .  getType  (  )  =  =  Token  .  CALL  )  {  Node  child  =  node  .  getFirstChild  (  )  ;  if  (  child  .  getType  (  )  =  =  Token  .  NAME  )  {  changed  .  add  (  child  .  getString  (  )  )  ;  }  }  for  (  Node  c  =  node  .  getFirstChild  (  )  ;  c  !  =  null  ;  c  =  c  .  getNext  (  )  )  {  findCalledFunctions  (  c  ,  changed  )  ;  }  }  	Closure_159_InlineFunctions_1_1	777	4	src/com/google/javascript/jscomp/InlineFunctions.java
686	ComposeWarningsGuard  composedGuards  =  new  ComposeWarningsGuard(guards);  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [METHOD]  initOptions  [TYPE]  void  [PARAMETER]  CompilerOptions  options  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  LifeCycleStage  lifeCycleStage  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  GlobalVarReferenceMap  globalRefMap  [TYPE]  PrintStreamErrorManager  printer  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MISSING_ENTRY_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  guards  inputs  modules  [TYPE]  WarningsGuard  warningsGuard  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  uniqueNameId  [TYPE]  boolean  false  hasRegExpGlobalReferences  true  useThreads  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  inputsByName  [CONTEXT]  }  else  if  (  options  .  disables  (  DiagnosticGroups  .  CHECK_TYPES  )  )  {  options  .  checkTypes  =  false  ;  }  else  if  (  !options  .  checkTypes  )  {  options  .  setWarningLevel  (  DiagnosticGroup  .  forType  (  RhinoErrorReporter  .  TYPE_PARSE_ERROR  )  ,  CheckLevel  .  OFF  )  ;  }  if  (  options  .  checkGlobalThisLevel  .  isOn  (  )  )  {  options  .  setWarningLevel  (  DiagnosticGroups  .  GLOBAL_THIS  ,  options  .  checkGlobalThisLevel  )  ;  }  List<WarningsGuard>  guards  =  Lists  .  newArrayList  (  )  ;  guards  .  add  (  new  SuppressDocWarningsGuard  (  getDiagnosticGroups  (  )  .  getRegisteredGroups  (  )  )  )  ;  guards  .  add  (  options  .  getWarningsGuard  (  )  )  ;  [BUGGY]  	Closure_160_Compiler_3_1	268	0	src/com/google/javascript/jscomp/Compiler.java
687	!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES))  {  composedGuards.addGuard(new  DiagnosticGroupWarningsGuard(  	[BUGGY]  (  warningsGuard  =  =  null  ||  !warningsGuard  .  disables  (  DiagnosticGroups  .  CHECK_VARIABLES  )  )  )  {  guards  .  add  (  new  DiagnosticGroupWarningsGuard  (  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [METHOD]  initOptions  [TYPE]  void  [PARAMETER]  CompilerOptions  options  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  LifeCycleStage  lifeCycleStage  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  GlobalVarReferenceMap  globalRefMap  [TYPE]  PrintStreamErrorManager  printer  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MISSING_ENTRY_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  guards  inputs  modules  [TYPE]  WarningsGuard  warningsGuard  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  uniqueNameId  [TYPE]  boolean  false  hasRegExpGlobalReferences  true  useThreads  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  inputsByName  [CONTEXT]  DiagnosticGroup  .  forType  (  RhinoErrorReporter  .  TYPE_PARSE_ERROR  )  ,  CheckLevel  .  OFF  )  ;  }  if  (  options  .  checkGlobalThisLevel  .  isOn  (  )  )  {  options  .  setWarningLevel  (  DiagnosticGroups  .  GLOBAL_THIS  ,  options  .  checkGlobalThisLevel  )  ;  }  List<WarningsGuard>  guards  =  Lists  .  newArrayList  (  )  ;  guards  .  add  (  new  SuppressDocWarningsGuard  (  getDiagnosticGroups  (  )  .  getRegisteredGroups  (  )  )  )  ;  guards  .  add  (  options  .  getWarningsGuard  (  )  )  ;  if  (  !options  .  checkSymbols  &&  [BUGGY]  (  warningsGuard  =  =  null  ||  !warningsGuard  .  disables  (  DiagnosticGroups  .  CHECK_VARIABLES  )  )  )  {  guards  .  add  (  new  DiagnosticGroupWarningsGuard  (  DiagnosticGroups  .  CHECK_VARIABLES  ,  CheckLevel  .  OFF  )  )  ;  }  	Closure_160_Compiler_3_2	275	3	src/com/google/javascript/jscomp/Compiler.java
688	this.warningsGuard  =  composedGuards;  	[BUGGY]  this  .  warningsGuard  =  new  ComposeWarningsGuard  (  guards  )  ;  [FE]  AssertionFailedError:  Expected  exactly  one  warning  or  error  Errors:  [METHOD]  initOptions  [TYPE]  void  [PARAMETER]  CompilerOptions  options  [CLASS]  Compiler  [TYPE]  FunctionInformationMap  functionInformationMap  [TYPE]  ErrorManager  errorManager  [TYPE]  StringBuilder  debugLog  sb  [TYPE]  Config  parserConfig  [TYPE]  Node  externAndJsRoot  externsRoot  jsRoot  [TYPE]  PerformanceTracker  tracker  [TYPE]  PassConfig  passes  [TYPE]  String  currentPassName  externExports  [TYPE]  LifeCycleStage  lifeCycleStage  [TYPE]  Logger  logger  [TYPE]  PassFactory  sanityCheck  [TYPE]  long  COMPILER_STACK_SIZE  serialVersionUID  [TYPE]  TypeValidator  typeValidator  [TYPE]  JSTypeRegistry  typeRegistry  [TYPE]  ErrorReporter  defaultErrorReporter  oldErrorReporter  [TYPE]  RecentChange  recentChange  [TYPE]  GlobalVarReferenceMap  globalRefMap  [TYPE]  PrintStreamErrorManager  printer  [TYPE]  DiagnosticType  DUPLICATE_EXTERN_INPUT  DUPLICATE_INPUT  EMPTY_MODULE_LIST_ERROR  EMPTY_ROOT_MODULE_ERROR  MISSING_ENTRY_ERROR  MODULE_DEPENDENCY_ERROR  MOTION_ITERATIONS_ERROR  OPTIMIZE_LOOP_ERROR  [TYPE]  SourceMap  sourceMap  [TYPE]  List  codeChangeHandlers  externs  guards  inputs  modules  [TYPE]  WarningsGuard  warningsGuard  [TYPE]  ReverseAbstractInterpreter  abstractInterpreter  [TYPE]  PrintStream  outStream  [TYPE]  Tracer  currentTracer  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  int  colCount  lineCount  uniqueNameId  [TYPE]  boolean  false  hasRegExpGlobalReferences  true  useThreads  [TYPE]  State  passConfigState  [TYPE]  CodingConvention  defaultCodingConvention  [TYPE]  CompilerOptions  options  [TYPE]  Map  inputsByName  [CONTEXT]  options  .  setWarningLevel  (  DiagnosticGroups  .  GLOBAL_THIS  ,  options  .  checkGlobalThisLevel  )  ;  }  List<WarningsGuard>  guards  =  Lists  .  newArrayList  (  )  ;  guards  .  add  (  new  SuppressDocWarningsGuard  (  getDiagnosticGroups  (  )  .  getRegisteredGroups  (  )  )  )  ;  guards  .  add  (  options  .  getWarningsGuard  (  )  )  ;  if  (  !options  .  checkSymbols  &&  (  warningsGuard  =  =  null  ||  !warningsGuard  .  disables  (  DiagnosticGroups  .  CHECK_VARIABLES  )  )  )  {  guards  .  add  (  new  DiagnosticGroupWarningsGuard  (  DiagnosticGroups  .  CHECK_VARIABLES  ,  CheckLevel  .  OFF  )  )  ;  }  [BUGGY]  this  .  warningsGuard  =  new  ComposeWarningsGuard  (  guards  )  ;  }  	Closure_160_Compiler_3_3	281	1	src/com/google/javascript/jscomp/Compiler.java
689	if  (isAssignmentTarget(n))  {  return  n;  }  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_INDEX_OUT_OF_BOUNDS_ERROR  Array  index  out  of  bounds:  NUMBER  10  1  [source_file:  testcode]  at  testcode  line  1  :  3  expected:<0>  but  was:<1>  [METHOD]  tryFoldArrayAccess  [TYPE]  Node  [PARAMETER]  Node  n  Node  left  Node  right  [CLASS]  PeepholeFoldConstants  [TYPE]  boolean  false  true  [TYPE]  DiagnosticType  BITWISE_OPERAND_OUT_OF_RANGE  FRACTIONAL_BITWISE_OPERAND  INDEX_OUT_OF_BOUNDS_ERROR  INVALID_GETELEM_INDEX_ERROR  NEGATING_A_NON_NUMBER_ERROR  SHIFT_AMOUNT_OUT_OF_BOUNDS  [TYPE]  double  MAX_FOLD_NUMBER  index  [TYPE]  int  i  intIndex  [TYPE]  Node  elem  left  n  parent  right  [CONTEXT]  private  Node  tryFoldArrayAccess  (  Node  n  ,  Node  left  ,  Node  right  )  {  Node  parent  =  n  .  getParent  (  )  ;  [BUGGY]  if  (  right  .  getType  (  )  !  =  Token  .  NUMBER  )  {  return  n  ;  }  	Closure_161_PeepholeFoldConstants_1_1	1283	0	src/com/google/javascript/jscomp/PeepholeFoldConstants.java
690	Iterable<Var>  getVarIterable()  {  return  vars.values();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[STRING  fooFooBar  4  [source_file:  testcode]  [CLASS]  [CONTEXT]  	Closure_162_Scope_1_1	568	0	src/com/google/javascript/jscomp/Scope.java
691	findAliases(t);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[STRING  fooFooBar  4  [source_file:  testcode]  [METHOD]  enterScope  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  boolean  false  hasErrors  true  [TYPE]  Map  aliases  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  [CONTEXT]  public  void  enterScope  (  NodeTraversal  t  )  {  Node  n  =  t  .  getCurrentNode  (  )  .  getParent  (  )  ;  if  (  n  !  =  null  &&  isCallToScopeMethod  (  n  )  )  {  transformation  =  transformationHandler  .  logAliasTransformation  (  n  .  getSourceFileName  (  )  ,  getSourceRegion  (  n  )  )  ;  [BUGGY]  }  }  	Closure_162_ScopedAliases_7_1	226	0	src/com/google/javascript/jscomp/ScopedAliases.java
692	private  void  findAliases(NodeTraversal  t)  {  Scope  scope  =  t.getScope();  for  (Var  v  :  scope.getVarIterable())  {  Node  n  =  v.getNode();  int  type  =  n.getType();  Node  parent  =  n.getParent();  if  (parent.getType()  ==  Token.VAR)  {  if  (n.hasChildren()  &&  n.getFirstChild().isQualifiedName())  {  String  name  =  n.getString();  Var  aliasVar  =  scope.getVar(name);  aliases.put(name,  aliasVar);  String  qualifiedName  =  aliasVar.getInitialValue().getQualifiedName();  transformation.addAlias(name,  qualifiedName);  }  else  {  report(t,  n,  GOOG_SCOPE_NON_ALIAS_LOCAL,  n.getString());  }  }  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[STRING  fooFooBar  4  [source_file:  testcode]  [CLASS]  [CONTEXT]  	Closure_162_ScopedAliases_7_2	271	0	src/com/google/javascript/jscomp/ScopedAliases.java
693	if  (t.getScopeDepth()  <  2)  {  return;  }  int  type  =  n.getType();  Var  aliasVar  =  null;  if  (type  ==  Token.NAME)  {  String  name  =  n.getString();  Var  lexicalVar  =  t.getScope().getVar(n.getString());  if  (lexicalVar  !=  null  &&  lexicalVar  ==  aliases.get(name))  {  aliasVar  =  lexicalVar;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[STRING  fooFooBar  4  [source_file:  testcode]  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  boolean  false  hasErrors  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  [TYPE]  Node  aliasedNode  n  node  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  qualifiedName  [TYPE]  JSDocInfo  info  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  isCallToScopeMethod  (  n  )  )  {  validateScopeCall  (  t  ,  n  ,  n  .  getParent  (  )  )  ;  }  [BUGGY]  if  (  t  .  getScopeDepth  (  )  =  =  2  )  {  int  type  =  n  .  getType  (  )  ;  if  (  type  =  =  Token  .  NAME  &&  parent  .  getType  (  )  =  =  Token  .  VAR  )  {  	Closure_162_ScopedAliases_7_3	303	0	src/com/google/javascript/jscomp/ScopedAliases.java
694	if  (aliasVar  !=  null  &&  NodeUtil.isLValue(n))  {  if  (aliasVar.getNode()  ==  n)  {  \n', "    	[BUGGY]  int  type  =  n  .  getType  (  )  ;  if  (  type  =  =  Token  .  NAME  &&  parent  .  getType  (  )  =  =  Token  .  VAR  )  {  if  (  n  .  hasChildren  (  )  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  t  .  getScope  (  )  .  getVar  (  name  )  ;  aliases  .  put  (  name  ,  aliasVar  )  ;  String  qualifiedName  =  aliasVar  .  getInitialValue  (  )  .  getQualifiedName  (  )  ;  transformation  .  addAlias  (  name  ,  qualifiedName  )  ;  [FE]  AssertionFailedError:  expected:<[STRING  fooFooBar  4  [source_file:  testcode]  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  boolean  false  hasErrors  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  [TYPE]  Node  aliasedNode  n  node  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  qualifiedName  [TYPE]  JSDocInfo  info  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  isCallToScopeMethod  (  n  )  )  {  validateScopeCall  (  t  ,  n  ,  n  .  getParent  (  )  )  ;  }  if  (  t  .  getScopeDepth  (  )  =  =  2  )  {  [BUGGY]  int  type  =  n  .  getType  (  )  ;  if  (  type  =  =  Token  .  NAME  &&  parent  .  getType  (  )  =  =  Token  .  VAR  )  {  if  (  n  .  hasChildren  (  )  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  t  .  getScope  (  )  .  getVar  (  name  )  ;  aliases  .  put  (  name  ,  aliasVar  )  ;  	Closure_162_ScopedAliases_7_4	307	10	src/com/google/javascript/jscomp/ScopedAliases.java
695	}  	[BUGGY]  report  (  t  ,  n  ,  GOOG_SCOPE_NON_ALIAS_LOCAL  ,  n  .  getString  (  )  )  ;  }  }  if  (  type  =  =  Token  .  NAME  &&  NodeUtil  .  isAssignmentOp  (  parent  )  &&  n  =  =  parent  .  getFirstChild  (  )  )  {  [FE]  AssertionFailedError:  expected:<[STRING  fooFooBar  4  [source_file:  testcode]  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  boolean  false  hasErrors  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  [TYPE]  Node  aliasedNode  n  node  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  qualifiedName  [TYPE]  JSDocInfo  info  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  isCallToScopeMethod  (  n  )  )  {  validateScopeCall  (  t  ,  n  ,  n  .  getParent  (  )  )  ;  }  if  (  t  .  getScopeDepth  (  )  =  =  2  )  {  int  type  =  n  .  getType  (  )  ;  if  (  type  =  =  Token  .  NAME  &&  parent  .  getType  (  )  =  =  Token  .  VAR  )  {  if  (  n  .  hasChildren  (  )  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  t  .  getScope  (  )  .  getVar  (  name  )  ;  aliases  .  put  (  name  ,  aliasVar  )  ;  aliasDefinitionsInOrder  .  add  (  n  )  ;  String  qualifiedName  =  aliasVar  .  getInitialValue  (  )  .  getQualifiedName  (  )  ;  transformation  .  addAlias  (  name  ,  qualifiedName  )  ;  return  ;  }  else  {  [BUGGY]  report  (  t  ,  n  ,  GOOG_SCOPE_NON_ALIAS_LOCAL  ,  n  .  getString  (  )  )  ;  }  }  if  (  type  =  =  Token  .  NAME  &&  NodeUtil  .  isAssignmentOp  (  parent  )  &&  n  =  =  parent  .  getFirstChild  (  )  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_ALIAS_REDEFINED  ,  n  .  getString  (  )  )  ;  	Closure_162_ScopedAliases_7_5	322	5	src/com/google/javascript/jscomp/ScopedAliases.java
696	if  (aliasVar  !=  null)  {\n', "    	[BUGGY]  if  (  n  .  getType  (  )  =  =  Token  .  NAME  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  aliases  .  get  (  name  )  ;  if  (  aliasVar  !  =  null  &&  t  .  getScope  (  )  .  getVar  (  name  )  =  =  aliasVar  )  {  [FE]  AssertionFailedError:  expected:<[STRING  fooFooBar  4  [source_file:  testcode]  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  boolean  false  hasErrors  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  [TYPE]  Node  aliasedNode  n  node  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  qualifiedName  [TYPE]  JSDocInfo  info  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  transformation  .  addAlias  (  name  ,  qualifiedName  )  ;  return  ;  }  else  {  report  (  t  ,  n  ,  GOOG_SCOPE_NON_ALIAS_LOCAL  ,  n  .  getString  (  )  )  ;  }  }  if  (  type  =  =  Token  .  NAME  &&  NodeUtil  .  isAssignmentOp  (  parent  )  &&  n  =  =  parent  .  getFirstChild  (  )  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_ALIAS_REDEFINED  ,  n  .  getString  (  )  )  ;  }  if  (  type  =  =  Token  .  RETURN  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_USES_RETURN  )  ;  }  else  if  (  type  =  =  Token  .  THIS  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_REFERENCES_THIS  )  ;  }  else  if  (  type  =  =  Token  .  THROW  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_USES_THROW  )  ;  }  }  if  (  t  .  getScopeDepth  (  )  >  =  2  )  {  [BUGGY]  if  (  n  .  getType  (  )  =  =  Token  .  NAME  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  aliases  .  get  (  name  )  ;  if  (  aliasVar  !  =  null  &&  t  .  getScope  (  )  .  getVar  (  name  )  =  =  aliasVar  )  {  	Closure_162_ScopedAliases_7_6	342	5	src/com/google/javascript/jscomp/ScopedAliases.java
697		[BUGGY]  }  [FE]  AssertionFailedError:  expected:<[STRING  fooFooBar  4  [source_file:  testcode]  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  boolean  false  hasErrors  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  aliasVar  [TYPE]  Node  aliasedNode  n  node  parent  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  name  qualifiedName  [TYPE]  JSDocInfo  info  [TYPE]  Map  aliases  [TYPE]  int  type  [CONTEXT]  if  (  type  =  =  Token  .  RETURN  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_USES_RETURN  )  ;  }  else  if  (  type  =  =  Token  .  THIS  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_REFERENCES_THIS  )  ;  }  else  if  (  type  =  =  Token  .  THROW  )  {  report  (  t  ,  n  ,  GOOG_SCOPE_USES_THROW  )  ;  }  }  if  (  t  .  getScopeDepth  (  )  >  =  2  )  {  if  (  n  .  getType  (  )  =  =  Token  .  NAME  )  {  String  name  =  n  .  getString  (  )  ;  Var  aliasVar  =  aliases  .  get  (  name  )  ;  if  (  aliasVar  !  =  null  &&  t  .  getScope  (  )  .  getVar  (  name  )  =  =  aliasVar  )  {  Node  aliasedNode  =  aliasVar  .  getInitialValue  (  )  ;  aliasUsages  .  add  (  new  AliasedNode  (  n  ,  aliasedNode  )  )  ;  [BUGGY]  }  }  JSDocInfo  info  =  n  .  getJSDocInfo  (  )  ;  if  (  info  !  =  null  )  {  for  (  Node  node  :  info  .  getTypeNodes  (  )  )  {  	Closure_162_ScopedAliases_7_7	355	1	src/com/google/javascript/jscomp/ScopedAliases.java
698	Node  n  =  t.getCurrentNode();  if  (n.isFunction())  {  String  propName  =  getPrototypePropertyNameFromRValue(n);  if  (propName  !=  null)  {  symbolStack.push(  new  NameContext(  getNameInfoForName(propName,  PROPERTY),  t.getScope()));  }  else  if  (isGlobalFunctionDeclaration(t,  n))  {  Node  parent  =  n.getParent();  String  name  =  parent.isName()  ?  parent.getString()  /*  VAR  */  :  n.getFirstChild().getString()  /*  named  function  */;  symbolStack.push(  new  NameContext(getNameInfoForName(name,  VAR),  t.getScope()));  }  else  {  	[BUGGY]  private  ProcessProperties  (  )  {  symbolStack  .  push  (  new  NameContext  (  globalNode  )  )  ;  }  symbolStack  .  peek  (  )  .  scope  =  t  .  getScope  (  )  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_1	201	4	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
699	symbolStack.push(new  NameContext(anonymousNode,  t.getScope()));  }  }  else  {  Preconditions.checkState(t.inGlobalScope());  symbolStack.push(new  NameContext(globalNode,  t.getScope()));  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_2	212	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
700	symbolStack.pop();  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  exitScope  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  ProcessProperties  [TYPE]  NodeTraversal  t  [TYPE]  Stack  symbolStack  [TYPE]  boolean  false  true  [CONTEXT]  public  void  exitScope  (  NodeTraversal  t  )  {  [BUGGY]  }  	Closure_163_AnalyzePrototypeProperties_31_3	216	1	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
701	String  propName  =  processNonFunctionPrototypeAssign(n,  parent);  if  (propName  !=  null)  {  symbolStack.push(  new  NameContext(  getNameInfoForName(propName,  PROPERTY),  null));  	[BUGGY]  if  (  isPrototypePropertyAssign  (  n  )  )  {  symbolStack  .  push  (  new  NameContext  (  getNameInfoForName  (  n  .  getFirstChild  (  )  .  getLastChild  (  )  .  getString  (  )  ,  PROPERTY  )  )  )  ;  }  else  if  (  isGlobalFunctionDeclaration  (  t  ,  n  )  )  {  String  name  =  parent  .  isName  (  )  ?  parent  .  getString  (  )  /*  VAR  */  :  n  .  getFirstChild  (  )  .  getString  (  )  /*  named  function  */  ;  symbolStack  .  push  (  new  NameContext  (  getNameInfoForName  (  name  ,  VAR  )  )  )  ;  }  else  if  (  n  .  isFunction  (  )  )  {  symbolStack  .  push  (  new  NameContext  (  anonymousNode  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  shouldTraverse  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ProcessProperties  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Stack  symbolStack  [TYPE]  Node  n  parent  [CONTEXT]  public  boolean  shouldTraverse  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  [BUGGY]  if  (  isPrototypePropertyAssign  (  n  )  )  {  symbolStack  .  push  (  new  NameContext  (  getNameInfoForName  (  n  .  getFirstChild  (  )  .  getLastChild  (  )  .  getString  (  )  ,  PROPERTY  )  )  )  ;  }  else  if  (  isGlobalFunctionDeclaration  (  t  ,  n  )  )  {  String  name  =  parent  .  isName  (  )  ?  parent  .  getString  (  )  /*  VAR  */  :  n  .  getFirstChild  (  )  .  getString  (  )  /*  named  function  */  ;  symbolStack  .  push  (  new  NameContext  (  getNameInfoForName  (  name  ,  VAR  )  )  )  ;  }  else  if  (  n  .  isFunction  (  )  )  {  symbolStack  .  push  (  new  NameContext  (  anonymousNode  )  )  ;  }  return  true  ;  }  	Closure_163_AnalyzePrototypeProperties_31_4	222	10	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
702	if  (n.isQualifiedName())  {  if  (processPrototypeRef(t,  n))  {  return;  }  return;  if  (n.getParent().isAssign()  &&  n.getNext()  !=  null)  {  String  rValueName  =  getPrototypePropertyNameFromRValue(n);  if  (rValueName  !=  null)  {  return;  }  }  }  addSymbolUse(propName,  t.getModule(),  PROPERTY);  }  else  if  (n.isObjectLit())  {\n', "    	[BUGGY]  processPrototypeParent  (  t  ,  parent  )  ;  }  else  if  (  n  .  isObjectLit  (  )  &&  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ProcessProperties  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  n  parent  propNameNode  [TYPE]  NameContext  context  [TYPE]  String  name  propName  [TYPE]  int  i  [TYPE]  Stack  symbolStack  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  isGetProp  (  )  )  {  String  propName  =  n  .  getFirstChild  (  )  .  getNext  (  )  .  getString  (  )  ;  [BUGGY]  if  (  propName  .  equals  ( "prototype "  )  )  {  processPrototypeParent  (  t  ,  parent  )  ;  }  else  if  (  compiler  .  getCodingConvention  (  )  .  isExported  (  propName  )  )  {  addGlobalUseOfSymbol  (  propName  ,  t  .  getModule  (  )  ,  PROPERTY  )  ;  }  else  {  	Closure_163_AnalyzePrototypeProperties_31_5	241	2	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
703	String  lValueName  =  NodeUtil.getBestLValueName(  NodeUtil.getBestLValue(n));  if  (lValueName  !=  null  &&  lValueName.endsWith( ".prototype "))  {  return;  }  	[BUGGY]  !  (  parent  .  isAssign  (  )  &&  parent  .  getFirstChild  (  )  .  isGetProp  (  )  &&  parent  .  getFirstChild  (  )  .  getLastChild  (  )  .  getString  (  )  .  equals  ( "prototype "  )  )  )  {  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ProcessProperties  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  n  parent  propNameNode  [TYPE]  NameContext  context  [TYPE]  String  name  propName  [TYPE]  int  i  [TYPE]  Stack  symbolStack  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  isGetProp  (  )  )  {  String  propName  =  n  .  getFirstChild  (  )  .  getNext  (  )  .  getString  (  )  ;  if  (  propName  .  equals  ( "prototype "  )  )  {  processPrototypeParent  (  t  ,  parent  )  ;  }  else  if  (  compiler  .  getCodingConvention  (  )  .  isExported  (  propName  )  )  {  addGlobalUseOfSymbol  (  propName  ,  t  .  getModule  (  )  ,  PROPERTY  )  ;  }  else  {  addSymbolUse  (  propName  ,  t  .  getModule  (  )  ,  PROPERTY  )  ;  }  }  else  if  (  n  .  isObjectLit  (  )  &&  [BUGGY]  !  (  parent  .  isAssign  (  )  &&  parent  .  getFirstChild  (  )  .  isGetProp  (  )  &&  parent  .  getFirstChild  (  )  .  getLastChild  (  )  .  getString  (  )  .  equals  ( "prototype "  )  )  )  {  	Closure_163_AnalyzePrototypeProperties_31_6	254	4	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
704	if  (!processGlobalFunctionDeclaration(t,  n,  var))  {  	[BUGGY]  if  (  !processGlobalFunctionDeclaration  (  t  ,  n  ,  parent  ,  parent  .  getParent  (  )  )  )  {  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ProcessProperties  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  n  parent  propNameNode  [TYPE]  NameContext  context  [TYPE]  String  name  propName  [TYPE]  int  i  [TYPE]  Stack  symbolStack  [CONTEXT]  !  (  parent  .  isAssign  (  )  &&  parent  .  getFirstChild  (  )  .  isGetProp  (  )  &&  parent  .  getFirstChild  (  )  .  getLastChild  (  )  .  getString  (  )  .  equals  ( "prototype "  )  )  )  {  for  (  Node  propNameNode  =  n  .  getFirstChild  (  )  ;  propNameNode  !  =  null  ;  propNameNode  =  propNameNode  .  getNext  (  )  )  {  if  (  !propNameNode  .  isQuotedString  (  )  )  {  addSymbolUse  (  propNameNode  .  getString  (  )  ,  t  .  getModule  (  )  ,  PROPERTY  )  ;  }  }  }  else  if  (  n  .  isName  (  )  )  {  String  name  =  n  .  getString  (  )  ;  Var  var  =  t  .  getScope  (  )  .  getVar  (  name  )  ;  if  (  var  !  =  null  )  {  if  (  var  .  isGlobal  (  )  )  {  if  (  var  .  getInitialValue  (  )  !  =  null  &&  var  .  getInitialValue  (  )  .  isFunction  (  )  )  {  if  (  t  .  inGlobalScope  (  )  )  {  [BUGGY]  if  (  !processGlobalFunctionDeclaration  (  t  ,  n  ,  parent  ,  parent  .  getParent  (  )  )  )  {  addGlobalUseOfSymbol  (  name  ,  t  .  getModule  (  )  ,  VAR  )  ;  }  }  else  {  addSymbolUse  (  name  ,  t  .  getModule  (  )  ,  VAR  )  ;  	Closure_163_AnalyzePrototypeProperties_31_7	278	2	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
705	if  (processNonFunctionPrototypeAssign(n,  parent)  !=  null)  {  	[BUGGY]  if  (  isPrototypePropertyAssign  (  n  )  ||  isGlobalFunctionDeclaration  (  t  ,  n  )  ||  n  .  isFunction  (  )  )  {  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  ProcessProperties  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  n  parent  propNameNode  [TYPE]  NameContext  context  [TYPE]  String  name  propName  [TYPE]  int  i  [TYPE]  Stack  symbolStack  [CONTEXT]  parent  .  getParent  (  )  )  )  {  addGlobalUseOfSymbol  (  name  ,  t  .  getModule  (  )  ,  VAR  )  ;  }  }  else  {  addSymbolUse  (  name  ,  t  .  getModule  (  )  ,  VAR  )  ;  }  }  }  else  if  (  var  .  getScope  (  )  !  =  t  .  getScope  (  )  )  {  for  (  int  i  =  symbolStack  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  NameContext  context  =  symbolStack  .  get  (  i  )  ;  if  (  context  .  scope  =  =  var  .  getScope  (  )  )  {  break  ;  }  context  .  name  .  readClosureVariables  =  true  ;  }  }  }  }  [BUGGY]  if  (  isPrototypePropertyAssign  (  n  )  ||  isGlobalFunctionDeclaration  (  t  ,  n  )  ||  n  .  isFunction  (  )  )  {  symbolStack  .  pop  (  )  ;  }  }  	Closure_163_AnalyzePrototypeProperties_31_8	304	3	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
706	private  String  processNonFunctionPrototypeAssign(Node  n,  Node  parent)  {  if  (isAssignRValue(n,  parent)  &&  !n.isFunction())  {  return  getPrototypePropertyNameFromRValue(n);  }  return  null;  }  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_9	330	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
707	if  (!(s.isGlobal()  ||  s.getDepth()  ==  1  &&  s.getRootNode()  ==  n))  {  return  false;  }  return  NodeUtil.isFunctionDeclaration(n)  ||  n.isFunction()  &&  n.getParent().isName();  	[BUGGY]  return  t  .  inGlobalScope  (  )  &&  (  NodeUtil  .  isFunctionDeclaration  (  n  )  ||  n  .  isFunction  (  )  &&  n  .  getParent  (  )  .  isName  (  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  isGlobalFunctionDeclaration  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  ProcessProperties  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Stack  symbolStack  [TYPE]  Node  n  [CONTEXT]  private  boolean  isGlobalFunctionDeclaration  (  NodeTraversal  t  ,  Node  n  )  {  [BUGGY]  return  t  .  inGlobalScope  (  )  &&  (  NodeUtil  .  isFunctionDeclaration  (  n  )  ||  n  .  isFunction  (  )  &&  n  .  getParent  (  )  .  isName  (  )  )  ;  }  	Closure_163_AnalyzePrototypeProperties_31_10	338	4	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
708	private  boolean  isAssignRValue(Node  n,  Node  parent)  {  return  parent  !=  null  &&  parent.isAssign()  &&  parent.getFirstChild()  !=  n;  }  	[BUGGY]  private  boolean  isPrototypePropertyAssign  (  Node  assign  )  {  Node  n  =  assign  .  getFirstChild  (  )  ;  if  (  n  !  =  null  &&  NodeUtil  .  isVarOrSimpleAssignLhs  (  n  ,  assign  )  &&  n  .  isGetProp  (  )  &&  assign  .  getParent  (  )  .  isExprResult  (  )  )  {  boolean  isChainedProperty  =  n  .  getFirstChild  (  )  .  isGetProp  (  )  ;  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_11	348	7	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
709	private  String  getPrototypePropertyNameFromRValue(Node  rValue)  {  Node  lValue  =  NodeUtil.getBestLValue(rValue);  if  (lValue  ==  null  ||  lValue.getParent()  ==  null  ||  lValue.getParent().getParent()  ==  null  ||  !(NodeUtil.isObjectLitKey(lValue,  lValue.getParent())  ||  NodeUtil.isExprAssign(lValue.getParent().getParent())))  {  return  null;  }  String  lValueName  =  NodeUtil.getBestLValueName(NodeUtil.getBestLValue(rValue));  if  (lValueName  ==  null)  {  return  null;  }   int  lastDot  =  lValueName.lastIndexOf('.');  if  (lastDot  ==  -1)  {  return  null;  String  firstPart  =  lValueName.substring(0,  lastDot);  if  (!firstPart.endsWith( ".prototype "))  {  return  null;  }  return  lValueName.substring(lastDot  +  1);  	[BUGGY]  if  (  isChainedProperty  )  {  Node  child  =  n  .  getFirstChild  (  )  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  child  .  isString  (  )  &&  child  .  getString  (  )  .  equals  ( "prototype "  )  )  {  return  true  ;  }  }  return  false  ;  [FE]  AssertionFailedError:  [METHOD]  isPrototypePropertyAssign  [TYPE]  boolean  [PARAMETER]  Node  assign  [CLASS]  ProcessProperties  [TYPE]  Stack  symbolStack  [TYPE]  Node  assign  child  n  [TYPE]  boolean  false  isChainedProperty  true  [CONTEXT]  private  boolean  isPrototypePropertyAssign  (  Node  assign  )  {  Node  n  =  assign  .  getFirstChild  (  )  ;  if  (  n  !  =  null  &&  NodeUtil  .  isVarOrSimpleAssignLhs  (  n  ,  assign  )  &&  n  .  isGetProp  (  )  &&  assign  .  getParent  (  )  .  isExprResult  (  )  )  {  boolean  isChainedProperty  =  n  .  getFirstChild  (  )  .  isGetProp  (  )  ;  [BUGGY]  if  (  isChainedProperty  )  {  Node  child  =  n  .  getFirstChild  (  )  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  child  .  isString  (  )  &&  child  .  getString  (  )  .  equals  ( "prototype "  )  )  {  return  true  ;  }  }  }  return  false  ;  }  	Closure_163_AnalyzePrototypeProperties_31_12	363	8	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
710	Node  nameNode,  Var  v)  {  Node  parent  =  nameNode.getParent();  	[BUGGY]  Node  nameNode  ,  Node  parent  ,  Node  gramps  )  {  [FE]  AssertionFailedError:  [METHOD]  processGlobalFunctionDeclaration  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  nameNode  Node  parent  Node  gramps  [CLASS]  ProcessProperties  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Stack  symbolStack  [TYPE]  Node  firstChild  gramps  nameNode  parent  [CONTEXT]  private  boolean  processGlobalFunctionDeclaration  (  NodeTraversal  t  ,  [BUGGY]  Node  nameNode  ,  Node  parent  ,  Node  gramps  )  {  Node  firstChild  =  nameNode  .  getFirstChild  (  )  ;  if  (  //  Check  for  a  named  FUNCTION  .  isGlobalFunctionDeclaration  (  t  ,  parent  )  ||  firstChild  !  =  null  &&  isGlobalFunctionDeclaration  (  t  ,  firstChild  )  )  {  String  name  =  nameNode  .  getString  (  )  ;  getNameInfoForName  (  name  ,  VAR  )  .  getDeclarations  (  )  .  add  (  new  GlobalFunction  (  nameNode  ,  parent  ,  gramps  ,  t  .  getModule  (  )  )  )  ;  if  (  compiler  .  getCodingConvention  (  )  .  isExported  (  name  )  ||  anchorUnusedVars  )  {  addGlobalUseOfSymbol  (  name  ,  t  .  getModule  (  )  ,  VAR  )  ;  }  return  true  ;  }  return  false  ;  }  	Closure_163_AnalyzePrototypeProperties_31_13	382	1	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
711	new  GlobalFunction(nameNode,  v,  t.getModule()));  	[BUGGY]  new  GlobalFunction  (  nameNode  ,  parent  ,  gramps  ,  t  .  getModule  (  )  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  processGlobalFunctionDeclaration  [TYPE]  boolean  [PARAMETER]  NodeTraversal  t  Node  nameNode  Node  parent  Node  gramps  [CLASS]  ProcessProperties  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Stack  symbolStack  [TYPE]  Node  firstChild  gramps  nameNode  parent  [CONTEXT]  private  boolean  processGlobalFunctionDeclaration  (  NodeTraversal  t  ,  Node  nameNode  ,  Node  parent  ,  Node  gramps  )  {  Node  firstChild  =  nameNode  .  getFirstChild  (  )  ;  if  (  //  Check  for  a  named  FUNCTION  .  isGlobalFunctionDeclaration  (  t  ,  parent  )  ||  firstChild  !  =  null  &&  isGlobalFunctionDeclaration  (  t  ,  firstChild  )  )  {  String  name  =  nameNode  .  getString  (  )  ;  getNameInfoForName  (  name  ,  VAR  )  .  getDeclarations  (  )  .  add  (  [BUGGY]  new  GlobalFunction  (  nameNode  ,  parent  ,  gramps  ,  t  .  getModule  (  )  )  )  ;  if  (  compiler  .  getCodingConvention  (  )  .  isExported  (  name  )  ||  anchorUnusedVars  )  {  addGlobalUseOfSymbol  (  name  ,  t  .  getModule  (  )  ,  VAR  )  ;  }  return  true  ;  }  return  false  ;  }  	Closure_163_AnalyzePrototypeProperties_31_14	392	1	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
712	private  boolean  processPrototypeRef(NodeTraversal  t,  Node  ref)  {  Node  root  =  NodeUtil.getRootOfQualifiedName(ref);  Node  n  =  ref.getParent();  	[BUGGY]  private  void  processPrototypeParent  (  NodeTraversal  t  ,  Node  n  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_15	412	1	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
713	t.getScope().getVar(root.getString()),  return  true;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  processPrototypeParent  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  ProcessProperties  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Property  prop  [TYPE]  Stack  symbolStack  [TYPE]  Node  dest  grandParent  key  map  n  parent  [CONTEXT]  private  void  processPrototypeParent  (  NodeTraversal  t  ,  Node  n  )  {  switch  (  n  .  getType  (  )  )  {  case  Token  .  GETPROP:  Node  dest  =  n  .  getFirstChild  (  )  .  getNext  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  Node  grandParent  =  parent  .  getParent  (  )  ;  if  (  dest  .  isString  (  )  &&  NodeUtil  .  isExprAssign  (  grandParent  )  &&  NodeUtil  .  isVarOrSimpleAssignLhs  (  n  ,  parent  )  )  {  String  name  =  dest  .  getString  (  )  ;  Property  prop  =  new  AssignmentProperty  (  grandParent  ,  [BUGGY]  t  .  getModule  (  )  )  ;  getNameInfoForName  (  name  ,  PROPERTY  )  .  getDeclarations  (  )  .  add  (  prop  )  ;  }  break  ;  	Closure_163_AnalyzePrototypeProperties_31_16	427	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
714	t.getScope().getVar(root.getString()),  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  processPrototypeParent  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  ProcessProperties  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Property  prop  [TYPE]  Stack  symbolStack  [TYPE]  Node  dest  grandParent  key  map  n  parent  [CONTEXT]  Node  dest  =  n  .  getFirstChild  (  )  .  getNext  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  Node  grandParent  =  parent  .  getParent  (  )  ;  if  (  dest  .  isString  (  )  &&  NodeUtil  .  isExprAssign  (  grandParent  )  &&  NodeUtil  .  isVarOrSimpleAssignLhs  (  n  ,  parent  )  )  {  String  name  =  dest  .  getString  (  )  ;  Property  prop  =  new  AssignmentProperty  (  grandParent  ,  t  .  getModule  (  )  )  ;  getNameInfoForName  (  name  ,  PROPERTY  )  .  getDeclarations  (  )  .  add  (  prop  )  ;  }  break  ;  case  Token  .  ASSIGN:  Node  map  =  n  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  map  .  isObjectLit  (  )  )  {  for  (  Node  key  =  map  .  getFirstChild  (  )  ;  key  !  =  null  ;  key  =  key  .  getNext  (  )  )  {  String  name  =  key  .  getString  (  )  ;  Property  prop  =  new  LiteralProperty  (  key  ,  key  .  getFirstChild  (  )  ,  map  ,  n  ,  [BUGGY]  t  .  getModule  (  )  )  ;  getNameInfoForName  (  name  ,  PROPERTY  )  .  getDeclarations  (  )  .  add  (  prop  )  ;  }  }  break  ;  }  	Closure_163_AnalyzePrototypeProperties_31_17	442	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
715	return  true;  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  processPrototypeParent  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  [CLASS]  ProcessProperties  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Property  prop  [TYPE]  Stack  symbolStack  [TYPE]  Node  dest  grandParent  key  map  n  parent  [CONTEXT]  if  (  dest  .  isString  (  )  &&  NodeUtil  .  isExprAssign  (  grandParent  )  &&  NodeUtil  .  isVarOrSimpleAssignLhs  (  n  ,  parent  )  )  {  String  name  =  dest  .  getString  (  )  ;  Property  prop  =  new  AssignmentProperty  (  grandParent  ,  t  .  getModule  (  )  )  ;  getNameInfoForName  (  name  ,  PROPERTY  )  .  getDeclarations  (  )  .  add  (  prop  )  ;  }  break  ;  case  Token  .  ASSIGN:  Node  map  =  n  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  map  .  isObjectLit  (  )  )  {  for  (  Node  key  =  map  .  getFirstChild  (  )  ;  key  !  =  null  ;  key  =  key  .  getNext  (  )  )  {  String  name  =  key  .  getString  (  )  ;  Property  prop  =  new  LiteralProperty  (  key  ,  key  .  getFirstChild  (  )  ,  map  ,  n  ,  t  .  getModule  (  )  )  ;  getNameInfoForName  (  name  ,  PROPERTY  )  .  getDeclarations  (  )  .  add  (  prop  )  ;  }  [BUGGY]  }  break  ;  }  }  private  void  addGlobalUseOfSymbol  (  String  name  ,  JSModule  module  ,  	Closure_163_AnalyzePrototypeProperties_31_18	445	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
716	return  false;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_19	448	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
717	Var  getRootVar();  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_20	499	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
718	private  final  Var  var;  GlobalFunction(Node  nameNode,  Var  var,  JSModule  module)  {  Node  parent  =  nameNode.getParent();  	[BUGGY]  GlobalFunction  (  Node  nameNode  ,  Node  parent  ,  Node  gramps  ,  JSModule  module  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_21	516	1	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
719	this.var  =  var;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_22	523	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
720	public  Var  getRootVar()  {  return  var;  }  @Override  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_23	527	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
721	private  final  Var  rootVar;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_24	576	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
722	AssignmentProperty(Node  node,  Var  rootVar,  JSModule  module)  {  this.rootVar  =  rootVar;  	[BUGGY]  AssignmentProperty  (  Node  node  ,  JSModule  module  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_25	581	1	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
723	public  Var  getRootVar()  {  return  rootVar;  }  @Override  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_26	587	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
724	private  final  Var  rootVar;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_27	623	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
725	Var  rootVar,  JSModule  module)  {  	[BUGGY]  JSModule  module  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_28	626	1	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
726	this.rootVar  =  rootVar;  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_29	631	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
727	public  Var  getRootVar()  {  return  rootVar;  }  @Override  	[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_30	635	0	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
728	final  Scope  scope;  NameContext(NameInfo  name,  Scope  scope)  {  this.scope  =  scope;  	[BUGGY]  Scope  scope  ;  NameContext  (  NameInfo  name  )  {  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Closure_163_AnalyzePrototypeProperties_31_31	665	2	src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java
729	if  (!(prop.getRootVar()  !=  null  &&  prop.getRootVar().isGlobal()))  {  continue;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  moveMethods  [TYPE]  void  [PARAMETER]  NameInfo>  allNameInfo  [CLASS]  CrossModuleMethodMotion  [TYPE]  Symbol  symbol  [TYPE]  Node  declarations  proto  stubCall  unstubCall  unstubParent  value  valueParent  [TYPE]  IdGenerator  idGenerator  [TYPE]  String  STUB_DECLARATIONS  STUB_METHOD_NAME  UNSTUB_METHOD_NAME  [TYPE]  Logger  logger  [TYPE]  JSModuleGraph  moduleGraph  [TYPE]  long  serialVersionUID  [TYPE]  int  currentId  stubId  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  hasStubDeclaration  true  [TYPE]  NameInfo  nameInfo  [TYPE]  DiagnosticType  NULL_COMMON_MODULE_ERROR  [TYPE]  AnalyzePrototypeProperties  analyzer  [TYPE]  Iterator  declarations  [TYPE]  Collection  allNameInfo  [TYPE]  JSModule  deepestCommonModuleRef  [TYPE]  Property  prop  [CONTEXT]  Iterator<Symbol>  declarations  =  nameInfo  .  getDeclarations  (  )  .  descendingIterator  (  )  ;  while  (  declarations  .  hasNext  (  )  )  {  Symbol  symbol  =  declarations  .  next  (  )  ;  if  (  !  (  symbol  instanceof  Property  )  )  {  continue  ;  }  Property  prop  =  (  Property  )  symbol  ;  [BUGGY]  Node  value  =  prop  .  getValue  (  )  ;  if  (  moduleGraph  .  dependsOn  (  deepestCommonModuleRef  ,  prop  .  getModule  (  )  )  &&  value  .  isFunction  (  )  )  {  Node  valueParent  =  value  .  getParent  (  )  ;  if  (  valueParent  .  isGetterDef  (  )  	Closure_163_CrossModuleMethodMotion_1_1	141	0	src/com/google/javascript/jscomp/CrossModuleMethodMotion.java
730	boolean  thisIsOptional  =  thisIsVarArgs  ||  thisParam.isOptionalArg();  boolean  thatIsOptional  =  thatIsVarArgs  ||  thatParam.isOptionalArg();  if  (!thisIsOptional  &&  thatIsOptional)  {  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  isSubtype  [TYPE]  boolean  [PARAMETER]  JSType  other  [CLASS]  ArrowType  [TYPE]  ArrowType  that  [TYPE]  JSType  other  returnType  thatParamType  thisParamType  [TYPE]  boolean  false  returnTypeInferred  thatIsVarArgs  thisIsVarArgs  true  [TYPE]  long  serialVersionUID  [TYPE]  Node  parameters  thatParam  thisParam  [CONTEXT]  Node  thisParam  =  parameters  .  getFirstChild  (  )  ;  Node  thatParam  =  that  .  parameters  .  getFirstChild  (  )  ;  while  (  thisParam  !  =  null  &&  thatParam  !  =  null  )  {  JSType  thisParamType  =  thisParam  .  getJSType  (  )  ;  JSType  thatParamType  =  thatParam  .  getJSType  (  )  ;  if  (  thisParamType  !  =  null  )  {  if  (  thatParamType  =  =  null  ||  !thatParamType  .  isSubtype  (  thisParamType  )  )  {  return  false  ;  }  }  boolean  thisIsVarArgs  =  thisParam  .  isVarArgs  (  )  ;  boolean  thatIsVarArgs  =  thatParam  .  isVarArgs  (  )  ;  [BUGGY]  	Closure_164_ArrowType_3_1	128	0	src/com/google/javascript/rhino/jstype/ArrowType.java
731	boolean  isTopFunction  =  thatIsVarArgs  &&  (thatParamType  ==  null  ||  thatParamType.isUnknownType()  ||  thatParamType.isNoType());  if  (!isTopFunction)  {  return  false;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  isSubtype  [TYPE]  boolean  [PARAMETER]  JSType  other  [CLASS]  ArrowType  [TYPE]  ArrowType  that  [TYPE]  JSType  other  returnType  thatParamType  thisParamType  [TYPE]  boolean  false  returnTypeInferred  thatIsVarArgs  thisIsVarArgs  true  [TYPE]  long  serialVersionUID  [TYPE]  Node  parameters  thatParam  thisParam  [CONTEXT]  Node  thisParam  =  parameters  .  getFirstChild  (  )  ;  Node  thatParam  =  that  .  parameters  .  getFirstChild  (  )  ;  while  (  thisParam  !  =  null  &&  thatParam  !  =  null  )  {  JSType  thisParamType  =  thisParam  .  getJSType  (  )  ;  JSType  thatParamType  =  thatParam  .  getJSType  (  )  ;  if  (  thisParamType  !  =  null  )  {  if  (  thatParamType  =  =  null  ||  !thatParamType  .  isSubtype  (  thisParamType  )  )  {  return  false  ;  }  }  boolean  thisIsVarArgs  =  thisParam  .  isVarArgs  (  )  ;  boolean  thatIsVarArgs  =  thatParam  .  isVarArgs  (  )  ;  [BUGGY]  if  (  !thisIsVarArgs  )  {  thisParam  =  thisParam  .  getNext  (  )  ;  }  if  (  !thatIsVarArgs  )  {  	Closure_164_ArrowType_3_2	135	0	src/com/google/javascript/rhino/jstype/ArrowType.java
732	if  (thisParam  !=  null  &&  !thisParam.isOptionalArg()  &&  !thisParam.isVarArgs()  &&  thatParam  ==  null)  {  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  isSubtype  [TYPE]  boolean  [PARAMETER]  JSType  other  [CLASS]  ArrowType  [TYPE]  ArrowType  that  [TYPE]  JSType  other  returnType  thatParamType  thisParamType  [TYPE]  boolean  false  returnTypeInferred  thatIsVarArgs  thisIsVarArgs  true  [TYPE]  long  serialVersionUID  [TYPE]  Node  parameters  thatParam  thisParam  [CONTEXT]  boolean  thatIsVarArgs  =  thatParam  .  isVarArgs  (  )  ;  if  (  !thisIsVarArgs  )  {  thisParam  =  thisParam  .  getNext  (  )  ;  }  if  (  !thatIsVarArgs  )  {  thatParam  =  thatParam  .  getNext  (  )  ;  }  if  (  thisIsVarArgs  &&  thatIsVarArgs  )  {  thisParam  =  null  ;  thatParam  =  null  ;  }  }  [BUGGY]  return  true  ;  }  	Closure_164_ArrowType_3_3	152	0	src/com/google/javascript/rhino/jstype/ArrowType.java
733	if  (maybeRecordType  !=  null  &&  maybeRecordType.isSynthetic())  {  continue;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  canPropertyBeDefined  [TYPE]  boolean  [PARAMETER]  JSType  type  String  propertyName  [CLASS]  JSTypeRegistry  [TYPE]  Multimap  interfaceToImplementors  resolvedNamedTypes  unresolvedNamedTypes  [TYPE]  ErrorReporter  reporter  [TYPE]  Set  forwardDeclaredTypes  namespaces  nonNullableTypeNames  [TYPE]  boolean  false  lastGeneration  tolerateUndefinedValues  true  [TYPE]  ResolveMode  IMMEDIATE  LAZY_EXPRESSIONS  LAZY_NAMES  resolveMode  [TYPE]  JSType  alt  greatestSubtype  type  [TYPE]  JSType[]  nativeTypes  [TYPE]  String  propertyName  templateTypeName  [TYPE]  TemplateType  templateType  [TYPE]  Map  eachRefTypeIndexedByProperty  greatestSubtypeByProperty  namesToTypes  typesIndexedByProperty  [TYPE]  long  serialVersionUID  [TYPE]  int  PROPERTY_CHECKING_UNION_SIZE  [CONTEXT]  public  boolean  canPropertyBeDefined  (  JSType  type  ,  String  propertyName  )  {  if  (  typesIndexedByProperty  .  containsKey  (  propertyName  )  )  {  for  (  JSType  alt  :  typesIndexedByProperty  .  get  (  propertyName  )  .  getAlternates  (  )  )  {  JSType  greatestSubtype  =  alt  .  getGreatestSubtype  (  type  )  ;  if  (  !greatestSubtype  .  isEmptyType  (  )  )  {  [BUGGY]  return  true  ;  }  }  }  return  false  ;  }  	Closure_165_JSTypeRegistry_1_1	698	0	src/com/google/javascript/rhino/jstype/JSTypeRegistry.java
734	public  final  boolean  defineSynthesizedProperty(String  propertyName,  JSType  type,  Node  propertyNode)  {  return  defineProperty(propertyName,  type,  false,  propertyNode);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_165_ObjectType_1_1	290	0	src/com/google/javascript/rhino/jstype/ObjectType.java
735	private  final  boolean  declared;  RecordType(JSTypeRegistry  registry,  Map<String,  RecordProperty>  properties)  {  this(registry,  properties,  true);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_165_RecordType_5_1	68	0	src/com/google/javascript/rhino/jstype/RecordType.java
736	RecordType(JSTypeRegistry  registry,  Map<String,  RecordProperty>  properties,  boolean  declared)  {  this.declared  =  declared;  	[BUGGY]  RecordType  (  JSTypeRegistry  registry  ,  Map<String  ,  RecordProperty>  properties  )  {  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_165_RecordType_5_2	83	1	src/com/google/javascript/rhino/jstype/RecordType.java
737	if  (declared)  {  }  else  {  defineSynthesizedProperty(  property,  prop.getType(),  prop.getPropertyNode());  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_165_RecordType_5_3	93	0	src/com/google/javascript/rhino/jstype/RecordType.java
738	boolean  isSynthetic()  {  return  !declared;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_165_RecordType_5_4	102	0	src/com/google/javascript/rhino/jstype/RecordType.java
739	builder.setSynthesized(true);  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  getGreatestSubtypeHelper  [TYPE]  JSType  [PARAMETER]  JSType  that  [CLASS]  RecordType  [TYPE]  ObjectType  alt  [TYPE]  Entry  entry  [TYPE]  boolean  false  isFrozen  true  [TYPE]  JSType  altPropType  greatestSubtype  propType  that  thatRestrictedToObj  [TYPE]  RecordType  thatRecord  [TYPE]  UnionTypeBuilder  builder  [TYPE]  SortedMap  properties  [TYPE]  String  propName  property  [TYPE]  RecordTypeBuilder  builder  [TYPE]  long  serialVersionUID  [CONTEXT]  JSType  getGreatestSubtypeHelper  (  JSType  that  )  {  if  (  that  .  isRecordType  (  )  )  {  RecordType  thatRecord  =  that  .  toMaybeRecordType  (  )  ;  RecordTypeBuilder  builder  =  new  RecordTypeBuilder  (  registry  )  ;  [BUGGY]  for  (  String  property  :  properties  .  keySet  (  )  )  {  if  (  thatRecord  .  hasProperty  (  property  )  &&  	Closure_165_RecordType_5_5	152	0	src/com/google/javascript/rhino/jstype/RecordType.java
740	private  boolean  isDeclared  =  true;  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_165_RecordTypeBuilder_3_1	54	0	src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java
741	void  setSynthesized(boolean  synthesized)  {  isDeclared  =  !synthesized;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [CLASS]  [CONTEXT]  	Closure_165_RecordTypeBuilder_3_2	62	0	src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java
742	registry,  Collections.unmodifiableMap(properties),  isDeclared);  	[BUGGY]  registry  ,  Collections  .  unmodifiableMap  (  properties  )  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  build  [TYPE]  JSType  [PARAMETER]  [CLASS]  RecordTypeBuilder  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  isEmpty  true  [TYPE]  JSType  type  [TYPE]  HashMap  properties  [TYPE]  Node  propertyNode  [CONTEXT]  public  JSType  build  (  )  {  if  (  isEmpty  )  {  return  registry  .  getNativeObjectType  (  JSTypeNative  .  OBJECT_TYPE  )  ;  }  return  new  RecordType  (  [BUGGY]  registry  ,  Collections  .  unmodifiableMap  (  properties  )  )  ;  }  	Closure_165_RecordTypeBuilder_3_3	92	1	src/com/google/javascript/rhino/jstype/RecordTypeBuilder.java
743	}  else  if  (constraint.isUnionType())  {  for  (JSType  alt  :  constraint.toMaybeUnionType().getAlternates())  {  if  (alt.isRecordType())  {  matchRecordTypeConstraint(alt.toObjectType());  }  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[a:  (  boolean|undefined  )  ,  b:  (  string|undefined  )  ]}>  but  was:<{[]}>  assertEquals  ( "{a:  (  boolean|undefined  )  ,  b:  (  string|undefined  )  } "  ,  [METHOD]  matchConstraint  [TYPE]  void  [PARAMETER]  JSType  constraint  [CLASS]  PrototypeObjectType  [TYPE]  ObjectType  implicitPrototypeFallback  [TYPE]  boolean  false  nativeType  prettyPrint  true  [TYPE]  JSType  constraint  [TYPE]  FunctionType  ownerFunction  [TYPE]  String  className  [TYPE]  Map  properties  [TYPE]  long  serialVersionUID  [TYPE]  int  MAX_PRETTY_PRINTED_PROPERTIES  [CONTEXT]  public  void  matchConstraint  (  JSType  constraint  )  {  if  (  hasReferenceName  (  )  )  {  return  ;  }  if  (  constraint  .  isRecordType  (  )  )  {  matchRecordTypeConstraint  (  constraint  .  toObjectType  (  )  )  ;  [BUGGY]  }  }  	Closure_166_PrototypeObjectType_1_1	573	0	src/com/google/javascript/rhino/jstype/PrototypeObjectType.java
744	left,  leftType,  leftIsRefineable  ?  merged.typeA  :  null,  right,  rightType,  rightIsRefineable  ?  merged.typeB  :  null);  	[BUGGY]  left  ,  leftIsRefineable  ,  merged  .  typeA  ,  right  ,  rightIsRefineable  ,  merged  .  typeB  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  caseEquality  [TYPE]  FlowScope  [PARAMETER]  Node  left  Node  right  FlowScope  blindScope  TypePair>  merging  [CLASS]  SemanticReverseAbstractInterpreter  [TYPE]  Function  EQ  INEQ  NE  SHEQ  SHNE  merging  [TYPE]  ObjectType  target  [TYPE]  JSType  leftType  rightType  [TYPE]  boolean  false  leftIsRefineable  rightIsRefineable  true  [TYPE]  Node  left  right  [TYPE]  TypePair  merged  [TYPE]  FlowScope  blindScope  [CONTEXT]  boolean  leftIsRefineable  ;  if  (  leftType  !  =  null  )  {  leftIsRefineable  =  true  ;  }  else  {  leftIsRefineable  =  false  ;  leftType  =  left  .  getJSType  (  )  ;  }  JSType  rightType  =  getTypeIfRefinable  (  right  ,  blindScope  )  ;  boolean  rightIsRefineable  ;  if  (  rightType  !  =  null  )  {  rightIsRefineable  =  true  ;  }  else  {  rightIsRefineable  =  false  ;  rightType  =  right  .  getJSType  (  )  ;  }  TypePair  merged  =  merging  .  apply  (  new  TypePair  (  leftType  ,  rightType  )  )  ;  if  (  merged  !  =  null  )  {  return  maybeRestrictTwoNames  (  blindScope  ,  [BUGGY]  left  ,  leftIsRefineable  ,  merged  .  typeA  ,  right  ,  rightIsRefineable  ,  merged  .  typeB  )  ;  }  return  blindScope  ;  }  	Closure_167_SemanticReverseAbstractInterpreter_5_1	301	2	src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java
745	left,  leftType,  leftIsRefineable  ?  restrictedLeftType  :  null,  right,  rightType,  rightIsRefineable  ?  restrictedRightType  :  null);  	[BUGGY]  left  ,  leftIsRefineable  ,  restrictedLeftType  ,  right  ,  rightIsRefineable  ,  restrictedRightType  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  caseAndOrNotShortCircuiting  [TYPE]  FlowScope  [PARAMETER]  Node  left  Node  right  FlowScope  blindScope  boolean  condition  [CLASS]  SemanticReverseAbstractInterpreter  [TYPE]  Function  EQ  INEQ  NE  SHEQ  SHNE  [TYPE]  ObjectType  target  [TYPE]  boolean  condition  false  leftIsRefineable  rightIsRefineable  true  [TYPE]  JSType  leftType  restrictedLeftType  restrictedRightType  rightType  [TYPE]  Node  left  right  [TYPE]  FlowScope  blindScope  [CONTEXT]  leftType  .  getRestrictedTypeGivenToBooleanOutcome  (  condition  )  ;  if  (  restrictedLeftType  =  =  null  )  {  return  firstPreciserScopeKnowingConditionOutcome  (  right  ,  blindScope  ,  condition  )  ;  }  JSType  rightType  =  getTypeIfRefinable  (  right  ,  blindScope  )  ;  boolean  rightIsRefineable  ;  if  (  rightType  !  =  null  )  {  rightIsRefineable  =  true  ;  }  else  {  rightIsRefineable  =  false  ;  rightType  =  right  .  getJSType  (  )  ;  blindScope  =  firstPreciserScopeKnowingConditionOutcome  (  right  ,  blindScope  ,  condition  )  ;  }  if  (  condition  )  {  JSType  restrictedRightType  =  (  rightType  =  =  null  )  ?  null  :  rightType  .  getRestrictedTypeGivenToBooleanOutcome  (  condition  )  ;  return  maybeRestrictTwoNames  (  blindScope  ,  [BUGGY]  left  ,  leftIsRefineable  ,  restrictedLeftType  ,  right  ,  rightIsRefineable  ,  restrictedRightType  )  ;  }  return  blindScope  ;  }  	Closure_167_SemanticReverseAbstractInterpreter_5_2	348	2	src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java
746	if  (restrictedType  !=  null  &&  restrictedType  !=  originalType)  {  	[BUGGY]  if  (  restrictedType  !  =  null  &&  !restrictedType  .  equals  (  originalType  )  )  {  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  maybeRestrictName  [TYPE]  FlowScope  [PARAMETER]  FlowScope  blindScope  Node  node  JSType  originalType  JSType  restrictedType  [CLASS]  SemanticReverseAbstractInterpreter  [TYPE]  Function  EQ  INEQ  NE  SHEQ  SHNE  [TYPE]  ObjectType  target  [TYPE]  JSType  originalType  restrictedType  [TYPE]  boolean  false  true  [TYPE]  FlowScope  blindScope  informed  [TYPE]  Node  node  [CONTEXT]  private  FlowScope  maybeRestrictName  (  FlowScope  blindScope  ,  Node  node  ,  JSType  originalType  ,  JSType  restrictedType  )  {  [BUGGY]  if  (  restrictedType  !  =  null  &&  !restrictedType  .  equals  (  originalType  )  )  {  FlowScope  informed  =  blindScope  .  createChildFlowScope  (  )  ;  declareNameInScope  (  informed  ,  node  ,  restrictedType  )  ;  return  informed  ;  }  return  blindScope  ;  }  	Closure_167_SemanticReverseAbstractInterpreter_5_3	394	1	src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java
747	Node  left,  JSType  originalLeftType,  JSType  restrictedLeftType,  Node  right,  JSType  originalRightType,  JSType  restrictedRightType)  {  restrictedLeftType  !=  null  &&  restrictedLeftType  !=  originalLeftType;  restrictedRightType  !=  null  &&  restrictedRightType  !=  originalRightType;  	[BUGGY]  Node  left  ,  boolean  leftIsRefineable  ,  JSType  restrictedLeftType  ,  Node  right  ,  boolean  rightIsRefineable  ,  JSType  restrictedRightType  )  {  leftIsRefineable  &&  restrictedLeftType  !  =  null  ;  rightIsRefineable  &&  restrictedRightType  !  =  null  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  maybeRestrictTwoNames  [TYPE]  FlowScope  [PARAMETER]  FlowScope  blindScope  Node  left  boolean  leftIsRefineable  JSType  restrictedLeftType  Node  right  boolean  rightIsRefineable  JSType  restrictedRightType  [CLASS]  SemanticReverseAbstractInterpreter  [TYPE]  Function  EQ  INEQ  NE  SHEQ  SHNE  [TYPE]  ObjectType  target  [TYPE]  boolean  false  leftIsRefineable  rightIsRefineable  shouldRefineLeft  shouldRefineRight  true  [TYPE]  JSType  restrictedLeftType  restrictedRightType  [TYPE]  FlowScope  blindScope  informed  [TYPE]  Node  left  right  [CONTEXT]  private  FlowScope  maybeRestrictTwoNames  (  FlowScope  blindScope  ,  [BUGGY]  Node  left  ,  boolean  leftIsRefineable  ,  JSType  restrictedLeftType  ,  Node  right  ,  boolean  rightIsRefineable  ,  JSType  restrictedRightType  )  {  boolean  shouldRefineLeft  =  leftIsRefineable  &&  restrictedLeftType  !  =  null  ;  boolean  shouldRefineRight  =  rightIsRefineable  &&  restrictedRightType  !  =  null  ;  if  (  shouldRefineLeft  ||  shouldRefineRight  )  {  FlowScope  informed  =  blindScope  .  createChildFlowScope  (  )  ;  if  (  shouldRefineLeft  )  {  declareNameInScope  (  informed  ,  left  ,  restrictedLeftType  )  ;  }  if  (  shouldRefineRight  )  {  declareNameInScope  (  informed  ,  right  ,  restrictedRightType  )  ;  }  return  informed  ;  }  return  blindScope  ;  }  	Closure_167_SemanticReverseAbstractInterpreter_5_4	407	4	src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java
748	return  maybeRestrictName(  blindScope,  name,  type,  type.getRestrictedTypeGivenToBooleanOutcome(outcome));  	[BUGGY]  JSType  restrictedType  =  type  .  getRestrictedTypeGivenToBooleanOutcome  (  outcome  )  ;  FlowScope  informed  =  blindScope  .  createChildFlowScope  (  )  ;  declareNameInScope  (  informed  ,  name  ,  restrictedType  )  ;  return  informed  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  caseNameOrGetProp  [TYPE]  FlowScope  [PARAMETER]  Node  name  FlowScope  blindScope  boolean  outcome  [CLASS]  SemanticReverseAbstractInterpreter  [TYPE]  Function  EQ  INEQ  NE  SHEQ  SHNE  [TYPE]  ObjectType  target  [TYPE]  boolean  false  outcome  true  [TYPE]  JSType  restrictedType  type  [TYPE]  Node  name  [TYPE]  FlowScope  blindScope  informed  [CONTEXT]  private  FlowScope  caseNameOrGetProp  (  Node  name  ,  FlowScope  blindScope  ,  boolean  outcome  )  {  JSType  type  =  getTypeIfRefinable  (  name  ,  blindScope  )  ;  if  (  type  !  =  null  )  {  [BUGGY]  JSType  restrictedType  =  type  .  getRestrictedTypeGivenToBooleanOutcome  (  outcome  )  ;  FlowScope  informed  =  blindScope  .  createChildFlowScope  (  )  ;  declareNameInScope  (  informed  ,  name  ,  restrictedType  )  ;  return  informed  ;  }  return  blindScope  ;  }  	Closure_167_SemanticReverseAbstractInterpreter_5_5	430	5	src/com/google/javascript/jscomp/type/SemanticReverseAbstractInterpreter.java
749	if  (outcome  &&  this  ==  getNativeType(JSTypeNative.UNKNOWN_TYPE))  {  return  getNativeType(JSTypeNative.CHECKED_UNKNOWN_TYPE);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  getRestrictedTypeGivenToBooleanOutcome  [TYPE]  JSType  [PARAMETER]  boolean  outcome  [CLASS]  JSType  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  inTemplatedCheckVisit  outcome  resolved  true  [TYPE]  JSType  resolveResult  typeA  typeB  [TYPE]  BooleanLiteralSet  literals  [TYPE]  String  EMPTY_TYPE_COMPONENT  NOT_A_CLASS  NOT_A_TYPE  UNKNOWN_NAME  [TYPE]  long  serialVersionUID  [TYPE]  int  ENUMDECL  NOT_ENUMDECL  [TYPE]  Comparator  ALPHA  [CONTEXT]  public  JSType  getRestrictedTypeGivenToBooleanOutcome  (  boolean  outcome  )  {  [BUGGY]  BooleanLiteralSet  literals  =  getPossibleToBooleanOutcomes  (  )  ;  if  (  literals  .  contains  (  outcome  )  )  {  return  this  ;  }  else  {  return  getNativeType  (  JSTypeNative  .  NO_TYPE  )  ;  }  }  	Closure_167_JSType_1_1	883	0	src/com/google/javascript/rhino/jstype/JSType.java
750	if  (t.getScopeDepth()  <=  1)  {  	[BUGGY]  if  (  t  .  getScopeDepth  (  )  <  =  2  )  {  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  FirstOrderFunctionAnalyzer  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  Scope  ownerScope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  var  [TYPE]  Node  n  parent  [TYPE]  String  name  [TYPE]  Map  data  [CONTEXT]  @Override  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  t  .  inGlobalScope  (  )  )  {  return  ;  }  if  (  n  .  isReturn  (  )  &&  n  .  getFirstChild  (  )  !  =  null  )  {  data  .  get  (  t  .  getScopeRoot  (  )  )  .  recordNonEmptyReturn  (  )  ;  }  [BUGGY]  if  (  t  .  getScopeDepth  (  )  <  =  2  )  {  	Closure_168_TypedScopeCreator_1_1	1996	1	src/com/google/javascript/jscomp/TypedScopeCreator.java
751	boolean  hasEqualParameters(ArrowType  that,  EquivalenceMethod  eqMethod)  {  	[BUGGY]  boolean  hasEqualParameters  (  ArrowType  that  ,  boolean  tolerateUnknowns  )  {  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [CLASS]  [CONTEXT]  	Closure_169_ArrowType_3_1	177	1	src/com/google/javascript/rhino/jstype/ArrowType.java
752	otherParamType,  eqMethod))  {  	[BUGGY]  otherParamType  ,  tolerateUnknowns  )  )  {  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  hasEqualParameters  [TYPE]  boolean  [PARAMETER]  ArrowType  that  boolean  tolerateUnknowns  [CLASS]  ArrowType  [TYPE]  ArrowType  that  [TYPE]  JSType  otherParamType  returnType  thisParamType  [TYPE]  boolean  false  returnTypeInferred  tolerateUnknowns  true  [TYPE]  long  serialVersionUID  [TYPE]  Node  otherParam  parameters  thisParam  [CONTEXT]  boolean  hasEqualParameters  (  ArrowType  that  ,  boolean  tolerateUnknowns  )  {  Node  thisParam  =  parameters  .  getFirstChild  (  )  ;  Node  otherParam  =  that  .  parameters  .  getFirstChild  (  )  ;  while  (  thisParam  !  =  null  &&  otherParam  !  =  null  )  {  JSType  thisParamType  =  thisParam  .  getJSType  (  )  ;  JSType  otherParamType  =  otherParam  .  getJSType  (  )  ;  if  (  thisParamType  !  =  null  )  {  if  (  otherParamType  !  =  null  &&  !thisParamType  .  checkEquivalenceHelper  (  [BUGGY]  otherParamType  ,  tolerateUnknowns  )  )  {  return  false  ;  }  }  else  {  if  (  otherParamType  !  =  null  )  {  return  false  ;  }  }  thisParam  =  thisParam  .  getNext  (  )  ;  otherParam  =  otherParam  .  getNext  (  )  ;  }  return  thisParam  =  =  otherParam  ;  }  	Closure_169_ArrowType_3_2	187	1	src/com/google/javascript/rhino/jstype/ArrowType.java
753	ArrowType  that,  EquivalenceMethod  eqMethod)  {  if  (!returnType.checkEquivalenceHelper(that.returnType,  eqMethod))  {  return  hasEqualParameters(that,  eqMethod);  	[BUGGY]  ArrowType  that  ,  boolean  tolerateUnknowns  )  {  if  (  !returnType  .  checkEquivalenceHelper  (  that  .  returnType  ,  tolerateUnknowns  )  )  {  return  hasEqualParameters  (  that  ,  tolerateUnknowns  )  ;  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  [METHOD]  checkArrowEquivalenceHelper  [TYPE]  boolean  [PARAMETER]  ArrowType  that  boolean  tolerateUnknowns  [CLASS]  ArrowType  [TYPE]  ArrowType  that  [TYPE]  JSType  returnType  [TYPE]  boolean  false  returnTypeInferred  tolerateUnknowns  true  [TYPE]  long  serialVersionUID  [TYPE]  Node  parameters  [CONTEXT]  boolean  checkArrowEquivalenceHelper  (  [BUGGY]  ArrowType  that  ,  boolean  tolerateUnknowns  )  {  if  (  !returnType  .  checkEquivalenceHelper  (  that  .  returnType  ,  tolerateUnknowns  )  )  {  return  false  ;  }  return  hasEqualParameters  (  that  ,  tolerateUnknowns  )  ;  }  	Closure_169_ArrowType_3_3	204	3	src/com/google/javascript/rhino/jstype/ArrowType.java
754	if  (n.isName()  &&  n.getString().equals(varName))  {  	[BUGGY]  if  (  n  .  isName  (  )  &&  n  .  getString  (  )  .  equals  (  varName  )  &&  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  4  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  parent  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  [BUGGY]  if  (  n  .  isName  (  )  &&  n  .  getString  (  )  .  equals  (  varName  )  &&  !  (  parent  .  isAssign  (  )  &&  (  parent  .  getFirstChild  (  )  =  =  n  )  )  )  {  numUsesWithinCfgNode++  ;  }  }  	Closure_170_FlowSensitiveInlineVariables_3_1	482	1	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
755	if  (parent.isAssign()  &&  (parent.getFirstChild()  ==  n)  &&  isAssignChain(parent,  cfgNode))  {\n', "    }  else  {  }  	[BUGGY]  !  (  parent  .  isAssign  (  )  &&  (  parent  .  getFirstChild  (  )  =  =  n  )  )  )  {  [FE]  AssertionFailedError:  [METHOD]  visit  [TYPE]  void  [PARAMETER]  NodeTraversal  t  Node  n  Node  parent  [CLASS]  4  [TYPE]  boolean  false  true  [TYPE]  NodeTraversal  t  [TYPE]  Node  n  parent  [CONTEXT]  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  isName  (  )  &&  n  .  getString  (  )  .  equals  (  varName  )  &&  [BUGGY]  !  (  parent  .  isAssign  (  )  &&  (  parent  .  getFirstChild  (  )  =  =  n  )  )  )  {  numUsesWithinCfgNode++  ;  }  }  	Closure_170_FlowSensitiveInlineVariables_3_2	488	2	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
756	private  boolean  isAssignChain(Node  child,  Node  ancestor)  {  for  (Node  n  =  child;  n  !=  ancestor;  n  =  n.getParent())  {  if  (!n.isAssign())  {  return  false;  }  }  return  true;  }  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  getNumUseInUseCfgNode  [TYPE]  void  [PARAMETER]  Node  cfgNode  [CLASS]  Candidate  [TYPE]  boolean  false  true  [TYPE]  AbstractCfgNodeTraversalCallback  gatherCb  [TYPE]  NodeTraversal  t  [TYPE]  Node  cfgNode  def  n  parent  use  useCfgNode  [TYPE]  Definition  defMetadata  [TYPE]  String  varName  [TYPE]  int  numUsesWithinCfgNode  [CONTEXT]  private  void  getNumUseInUseCfgNode  (  final  Node  cfgNode  )  {  numUsesWithinCfgNode  =  0  ;  AbstractCfgNodeTraversalCallback  gatherCb  =  new  AbstractCfgNodeTraversalCallback  (  )  {  @Override  public  void  visit  (  NodeTraversal  t  ,  Node  n  ,  Node  parent  )  {  if  (  n  .  isName  (  )  &&  n  .  getString  (  )  .  equals  (  varName  )  &&  !  (  parent  .  isAssign  (  )  &&  (  parent  .  getFirstChild  (  )  =  =  n  )  )  )  {  numUsesWithinCfgNode++  ;  }  }  [BUGGY]  }  ;  NodeTraversal  .  traverse  (  compiler  ,  cfgNode  ,  gatherCb  )  ;  }  	Closure_170_FlowSensitiveInlineVariables_3_3	495	0	src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java
757	if  (objectType  ==  null  ||  n.getBooleanProp(Node.REFLECTED_OBJECT))  {  	[BUGGY]  if  (  objectType  =  =  null  )  {  return  scope  ;  }  boolean  hasLendsName  =  n  .  getJSDocInfo  (  )  !  =  null  &&  n  .  getJSDocInfo  (  )  .  getLendsName  (  )  !  =  null  ;  if  (  objectType  .  hasReferenceName  (  )  &&  !hasLendsName  )  {  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  traverseObjectLiteral  [TYPE]  FlowScope  [PARAMETER]  Node  n  FlowScope  scope  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  oldType  rawValueType  type  valueType  [TYPE]  Var  var  [TYPE]  Node  n  name  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  memberName  qKeyName  qObjName  [TYPE]  ObjectType  objectType  unknownType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  hasLendsName  madeChanges  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  [TYPE]  Map  assertionFunctionsMap  replacements  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  FlowScope  traverseObjectLiteral  (  Node  n  ,  FlowScope  scope  )  {  JSType  type  =  n  .  getJSType  (  )  ;  Preconditions  .  checkNotNull  (  type  )  ;  for  (  Node  name  =  n  .  getFirstChild  (  )  ;  name  !  =  null  ;  name  =  name  .  getNext  (  )  )  {  scope  =  traverse  (  name  .  getFirstChild  (  )  ,  scope  )  ;  }  ObjectType  objectType  =  ObjectType  .  cast  (  type  )  ;  [BUGGY]  if  (  objectType  =  =  null  )  {  return  scope  ;  }  boolean  hasLendsName  =  n  .  getJSDocInfo  (  )  !  =  null  &&  n  .  getJSDocInfo  (  )  .  getLendsName  (  )  !  =  null  ;  if  (  objectType  .  hasReferenceName  (  )  &&  !hasLendsName  )  {  	Closure_171_TypeInference_1_1	731	6	src/com/google/javascript/jscomp/TypeInference.java
758	if  (qName  !=  null  &&  qName.endsWith( ".prototype "))  {  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  isQualifiedNameInferred  [TYPE]  boolean  [PARAMETER]  String  qName  Node  n  JSDocInfo  info  Node  rhsValue  JSType  valueType  [CLASS]  AbstractScopeBuilder  [TYPE]  JSType  thisType  valueType  [TYPE]  boolean  false  inferred  true  [TYPE]  Scope  scope  [TYPE]  Node  current  n  rhsValue  [TYPE]  InputId  inputId  [TYPE]  AstFunctionContents  contents  [TYPE]  List  deferredSetTypes  lentObjectLiterals  nonExternFunctions  stubDeclarations  [TYPE]  String  qName  sourceName  [TYPE]  JSDocInfo  info  [CONTEXT]  private  boolean  isQualifiedNameInferred  (  String  qName  ,  Node  n  ,  JSDocInfo  info  ,  Node  rhsValue  ,  JSType  valueType  )  {  if  (  valueType  =  =  null  )  {  return  true  ;  }  [BUGGY]  boolean  inferred  =  true  ;  if  (  info  !  =  null  )  {  inferred  =  !  (  info  .  hasType  (  )  ||  info  .  hasEnumParameterType  (  )  ||  (  isConstantSymbol  (  info  ,  n  )  &&  valueType  !  =  null  	Closure_171_TypedScopeCreator_1_1	1669	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
759	String  className  =  qName.substring(0,  qName.lastIndexOf( ".prototype "));  Var  slot  =  scope.getSlot(className);  JSType  classType  =  slot  ==  null  ?  null  :  slot.getType();  if  (classType  !=  null  &&  (classType.isConstructor()  ||  classType.isInterface()))  {  }  	[BUGGY]  [FE]  AssertionFailedError:  unexpected  warnings  (  s  )  :  assertEquals  (  0  ,  compiler  .  getWarningCount  (  )  )  ;  [METHOD]  isQualifiedNameInferred  [TYPE]  boolean  [PARAMETER]  String  qName  Node  n  JSDocInfo  info  Node  rhsValue  JSType  valueType  [CLASS]  AbstractScopeBuilder  [TYPE]  JSType  thisType  valueType  [TYPE]  boolean  false  inferred  true  [TYPE]  Scope  scope  [TYPE]  Node  current  n  rhsValue  [TYPE]  InputId  inputId  [TYPE]  AstFunctionContents  contents  [TYPE]  List  deferredSetTypes  lentObjectLiterals  nonExternFunctions  stubDeclarations  [TYPE]  String  qName  sourceName  [TYPE]  JSDocInfo  info  [CONTEXT]  private  boolean  isQualifiedNameInferred  (  String  qName  ,  Node  n  ,  JSDocInfo  info  ,  Node  rhsValue  ,  JSType  valueType  )  {  if  (  valueType  =  =  null  )  {  return  true  ;  }  if  (  qName  !  =  null  &&  qName  .  endsWith  ( "  .  prototype "  )  )  {  [BUGGY]  return  false  ;  }  boolean  inferred  =  true  ;  if  (  info  !  =  null  )  {  inferred  =  !  (  info  .  hasType  (  )  	Closure_172_TypedScopeCreator_1_1	1670	0	src/com/google/javascript/jscomp/TypedScopeCreator.java
760	if  (NodeUtil.isAssignmentOp(n)  &&  NodeUtil.isAssignmentOp(last))  {  	[BUGGY]  if  (  last  .  getType  (  )  =  =  type  &&  NodeUtil  .  isAssociative  (  type  )  )  {  addExpr  (  first  ,  p  ,  context  )  ;  cc  .  addOp  (  opstr  ,  true  )  ;  addExpr  (  last  ,  p  ,  rhsContext  )  ;  }  else  if  (  NodeUtil  .  isAssignmentOp  (  n  )  &&  NodeUtil  .  isAssignmentOp  (  last  )  )  {  [FE]  ComparisonFailure:  expected:<var  a  ,  b  ,  c  ;  a||[  (  b||c  )  ;  a*  (  b*c  )  ;  a|  (  b|c  )  ]>  but  was:<var  a  ,  b  ,  c  ;  a||[b||c  ;  a*b*c  ;  a|b|c]>  assertEquals  ( "\ "f\ "  ;  \n\ "g\ "  ;  \n "  ,  result  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  Node  n  Context  context  [CLASS]  CodeGenerator  [TYPE]  Context  BEFORE_DANGLING_ELSE  IN_FOR_INIT_CLAUSE  OTHER  PRESERVE_BLOCK  START_OF_EXPR  STATEMENT  context  rhsContext  [TYPE]  LanguageMode  languageMode  [TYPE]  boolean  ambiguousElseClause  false  funcNeedsParens  hasElse  needsParens  preferLineBreaks  preferSingleQuotes  preserveBlock  true  trustedStrings  [TYPE]  double  d  [TYPE]  Node  body  c  catchblock  first  fn  last  n  next  parameters  [TYPE]  CodeConsumer  cc  [TYPE]  String  GT_ESCAPED  LT_ESCAPED  key  name  o  opstr  regexp  [TYPE]  Map  escapedJsStrings  [TYPE]  CharsetEncoder  outputCharsetEncoder  [TYPE]  int  childCount  p  postProp  precedence  type  [TYPE]  char[]  HEX_CHARS  [CONTEXT]  void  add  (  Node  n  ,  Context  context  )  {  if  (  !cc  .  continueProcessing  (  )  )  {  return  ;  }  int  type  =  n  .  getType  (  )  ;  String  opstr  =  NodeUtil  .  opToStr  (  type  )  ;  int  childCount  =  n  .  getChildCount  (  )  ;  Node  first  =  n  .  getFirstChild  (  )  ;  Node  last  =  n  .  getLastChild  (  )  ;  if  (  opstr  !  =  null  &&  first  !  =  last  )  {  Preconditions  .  checkState  (  childCount  =  =  2  , "Bad  binary  operator  \ "%s\ ":  expected  2  arguments  but  got  %s "  ,  opstr  ,  childCount  )  ;  int  p  =  NodeUtil  .  precedence  (  type  )  ;  Context  rhsContext  =  getContextForNoInOperator  (  context  )  ;  [BUGGY]  if  (  last  .  getType  (  )  =  =  type  &&  NodeUtil  .  isAssociative  (  type  )  )  {  addExpr  (  first  ,  p  ,  context  )  ;  cc  .  addOp  (  opstr  ,  true  )  ;  addExpr  (  last  ,  p  ,  rhsContext  )  ;  }  else  if  (  NodeUtil  .  isAssignmentOp  (  n  )  &&  NodeUtil  .  isAssignmentOp  (  last  )  )  {  	Closure_173_CodeGenerator_1_1	130	6	src/com/google/javascript/jscomp/CodeGenerator.java
761	case  Token.MUL:  case  Token.AND:  case  Token.OR:  case  Token.BITOR:  case  Token.BITXOR:  case  Token.BITAND:  return  tryRotateAssociativeOperator(node);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<var  a  ,  b  ,  c  ;  a||[  (  b||c  )  ;  a*  (  b*c  )  ;  a|  (  b|c  )  ]>  but  was:<var  a  ,  b  ,  c  ;  a||[b||c  ;  a*b*c  ;  a|b|c]>  assertEquals  ( "\ "f\ "  ;  \n\ "g\ "  ;  \n "  ,  result  )  ;  [METHOD]  optimizeSubtree  [TYPE]  Node  [PARAMETER]  Node  node  [CLASS]  PeepholeSubstituteAlternateSyntax  [TYPE]  Pattern  REGEXP_FLAGS_RE  [TYPE]  FoldArrayAction  NOT_SAFE_TO_FOLD  SAFE_TO_FOLD_WITHOUT_ARGS  SAFE_TO_FOLD_WITH_ARGS  [TYPE]  boolean  false  late  true  [TYPE]  ImmutableSet  STANDARD_OBJECT_CONSTRUCTORS  [TYPE]  DiagnosticType  INVALID_REGULAR_EXPRESSION_FLAGS  [TYPE]  Node  node  result  [TYPE]  CodeGenerator  REGEXP_ESCAPER  [TYPE]  int  STRING_SPLIT_OVERHEAD  [CONTEXT]  }  case  Token  .  CALL:  Node  result  =  tryFoldLiteralConstructor  (  node  )  ;  if  (  result  =  =  node  )  {  result  =  tryFoldSimpleFunctionCall  (  node  )  ;  if  (  result  =  =  node  )  {  result  =  tryFoldImmediateCallToBoundFunction  (  node  )  ;  }  }  return  result  ;  case  Token  .  RETURN:  return  tryReduceReturn  (  node  )  ;  case  Token  .  COMMA:  return  trySplitComma  (  node  )  ;  case  Token  .  NAME:  return  tryReplaceUndefined  (  node  )  ;  case  Token  .  ARRAYLIT:  return  tryMinimizeArrayLiteral  (  node  )  ;  [BUGGY]  default:  return  node  ;  //Nothing  changed  }  }  	Closure_173_PeepholeSubstituteAlternateSyntax_2_1	102	0	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
762	private  Node  tryRotateAssociativeOperator(Node  n)  {  if  (!late)  {  return  n;  }  Preconditions.checkArgument(NodeUtil.isAssociative(n.getType()));  Node  rhs  =  n.getLastChild();  if  (n.getType()  ==  rhs.getType())  {  Node  parent  =  n.getParent();  Node  first  =  n.getFirstChild().detachFromParent();  Node  second  =  rhs.getFirstChild().detachFromParent();  Node  third  =  rhs.getLastChild().detachFromParent();  Node  newLhs  =  new  Node(n.getType(),  first,  second)  .copyInformationFrom(n);  Node  newRoot  =  new  Node(rhs.getType(),  newLhs,  third)  .copyInformationFrom(rhs);  parent.replaceChild(n,  newRoot);  reportCodeChange();  return  newRoot;  }  return  n;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<var  a  ,  b  ,  c  ;  a||[  (  b||c  )  ;  a*  (  b*c  )  ;  a|  (  b|c  )  ]>  but  was:<var  a  ,  b  ,  c  ;  a||[b||c  ;  a*b*c  ;  a|b|c]>  assertEquals  ( "\ "f\ "  ;  \n\ "g\ "  ;  \n "  ,  result  )  ;  [CLASS]  [CONTEXT]  	Closure_173_PeepholeSubstituteAlternateSyntax_2_2	108	0	src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java
763	int  startErrorCount  =  compiler.getErrorManager().getErrorCount();  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  a  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  30  expected:<0>  but  was:<1>  [METHOD]  parse  [TYPE]  void  [PARAMETER]  AbstractCompiler  compiler  [CLASS]  JsAst  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  ParseResult  result  [TYPE]  Node  root  [TYPE]  InputId  inputId  [TYPE]  SourceFile  sourceFile  [TYPE]  String  fileName  [TYPE]  IOException  e  [TYPE]  Logger  logger_  [TYPE]  long  serialVersionUID  [CONTEXT]  private  void  parse  (  AbstractCompiler  compiler  )  {  [BUGGY]  try  {  ParserRunner  .  ParseResult  result  =  ParserRunner  .  parse  (  sourceFile  ,  sourceFile  .  getCode  (  )  ,  compiler  .  getParserConfig  (  )  ,  compiler  .  getDefaultErrorReporter  (  )  ,  logger_  )  ;  root  =  result  .  ast  ;  compiler  .  setOldParseTree  (  sourceFile  .  getName  (  )  ,  result  .  oldAst  )  ;  }  catch  (  IOException  e  )  {  compiler  .  report  (  JSError  .  make  (  AbstractCompiler  .  READ_ERROR  ,  sourceFile  .  getName  (  )  )  )  ;  }  if  (  root  =  =  null  ||  compiler  .  hasHaltingErrors  (  )  )  {  root  =  IR  .  script  (  )  ;  }  else  {  compiler  .  prepareAst  (  root  )  ;  }  root  .  setStaticSourceFile  (  sourceFile  )  ;  }  	Closure_174_JsAst_3_1	82	0	src/com/google/javascript/jscomp/JsAst.java
764	if  (root  ==  null  ||  	[BUGGY]  if  (  root  =  =  null  ||  compiler  .  hasHaltingErrors  (  )  )  {  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  a  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  30  expected:<0>  but  was:<1>  [METHOD]  parse  [TYPE]  void  [PARAMETER]  AbstractCompiler  compiler  [CLASS]  JsAst  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  ParseResult  result  [TYPE]  Node  root  [TYPE]  InputId  inputId  [TYPE]  SourceFile  sourceFile  [TYPE]  String  fileName  [TYPE]  IOException  e  [TYPE]  Logger  logger_  [TYPE]  long  serialVersionUID  [CONTEXT]  private  void  parse  (  AbstractCompiler  compiler  )  {  try  {  ParserRunner  .  ParseResult  result  =  ParserRunner  .  parse  (  sourceFile  ,  sourceFile  .  getCode  (  )  ,  compiler  .  getParserConfig  (  )  ,  compiler  .  getDefaultErrorReporter  (  )  ,  logger_  )  ;  root  =  result  .  ast  ;  compiler  .  setOldParseTree  (  sourceFile  .  getName  (  )  ,  result  .  oldAst  )  ;  }  catch  (  IOException  e  )  {  compiler  .  report  (  JSError  .  make  (  AbstractCompiler  .  READ_ERROR  ,  sourceFile  .  getName  (  )  )  )  ;  }  [BUGGY]  if  (  root  =  =  null  ||  compiler  .  hasHaltingErrors  (  )  )  {  root  =  IR  .  script  (  )  ;  }  else  {  compiler  .  prepareAst  (  root  )  ;  }  root  .  setStaticSourceFile  (  sourceFile  )  ;  }  	Closure_174_JsAst_3_2	95	1	src/com/google/javascript/jscomp/JsAst.java
765	(compiler.getErrorManager().getErrorCount()  >  startErrorCount  &&  !compiler.isIdeMode()))  {  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  a  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  30  expected:<0>  but  was:<1>  [METHOD]  parse  [TYPE]  void  [PARAMETER]  AbstractCompiler  compiler  [CLASS]  JsAst  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  false  true  [TYPE]  ParseResult  result  [TYPE]  Node  root  [TYPE]  InputId  inputId  [TYPE]  SourceFile  sourceFile  [TYPE]  String  fileName  [TYPE]  IOException  e  [TYPE]  Logger  logger_  [TYPE]  long  serialVersionUID  [CONTEXT]  private  void  parse  (  AbstractCompiler  compiler  )  {  try  {  ParserRunner  .  ParseResult  result  =  ParserRunner  .  parse  (  sourceFile  ,  sourceFile  .  getCode  (  )  ,  compiler  .  getParserConfig  (  )  ,  compiler  .  getDefaultErrorReporter  (  )  ,  logger_  )  ;  root  =  result  .  ast  ;  compiler  .  setOldParseTree  (  sourceFile  .  getName  (  )  ,  result  .  oldAst  )  ;  }  catch  (  IOException  e  )  {  compiler  .  report  (  JSError  .  make  (  AbstractCompiler  .  READ_ERROR  ,  sourceFile  .  getName  (  )  )  )  ;  }  if  (  root  =  =  null  ||  compiler  .  hasHaltingErrors  (  )  )  {  [BUGGY]  root  =  IR  .  script  (  )  ;  }  else  {  compiler  .  prepareAst  (  root  )  ;  }  root  .  setStaticSourceFile  (  sourceFile  )  ;  }  	Closure_174_JsAst_3_3	99	0	src/com/google/javascript/jscomp/JsAst.java
766	}  else  if  (value  !=  null)  {  }  else  {  result  =  IR.exprResult(nameNode);  result.getFirstChild().setJSDocInfo(info);  	[BUGGY]  }  else  {  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  a  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  30  expected:<0>  but  was:<1>  [METHOD]  newQualifiedNameNodeDeclaration  [TYPE]  Node  [PARAMETER]  CodingConvention  convention  String  name  Node  value  JSDocInfo  info  [CLASS]  NodeUtil  [TYPE]  Set  BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS  CONSTRUCTORS_WITHOUT_SIDE_EFFECTS  OBJECT_METHODS_WITHOUT_SIDEEFFECTS  REGEXP_METHODS  STRING_REGEXP_METHODS  [TYPE]  Node  nameNode  result  value  [TYPE]  String  JSC_PROPERTY_NAME_FN  name  [TYPE]  JSDocInfo  info  [TYPE]  long  MAX_POSITIVE_INTEGER_NUMBER  [TYPE]  int  type  [TYPE]  Predicate  IMMUTABLE_PREDICATE  MATCH_NOT_FUNCTION  [TYPE]  BooleanResultPredicate  BOOLEAN_RESULT_PREDICATE  [TYPE]  NumbericResultPredicate  NUMBERIC_RESULT_PREDICATE  [TYPE]  boolean  false  true  [TYPE]  MayBeStringResultPredicate  MAY_BE_STRING_PREDICATE  [TYPE]  CodingConvention  convention  [TYPE]  char  LARGEST_BASIC_LATIN  [TYPE]  Map  vars  [CONTEXT]  public  static  Node  newQualifiedNameNodeDeclaration  (  CodingConvention  convention  ,  String  name  ,  Node  value  ,  JSDocInfo  info  )  {  Node  result  ;  Node  nameNode  =  newQualifiedNameNode  (  convention  ,  name  )  ;  if  (  nameNode  .  isName  (  )  )  {  result  =  IR  .  var  (  nameNode  ,  value  )  ;  result  .  setJSDocInfo  (  info  )  ;  [BUGGY]  }  else  {  result  =  IR  .  exprResult  (  IR  .  assign  (  nameNode  ,  value  )  )  ;  result  .  getFirstChild  (  )  .  setJSDocInfo  (  info  )  ;  }  return  result  ;  }  	Closure_174_NodeUtil_1_1	2367	1	src/com/google/javascript/jscomp/NodeUtil.java
767	boolean  isVar  =  parent.isVar();  if  (isVar  &&  n.getFirstChild()  !=  null  &&  n.getFirstChild().isQualifiedName())  {  	[BUGGY]  boolean  isVarAssign  =  parent  .  isVar  (  )  &&  n  .  hasChildren  (  )  ;  if  (  isVarAssign  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  a  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  30  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVarAssign  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  n  newDecl  parent  value  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  private  void  findAliases  (  NodeTraversal  t  )  {  Scope  scope  =  t  .  getScope  (  )  ;  for  (  Var  v  :  scope  .  getVarIterable  (  )  )  {  Node  n  =  v  .  getNode  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  [BUGGY]  boolean  isVarAssign  =  parent  .  isVar  (  )  &&  n  .  hasChildren  (  )  ;  if  (  isVarAssign  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  recordAlias  (  v  )  ;  }  else  if  (  v  .  isBleedingFunction  (  )  )  {  	Closure_174_ScopedAliases_4_1	356	2	src/com/google/javascript/jscomp/ScopedAliases.java
768	}  else  if  (isVar)  {  Node  value  =  n.hasChildren()  ?  v.getInitialValue().detachFromParent()  :  null;  	[BUGGY]  }  else  if  (  isVarAssign  )  {  Node  value  =  v  .  getInitialValue  (  )  .  detachFromParent  (  )  ;  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  a  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  30  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVarAssign  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  n  newDecl  parent  value  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  private  void  findAliases  (  NodeTraversal  t  )  {  Scope  scope  =  t  .  getScope  (  )  ;  for  (  Var  v  :  scope  .  getVarIterable  (  )  )  {  Node  n  =  v  .  getNode  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  boolean  isVarAssign  =  parent  .  isVar  (  )  &&  n  .  hasChildren  (  )  ;  if  (  isVarAssign  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  recordAlias  (  v  )  ;  }  else  if  (  v  .  isBleedingFunction  (  )  )  {  }  else  if  (  parent  .  getType  (  )  =  =  Token  .  LP  )  {  [BUGGY]  }  else  if  (  isVarAssign  )  {  Node  value  =  v  .  getInitialValue  (  )  .  detachFromParent  (  )  ;  String  name  =  n  .  getString  (  )  ;  int  nameCount  =  scopedAliasNames  .  count  (  name  )  ;  scopedAliasNames  .  add  (  name  )  ;  String  globalName  =  	Closure_174_ScopedAliases_4_2	365	2	src/com/google/javascript/jscomp/ScopedAliases.java
769	if  (value  !=  null  ||  v.getJSDocInfo()  !=  null)  {  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  a  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  30  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVarAssign  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  n  newDecl  parent  value  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  Scope  scope  =  t  .  getScope  (  )  ;  for  (  Var  v  :  scope  .  getVarIterable  (  )  )  {  Node  n  =  v  .  getNode  (  )  ;  Node  parent  =  n  .  getParent  (  )  ;  boolean  isVarAssign  =  parent  .  isVar  (  )  &&  n  .  hasChildren  (  )  ;  if  (  isVarAssign  &&  n  .  getFirstChild  (  )  .  isQualifiedName  (  )  )  {  recordAlias  (  v  )  ;  }  else  if  (  v  .  isBleedingFunction  (  )  )  {  }  else  if  (  parent  .  getType  (  )  =  =  Token  .  LP  )  {  }  else  if  (  isVarAssign  )  {  Node  value  =  v  .  getInitialValue  (  )  .  detachFromParent  (  )  ;  String  name  =  n  .  getString  (  )  ;  int  nameCount  =  scopedAliasNames  .  count  (  name  )  ;  scopedAliasNames  .  add  (  name  )  ;  String  globalName  = "$jscomp  .  scope  . "  +  name  +  (  nameCount  =  =  0  ? " "  :  ( "$ "  +  nameCount  )  )  ;  compiler  .  ensureLibraryInjected  ( "base "  )  ;  [BUGGY]  Node  newDecl  =  NodeUtil  .  newQualifiedNameNodeDeclaration  (  compiler  .  getCodingConvention  (  )  ,  globalName  ,  value  ,  v  .  getJSDocInfo  (  )  )  .  useSourceInfoIfMissingFromForTree  (  n  )  ;  	Closure_174_ScopedAliases_4_3	377	0	src/com/google/javascript/jscomp/ScopedAliases.java
770	}  	[BUGGY]  [FE]  AssertionFailedError:  Unexpected  error  (  s  )  :  JSC_GOOG_SCOPE_NON_ALIAS_LOCAL  The  local  variable  a  is  in  a  googscope  and  is  not  an  alias  at  testcode  line  1  :  30  expected:<0>  but  was:<1>  [METHOD]  findAliases  [TYPE]  void  [PARAMETER]  NodeTraversal  t  [CLASS]  Traversal  [TYPE]  AliasTransformation  transformation  [TYPE]  Set  forbiddenLocals  [TYPE]  boolean  false  hasErrors  hasNamespaceShadows  isVarAssign  true  [TYPE]  Scope  scope  [TYPE]  NodeTraversal  t  [TYPE]  Var  v  [TYPE]  Node  n  newDecl  parent  value  [TYPE]  List  aliasDefinitionsInOrder  aliasUsages  scopeCalls  [TYPE]  String  globalName  name  [TYPE]  Map  aliases  [TYPE]  int  nameCount  [CONTEXT]  }  else  if  (  parent  .  getType  (  )  =  =  Token  .  LP  )  {  }  else  if  (  isVarAssign  )  {  Node  value  =  v  .  getInitialValue  (  )  .  detachFromParent  (  )  ;  String  name  =  n  .  getString  (  )  ;  int  nameCount  =  scopedAliasNames  .  count  (  name  )  ;  scopedAliasNames  .  add  (  name  )  ;  String  globalName  = "$jscomp  .  scope  . "  +  name  +  (  nameCount  =  =  0  ? " "  :  ( "$ "  +  nameCount  )  )  ;  compiler  .  ensureLibraryInjected  ( "base "  )  ;  Node  newDecl  =  NodeUtil  .  newQualifiedNameNodeDeclaration  (  compiler  .  getCodingConvention  (  )  ,  globalName  ,  value  ,  v  .  getJSDocInfo  (  )  )  .  useSourceInfoIfMissingFromForTree  (  n  )  ;  NodeUtil  .  setDebugInformation  (  newDecl  .  getFirstChild  (  )  .  getFirstChild  (  )  ,  n  ,  name  )  ;  parent  .  getParent  (  )  .  addChildBefore  (  newDecl  ,  parent  )  ;  [BUGGY]  v  .  getNameNode  (  )  .  addChildToFront  (  NodeUtil  .  newQualifiedNameNode  (  compiler  .  getCodingConvention  (  )  ,  globalName  ,  n  ,  name  )  )  ;  	Closure_174_ScopedAliases_4_4	386	0	src/com/google/javascript/jscomp/ScopedAliases.java
771	private  final  Supplier<String>  throwawayNameSupplier  =  new  Supplier<String>()  {  private  int  nextId  =  0;  @Override  public  String  get()  {  return  String.valueOf(nextId++);  }  };  	[BUGGY]  [FE]  AssertionFailedError:  expected:<NO>  but  was:<YES>  [CLASS]  [CONTEXT]  	Closure_175_FunctionInjector_5_1	46	0	src/com/google/javascript/jscomp/FunctionInjector.java
772	return  canInlineReferenceDirectly(callNode,  fnNode,  needAliases);  	[BUGGY]  return  canInlineReferenceDirectly  (  callNode  ,  fnNode  )  ;  [FE]  AssertionFailedError:  expected:<NO>  but  was:<YES>  [METHOD]  canInlineReferenceToFunction  [TYPE]  FunctionInjector$CanInlineResult  [PARAMETER]  NodeTraversal  t  Node  callNode  Node  fnNode  String>  needAliases  InliningMode  mode  boolean  referencesThis  boolean  containsFunctions  [CLASS]  FunctionInjector  [TYPE]  CanInlineResult  AFTER_PREPARATION  NO  YES  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  allowDecomposition  assumeMinimumCapture  assumeStrictThis  containsFunctions  false  referencesThis  true  [TYPE]  Set  knownConstants  needAliases  [TYPE]  NodeTraversal  t  [TYPE]  InliningMode  BLOCK  DIRECT  mode  [TYPE]  CallSiteType  DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node  callNode  fnNode  [TYPE]  JSModule  module  [TYPE]  Supplier  safeNameIdSupplier  [TYPE]  int  COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [CONTEXT]  if  (  containsFunctions  )  {  if  (  !assumeMinimumCapture  &&  !t  .  inGlobalScope  (  )  )  {  return  CanInlineResult  .  NO  ;  }  else  if  (  NodeUtil  .  isWithinLoop  (  callNode  )  )  {  return  CanInlineResult  .  NO  ;  }  }  if  (  referencesThis  &&  !NodeUtil  .  isFunctionObjectCall  (  callNode  )  )  {  return  CanInlineResult  .  NO  ;  }  if  (  mode  =  =  InliningMode  .  DIRECT  )  {  [BUGGY]  return  canInlineReferenceDirectly  (  callNode  ,  fnNode  )  ;  }  else  {  return  canInlineReferenceAsStatementBlock  (  t  ,  callNode  ,  fnNode  ,  needAliases  )  ;  }  }  	Closure_175_FunctionInjector_5_2	208	1	src/com/google/javascript/jscomp/FunctionInjector.java
773	Node  callNode,  Node  fnNode,  Set<String>  namesToAlias)  {  	[BUGGY]  Node  callNode  ,  Node  fnNode  )  {  [FE]  AssertionFailedError:  expected:<NO>  but  was:<YES>  [METHOD]  canInlineReferenceDirectly  [TYPE]  FunctionInjector$CanInlineResult  [PARAMETER]  Node  callNode  Node  fnNode  [CLASS]  FunctionInjector  [TYPE]  CanInlineResult  AFTER_PREPARATION  NO  YES  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  allowDecomposition  assumeMinimumCapture  assumeStrictThis  false  true  [TYPE]  Set  knownConstants  [TYPE]  InliningMode  BLOCK  DIRECT  mode  [TYPE]  CallSiteType  DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node  block  cArg  callNode  fnNode  fnParam  [TYPE]  JSModule  module  [TYPE]  Supplier  safeNameIdSupplier  [TYPE]  int  COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [CONTEXT]  private  CanInlineResult  canInlineReferenceDirectly  (  [BUGGY]  Node  callNode  ,  Node  fnNode  )  {  if  (  !isDirectCallNodeReplacementPossible  (  fnNode  )  )  {  return  CanInlineResult  .  NO  ;  }  Node  block  =  fnNode  .  getLastChild  (  )  ;  	Closure_175_FunctionInjector_5_3	690	1	src/com/google/javascript/jscomp/FunctionInjector.java
774		[BUGGY]  Node  block  =  fnNode  .  getLastChild  (  )  ;  [FE]  AssertionFailedError:  expected:<NO>  but  was:<YES>  [METHOD]  canInlineReferenceDirectly  [TYPE]  FunctionInjector$CanInlineResult  [PARAMETER]  Node  callNode  Node  fnNode  [CLASS]  FunctionInjector  [TYPE]  CanInlineResult  AFTER_PREPARATION  NO  YES  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  allowDecomposition  assumeMinimumCapture  assumeStrictThis  false  true  [TYPE]  Set  knownConstants  [TYPE]  InliningMode  BLOCK  DIRECT  mode  [TYPE]  CallSiteType  DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node  block  cArg  callNode  fnNode  fnParam  [TYPE]  JSModule  module  [TYPE]  Supplier  safeNameIdSupplier  [TYPE]  int  COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [CONTEXT]  private  CanInlineResult  canInlineReferenceDirectly  (  Node  callNode  ,  Node  fnNode  )  {  if  (  !isDirectCallNodeReplacementPossible  (  fnNode  )  )  {  return  CanInlineResult  .  NO  ;  }  [BUGGY]  Node  block  =  fnNode  .  getLastChild  (  )  ;  Node  cArg  =  callNode  .  getFirstChild  (  )  .  getNext  (  )  ;  	Closure_175_FunctionInjector_5_4	695	1	src/com/google/javascript/jscomp/FunctionInjector.java
775	Map<String,  Node>  args  =  FunctionArgumentInjector.getFunctionCallParameterMap(  fnNode,  callNode,  this.throwawayNameSupplier);  boolean  hasArgs  =  !args.isEmpty();  if  (hasArgs)  {  Set<String>  allNamesToAlias  =  Sets.newHashSet(namesToAlias);  FunctionArgumentInjector.maybeAddTempsForCallArguments(  fnNode,  args,  allNamesToAlias,  compiler.getCodingConvention());  if  (!allNamesToAlias.isEmpty())  {  	[BUGGY]  Node  fnParam  =  NodeUtil  .  getFunctionParameters  (  fnNode  )  .  getFirstChild  (  )  ;  while  (  cArg  !  =  null  ||  fnParam  !  =  null  )  {  if  (  fnParam  !  =  null  )  {  if  (  cArg  !  =  null  )  {  if  (  NodeUtil  .  mayEffectMutableState  (  cArg  ,  compiler  )  &&  NodeUtil  .  getNameReferenceCount  (  block  ,  fnParam  .  getString  (  )  )  >  1  )  {  return  CanInlineResult  .  NO  ;  }  }  fnParam  =  fnParam  .  getNext  (  )  ;  }  if  (  cArg  !  =  null  )  {  if  (  NodeUtil  .  mayHaveSideEffects  (  cArg  ,  compiler  )  )  {  }  cArg  =  cArg  .  getNext  (  )  ;  [FE]  AssertionFailedError:  expected:<NO>  but  was:<YES>  [METHOD]  canInlineReferenceDirectly  [TYPE]  FunctionInjector$CanInlineResult  [PARAMETER]  Node  callNode  Node  fnNode  [CLASS]  FunctionInjector  [TYPE]  CanInlineResult  AFTER_PREPARATION  NO  YES  [TYPE]  AbstractCompiler  compiler  [TYPE]  boolean  allowDecomposition  assumeMinimumCapture  assumeStrictThis  false  true  [TYPE]  Set  knownConstants  [TYPE]  InliningMode  BLOCK  DIRECT  mode  [TYPE]  CallSiteType  DECOMPOSABLE_EXPRESSION  EXPRESSION  SIMPLE_ASSIGNMENT  SIMPLE_CALL  UNSUPPORTED  VAR_DECL_SIMPLE_ASSIGNMENT  [TYPE]  Node  block  cArg  callNode  fnNode  fnParam  [TYPE]  JSModule  module  [TYPE]  Supplier  safeNameIdSupplier  [TYPE]  int  COMMA_COST  NAME_COST_ESTIMATE  PAREN_COST  [CONTEXT]  Node  callNode  ,  Node  fnNode  )  {  if  (  !isDirectCallNodeReplacementPossible  (  fnNode  )  )  {  return  CanInlineResult  .  NO  ;  }  Node  block  =  fnNode  .  getLastChild  (  )  ;  Node  cArg  =  callNode  .  getFirstChild  (  )  .  getNext  (  )  ;  if  (  !callNode  .  getFirstChild  (  )  .  isName  (  )  )  {  if  (  NodeUtil  .  isFunctionObjectCall  (  callNode  )  )  {  if  (  cArg  =  =  null  ||  !cArg  .  isThis  (  )  )  {  return  CanInlineResult  .  NO  ;  }  cArg  =  cArg  .  getNext  (  )  ;  }  else  {  Preconditions  .  checkState  (  !NodeUtil  .  isFunctionObjectApply  (  callNode  )  )  ;  }  }  [BUGGY]  Node  fnParam  =  NodeUtil  .  getFunctionParameters  (  fnNode  )  .  getFirstChild  (  )  ;  while  (  cArg  !  =  null  ||  fnParam  !  =  null  )  {  if  (  fnParam  !  =  null  )  {  if  (  cArg  !  =  null  )  {  if  (  NodeUtil  .  mayEffectMutableState  (  cArg  ,  compiler  )  &&  NodeUtil  .  getNameReferenceCount  (  	Closure_175_FunctionInjector_5_5	715	16	src/com/google/javascript/jscomp/FunctionInjector.java
776	JSType  varType  =  var  ==  null  ?  null  :  var.getType();  boolean  isVarDeclaration  =  left.hasChildren()  &&  varType  !=  null  &&  !var.isTypeInferred();  	[BUGGY]  boolean  isVarDeclaration  =  left  .  hasChildren  (  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  updateScopeForTypeChange  [TYPE]  void  [PARAMETER]  FlowScope  scope  Node  left  JSType  leftType  JSType  resultType  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  leftType  oldType  resultType  [TYPE]  Var  var  [TYPE]  Node  left  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  qualifiedName  varName  [TYPE]  ObjectType  unknownType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  isVarDeclaration  isVarTypeBetter  madeChanges  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  [TYPE]  Map  assertionFunctionsMap  replacements  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  void  updateScopeForTypeChange  (  FlowScope  scope  ,  Node  left  ,  JSType  leftType  ,  JSType  resultType  )  {  Preconditions  .  checkNotNull  (  resultType  )  ;  switch  (  left  .  getType  (  )  )  {  case  Token  .  NAME:  String  varName  =  left  .  getString  (  )  ;  Var  var  =  syntacticScope  .  getVar  (  varName  )  ;  [BUGGY]  boolean  isVarDeclaration  =  left  .  hasChildren  (  )  ;  	Closure_176_TypeInference_3_1	530	1	src/com/google/javascript/jscomp/TypeInference.java
777	boolean  isVarTypeBetter  =  isVarDeclaration  &&  !resultType.isNullType()  &&  !resultType.isVoidType();  	[BUGGY]  boolean  isVarTypeBetter  =  !isVarDeclaration  ||  var  =  =  null  ||  var  .  isTypeInferred  (  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  updateScopeForTypeChange  [TYPE]  void  [PARAMETER]  FlowScope  scope  Node  left  JSType  leftType  JSType  resultType  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  leftType  oldType  resultType  [TYPE]  Var  var  [TYPE]  Node  left  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  qualifiedName  varName  [TYPE]  ObjectType  unknownType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  isVarDeclaration  isVarTypeBetter  madeChanges  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  [TYPE]  Map  assertionFunctionsMap  replacements  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  private  void  updateScopeForTypeChange  (  FlowScope  scope  ,  Node  left  ,  JSType  leftType  ,  JSType  resultType  )  {  Preconditions  .  checkNotNull  (  resultType  )  ;  switch  (  left  .  getType  (  )  )  {  case  Token  .  NAME:  String  varName  =  left  .  getString  (  )  ;  Var  var  =  syntacticScope  .  getVar  (  varName  )  ;  boolean  isVarDeclaration  =  left  .  hasChildren  (  )  ;  [BUGGY]  boolean  isVarTypeBetter  =  !isVarDeclaration  ||  var  =  =  null  ||  var  .  isTypeInferred  (  )  ;  	Closure_176_TypeInference_3_2	548	1	src/com/google/javascript/jscomp/TypeInference.java
778	redeclareSimpleVar(scope,  left,  varType);  }  else  {  left.setJSType(resultType);  	[BUGGY]  left  .  setJSType  (  isVarDeclaration  ||  leftType  =  =  null  ?  resultType  :  null  )  ;  [FE]  AssertionFailedError:  expected  a  warning  [METHOD]  updateScopeForTypeChange  [TYPE]  void  [PARAMETER]  FlowScope  scope  Node  left  JSType  leftType  JSType  resultType  [CLASS]  TypeInference  [TYPE]  ReverseAbstractInterpreter  reverseInterpreter  [TYPE]  JSType  leftType  oldType  resultType  [TYPE]  Var  var  [TYPE]  Node  left  [TYPE]  BooleanLiteralSet  booleanValues  toBooleanOutcomes  [TYPE]  String  qualifiedName  varName  [TYPE]  ObjectType  unknownType  [TYPE]  AbstractCompiler  compiler  [TYPE]  JSTypeRegistry  registry  [TYPE]  boolean  false  isVarDeclaration  isVarTypeBetter  madeChanges  true  [TYPE]  Scope  syntacticScope  [TYPE]  DiagnosticType  FUNCTION_LITERAL_UNDEFINED_THIS  [TYPE]  Map  assertionFunctionsMap  replacements  [TYPE]  FlowScope  bottomScope  functionScope  joinedScope  leftScope  rightScope  scope  [CONTEXT]  boolean  isVarTypeBetter  =  !isVarDeclaration  ||  var  =  =  null  ||  var  .  isTypeInferred  (  )  ;  if  (  isVarTypeBetter  )  {  [BUGGY]  redeclareSimpleVar  (  scope  ,  left  ,  resultType  )  ;  }  left  .  setJSType  (  isVarDeclaration  ||  leftType  =  =  null  ?  resultType  :  null  )  ;  if  (  var  !  =  null  &&  var  .  isTypeInferred  (  )  )  {  	Closure_176_TypeInference_3_3	562	2	src/com/google/javascript/jscomp/TypeInference.java
779	tokens.add(token);  break;  	[BUGGY]  tokens  .  add  ( "- "  +  ch  )  ;  [FE]  commonscliUnrecognizedOptionException:  Unrecognized  option:  -o  assertEquals  ( "-something "  ,  commandLine  .  getOptionValue  (  't'  )  )  ;  [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  ArrayList  tokens  [TYPE]  Options  options  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  hasOption  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  tokenLength  [CONTEXT]  int  tokenLength  =  token  .  length  (  )  ;  for  (  int  i  =  1  ;  i  <  tokenLength  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ;  if  (  hasOption  )  {  tokens  .  add  ( "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =  (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;  break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  }  else  {  [BUGGY]  tokens  .  add  ( "- "  +  ch  )  ;  }  }  }  }  	Cli_2_PosixParser_1_1	305	1	src/java/org/apache/commons/cli/PosixParser.java
781		[BUGGY]  [FE]  AssertionFailedError:  number  flag  n  expected:<45>  but  was:<45>  //  assertEquals  ( "number  flag  t "  ,  new  java  .  util  .  Date  (  1023400137276L  )  ,  line  .  getOptionObject  (  'z'  )  )  ;  [CLASS]  [CONTEXT]  	Cli_3_TypeHandler_2_1	25	0	src/java/org/apache/commons/cli/TypeHandler.java
782	if(  str  !=  null  )  {     if(  str.indexOf('.')  !=  -1  )    {  return  Double.valueOf(str);  }  else  {  return  Long.valueOf(str);  }  }  	[BUGGY]  return  NumberUtils  .  createNumber  (  str  )  ;  [FE]  AssertionFailedError:  number  flag  n  expected:<45>  but  was:<45>  //  assertEquals  ( "number  flag  t "  ,  new  java  .  util  .  Date  (  1023400137276L  )  ,  line  .  getOptionObject  (  'z'  )  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  TypeHandler  [TYPE]  boolean  false  true  [TYPE]  NumberFormatException  nfe  [TYPE]  String  str  [CONTEXT]  public  static  Number  createNumber  (  String  str  )  {  try  {  [BUGGY]  return  NumberUtils  .  createNumber  (  str  )  ;  }  catch  (  NumberFormatException  nfe  )  {  System  .  err  .  println  (  nfe  .  getMessage  (  )  )  ;  }  return  null  ;  }  	Cli_3_TypeHandler_2_2	162	1	src/java/org/apache/commons/cli/TypeHandler.java
783	StringBuffer  buff  =  new  StringBuffer( "Missing  required  option ");  buff.append(requiredOptions.size()  ==  1  ? " "  : "s ");  buff.append( ": ");  	[BUGGY]  StringBuffer  buff  =  new  StringBuffer  (  )  ;  [FE]  ComparisonFailure:  expected:<[Missing  required  options:  ]fx>  but  was:<[]fx>  assertEquals  ( "Missing  required  options:  fx "  ,  e  .  getMessage  (  )  )  ;  [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser  [TYPE]  Iterator  iter  [TYPE]  Options  options  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  [CONTEXT]  private  void  checkRequiredOptions  (  )  throws  MissingOptionException  {  if  (  requiredOptions  .  size  (  )  >  0  )  {  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  [BUGGY]  StringBuffer  buff  =  new  StringBuffer  (  )  ;  while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }  	Cli_4_Parser_1_1	298	1	src/java/org/apache/commons/cli/Parser.java
784	if  (str  ==  null)  {  return  null;  }  	[BUGGY]  [FE]  NullPointerException  assertNull  (  Util  .  stripLeadingHyphens  (  null  )  )  ;  [METHOD]  stripLeadingHyphens  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util  [TYPE]  boolean  false  true  [TYPE]  String  str  [CONTEXT]  static  String  stripLeadingHyphens  (  String  str  )  {  [BUGGY]  if  (  str  .  startsWith  ( "-- "  )  )  {  return  str  .  substring  (  2  ,  str  .  length  (  )  )  ;  }  else  if  (  str  .  startsWith  ( "- "  )  )  {  return  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  return  str  ;  }  	Cli_5_Util_1_1	36	0	src/java/org/apache/commons/cli/Util.java
785		[BUGGY]  [FE]  ComparisonFailure:  expected:<[[-h]]>  but  was:<[-c  <arg>]>  assertFalse  (  i  .  hasNext  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_7_PatternBuilder_2_1	19	0	src/java/org/apache/commons/cli2/builder/PatternBuilder.java
786	private  final  Set  options  =  new  LinkedHashSet();  	[BUGGY]  private  final  Set  options  =  new  HashSet  (  )  ;  [FE]  ComparisonFailure:  expected:<[[-h]]>  but  was:<[-c  <arg>]>  assertFalse  (  i  .  hasNext  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_7_PatternBuilder_2_2	67	1	src/java/org/apache/commons/cli2/builder/PatternBuilder.java
787	pos  =  findWrapPos(text,  width,  0);  	[BUGGY]  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;  [FE]  ComparisonFailure:  single  line  padded  text  2  expected:<TE[-DATE]  where  DATE[  assertEquals  (   "multi-line  padded  text "  ,  expected  ,  sb  .  toString  (  )  )  ;  [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  padding  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  nextLineTabStop  pos  width  [CONTEXT]  protected  StringBuffer  renderWrappedText  (  StringBuffer  sb  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;  if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;  return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;    final  String  padding  =  createPadding  (  nextLineTabStop  )  ;  while  (  true  )  {  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  [BUGGY]  pos  =  findWrapPos  (  text  ,  width  ,  nextLineTabStop  )  ;  if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;  	Cli_8_HelpFormatter_1_1	812	1	src/java/org/apache/commons/cli/HelpFormatter.java
788	buff.append( ",   ");  throw  new  MissingOptionException(buff.substring(0,  buff.length()  -  2));  	[BUGGY]  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  [FE]  ComparisonFailure:  expected:<  required  options:  f[  ,  ]x>  but  was:<  required  options:  f[]x>  assertEquals  (   "Missing  required  options:  f  ,  x "  ,  e  .  getMessage  (  )  )  ;  [METHOD]  checkRequiredOptions  [TYPE]  void  [PARAMETER]  [CLASS]  Parser  [TYPE]  Iterator  iter  [TYPE]  Options  options  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  [TYPE]  StringBuffer  buff  [TYPE]  boolean  false  true  [CONTEXT]  protected  void  checkRequiredOptions  (  )  throws  MissingOptionException  {    if  (  getRequiredOptions  (  )  .  size  (  )  >  0  )  {  Iterator  iter  =  getRequiredOptions  (  )  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (   "Missing  required  option "  )  ;  buff  .  append  (  getRequiredOptions  (  )  .  size  (  )  =  =  1  ?   " "  :   "s "  )  ;  buff  .  append  (   ":   "  )  ;    while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ;  [BUGGY]  }  throw  new  MissingOptionException  (  buff  .  toString  (  )  )  ;  }  }  	Cli_9_Parser_1_1	320	1	src/java/org/apache/commons/cli/Parser.java
789		[BUGGY]  [FE]  AssertionFailedError:  MissingOptionException  not  thrown  [CLASS]  [CONTEXT]  	Cli_10_Parser_2_1	19	0	src/java/org/apache/commons/cli/Parser.java
790	this.requiredOptions  =  new  ArrayList(options.getRequiredOptions());  	[BUGGY]  this  .  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  [FE]  AssertionFailedError:  MissingOptionException  not  thrown  [METHOD]  setOptions  [TYPE]  void  [PARAMETER]  Options  options  [CLASS]  Parser  [TYPE]  Options  options  [TYPE]  CommandLine  cmd  [TYPE]  List  requiredOptions  [TYPE]  boolean  false  true  [CONTEXT]  protected  void  setOptions  (  final  Options  options  )  {  this  .  options  =  options  ;  [BUGGY]  this  .  requiredOptions  =  options  .  getRequiredOptions  (  )  ;  }  	Cli_10_Parser_2_2	46	1	src/java/org/apache/commons/cli/Parser.java
791	if  (option.hasArg()  &&  option.hasArgName())  	[BUGGY]  if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !  =  null  )  )  [FE]  ComparisonFailure:  expected:<usage:  app  -f[]  assertEquals  (   "usage:  app  -f "  +  EOL  ,  out  .  toString  (  )  )  ;  [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  [TYPE]  Comparator  optionComparator  [CONTEXT]  private  static  void  appendOption  (  final  StringBuffer  buff  ,  final  Option  option  ,  final  boolean  required  )  {  if  (  !required  )  {  buff  .  append  (   "[ "  )  ;  }  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }  [BUGGY]  if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !  =  null  )  )  {  buff  .  append  (   "  < "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  if  (  !required  )  {  buff  .  append  (   "] "  )  ;  }  }  	Cli_11_HelpFormatter_1_1	632	1	src/java/org/apache/commons/cli/HelpFormatter.java
792	else  if  (options.hasOption(arg.substring(0,  2)))  {  	[BUGGY]  if  (  options  .  hasOption  (  arg  .  substring  (  0  ,  2  )  )  )  \n'  ,   "+          if  (  opt  .  indexOf  (  '  =  '  )  !  =  -1  &&  options  .  hasOption  (  opt  .  substring  (  0  ,  opt  .  indexOf  (  '  =  '  )  )  )  )  \n "  ,  '            {  [FE]  ComparisonFailure:  expected:<[]bar>  but  was:<[  =  ]bar>  assertEquals  (   "bar "  ,  cl  .  getOptionValue  (   "foo "  )  )  ;  [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  GnuParser  [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  List  tokens  [TYPE]  String[]  arguments  [TYPE]  String  arg  opt  [TYPE]  int  i  [CONTEXT]  boolean  eatTheRest  =  false  ;  for  (  int  i  =  0  ;  i  <  arguments  .  length  ;  i++  )  {  String  arg  =  arguments[i]  ;  if  (   "-- "  .  equals  (  arg  )  )  {  eatTheRest  =  true  ;  tokens  .  add  (   "-- "  )  ;  }  else  if  (   "- "  .  equals  (  arg  )  )  {  tokens  .  add  (   "- "  )  ;  }  else  if  (  arg  .  startsWith  (   "- "  )  )  {  String  opt  =  Util  .  stripLeadingHyphens  (  arg  )  ;  if  (  options  .  hasOption  (  opt  )  )  {  tokens  .  add  (  arg  )  ;  }  else  {  [BUGGY]  if  (  options  .  hasOption  (  arg  .  substring  (  0  ,  2  )  )  )  {    tokens  .  add  (  arg  .  substring  (  0  ,  2  )  )  ;  //  -D  tokens  .  add  (  arg  .  substring  (  2  )  )  ;  //  property  =  value  	Cli_12_GnuParser_1_1	81	1	src/java/org/apache/commons/cli/GnuParser.java
793	List  getUndefaultedValues(final  Option  option);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<Unexpected  [testfiletxt  while  processing  ]>  but  was:<Unexpected  [value   "testfiletxt "  found  while  processing  input]>  assertEquals  (   "Unexpected  testfile  .  txt  while  processing   "  ,  e  .  getMessage  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_13_WriteableCommandLine_1_1	47	0	src/java/org/apache/commons/cli2/WriteableCommandLine.java
794	public  List  getUndefaultedValues(Option  option)  {  List  valueList  =  (List)  values.get(option);  if  (valueList  ==  null)  {  valueList  =  Collections.EMPTY_LIST;  }    return  valueList;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<Unexpected  [testfiletxt  while  processing  ]>  but  was:<Unexpected  [value   "testfiletxt "  found  while  processing  input]>  assertEquals  (   "Unexpected  testfile  .  txt  while  processing   "  ,  e  .  getMessage  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_13_WriteableCommandLineImpl_1_1	132	0	src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java
795	int  argumentCount  =  commandLine.getUndefaultedValues(option).size();  	[BUGGY]  int  argumentCount  =  0  ;  [FE]  ComparisonFailure:  expected:<Unexpected  [testfiletxt  while  processing  ]>  but  was:<Unexpected  [value   "testfiletxt "  found  while  processing  input]>  assertEquals  (   "Unexpected  testfile  .  txt  while  processing   "  ,  e  .  getMessage  (  )  )  ;  [METHOD]  processValues  [TYPE]  void  [PARAMETER]  WriteableCommandLine  commandLine  ListIterator  arguments  Option  option  [CLASS]  ArgumentImpl  [TYPE]  StringTokenizer  values  [TYPE]  boolean  false  subsequentSplit  true  [TYPE]  char  DEFAULT_INITIAL_SEPARATOR  DEFAULT_SUBSEQUENT_SEPARATOR  NUL  initialSeparator  subsequentSeparator  [TYPE]  WriteableCommandLine  commandLine  [TYPE]  ResourceHelper  resources  [TYPE]  List  defaultValues  [TYPE]  Option  option  [TYPE]  String  DEFAULT_CONSUME_REMAINING  allValues  allValuesQuoted  consumeRemaining  description  name  token  [TYPE]  ListIterator  arguments  [TYPE]  int  argumentCount  maximum  minimum  [TYPE]  Validator  validator  [CONTEXT]  public  void  processValues  (  final  WriteableCommandLine  commandLine  ,  final  ListIterator  arguments  ,  final  Option  option  )  throws  OptionException  {  [BUGGY]  int  argumentCount  =  0  ;  while  (  arguments  .  hasNext  (  )  &&  (  argumentCount  <  maximum  )  )  {  final  String  allValuesQuoted  =  (  String  )  arguments  .  next  (  )  ;  final  String  allValues  =  stripBoundaryQuotes  (  allValuesQuoted  )  ;  	Cli_13_ArgumentImpl_1_1	144	1	src/java/org/apache/commons/cli2/option/ArgumentImpl.java
796		[BUGGY]  if  (  validate  )  {  option  .  validate  (  commandLine  )  ;  }  [FE]  ClassCastException:  javaioFile  cannot  be  cast  to  javalangString  assertEquals  (   "Wrong  file "  ,  new  File  (  fileName  )  ,  cl  .  getValue  (  fileNameOption  )  )  ;  [METHOD]  validate  [TYPE]  void  [PARAMETER]  WriteableCommandLine  commandLine  [CLASS]  GroupImpl  [TYPE]  Set  prefixes  [TYPE]  boolean  false  true  validate  [TYPE]  SortedMap  optionMap  [TYPE]  WriteableCommandLine  commandLine  [TYPE]  Iterator  i  [TYPE]  List  anonymous  options  [TYPE]  Option  option  unexpected  [TYPE]  String  description  name  [TYPE]  int  maximum  minimum  present  [CONTEXT]  public  void  validate  (  final  WriteableCommandLine  commandLine  )  throws  OptionException  {  int  present  =  0  ;    Option  unexpected  =  null  ;  for  (  final  Iterator  i  =  options  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  Option  option  =  (  Option  )  i  .  next  (  )  ;    boolean  validate  =  option  .  isRequired  (  )  ||  option  instanceof  Group  ;  [BUGGY]  if  (  validate  )  {  option  .  validate  (  commandLine  )  ;  }  if  (  commandLine  .  hasOption  (  option  )  )  {  	Cli_14_GroupImpl_2_1	250	3	src/java/org/apache/commons/cli2/option/GroupImpl.java
797	validate  =  true;  }  if  (validate)  {  	[BUGGY]  [FE]  ClassCastException:  javaioFile  cannot  be  cast  to  javalangString  assertEquals  (   "Wrong  file "  ,  new  File  (  fileName  )  ,  cl  .  getValue  (  fileNameOption  )  )  ;  [METHOD]  validate  [TYPE]  void  [PARAMETER]  WriteableCommandLine  commandLine  [CLASS]  GroupImpl  [TYPE]  Set  prefixes  [TYPE]  boolean  false  true  validate  [TYPE]  SortedMap  optionMap  [TYPE]  WriteableCommandLine  commandLine  [TYPE]  Iterator  i  [TYPE]  List  anonymous  options  [TYPE]  Option  option  unexpected  [TYPE]  String  description  name  [TYPE]  int  maximum  minimum  present  [CONTEXT]  public  void  validate  (  final  WriteableCommandLine  commandLine  )  throws  OptionException  {  int  present  =  0  ;    Option  unexpected  =  null  ;  for  (  final  Iterator  i  =  options  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  Option  option  =  (  Option  )  i  .  next  (  )  ;    boolean  validate  =  option  .  isRequired  (  )  ||  option  instanceof  Group  ;  if  (  validate  )  {  option  .  validate  (  commandLine  )  ;  }  if  (  commandLine  .  hasOption  (  option  )  )  {  if  (  ++present  >  maximum  )  {  unexpected  =  option  ;  break  ;  }  [BUGGY]  option  .  validate  (  commandLine  )  ;  }  }  	Cli_14_GroupImpl_2_2	261	0	src/java/org/apache/commons/cli2/option/GroupImpl.java
798	if  (defaultValues  ==  null  ||  defaultValues.isEmpty())  {  defaultValues  =  (List)  this.defaultValues.get(option);  	[BUGGY]  if  (  (  valueList  =  =  null  )  ||  valueList  .  isEmpty  (  )  )  {  valueList  =  defaultValues  ;  [FE]  ComparisonFailure:  expected:<[1[  ,  1000]]>  but  was:<[1[]]>  assertEquals  (   "[ "  +  enteredValue1  +   "  ,  1000] "  ,  b  +   " "  )  ;  [METHOD]  getValues  [TYPE]  List  [PARAMETER]  Option  option  List  defaultValues  [CLASS]  WriteableCommandLineImpl  [TYPE]  List  defaultValues  normalised  options  valueList  [TYPE]  Option  option  [TYPE]  Set  prefixes  [TYPE]  boolean  false  true  [TYPE]  Map  defaultSwitches  defaultValues  nameToOption  optionToProperties  switches  values  [CONTEXT]  public  List  getValues  (  final  Option  option  ,  List  defaultValues  )  {  List  valueList  =  (  List  )  values  .  get  (  option  )  ;    [BUGGY]  if  (  (  valueList  =  =  null  )  ||  valueList  .  isEmpty  (  )  )  {  valueList  =  defaultValues  ;  }  if  (  (  valueList  =  =  null  )  ||  valueList  .  isEmpty  (  )  )  {  valueList  =  (  List  )  this  .  defaultValues  .  get  (  option  )  ;  }    return  valueList  =  =  null  ?  Collections  .  EMPTY_LIST  :  valueList  ;  }  	Cli_15_WriteableCommandLineImpl_2_1	117	2	src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java
799	if  (defaultValues  !=  null  &&  !defaultValues.isEmpty())  {  if  (valueList  ==  null  ||  valueList.isEmpty())  {  valueList  =  defaultValues;  }  else  {  if  (defaultValues.size()  >  valueList.size())  {  valueList  =  new  ArrayList(valueList);  for  (int  i=valueList.size();  i<defaultValues.size();  i++)  {  valueList.add(defaultValues.get(i));  }  }  }  }  	[BUGGY]  if  (  (  valueList  =  =  null  )  ||  valueList  .  isEmpty  (  )  )  {  valueList  =  (  List  )  this  .  defaultValues  .  get  (  option  )  ;  }  [FE]  ComparisonFailure:  expected:<[1[  ,  1000]]>  but  was:<[1[]]>  assertEquals  (   "[ "  +  enteredValue1  +   "  ,  1000] "  ,  b  +   " "  )  ;  [METHOD]  getValues  [TYPE]  List  [PARAMETER]  Option  option  List  defaultValues  [CLASS]  WriteableCommandLineImpl  [TYPE]  List  defaultValues  normalised  options  valueList  [TYPE]  Option  option  [TYPE]  Set  prefixes  [TYPE]  boolean  false  true  [TYPE]  Map  defaultSwitches  defaultValues  nameToOption  optionToProperties  switches  values  [CONTEXT]  public  List  getValues  (  final  Option  option  ,  List  defaultValues  )  {  List  valueList  =  (  List  )  values  .  get  (  option  )  ;    if  (  (  valueList  =  =  null  )  ||  valueList  .  isEmpty  (  )  )  {  valueList  =  defaultValues  ;  }  [BUGGY]  if  (  (  valueList  =  =  null  )  ||  valueList  .  isEmpty  (  )  )  {  valueList  =  (  List  )  this  .  defaultValues  .  get  (  option  )  ;  }    return  valueList  =  =  null  ?  Collections  .  EMPTY_LIST  :  valueList  ;  }  	Cli_15_WriteableCommandLineImpl_2_2	122	3	src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java
800	Option  getParent();  	[BUGGY]  [FE]  commonscli2OptionException:  Missing  option  parentOptions  assertTrue  (   "Child  group  not  found "  ,  cl  .  hasOption  (  childGroup  )  )  ;  [CLASS]  [CONTEXT]  	Cli_16_Option_2_1	206	0	src/java/org/apache/commons/cli2/Option.java
801	void  setParent(Option  parent);  	[BUGGY]  [FE]  commonscli2OptionException:  Missing  option  parentOptions  assertTrue  (   "Child  group  not  found "  ,  cl  .  hasOption  (  childGroup  )  )  ;  [CLASS]  [CONTEXT]  	Cli_16_Option_2_2	216	0	src/java/org/apache/commons/cli2/Option.java
802	Option  parent  =  option.getParent();  while  (parent  !=  null  &&  !options.contains(parent))  {  options.add(parent);  parent  =  parent.getParent();  }  	[BUGGY]  [FE]  commonscli2OptionException:  Missing  option  parentOptions  assertTrue  (   "Child  group  not  found "  ,  cl  .  hasOption  (  childGroup  )  )  ;  [CLASS]  [CONTEXT]  	Cli_16_WriteableCommandLineImpl_1_1	74	0	src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java
803	option.setParent(this);  	[BUGGY]  [FE]  commonscli2OptionException:  Missing  option  parentOptions  assertTrue  (   "Child  group  not  found "  ,  cl  .  hasOption  (  childGroup  )  )  ;  [CLASS]  [CONTEXT]  	Cli_16_GroupImpl_1_1	92	0	src/java/org/apache/commons/cli2/option/GroupImpl.java
804	private  Option  parent;  	[BUGGY]  [FE]  commonscli2OptionException:  Missing  option  parentOptions  assertTrue  (   "Child  group  not  found "  ,  cl  .  hasOption  (  childGroup  )  )  ;  [CLASS]  [CONTEXT]  	Cli_16_OptionImpl_2_1	36	0	src/java/org/apache/commons/cli2/option/OptionImpl.java
805	public  Option  getParent()  {  return  parent;  }  public  void  setParent(Option  parent)  {  this.parent  =  parent;  }  	[BUGGY]  [FE]  commonscli2OptionException:  Missing  option  parentOptions  assertTrue  (   "Child  group  not  found "  ,  cl  .  hasOption  (  childGroup  )  )  ;  [CLASS]  [CONTEXT]  	Cli_16_OptionImpl_2_2	128	0	src/java/org/apache/commons/cli2/option/OptionImpl.java
806	break;  	[BUGGY]  [FE]  AssertionFailedError:  Confirm  1  extra  arg:  2  assertTrue  (  cl  .  getArgList  (  )  .  contains  (   "zc "  )  )  ;  [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  [CONTEXT]  protected  void  burstToken  (  String  token  ,  boolean  stopAtNonOption  )  {  for  (  int  i  =  1  ;  i  <  token  .  length  (  )  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  if  (  options  .  hasOption  (  ch  )  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =  (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;  break  ;  }  }  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  [BUGGY]  }  else  {  tokens  .  add  (  token  )  ;  break  ;  }  }  }  	Cli_17_PosixParser_1_1	303	0	src/java/org/apache/commons/cli/PosixParser.java
807	tokens.add(token);  	[BUGGY]  processSingleHyphen  (  token  )  ;  [FE]  AssertionFailedError:  Confirm  -a  is  not  set  assertTrue  (   "Confirm  3  extra  args:   "  +  cl  .  getArgList  (  )  .  size  (  )  ,  cl  .  getArgList  (  )  .  size  (  )  =  =  3  )  ;  [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  Iterator  iter  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [CONTEXT]  Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  String  token  =  (  String  )  iter  .  next  (  )  ;    if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  tokens  .  add  (  token  )  ;  }  }  else  if  (   "- "  .  equals  (  token  )  )  {  [BUGGY]  processSingleHyphen  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  if  (  token  .  length  (  )  =  =  2  )  {  	Cli_18_PosixParser_3_1	128	1	src/java/org/apache/commons/cli/PosixParser.java
808		[BUGGY]  private  void  processSingleHyphen  (  String  hyphen  )  {  tokens  .  add  (  hyphen  )  ;  }  [FE]  AssertionFailedError:  Confirm  -a  is  not  set  assertTrue  (   "Confirm  3  extra  args:   "  +  cl  .  getArgList  (  )  .  size  (  )  ,  cl  .  getArgList  (  )  .  size  (  )  =  =  3  )  ;  [CLASS]  [CONTEXT]  	Cli_18_PosixParser_3_2	213	4	src/java/org/apache/commons/cli/PosixParser.java
809	tokens.add(token);  	[BUGGY]  [FE]  AssertionFailedError:  Confirm  -a  is  not  set  assertTrue  (   "Confirm  3  extra  args:   "  +  cl  .  getArgList  (  )  .  size  (  )  ,  cl  .  getArgList  (  )  .  size  (  )  =  =  3  )  ;  [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  options  .  hasOption  (  token  )  )  {  currentOption  =  options  .  getOption  (  token  )  ;  tokens  .  add  (  token  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  [BUGGY]  }  }  	Cli_18_PosixParser_3_3	241	0	src/java/org/apache/commons/cli/PosixParser.java
810		[BUGGY]  tokens  .  add  (  token  )  ;  [FE]  AssertionFailedError:  UnrecognizedOptionException  wasn't  thrown  assertEquals  (   "-z "  ,  e  .  getOption  (  )  )  ;  [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  options  .  hasOption  (  token  )  )  {  currentOption  =  options  .  getOption  (  token  )  ;  [BUGGY]  tokens  .  add  (  token  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  tokens  .  add  (  token  )  ;  }  }  	Cli_19_PosixParser_2_1	232	1	src/java/org/apache/commons/cli/PosixParser.java
811	  tokens.add(token);  	[BUGGY]  tokens  .  add  (  token  )  ;  [FE]  AssertionFailedError:  UnrecognizedOptionException  wasn't  thrown  assertEquals  (   "-z "  ,  e  .  getOption  (  )  )  ;  [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  options  .  hasOption  (  token  )  )  {  currentOption  =  options  .  getOption  (  token  )  ;  tokens  .  add  (  token  )  ;  }  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true  ;  [BUGGY]  tokens  .  add  (  token  )  ;  }  }  	Cli_19_PosixParser_2_2	237	1	src/java/org/apache/commons/cli/PosixParser.java
812	  if  (!options.hasOption(opt)  &&  stopAtNonOption)  	[BUGGY]  [FE]  AssertionFailedError:  Confirm  3  extra  args:  7  assertTrue  (   "Confirm  3  extra  args:   "  +  cl  .  getArgList  (  )  .  size  (  )  ,  cl  .  getArgList  (  )  .  size  (  )  =  =  3  )  ;  [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  Iterator  iter  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [CONTEXT]  protected  String[]  flatten  (  Options  options  ,  String[]  arguments  ,  boolean  stopAtNonOption  )  {  init  (  )  ;  this  .  options  =  options  ;    Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  String  token  =  (  String  )  iter  .  next  (  )  ;    if  (  token  .  startsWith  (   "-- "  )  )  {  [BUGGY]  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  	Cli_20_PosixParser_2_1	114	0	src/java/org/apache/commons/cli/PosixParser.java
813	tokens.add(opt);  if  (pos  !=  -1)  {  tokens.add(token.substring(pos  +  1));  }  	[BUGGY]  tokens  .  add  (  token  )  ;  [FE]  AssertionFailedError:  Confirm  3  extra  args:  7  assertTrue  (   "Confirm  3  extra  args:   "  +  cl  .  getArgList  (  )  .  size  (  )  ,  cl  .  getArgList  (  )  .  size  (  )  =  =  3  )  ;  [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  Iterator  iter  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  String[]  arguments  [TYPE]  String  token  [CONTEXT]  protected  String[]  flatten  (  Options  options  ,  String[]  arguments  ,  boolean  stopAtNonOption  )  {  init  (  )  ;  this  .  options  =  options  ;    Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  String  token  =  (  String  )  iter  .  next  (  )  ;    if  (  token  .  startsWith  (   "-- "  )  )  {  if  (  token  .  indexOf  (  '  =  '  )  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  0  ,  token  .  indexOf  (  '  =  '  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '  =  '  )  +  1  ,  token  .  length  (  )  )  )  ;  }  else  {  [BUGGY]  tokens  .  add  (  token  )  ;  }  }  else  if  (   "- "  .  equals  (  token  )  )  	Cli_20_PosixParser_2_2	121	1	src/java/org/apache/commons/cli/PosixParser.java
814	Option  getCurrentOption();  	[BUGGY]  [FE]  commonscli2OptionException:  Unexpected  -42  while  processing  --num  assertEquals  (   "Wrong  option  value "  ,  -42  ,  num  .  intValue  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_21_WriteableCommandLine_2_1	102	0	src/java/org/apache/commons/cli2/WriteableCommandLine.java
815	void  setCurrentOption(Option  currentOption);  	[BUGGY]  [FE]  commonscli2OptionException:  Unexpected  -42  while  processing  --num  assertEquals  (   "Wrong  option  value "  ,  -42  ,  num  .  intValue  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_21_WriteableCommandLine_2_2	110	0	src/java/org/apache/commons/cli2/WriteableCommandLine.java
816	private  Option  currentOption;  private  String  checkForOption;  	[BUGGY]  [FE]  commonscli2OptionException:  Unexpected  -42  while  processing  --num  assertEquals  (   "Wrong  option  value "  ,  -42  ,  num  .  intValue  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_21_WriteableCommandLineImpl_4_1	51	0	src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java
817	setCurrentOption(rootOption);  public  Option  getCurrentOption()  {  return  currentOption;  }  public  void  setCurrentOption(Option  currentOption)  {  this.currentOption  =  currentOption;  }  	[BUGGY]  [FE]  commonscli2OptionException:  Unexpected  -42  while  processing  --num  assertEquals  (   "Wrong  option  value "  ,  -42  ,  num  .  intValue  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_21_WriteableCommandLineImpl_4_2	63	0	src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java
818	if  (checkForOption  !=  null)  {  return  !checkForOption.equals(trigger);  }  checkForOption  =  trigger;  try  {  	[BUGGY]  [FE]  commonscli2OptionException:  Unexpected  -42  while  processing  --num  assertEquals  (   "Wrong  option  value "  ,  -42  ,  num  .  intValue  (  )  )  ;  [METHOD]  looksLikeOption  [TYPE]  boolean  [PARAMETER]  String  trigger  [CLASS]  WriteableCommandLineImpl  [TYPE]  Iterator  i  [TYPE]  List  normalised  options  [TYPE]  Set  prefixes  [TYPE]  String  prefix  trigger  [TYPE]  boolean  false  true  [TYPE]  Map  defaultSwitches  defaultValues  nameToOption  optionToProperties  switches  values  [CONTEXT]  public  boolean  looksLikeOption  (  final  String  trigger  )  {  [BUGGY]  for  (  final  Iterator  i  =  prefixes  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  String  prefix  =  (  String  )  i  .  next  (  )  ;  if  (  trigger  .  startsWith  (  prefix  )  )  {  return  true  ;  }  }  return  false  ;  }  	Cli_21_WriteableCommandLineImpl_4_3	234	0	src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java
819	if  (getCurrentOption().canProcess(this,  trigger)  ||  getCurrentOption().findOption(trigger)  !=  null)  {  }    }  finally  {  checkForOption  =  null;  }  	[BUGGY]  [FE]  commonscli2OptionException:  Unexpected  -42  while  processing  --num  assertEquals  (   "Wrong  option  value "  ,  -42  ,  num  .  intValue  (  )  )  ;  [METHOD]  looksLikeOption  [TYPE]  boolean  [PARAMETER]  String  trigger  [CLASS]  WriteableCommandLineImpl  [TYPE]  Iterator  i  [TYPE]  List  normalised  options  [TYPE]  Set  prefixes  [TYPE]  String  prefix  trigger  [TYPE]  boolean  false  true  [TYPE]  Map  defaultSwitches  defaultValues  nameToOption  optionToProperties  switches  values  [CONTEXT]  public  boolean  looksLikeOption  (  final  String  trigger  )  {  for  (  final  Iterator  i  =  prefixes  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  final  String  prefix  =  (  String  )  i  .  next  (  )  ;  if  (  trigger  .  startsWith  (  prefix  )  )  {  [BUGGY]  return  true  ;  }  }  return  false  ;  }  	Cli_21_WriteableCommandLineImpl_4_4	242	0	src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java
820	Option  oldOption  =  commandLine.getCurrentOption();  try  {  commandLine.setCurrentOption(this);  }  finally  {  commandLine.setCurrentOption(oldOption);  }  	[BUGGY]  [FE]  commonscli2OptionException:  Unexpected  -42  while  processing  --num  assertEquals  (   "Wrong  option  value "  ,  -42  ,  num  .  intValue  (  )  )  ;  [METHOD]  looksLikeOption  [TYPE]  boolean  [PARAMETER]  WriteableCommandLine  commandLine  String  trigger  [CLASS]  GroupImpl  [TYPE]  Set  prefixes  [TYPE]  boolean  false  true  [TYPE]  SortedMap  optionMap  [TYPE]  WriteableCommandLine  commandLine  [TYPE]  List  anonymous  options  [TYPE]  String  description  name  trigger  [TYPE]  int  maximum  minimum  [CONTEXT]  private  boolean  looksLikeOption  (  final  WriteableCommandLine  commandLine  ,  final  String  trigger  )  {  [BUGGY]  return  commandLine  .  looksLikeOption  (  trigger  )  ;  }  	Cli_21_GroupImpl_1_1	513	0	src/java/org/apache/commons/cli2/option/GroupImpl.java
821	private  Option  currentOption;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[println  'hello']>  but  was:<[--]>  assertEquals  (   "println  'hello' "  ,  line  .  getOptionValue  (  'e'  )  )  ;  [CLASS]  [CONTEXT]  	Cli_22_PosixParser_8_1	41	0	src/java/org/apache/commons/cli/PosixParser.java
822	processNonOptionToken(token,  stopAtNonOption);  	[BUGGY]  processNonOptionToken  (  token  )  ;  [FE]  ComparisonFailure:  expected:<[println  'hello']>  but  was:<[--]>  assertEquals  (   "println  'hello' "  ,  line  .  getOptionValue  (  'e'  )  )  ;  [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  Iterator  iter  [TYPE]  List  tokens  [TYPE]  String[]  arguments  [TYPE]  String  opt  token  [TYPE]  int  pos  [CONTEXT]  protected  String[]  flatten  (  Options  options  ,  String[]  arguments  ,  boolean  stopAtNonOption  )  {  init  (  )  ;  this  .  options  =  options  ;    Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  String  token  =  (  String  )  iter  .  next  (  )  ;    if  (  token  .  startsWith  (   "-- "  )  )  {  int  pos  =  token  .  indexOf  (  '  =  '  )  ;  String  opt  =  pos  =  =  -1  ?  token  :  token  .  substring  (  0  ,  pos  )  ;  //  --foo  if  (  !options  .  hasOption  (  opt  )  )  {  [BUGGY]  processNonOptionToken  (  token  )  ;  }  else  {  tokens  .  add  (  opt  )  ;  	Cli_22_PosixParser_8_2	116	1	src/java/org/apache/commons/cli/PosixParser.java
823	currentOption  =  options.getOption(opt);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[println  'hello']>  but  was:<[--]>  assertEquals  (   "println  'hello' "  ,  line  .  getOptionValue  (  'e'  )  )  ;  [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  Iterator  iter  [TYPE]  List  tokens  [TYPE]  String[]  arguments  [TYPE]  String  opt  token  [TYPE]  int  pos  [CONTEXT]  {  init  (  )  ;  this  .  options  =  options  ;    Iterator  iter  =  Arrays  .  asList  (  arguments  )  .  iterator  (  )  ;    while  (  iter  .  hasNext  (  )  )  {  String  token  =  (  String  )  iter  .  next  (  )  ;    if  (  token  .  startsWith  (   "-- "  )  )  {  int  pos  =  token  .  indexOf  (  '  =  '  )  ;  String  opt  =  pos  =  =  -1  ?  token  :  token  .  substring  (  0  ,  pos  )  ;  //  --foo  if  (  !options  .  hasOption  (  opt  )  )  {  processNonOptionToken  (  token  )  ;  }  else  {  [BUGGY]  tokens  .  add  (  opt  )  ;  if  (  pos  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  pos  +  1  )  )  ;  }  	Cli_22_PosixParser_8_3	120	0	src/java/org/apache/commons/cli/PosixParser.java
824	processNonOptionToken(token,  stopAtNonOption);  	[BUGGY]  else  if  (  stopAtNonOption  )  {  processNonOptionToken  (  token  )  ;  }  tokens  .  add  (  token  )  ;  [FE]  ComparisonFailure:  expected:<[println  'hello']>  but  was:<[--]>  assertEquals  (   "println  'hello' "  ,  line  .  getOptionValue  (  'e'  )  )  ;  [METHOD]  flatten  [TYPE]  String[]  [PARAMETER]  Options  options  String[]  arguments  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  Iterator  iter  [TYPE]  List  tokens  [TYPE]  String[]  arguments  [TYPE]  String  opt  token  [TYPE]  int  pos  [CONTEXT]  tokens  .  add  (  opt  )  ;  if  (  pos  !  =  -1  )  {  tokens  .  add  (  token  .  substring  (  pos  +  1  )  )  ;  }  }  }  else  if  (   "- "  .  equals  (  token  )  )  {  tokens  .  add  (  token  )  ;  }  else  if  (  token  .  startsWith  (   "- "  )  )  {  if  (  token  .  length  (  )  =  =  2  ||  options  .  hasOption  (  token  )  )  {  processOptionToken  (  token  ,  stopAtNonOption  )  ;  }  else  {  burstToken  (  token  ,  stopAtNonOption  )  ;  }  }  [BUGGY]  else  if  (  stopAtNonOption  )  {  processNonOptionToken  (  token  )  ;  }  else  {  	Cli_22_PosixParser_8_4	146	5	src/java/org/apache/commons/cli/PosixParser.java
825	private  void  processNonOptionToken(String  value,  boolean  stopAtNonOption)  if  (stopAtNonOption  &&  (currentOption  ==  null  ||  !currentOption.hasArg()))  {  }  	[BUGGY]  private  void  processNonOptionToken  (  String  value  )  [FE]  ComparisonFailure:  expected:<[println  'hello']>  but  was:<[--]>  assertEquals  (   "println  'hello' "  ,  line  .  getOptionValue  (  'e'  )  )  ;  [CLASS]  [CONTEXT]  	Cli_22_PosixParser_8_5	184	1	src/java/org/apache/commons/cli/PosixParser.java
826	if  (options.hasOption(token))  {  currentOption  =  options.getOption(token);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[println  'hello']>  but  was:<[--]>  assertEquals  (   "println  'hello' "  ,  line  .  getOptionValue  (  'e'  )  )  ;  [METHOD]  processOptionToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  List  tokens  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  token  [CONTEXT]  private  void  processOptionToken  (  String  token  ,  boolean  stopAtNonOption  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  token  )  )  {  eatTheRest  =  true  ;  }  [BUGGY]  tokens  .  add  (  token  )  ;  }  	Cli_22_PosixParser_8_6	211	0	src/java/org/apache/commons/cli/PosixParser.java
827		[BUGGY]  Option  currentOption  ;  [FE]  ComparisonFailure:  expected:<[println  'hello']>  but  was:<[--]>  assertEquals  (   "println  'hello' "  ,  line  .  getOptionValue  (  'e'  )  )  ;  [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  [CONTEXT]  protected  void  burstToken  (  String  token  ,  boolean  stopAtNonOption  )  {  [BUGGY]  Option  currentOption  ;  for  (  int  i  =  1  ;  i  <  token  .  length  (  )  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  if  (  options  .  hasOption  (  ch  )  )  	Cli_22_PosixParser_8_7	243	1	src/java/org/apache/commons/cli/PosixParser.java
828	processNonOptionToken(token.substring(i),  true);  	[BUGGY]  processNonOptionToken  (  token  .  substring  (  i  )  )  ;  [FE]  ComparisonFailure:  expected:<[println  'hello']>  but  was:<[--]>  assertEquals  (   "println  'hello' "  ,  line  .  getOptionValue  (  'e'  )  )  ;  [METHOD]  burstToken  [TYPE]  void  [PARAMETER]  String  token  boolean  stopAtNonOption  [CLASS]  PosixParser  [TYPE]  Options  options  [TYPE]  List  tokens  [TYPE]  Option  currentOption  [TYPE]  boolean  eatTheRest  false  stopAtNonOption  true  [TYPE]  String  ch  token  [TYPE]  int  i  [CONTEXT]  protected  void  burstToken  (  String  token  ,  boolean  stopAtNonOption  )  {  Option  currentOption  ;  for  (  int  i  =  1  ;  i  <  token  .  length  (  )  ;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  if  (  options  .  hasOption  (  ch  )  )  {  tokens  .  add  (   "- "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ;  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !  =  (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;  break  ;  }  }  else  if  (  stopAtNonOption  )  {  [BUGGY]  processNonOptionToken  (  token  .  substring  (  i  )  )  ;  break  ;  }  else  {  tokens  .  add  (  token  )  ;  	Cli_22_PosixParser_8_8	262	1	src/java/org/apache/commons/cli/PosixParser.java
829		[BUGGY]  int  lastPos  =  pos  ;  [FE]  RuntimeException:  Text  too  long  for  line  -  throwing  exception  to  avoid  infinite  loop  [CLI-162]:        looooong  description  [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  padding  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  lastPos  nextLineTabStop  pos  width  [TYPE]  Comparator  optionComparator  [CONTEXT]  protected  StringBuffer  renderWrappedText  (  StringBuffer  sb  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;  if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;  return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;    final  String  padding  =  createPadding  (  nextLineTabStop  )  ;  while  (  true  )  {  [BUGGY]  int  lastPos  =  pos  ;  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;  if  (  pos  =  =  -1  )  {  	Cli_23_HelpFormatter_2_1	824	1	src/java/org/apache/commons/cli/HelpFormatter.java
830	}    if  (  (text.length()  >  width)  &&  (pos  ==  nextLineTabStop  -  1)  )  {  sb.append(text);    return  sb;  	[BUGGY]  }  else  if  (  pos  =  =  lastPos  )  {  throw  new  RuntimeException  (   "Text  too  long  for  line  -  throwing  exception  to  avoid  infinite  loop  [CLI-162]:   "  +  text  )  ;  [FE]  RuntimeException:  Text  too  long  for  line  -  throwing  exception  to  avoid  infinite  loop  [CLI-162]:        looooong  description  [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  padding  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  lastPos  nextLineTabStop  pos  width  [TYPE]  Comparator  optionComparator  [CONTEXT]  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;  if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;  return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;    final  String  padding  =  createPadding  (  nextLineTabStop  )  ;  while  (  true  )  {  int  lastPos  =  pos  ;  text  =  padding  +  text  .  substring  (  pos  )  .  trim  (  )  ;  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;  if  (  pos  =  =  -1  )  {  sb  .  append  (  text  )  ;  return  sb  ;  [BUGGY]  }  else  if  (  pos  =  =  lastPos  )  {  throw  new  RuntimeException  (   "Text  too  long  for  line  -  throwing  exception  to  avoid  infinite  loop  [CLI-162]:   "  +  text  )  ;  }  	Cli_23_HelpFormatter_2_2	833	4	src/java/org/apache/commons/cli/HelpFormatter.java
831	nextLineTabStop  =  width  -  1;  	[BUGGY]  throw  new  IllegalStateException  (   "Total  width  is  less  than  the  width  of  the  argument  and  indent   "  +   "-  no  room  for  the  description "  )  ;  [FE]  IllegalStateException:  Total  width  is  less  than  the  width  of  the  argument  and  indent  -  no  room  for  the  description  assertEquals  (   "Long  arguments  did  not  split  as  expected "  ,  expected  ,  sw  .  toString  (  )    )  ;  [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  padding  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  nextLineTabStop  pos  width  [TYPE]  Comparator  optionComparator  [CONTEXT]  protected  StringBuffer  renderWrappedText  (  StringBuffer  sb  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;  if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;  return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  if  (  nextLineTabStop  >  =  width  )  {  [BUGGY]  throw  new  IllegalStateException  (   "Total  width  is  less  than  the  width  of  the  argument  and  indent   "  +   "-  no  room  for  the  description "  )  ;  }    	Cli_24_HelpFormatter_1_1	825	2	src/java/org/apache/commons/cli/HelpFormatter.java
832	nextLineTabStop  =  1;  	[BUGGY]  nextLineTabStop  =  width  -  1  ;  [FE]  ComparisonFailure:  Long  arguments  did  not  split  as  expected  expected:<  assertEquals  (   "Long  arguments  did  not  split  as  expected "  ,  expected  ,  sw  .  toString  (  )    )  ;  [METHOD]  renderWrappedText  [TYPE]  StringBuffer  [PARAMETER]  StringBuffer  sb  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  padding  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  nextLineTabStop  pos  width  [TYPE]  Comparator  optionComparator  [CONTEXT]  protected  StringBuffer  renderWrappedText  (  StringBuffer  sb  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  int  pos  =  findWrapPos  (  text  ,  width  ,  0  )  ;  if  (  pos  =  =  -1  )  {  sb  .  append  (  rtrim  (  text  )  )  ;  return  sb  ;  }  sb  .  append  (  rtrim  (  text  .  substring  (  0  ,  pos  )  )  )  .  append  (  defaultNewLine  )  ;  if  (  nextLineTabStop  >  =  width  )  {  [BUGGY]  nextLineTabStop  =  width  -  1  ;  }    final  String  padding  =  createPadding  (  nextLineTabStop  )  ;  	Cli_25_HelpFormatter_1_1	825	1	src/java/org/apache/commons/cli/HelpFormatter.java
833	Option  option  =  null;  try  {  option  =  new  Option(opt,  description);  	[BUGGY]  Option  option  =  new  Option  (  opt  ,  description  )  ;  [FE]  AssertionFailedError:  we  inherited  a  description  assertNull  (   "we  inherited  a  description "  ,  OptionBuilder  .  create  (  'x'  )  .  getDescription  (  )  )  ;  [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder  [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  opt  [TYPE]  int  numberOfArgs  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {  [BUGGY]  Option  option  =  new  Option  (  opt  ,  description  )  ;    option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;  OptionBuilder  .  reset  (  )  ;    return  option  ;  }  	Cli_26_OptionBuilder_2_1	348	1	src/java/org/apache/commons/cli/OptionBuilder.java
834	}  finally  {  }  	[BUGGY]  [FE]  AssertionFailedError:  we  inherited  a  description  assertNull  (   "we  inherited  a  description "  ,  OptionBuilder  .  create  (  'x'  )  .  getDescription  (  )  )  ;  [METHOD]  create  [TYPE]  Option  [PARAMETER]  String  opt  [CLASS]  OptionBuilder  [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  Option  option  [TYPE]  String  argName  description  longopt  opt  [TYPE]  int  numberOfArgs  [CONTEXT]  public  static  Option  create  (  String  opt  )  throws  IllegalArgumentException  {  Option  option  =  new  Option  (  opt  ,  description  )  ;    option  .  setLongOpt  (  longopt  )  ;  option  .  setRequired  (  required  )  ;  option  .  setOptionalArg  (  optionalArg  )  ;  option  .  setArgs  (  numberOfArgs  )  ;  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ;  option  .  setArgName  (  argName  )  ;  [BUGGY]  OptionBuilder  .  reset  (  )  ;    return  option  ;  }  	Cli_26_OptionBuilder_2_2	359	0	src/java/org/apache/commons/cli/OptionBuilder.java
835	if  (selected  ==  null  ||  selected.equals(option.getKey())) { selected  =  option.getKey();  	[BUGGY]  if  (  selected  =  =  null  ||  selected  .  equals  (  option  .  getOpt  (  )  )  ) { selected  =  option  .  getOpt  (  )  ;  [FE]  ComparisonFailure:  selected  option  expected:<bar>  but  was:<null>  [METHOD]  setSelected  [TYPE]  void  [PARAMETER]  Option  option  [CLASS]  OptionGroup  [TYPE]  Option  option  [TYPE]  boolean  false  required  true  [TYPE]  String  selected  [TYPE]  Map  optionMap  [TYPE]  long  serialVersionUID  [CONTEXT]  public  void  setSelected  (  Option  option  )  throws  AlreadySelectedException  {  if  (  option  =  =  null  )  {  selected  =  null  ;  return  ;  }    [BUGGY]  if  (  selected  =  =  null  ||  selected  .  equals  (  option  .  getOpt  (  )  )  )  {  selected  =  option  .  getOpt  (  )  ;  }  else  {  throw  new  AlreadySelectedException  (  this  ,  option  )  ;  }  }  	Cli_27_OptionGroup_1_1	98	3	src/java/org/apache/commons/cli/OptionGroup.java
836	continue;  	[BUGGY]  break  ;  [FE]  AssertionFailedError  assertTrue  (  cmd  .  hasOption  (   "e "  )    )  ;  [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser  [TYPE]  Options  options  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  [CONTEXT]  Option  opt  =  getOptions  (  )  .  getOption  (  option  )  ;    String  value  =  properties  .  getProperty  (  option  )  ;  if  (  opt  .  hasArg  (  )  )  {  if  (  opt  .  getValues  (  )  =  =  null  ||  opt  .  getValues  (  )  .  length  =  =  0  )  {  try  {  opt  .  addValueForProcessing  (  value  )  ;  }  catch  (  RuntimeException  exp  )  {  }  }  }  else  if  (  !  (   "yes "  .  equalsIgnoreCase  (  value  )  ||   "true "  .  equalsIgnoreCase  (  value  )  ||   "1 "  .  equalsIgnoreCase  (  value  )  )  )  {    [BUGGY]  break  ;  }  cmd  .  addOption  (  opt  )  ;  }  }  	Cli_28_Parser_1_1	290	1	src/java/org/apache/commons/cli/Parser.java
837	if  (length  >  1  &&  str.startsWith( "\\ " ")  &&  str.endsWith( "\\ " ")  &&  str.substring(1,  length  -  1).indexOf(\' "\')  ==  -1)  str  =  str.substring(1,  length  -  1);  	[BUGGY]  if  (  str  .  startsWith  (   "\\ " "  )  )  {  str  =  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  if  (  str  .  endsWith  (   "\\ " "  )  )  str  =  str  .  substring  (  0  ,  length  -  1  )  ;  [FE]  ComparisonFailure:  expected:<foo   "bar[ "]>  but  was:<foo   "bar[]>  assertEquals  (   "\ " "  ,  Util  .  stripLeadingAndTrailingQuotes  (   "\ " "  )  )  ;  [METHOD]  stripLeadingAndTrailingQuotes  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Util  [TYPE]  boolean  false  true  [TYPE]  String  str  [TYPE]  int  length  [CONTEXT]  static  String  stripLeadingAndTrailingQuotes  (  String  str  )  {  [BUGGY]  if  (  str  .  startsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  1  ,  str  .  length  (  )  )  ;  }  int  length  =  str  .  length  (  )  ;  if  (  str  .  endsWith  (   "\ " "  )  )  {  str  =  str  .  substring  (  0  ,  length  -  1  )  ;  }  return  str  ;  }  	Cli_29_Util_1_1	65	6	src/java/org/apache/commons/cli/Util.java
838	Option  opt  =  options.getOption(option);  if  (opt  ==  null)  throw  new  UnrecognizedOptionException( "Default  option  wasn\'t  defined ",  option);  }  OptionGroup  group  =  options.getOptionGroup(opt);  boolean  selected  =  group  !=  null  &&  group.getSelected()  !=  null;  if  (!cmd.hasOption(option)  &&  !selected)  {  	[BUGGY]  if  (  !cmd  .  hasOption  (  option  )  )  Option  opt  =  options  .  getOption  (  option  )  ;  [FE]  commonscliAlreadySelectedException:  The  option  'b'  was  specified  but  an  option  from  this  group  has  already  been  selected:  'a'  [METHOD]  handleProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  DefaultParser  [TYPE]  Options  options  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  skipParsing  stopAtNonOption  true  [TYPE]  Enumeration  e  [TYPE]  Option  currentOption  opt  [TYPE]  List  expectedOpts  [TYPE]  String  currentToken  option  value  [TYPE]  Properties  properties  [CONTEXT]  private  void  handleProperties  (  Properties  properties  )  throws  ParseException  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;  [BUGGY]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  options  .  getOption  (  option  )  ;    	Cli_30_DefaultParser_1_1	150	2	src/main/java/org/apache/commons/cli/DefaultParser.java
839	Option  opt  =  options.getOption(option);  if  (opt  ==  null)  throw  new  UnrecognizedOptionException( "Default  option  wasn\'t  defined ",  option);  }  OptionGroup  group  =  options.getOptionGroup(opt);  boolean  selected  =  group  !=  null  &&  group.getSelected()  !=  null;  if  (!cmd.hasOption(option)  &&  !selected)  {  	[BUGGY]  if  (  !cmd  .  hasOption  (  option  )  )  Option  opt  =  getOptions  (  )  .  getOption  (  option  )  ;  [FE]  commonscliAlreadySelectedException:  The  option  'b'  was  specified  but  an  option  from  this  group  has  already  been  selected:  'a'  [METHOD]  processProperties  [TYPE]  void  [PARAMETER]  Properties  properties  [CLASS]  Parser  [TYPE]  Options  options  [TYPE]  CommandLine  cmd  [TYPE]  Enumeration  e  [TYPE]  RuntimeException  exp  [TYPE]  boolean  false  true  [TYPE]  List  requiredOptions  [TYPE]  Option  opt  [TYPE]  String  option  value  [TYPE]  Properties  properties  [CONTEXT]  protected  void  processProperties  (  Properties  properties  )  throws  ParseException  {  if  (  properties  =  =  null  )  {  return  ;  }  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )  .  toString  (  )  ;  [BUGGY]  if  (  !cmd  .  hasOption  (  option  )  )  {  Option  opt  =  getOptions  (  )  .  getOption  (  option  )  ;    	Cli_30_Parser_1_1	263	2	src/main/java/org/apache/commons/cli/Parser.java
840	if  (option.hasArg()  &&  (option.getArgName()  ==  null  ||  option.getArgName().length()  !=  0))  buff.append( "< ").append(option.getArgName()  !=  null  ?  option.getArgName()  :  getArgName()).append( "> ");  	[BUGGY]  if  (  option  .  hasArg  (  )  &&  option  .  hasArgName  (  )  )  buff  .  append  (   "< "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  [FE]  ComparisonFailure:  expected:<usage:  app  -f  <arg[ument]>  assertEquals  (   "usage:  app  -f  <argument> "  +  EOL  ,  out  .  toString  (  )  )  ;  [METHOD]  appendOption  [TYPE]  void  [PARAMETER]  StringBuffer  buff  Option  option  final  boolean  required  [CLASS]  HelpFormatter  [TYPE]  StringBuffer  buff  [TYPE]  Option  option  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_LONG_OPT_SEPARATOR  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  longOptSeparator  [TYPE]  boolean  false  required  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  [TYPE]  Comparator  optionComparator  [CONTEXT]  private  void  appendOption  (  final  StringBuffer  buff  ,  final  Option  option  ,  final  boolean  required  )  {  if  (  !required  )  {  buff  .  append  (   "[ "  )  ;  }  if  (  option  .  getOpt  (  )  !  =  null  )  {  buff  .  append  (   "- "  )  .  append  (  option  .  getOpt  (  )  )  ;  }  else  {  buff  .  append  (   "-- "  )  .  append  (  option  .  getLongOpt  (  )  )  ;  }  [BUGGY]  if  (  option  .  hasArg  (  )  &&  option  .  hasArgName  (  )  )  {  buff  .  append  (  option  .  getOpt  (  )  =  =  null  ?  longOptSeparator  :   "   "  )  ;  buff  .  append  (   "< "  )  .  append  (  option  .  getArgName  (  )  )  .  append  (   "> "  )  ;  }  if  (  !required  )  {  buff  .  append  (   "] "  )  ;  }  }  	Cli_31_HelpFormatter_1_1	653	2	src/main/java/org/apache/commons/cli/HelpFormatter.java
841	private  String  argName;  	[BUGGY]  private  String  argName  =   "arg "  ;  [FE]  ComparisonFailure:  expected:<usage:  app  -f  <arg[ument]>  assertEquals  (   "usage:  app  -f  <argument> "  +  EOL  ,  out  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Cli_31_Option_1_1	57	1	src/main/java/org/apache/commons/cli/Option.java
842	argName  =  null;  	[BUGGY]  argName  =   "arg "  ;  [FE]  ComparisonFailure:  expected:<usage:  app  -f  <arg[ument]>  assertEquals  (   "usage:  app  -f  <argument> "  +  EOL  ,  out  .  toString  (  )  )  ;  [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder  [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Object  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  [BUGGY]  argName  =   "arg "  ;  longopt  =  null  ;  type  =  null  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;  optionalArg  =  false  ;  valuesep  =  (  char  )  0  ;  }  	Cli_31_OptionBuilder_1_1	80	1	src/main/java/org/apache/commons/cli/OptionBuilder.java
843		[BUGGY]  while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\n') && (c != '\r')) { ++pos  ;  }  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  12  assertEquals  (   "cut  and  wrap "  ,  expected  ,  sb  .  toString  (  )  )  ;  [METHOD]  findWrapPos  [TYPE]  int  [PARAMETER]  String  text  int  width  int  startPos  [CLASS]  HelpFormatter  [TYPE]  char  c  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_LONG_OPT_SEPARATOR  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  longOptSeparator  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  pos  startPos  width  [TYPE]  Comparator  optionComparator  [CONTEXT]  else  if  (  startPos  +  width  >  =  text  .  length  (  )  )  {  return  -1  ;  }    pos  =  startPos  +  width  ;  char  c  ;  while  (  (  pos  >  =  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  --pos  ;  }  if  (  pos  >  startPos  )  {  return  pos  ;  }  pos  =  startPos  +  width  ;  [BUGGY]  while  (  (  pos  <  =  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !  =  '  '  )  &&  (  c  !  =  '\n'  )  &&  (  c  !  =  '\r'  )  )  {  ++pos  ;  }  return  pos  =  =  text  .  length  (  )  ?  -1  :  pos  ;  	Cli_32_HelpFormatter_1_1	937	2	src/main/java/org/apache/commons/cli/HelpFormatter.java
844	renderWrappedTextBlock(sb,  width,  nextLineTabStop,  text);  	[BUGGY]  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  text  )  ;  [FE]  ComparisonFailure:  expected:<e:  foobar  assertEquals  (  [METHOD]  printWrapped  [TYPE]  void  [PARAMETER]  PrintWriter  pw  int  width  int  nextLineTabStop  String  text  [CLASS]  HelpFormatter  [TYPE]  StringBuffer  sb  [TYPE]  String  DEFAULT_ARG_NAME  DEFAULT_LONG_OPT_PREFIX  DEFAULT_LONG_OPT_SEPARATOR  DEFAULT_OPT_PREFIX  DEFAULT_SYNTAX_PREFIX  defaultArgName  defaultLongOptPrefix  defaultNewLine  defaultOptPrefix  defaultSyntaxPrefix  longOptSeparator  text  [TYPE]  boolean  false  true  [TYPE]  int  DEFAULT_DESC_PAD  DEFAULT_LEFT_PAD  DEFAULT_WIDTH  defaultDescPad  defaultLeftPad  defaultWidth  nextLineTabStop  width  [TYPE]  Comparator  optionComparator  [TYPE]  PrintWriter  pw  [CONTEXT]  public  void  printWrapped  (  PrintWriter  pw  ,  int  width  ,  int  nextLineTabStop  ,  String  text  )  {  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ;  [BUGGY]  renderWrappedText  (  sb  ,  width  ,  nextLineTabStop  ,  text  )  ;  pw  .  println  (  sb  .  toString  (  )  )  ;  }  	Cli_33_HelpFormatter_2_1	730	1	src/main/java/org/apache/commons/cli/HelpFormatter.java
845	private  StringBuffer  renderWrappedTextBlock(StringBuffer  sb,  int  width,  int  nextLineTabStop,  String  text)  {  try  {  BufferedReader  in  =  new  BufferedReader(new  StringReader(text));  String  line;  boolean  firstLine  =  true;  while  ((line  =  in.readLine())  !=  null)  {  if  (!firstLine)  {  sb.append(getNewLine());  }  else  {  firstLine  =  false;  }  renderWrappedText(sb,  width,  nextLineTabStop,  line);  }  }  catch  (IOException  e)  {  }  return  sb;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<e:  foobar  assertEquals  (  [CLASS]  [CONTEXT]  	Cli_33_HelpFormatter_2_2	900	0	src/main/java/org/apache/commons/cli/HelpFormatter.java
846	private  Class  type  =  String.class;  	[BUGGY]  private  Class  type  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<null>  assertEquals  (   "foo "  ,  cmd  .  getParsedOptionValue  (   "f "  )  )  ;  [CLASS]  [CONTEXT]  	Cli_34_Option_1_1	72	1	src/main/java/org/apache/commons/cli/Option.java
847	type  =  String.class;  	[BUGGY]  type  =  null  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<null>  assertEquals  (   "foo "  ,  cmd  .  getParsedOptionValue  (   "f "  )  )  ;  [METHOD]  reset  [TYPE]  void  [PARAMETER]  [CLASS]  OptionBuilder  [TYPE]  boolean  false  optionalArg  required  true  [TYPE]  OptionBuilder  instance  [TYPE]  char  valuesep  [TYPE]  Class  type  [TYPE]  String  argName  description  longopt  [TYPE]  int  numberOfArgs  [CONTEXT]  private  static  void  reset  (  )  {  description  =  null  ;  argName  =  null  ;  longopt  =  null  ;  [BUGGY]  type  =  null  ;  required  =  false  ;  numberOfArgs  =  Option  .  UNINITIALIZED  ;  optionalArg  =  false  ;  valuesep  =  (  char  )  0  ;  }  	Cli_34_OptionBuilder_1_1	84	1	src/main/java/org/apache/commons/cli/OptionBuilder.java
848	if(longOpts.keySet().contains(opt))  {  return  Collections.singletonList(opt);  }  	[BUGGY]  [FE]  commonscliAmbiguousOptionException:  Ambiguous  option:  '--prefix'  (  could  be:  'prefix'  ,  'prefixplusplus'  )  [METHOD]  getMatchingOptions  [TYPE]  List  [PARAMETER]  String  opt  [CLASS]  Options  [TYPE]  List  matchingOpts  requiredOpts  [TYPE]  String  longOpt  opt  [TYPE]  boolean  false  true  [TYPE]  Map  longOpts  optionGroups  shortOpts  [TYPE]  long  serialVersionUID  [CONTEXT]  public  List<String>  getMatchingOptions  (  String  opt  )  {  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ;  List<String>  matchingOpts  =  new  ArrayList<String>  (  )  ;    [BUGGY]  for  (  String  longOpt  :  longOpts  .  keySet  (  )  )  {  if  (  longOpt  .  startsWith  (  opt  )  )  {  matchingOpts  .  add  (  longOpt  )  ;  }  }  return  matchingOpts  ;  }  	Cli_35_Options_1_1	240	0	src/main/java/org/apache/commons/cli/Options.java
849		[BUGGY]  [FE]  AssertionFailedError:  expected:<[p]>  but  was:<[x]>  Assert  .  assertEquals  (  o  .  getOpt  (  )  ,  insertedOrder  .  get  (  i  )  )  ;  [CLASS]  [CONTEXT]  	Cli_36_OptionGroup_2_1	22	0	src/main/java/org/apache/commons/cli/OptionGroup.java
850	private  final  Map<String,  Option>  optionMap  =  new  LinkedHashMap<String,  Option>();  	[BUGGY]  private  final  Map<String  ,  Option>  optionMap  =  new  HashMap<String  ,  Option>  (  )  ;  [FE]  AssertionFailedError:  expected:<[p]>  but  was:<[x]>  Assert  .  assertEquals  (  o  .  getOpt  (  )  ,  insertedOrder  .  get  (  i  )  )  ;  [CLASS]  [CONTEXT]  	Cli_36_OptionGroup_2_2	37	1	src/main/java/org/apache/commons/cli/OptionGroup.java
851		[BUGGY]  [FE]  AssertionFailedError:  expected:<[p]>  but  was:<[x]>  Assert  .  assertEquals  (  o  .  getOpt  (  )  ,  insertedOrder  .  get  (  i  )  )  ;  [CLASS]  [CONTEXT]  	Cli_36_Options_2_1	24	0	src/main/java/org/apache/commons/cli/Options.java
852	private  final  Map<String,  OptionGroup>  optionGroups  =  new  LinkedHashMap<String,  OptionGroup>();  	[BUGGY]  private  final  Map<String  ,  OptionGroup>  optionGroups  =  new  HashMap<String  ,  OptionGroup>  (  )  ;  [FE]  AssertionFailedError:  expected:<[p]>  but  was:<[x]>  Assert  .  assertEquals  (  o  .  getOpt  (  )  ,  insertedOrder  .  get  (  i  )  )  ;  [CLASS]  [CONTEXT]  	Cli_36_Options_2_2	61	1	src/main/java/org/apache/commons/cli/Options.java
853	if  (!token.startsWith( "- ")  ||  token.length()  ==  1)  {  return  false;  }  int  pos  =  token.indexOf( "= ");  String  optName  =  pos  ==  -1  ?  token.substring(1)  :  token.substring(1,  pos);  return  options.hasShortOption(optName);  	[BUGGY]  return  token  .  startsWith  (   "- "  )  &&  token  .  length  (  )  >  =  2  &&  options  .  hasShortOption  (  token  .  substring  (  1  ,  2  )  )  ;  [FE]  AssertionFailedError:  Second  option  has  been  used  as  value  for  first  option  Actual:  -last  assertTrue  (   "Second  option  has  not  been  detected "  ,  commandLine  .  hasOption  (   "last "  )  )  ;  [METHOD]  isShortOption  [TYPE]  boolean  [PARAMETER]  String  token  [CLASS]  DefaultParser  [TYPE]  Options  options  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  skipParsing  stopAtNonOption  true  [TYPE]  Option  currentOption  [TYPE]  List  expectedOpts  [TYPE]  String  currentToken  token  [CONTEXT]  private  boolean  isShortOption  (  String  token  )  {  [BUGGY]  return  token  .  startsWith  (   "- "  )  &&  token  .  length  (  )  >  =  2  &&  options  .  hasShortOption  (  token  .  substring  (  1  ,  2  )  )  ;    }  	Cli_37_DefaultParser_1_1	302	1	src/main/java/org/apache/commons/cli/DefaultParser.java
854	if  (options.hasShortOption(optName))  {  return  true;  }  return  optName.length()  >  0  &&  options.hasShortOption(String.valueOf(optName.charAt(0)));  	[BUGGY]  return  options  .  hasShortOption  (  optName  )  ;  [FE]  AssertionFailedError:  expected  null  ,  but  was:<-ab>  assertFalse  (  commandLine  .  hasOption  (   "last "  )  )  ;  [METHOD]  isShortOption  [TYPE]  boolean  [PARAMETER]  String  token  [CLASS]  DefaultParser  [TYPE]  Options  options  [TYPE]  CommandLine  cmd  [TYPE]  boolean  false  skipParsing  stopAtNonOption  true  [TYPE]  Option  currentOption  [TYPE]  List  expectedOpts  [TYPE]  String  currentToken  optName  token  [TYPE]  int  pos  [CONTEXT]  private  boolean  isShortOption  (  String  token  )  {  if  (  !token  .  startsWith  (   "- "  )  ||  token  .  length  (  )  =  =  1  )  {  return  false  ;  }  int  pos  =  token  .  indexOf  (   "  =   "  )  ;  String  optName  =  pos  =  =  -1  ?  token  .  substring  (  1  )  :  token  .  substring  (  1  ,  pos  )  ;  [BUGGY]  return  options  .  hasShortOption  (  optName  )  ;  }  	Cli_38_DefaultParser_1_1	310	1	src/main/java/org/apache/commons/cli/DefaultParser.java
855	return  openFile(str);  	[BUGGY]  return  createFile  (  str  )  ;  [FE]  AssertionFailedError:  option  g  not  FileInputStream  assertNull  (   "option  f  parsed "  ,  line  .  getOptionObject  (   "f "  )  )  ;  [METHOD]  createValue  [TYPE]  Object  [PARAMETER]  String  str  Class<?>  clazz  [CLASS]  TypeHandler  [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  [CONTEXT]  {  return  str  ;  }  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  =  =  clazz  )  {  return  createObject  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  =  =  clazz  )  {  return  createNumber  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  DATE_VALUE  =  =  clazz  )  {  return  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  [BUGGY]  return  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  createFiles  (  str  )  ;  }  	Cli_39_TypeHandler_2_1	92	1	src/main/java/org/apache/commons/cli/TypeHandler.java
856	public  static  FileInputStream  openFile(String  str)  throws  ParseException  {  try  {  return  new  FileInputStream(str);  }  catch  (FileNotFoundException  e)  {  throw  new  ParseException( "Unable  to  find  file:   "  +  str);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  option  g  not  FileInputStream  assertNull  (   "option  f  parsed "  ,  line  .  getOptionObject  (   "f "  )  )  ;  [CLASS]  [CONTEXT]  	Cli_39_TypeHandler_2_2	234	0	src/main/java/org/apache/commons/cli/TypeHandler.java
857	throw  new  ParseException( "Unable  to  handle  the  class:   "  +  clazz);  	[BUGGY]  return  null  ;  [FE]  AssertionFailedError:  Expected  exception:  orgapachecommonscliParseException  [METHOD]  createValue  [TYPE]  <T>  [PARAMETER]  String  str  Class<T>  clazz  [CLASS]  TypeHandler  [TYPE]  boolean  false  true  [TYPE]  Class  clazz  [TYPE]  String  str  [CONTEXT]  {  return  (  T  )  createDate  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  =  =  clazz  )  {  return  (  T  )  createClass  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILE_VALUE  =  =  clazz  )  {  return  (  T  )  createFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  =  =  clazz  )  {  return  (  T  )  openFile  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  FILES_VALUE  =  =  clazz  )  {  return  (  T  )  createFiles  (  str  )  ;  }  else  if  (  PatternOptionBuilder  .  URL_VALUE  =  =  clazz  )  {  return  (  T  )  createURL  (  str  )  ;  }  else  {  [BUGGY]  return  null  ;  }  }    	Cli_40_TypeHandler_1_1	103	1	src/main/java/org/apache/commons/cli/TypeHandler.java
858	if  (lineLength  >  0  &&  pos  >  0)  {  	[BUGGY]  if  (  lineLength  >  0  )  {  [FE]  AssertionFailedError:  EOF  expected:<-1>  but  was:<13>  [METHOD]  encode  [TYPE]  void  [PARAMETER]  byte[]  in  int  inPos  int  inAvail  [CLASS]  Base64  [TYPE]  byte[]  CHUNK_SEPARATOR  DECODE_TABLE  STANDARD_ENCODE_TABLE  URL_SAFE_ENCODE_TABLE  buf  encodeTable  in  lineSeparator  [TYPE]  boolean  eof  false  true  [TYPE]  byte  PAD  [TYPE]  int  CHUNK_SIZE  MASK_6BITS  MASK_8BITS  b  currentLinePos  decodeSize  encodeSize  i  inAvail  inPos  lineLength  modulus  pos  readPos  x  [CONTEXT]  eof  =  true  ;  if  (  buf  =  =  null  ||  buf  .  length  -  pos  <  encodeSize  )  {  resizeBuf  (  )  ;  }  switch  (  modulus  )  {  case  1:  buf[pos++]  =  encodeTable[  (  x  >>  2  )  &  MASK_6BITS]  ;  buf[pos++]  =  encodeTable[  (  x  <<  4  )  &  MASK_6BITS]  ;  if  (  encodeTable  =  =  STANDARD_ENCODE_TABLE  )  {  buf[pos++]  =  PAD  ;  buf[pos++]  =  PAD  ;  }  break  ;  case  2:  buf[pos++]  =  encodeTable[  (  x  >>  10  )  &  MASK_6BITS]  ;  buf[pos++]  =  encodeTable[  (  x  >>  4  )  &  MASK_6BITS]  ;  buf[pos++]  =  encodeTable[  (  x  <<  2  )  &  MASK_6BITS]  ;  if  (  encodeTable  =  =  STANDARD_ENCODE_TABLE  )  {  buf[pos++]  =  PAD  ;  }  break  ;  }  [BUGGY]  if  (  lineLength  >  0  )  {  System  .  arraycopy  (  lineSeparator  ,  0  ,  buf  ,  pos  ,  lineSeparator  .  length  )  ;  pos  +  =  lineSeparator  .  length  ;  }  }  else  {  for  (  int  i  =  0  ;  i  <  inAvail  ;  i++  )  {  	Codec_2_Base64_1_1	446	1	src/java/org/apache/commons/codec/binary/Base64.java
859	}  else  if  (contains(value,  index  +  1,  3,   "IER "))  {\n',   "                                  result.append('J');\n "]  	[BUGGY]  [FE]  ComparisonFailure:  Test  [19]  =  Angier  expected:<AN[J]R>  but  was:<AN[K]R>  assertEquals  (   "Test  [ "  +  i  +   "]  =   "  +  value  ,  TEST_DATA[i][2]  ,  doubleMetaphone  .  doubleMetaphone  (  value  ,  true  )  )  ;  [METHOD]  handleG  [TYPE]  int  [PARAMETER]  String  value  DoubleMetaphoneResult  result  int  index  boolean  slavoGermanic  [CLASS]  DoubleMetaphone  [TYPE]  StringBuffer  alternate  primary  [TYPE]  String  VOWELS  value  [TYPE]  String[]  ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER  L_R_N_M_B_H_F_V_W_SPACE  L_T_K_S_N_M_B_Z  SILENT_START  [TYPE]  boolean  false  slavoGermanic  true  [TYPE]  int  index  maxCodeLen  maxLength  [TYPE]  DoubleMetaphoneResult  result  [CONTEXT]  }  else  {  result  .  append  (   "KN "  )  ;  }  index  =  index  +  2  ;  }  else  if  (  contains  (  value  ,  index  +  1  ,  2  ,   "LI "  )  &&  !slavoGermanic  )  {  result  .  append  (   "KL "  ,   "L "  )  ;  index  +  =  2  ;  }  else  if  (  index  =  =  0  &&  (  charAt  (  value  ,  index  +  1  )  =  =  'Y'  ||  contains  (  value  ,  index  +  1  ,  2  ,  ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER  )  )  )  {  result  .  append  (  'K'  ,  'J'  )  ;  index  +  =  2  ;  }  else  if  (  (  contains  (  value  ,  index  +  1  ,  2  ,   "ER "  )  ||  charAt  (  value  ,  index  +  1  )  =  =  'Y'  )  &&  !contains  (  value  ,  0  ,  6  ,   "DANGER "  ,   "RANGER "  ,   "MANGER "  )  &&  !contains  (  value  ,  index  -  1  ,  1  ,   "E "  ,   "I "  )  &&  !contains  (  value  ,  index  -  1  ,  3  ,   "RGY "  ,   "OGY "  )  )  {  result  .  append  (  'K'  ,  'J'  )  ;  index  +  =  2  ;  }  else  if  (  contains  (  value  ,  index  +  1  ,  1  ,   "E "  ,   "I "  ,   "Y "  )  ||  contains  (  value  ,  index  -  1  ,  4  ,   "AGGI "  ,   "OGGI "  )  )  {  if  (  (  contains  (  value  ,  0  ,  4  ,   "VAN   "  ,   "VON   "  )  ||  contains  (  value  ,  0  ,  3  ,   "SCH "  )  )  ||  contains  (  value  ,  index  +  1  ,  2  ,   "ET "  )  )  {  result  .  append  (  'K'  )  ;  [BUGGY]  }  else  if  (  contains  (  value  ,  index  +  1  ,  4  ,   "IER "  )  )  {  result  .  append  (  'J'  )  ;  }  else  {  result  .  append  (  'J'  ,  'K'  )  ;  }  index  +  =  2  ;  	Codec_3_DoubleMetaphone_1_1	455	0	src/java/org/apache/commons/codec/language/DoubleMetaphone.java
860	this(0);  	[BUGGY]  this  (  false  )  ;  [FE]  AssertionFailedError:  Encoder  test-1  assertTrue  (   "Encoder  test- "  +  i  ,  b  )  ;  [CLASS]  [CONTEXT]  	Codec_4_Base64_1_1	225	1	src/java/org/apache/commons/codec/binary/Base64.java
861	if  (buffer  ==  null  ||  buffer.length  -  pos  <  decodeSize)  {  resizeBuffer();  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  [METHOD]  decode  [TYPE]  void  [PARAMETER]  byte[]  in  int  inPos  int  inAvail  [CLASS]  Base64  [TYPE]  byte[]  CHUNK_SEPARATOR  DECODE_TABLE  STANDARD_ENCODE_TABLE  URL_SAFE_ENCODE_TABLE  buffer  encodeTable  in  lineSeparator  [TYPE]  boolean  eof  false  true  [TYPE]  byte  PAD  b  [TYPE]  int  DEFAULT_BUFFER_RESIZE_FACTOR  DEFAULT_BUFFER_SIZE  MASK_6BITS  MASK_8BITS  MIME_CHUNK_SIZE  PEM_CHUNK_SIZE  currentLinePos  decodeSize  encodeSize  i  inAvail  inPos  lineLength  modulus  pos  readPos  result  x  [CONTEXT]  byte  b  =  in[inPos++]  ;  if  (  b  =  =  PAD  )  {  eof  =  true  ;  break  ;  }  else  {  if  (  b  >  =  0  &&  b  <  DECODE_TABLE  .  length  )  {  int  result  =  DECODE_TABLE[b]  ;  if  (  result  >  =  0  )  {  modulus  =  (  ++modulus  )  %  4  ;  x  =  (  x  <<  6  )  +  result  ;  if  (  modulus  =  =  0  )  {  buffer[pos++]  =  (  byte  )    (  (  x  >>  16  )  &  MASK_8BITS  )  ;  buffer[pos++]  =  (  byte  )    (  (  x  >>  8  )  &  MASK_8BITS  )  ;  buffer[pos++]  =  (  byte  )    (  x  &  MASK_8BITS  )  ;  }  }  }  }  }    if  (  eof  &&  modulus  !  =  0  )  {  [BUGGY]  x  =  x  <<  6  ;  switch  (  modulus  )  {  case  2  :  x  =  x  <<  6  ;  buffer[pos++]  =  (  byte  )    (  (  x  >>  16  )  &  MASK_8BITS  )  ;  	Codec_5_Base64_1_1	586	0	src/java/org/apache/commons/codec/binary/Base64.java
862	int  readLen  =  0;  	[BUGGY]  [FE]  AssertionFailedError:  Codec101:  First  read  successful  [c  =  0]  assertTrue  (   "Codec101:  Second  read  should  report  end-of-stream  [c  =   "  +  c  +   "] "  ,  c  <  0  )  ;  [METHOD]  read  [TYPE]  int  [PARAMETER]  byte[]  b  int  offset  int  len  [CLASS]  Base64InputStream  [TYPE]  byte[]  b  buf  singleByte  [TYPE]  boolean  doEncode  false  true  [TYPE]  Base64  base64  [TYPE]  int  c  len  offset  [CONTEXT]  public  int  read  (  byte  b[]  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  b  =  =  null  )  {  throw  new  NullPointerException  (  )  ;  }  else  if  (  offset  <  0  ||  len  <  0  )  {  throw  new  IndexOutOfBoundsException  (  )  ;  }  else  if  (  offset  >  b  .  length  ||  offset  +  len  >  b  .  length  )  {  throw  new  IndexOutOfBoundsException  (  )  ;  }  else  if  (  len  =  =  0  )  {  return  0  ;  }  else  {  [BUGGY]  Rationale  for  while-loop  on  (  readLen  =  =  0  )  :  -----  Base64  .  readResults  (  )  usually  returns  >  0  or  EOF  (  -1  )  .  In  the  rare  case  where  it  returns  0  ,  we  just  keep  trying  .  	Codec_6_Base64InputStream_3_1	148	0	src/java/org/apache/commons/codec/binary/Base64InputStream.java
863	while  (readLen  ==  0)  {  	[BUGGY]  [FE]  AssertionFailedError:  Codec101:  First  read  successful  [c  =  0]  assertTrue  (   "Codec101:  Second  read  should  report  end-of-stream  [c  =   "  +  c  +   "] "  ,  c  <  0  )  ;  [METHOD]  read  [TYPE]  int  [PARAMETER]  byte[]  b  int  offset  int  len  [CLASS]  Base64InputStream  [TYPE]  byte[]  b  buf  singleByte  [TYPE]  boolean  doEncode  false  true  [TYPE]  Base64  base64  [TYPE]  int  c  len  offset  [CONTEXT]  if  (  b  =  =  null  )  {  throw  new  NullPointerException  (  )  ;  }  else  if  (  offset  <  0  ||  len  <  0  )  {  throw  new  IndexOutOfBoundsException  (  )  ;  }  else  if  (  offset  >  b  .  length  ||  offset  +  len  >  b  .  length  )  {  throw  new  IndexOutOfBoundsException  (  )  ;  }  else  if  (  len  =  =  0  )  {  return  0  ;  }  else  {  Rationale  for  while-loop  on  (  readLen  =  =  0  )  :  -----  Base64  .  readResults  (  )  usually  returns  >  0  or  EOF  (  -1  )  .  In  the  rare  case  where  it  returns  0  ,  we  just  keep  trying  .  This  is  essentially  an  undocumented  contract  for  InputStream  implementors  that  want  their  code  to  work  properly  with  java  .  io  .  InputStreamReader  ,  since  the  latter  hates  it  when  InputStream  .  read  (  byte[]  )  returns  a  zero  .  Unfortunately  our  readResults  (  )  call  must  return  0  if  a  large  amount  of  the  data  being  decoded  was  non-base64  ,  so  this  while-loop  enables  proper  interop  with  InputStreamReader  for  that  scenario  .  -----  This  is  a  fix  for  CODEC-101  [BUGGY]  if  (  !base64  .  hasData  (  )  )  {  byte[]  buf  =  new  byte[doEncode  ?  4096  :  8192]  ;  int  c  =  in  .  read  (  buf  )  ;    if  (  c  >  0  &&  b  .  length  =  =  len  )  {  	Codec_6_Base64InputStream_3_2	164	0	src/java/org/apache/commons/codec/binary/Base64InputStream.java
864	readLen  =  base64.readResults(b,  offset,  len);  }  return  readLen;  	[BUGGY]  return  base64  .  readResults  (  b  ,  offset  ,  len  )  ;  [FE]  AssertionFailedError:  Codec101:  First  read  successful  [c  =  0]  assertTrue  (   "Codec101:  Second  read  should  report  end-of-stream  [c  =   "  +  c  +   "] "  ,  c  <  0  )  ;  [METHOD]  read  [TYPE]  int  [PARAMETER]  byte[]  b  int  offset  int  len  [CLASS]  Base64InputStream  [TYPE]  byte[]  b  buf  singleByte  [TYPE]  boolean  doEncode  false  true  [TYPE]  Base64  base64  [TYPE]  int  c  len  offset  [CONTEXT]  This  is  essentially  an  undocumented  contract  for  InputStream  implementors  that  want  their  code  to  work  properly  with  java  .  io  .  InputStreamReader  ,  since  the  latter  hates  it  when  InputStream  .  read  (  byte[]  )  returns  a  zero  .  Unfortunately  our  readResults  (  )  call  must  return  0  if  a  large  amount  of  the  data  being  decoded  was  non-base64  ,  so  this  while-loop  enables  proper  interop  with  InputStreamReader  for  that  scenario  .  -----  This  is  a  fix  for  CODEC-101  if  (  !base64  .  hasData  (  )  )  {  byte[]  buf  =  new  byte[doEncode  ?  4096  :  8192]  ;  int  c  =  in  .  read  (  buf  )  ;    if  (  c  >  0  &&  b  .  length  =  =  len  )  {  base64  .  setInitialBuffer  (  b  ,  offset  ,  len  )  ;  }  if  (  doEncode  )  {  base64  .  encode  (  buf  ,  0  ,  c  )  ;  }  else  {  base64  .  decode  (  buf  ,  0  ,  c  )  ;  }  }  [BUGGY]  return  base64  .  readResults  (  b  ,  offset  ,  len  )  ;  }  }    	Codec_6_Base64InputStream_3_3	178	1	src/java/org/apache/commons/codec/binary/Base64InputStream.java
865	return  StringUtils.newStringUtf8(encodeBase64(binaryData,  false));  	[BUGGY]  return  StringUtils  .  newStringUtf8  (  encodeBase64  (  binaryData  ,  true  )  )  ;  [FE]  ComparisonFailure:  byteToString  static  Hello  World  expected:<SGVsbG8gV29ybGQ  =  []>  but  was:<SGVsbG8gV29ybGQ  =  [  assertEquals  (   "byteToString  static-url-safe  UUID "  ,   "K_fMJwH-Q5e0nr7tWsxwkA "  ,  Base64  .  encodeBase64URLSafeString  (  b4  )  )  ;  [METHOD]  encodeBase64String  [TYPE]  String  [PARAMETER]  byte[]  binaryData  [CLASS]  Base64  [TYPE]  byte[]  CHUNK_SEPARATOR  DECODE_TABLE  STANDARD_ENCODE_TABLE  URL_SAFE_ENCODE_TABLE  binaryData  buffer  encodeTable  lineSeparator  [TYPE]  boolean  eof  false  true  [TYPE]  byte  PAD  [TYPE]  int  DEFAULT_BUFFER_RESIZE_FACTOR  DEFAULT_BUFFER_SIZE  MASK_6BITS  MASK_8BITS  MIME_CHUNK_SIZE  PEM_CHUNK_SIZE  currentLinePos  decodeSize  encodeSize  lineLength  modulus  pos  readPos  x  [CONTEXT]  public  static  String  encodeBase64String  (  byte[]  binaryData  )  {  [BUGGY]  return  StringUtils  .  newStringUtf8  (  encodeBase64  (  binaryData  ,  true  )  )  ;  }  	Codec_7_Base64_1_1	670	1	src/java/org/apache/commons/codec/binary/Base64.java
866		[BUGGY]  void  setInitialBuffer  (  byte[]  out  ,  int  outPos  ,  int  outAvail  )  {  if  (  out  !  =  null  &&  out  .  length  =  =  outAvail  )  {  buffer  =  out  ;  pos  =  outPos  ;  readPos  =  outPos  ;  }  }  [FE]  ArrayIndexOutOfBoundsException:  2  [CLASS]  [CONTEXT]  	Codec_8_Base64_1_1	419	7	src/java/org/apache/commons/codec/binary/Base64.java
867		[BUGGY]  if  (  c  >  0  &&  b  .  length  =  =  len  )  {  base64  .  setInitialBuffer  (  b  ,  offset  ,  len  )  ;  }  [FE]  ArrayIndexOutOfBoundsException:  2  [METHOD]  read  [TYPE]  int  [PARAMETER]  byte[]  b  int  offset  int  len  [CLASS]  Base64InputStream  [TYPE]  byte[]  b  buf  singleByte  [TYPE]  boolean  doEncode  false  true  [TYPE]  Base64  base64  [TYPE]  int  c  len  offset  readLen  [CONTEXT]  throw  new  IndexOutOfBoundsException  (  )  ;  }  else  if  (  len  =  =  0  )  {  return  0  ;  }  else  {  int  readLen  =  0  ;  Rationale  for  while-loop  on  (  readLen  =  =  0  )  :  -----  Base64  .  readResults  (  )  usually  returns  >  0  or  EOF  (  -1  )  .  In  the  rare  case  where  it  returns  0  ,  we  just  keep  trying  .  This  is  essentially  an  undocumented  contract  for  InputStream  implementors  that  want  their  code  to  work  properly  with  java  .  io  .  InputStreamReader  ,  since  the  latter  hates  it  when  InputStream  .  read  (  byte[]  )  returns  a  zero  .  Unfortunately  our  readResults  (  )  call  must  return  0  if  a  large  amount  of  the  data  being  decoded  was  non-base64  ,  so  this  while-loop  enables  proper  interop  with  InputStreamReader  for  that  scenario  .  -----  This  is  a  fix  for  CODEC-101  while  (  readLen  =  =  0  )  {  if  (  !base64  .  hasData  (  )  )  {  byte[]  buf  =  new  byte[doEncode  ?  4096  :  8192]  ;  int  c  =  in  .  read  (  buf  )  ;  [BUGGY]  if  (  c  >  0  &&  b  .  length  =  =  len  )  {  base64  .  setInitialBuffer  (  b  ,  offset  ,  len  )  ;  }  if  (  doEncode  )  {  base64  .  encode  (  buf  ,  0  ,  c  )  ;  }  else  {  	Codec_8_Base64InputStream_1_1	169	3	src/java/org/apache/commons/codec/binary/Base64InputStream.java
868	long  len  =  getEncodeLength(binaryData,  isChunked  ?  MIME_CHUNK_SIZE  :  0,  CHUNK_SEPARATOR);  	[BUGGY]  long  len  =  getEncodeLength  (  binaryData  ,  MIME_CHUNK_SIZE  ,  CHUNK_SEPARATOR  )  ;  [FE]  IllegalArgumentException:  Input  array  too  big  ,  the  output  array  would  be  bigger  (  6  )  than  the  specified  maxium  size  of  4  [METHOD]  encodeBase64  [TYPE]  byte[]  [PARAMETER]  byte[]  binaryData  boolean  isChunked  boolean  urlSafe  int  maxResultSize  [CLASS]  Base64  [TYPE]  byte[]  CHUNK_SEPARATOR  DECODE_TABLE  STANDARD_ENCODE_TABLE  URL_SAFE_ENCODE_TABLE  binaryData  buffer  encodeTable  lineSeparator  [TYPE]  boolean  eof  false  isChunked  true  urlSafe  [TYPE]  Base64  b64  [TYPE]  byte  PAD  [TYPE]  int  DEFAULT_BUFFER_RESIZE_FACTOR  DEFAULT_BUFFER_SIZE  MASK_6BITS  MASK_8BITS  MIME_CHUNK_SIZE  PEM_CHUNK_SIZE  currentLinePos  decodeSize  encodeSize  lineLength  maxResultSize  modulus  pos  readPos  x  [TYPE]  long  len  [CONTEXT]  public  static  byte[]  encodeBase64  (  byte[]  binaryData  ,  boolean  isChunked  ,  boolean  urlSafe  ,  int  maxResultSize  )  {  if  (  binaryData  =  =  null  ||  binaryData  .  length  =  =  0  )  {  return  binaryData  ;  }  [BUGGY]  long  len  =  getEncodeLength  (  binaryData  ,  MIME_CHUNK_SIZE  ,  CHUNK_SEPARATOR  )  ;  if  (  len  >  maxResultSize  )  {  throw  new  IllegalArgumentException  (   "Input  array  too  big  ,  the  output  array  would  be  bigger  (   "  +  len  +   "  )  than  the  specified  maxium  size  of   "  +  maxResultSize  )  ;  }  Base64  b64  =  isChunked  ?  new  Base64  (  urlSafe  )  :  new  Base64  (  0  ,  CHUNK_SEPARATOR  ,  urlSafe  )  ;  return  b64  .  encode  (  binaryData  )  ;  }  	Codec_9_Base64_1_1	827	1	src/java/org/apache/commons/codec/binary/Base64.java
869	txt  =  txt.replaceAll( "mb$ ",   "m2 ");  	[BUGGY]  txt  =  txt  .  replaceAll  (   "^mb "  ,   "m2 "  )  ;  [FE]  ComparisonFailure:  Source:  mbmb  expected:<M[PM]1111111>  but  was:<M[MP]1111111>  [METHOD]  caverphone  [TYPE]  String  [PARAMETER]  String  txt  [CLASS]  Caverphone  [TYPE]  boolean  false  true  [TYPE]  String  txt  [CONTEXT]    if  (  txt  =  =  null  ||  txt  .  length  (  )  =  =  0  )  {  return   "1111111111 "  ;  }  txt  =  txt  .  toLowerCase  (  java  .  util  .  Locale  .  ENGLISH  )  ;    txt  =  txt  .  replaceAll  (   "[^a-z] "  ,   " "  )  ;    txt  =  txt  .  replaceAll  (   "e$ "  ,   " "  )  ;  //  2  .  0  only  txt  =  txt  .  replaceAll  (   "^cough "  ,   "cou2f "  )  ;  txt  =  txt  .  replaceAll  (   "^rough "  ,   "rou2f "  )  ;  txt  =  txt  .  replaceAll  (   "^tough "  ,   "tou2f "  )  ;  txt  =  txt  .  replaceAll  (   "^enough "  ,   "enou2f "  )  ;  //  2  .  0  only  txt  =  txt  .  replaceAll  (   "^trough "  ,   "trou2f "  )  ;  //  2  .  0  only  -  note  the  spec  says  ^enough  here  again  ,  c+p  error  I  assume  txt  =  txt  .  replaceAll  (   "^gn "  ,   "2n "  )  ;    [BUGGY]  txt  =  txt  .  replaceAll  (   "^mb "  ,   "m2 "  )  ;    txt  =  txt  .  replaceAll  (   "cq "  ,   "2q "  )  ;  txt  =  txt  .  replaceAll  (   "ci "  ,   "si "  )  ;  txt  =  txt  .  replaceAll  (   "ce "  ,   "se "  )  ;  	Codec_10_Caverphone_1_1	76	1	src/java/org/apache/commons/codec/language/Caverphone.java
870	private  static  final  byte  CR  =  13;  private  static  final  byte  LF  =  10;  private  static  final  int  SAFE_LENGTH  =  73;  	[BUGGY]  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [CLASS]  [CONTEXT]  	Codec_11_QuotedPrintableCodec_11_1	70	0	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
871	private  static  final  int  encodeQuotedPrintable(int  b,  ByteArrayOutputStream  buffer)  {  	[BUGGY]  private  static  final  void  encodeQuotedPrintable  (  int  b  ,  ByteArrayOutputStream  buffer  )  {  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [CLASS]  [CONTEXT]  	Codec_11_QuotedPrintableCodec_11_2	114	1	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
872	return  3;  	[BUGGY]  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [CLASS]  [CONTEXT]  	Codec_11_QuotedPrintableCodec_11_3	120	0	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
873	private  static  int  getUnsignedOctet(final  int  index,  final  byte[]  bytes)  {  int  b  =  bytes[index];  if  (b  <  0)  {  b  =  256  +  b;  }  return  b;  }  	[BUGGY]  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [CLASS]  [CONTEXT]  	Codec_11_QuotedPrintableCodec_11_4	132	0	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
874	private  static  int  encodeByte(final  int  b,  final  boolean  encode,  final  ByteArrayOutputStream  buffer)  {  if  (encode)  {  return  encodeQuotedPrintable(b,  buffer);  }  else  {  buffer.write(b);  return  1;  }  }  	[BUGGY]  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [CLASS]  [CONTEXT]  	Codec_11_QuotedPrintableCodec_11_5	144	0	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
875	private  static  boolean  isWhitespace(final  int  b)  {  return  b  ==  SPACE  ||  b  ==  TAB;  }  	[BUGGY]  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [CLASS]  [CONTEXT]  	Codec_11_QuotedPrintableCodec_11_6	152	0	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
876	int  pos  =  1;  for  (int  i  =  0;  i  <  bytes.length  -  3;  i++)  {  int  b  =  getUnsignedOctet(i,  bytes);  if  (pos  <  SAFE_LENGTH)  {  pos  +=  encodeByte(b,  !printable.get(b),  buffer);  encodeByte(b,  !printable.get(b)  ||  isWhitespace(b),  buffer);  buffer.write(ESCAPE_CHAR);  buffer.write(CR);  buffer.write(LF);  pos  =  1;  	[BUGGY]  for  (  byte  c  :  bytes  )  {  int  b  =  c  ;  if  (  b  <  0  )  {  b  =  256  +  b  ;  }  if  (  printable  .  get  (  b  )  )  {  buffer  .  write  (  b  )  ;  encodeQuotedPrintable  (  b  ,  buffer  )  ;  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [METHOD]  encodeQuotedPrintable  [TYPE]  byte[]  [PARAMETER]  BitSet  printable  byte[]  bytes  [CLASS]  QuotedPrintableCodec  [TYPE]  byte[]  bytes  [TYPE]  boolean  false  true  [TYPE]  byte  ESCAPE_CHAR  SPACE  TAB  c  [TYPE]  BitSet  PRINTABLE_CHARS  printable  [TYPE]  String  charset  [TYPE]  ByteArrayOutputStream  buffer  [TYPE]  int  b  [CONTEXT]  public  static  final  byte[]  encodeQuotedPrintable  (  BitSet  printable  ,  byte[]  bytes  )  {  if  (  bytes  =  =  null  )  {  return  null  ;  }  if  (  printable  =  =  null  )  {  printable  =  PRINTABLE_CHARS  ;  }  ByteArrayOutputStream  buffer  =  new  ByteArrayOutputStream  (  )  ;  [BUGGY]    for  (  byte  c  :  bytes  )  {  int  b  =  c  ;  if  (  b  <  0  )  {  	Codec_11_QuotedPrintableCodec_11_7	175	8	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
877	int  b  =  getUnsignedOctet(bytes.length  -  3,  bytes);  boolean  encode  =  !printable.get(b)  ||  (isWhitespace(b)  &&  pos  >  SAFE_LENGTH  -  5);  pos  +=  encodeByte(b,  encode,  buffer);  	[BUGGY]  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [METHOD]  encodeQuotedPrintable  [TYPE]  byte[]  [PARAMETER]  BitSet  printable  byte[]  bytes  [CLASS]  QuotedPrintableCodec  [TYPE]  byte[]  bytes  [TYPE]  boolean  false  true  [TYPE]  byte  ESCAPE_CHAR  SPACE  TAB  c  [TYPE]  BitSet  PRINTABLE_CHARS  printable  [TYPE]  String  charset  [TYPE]  ByteArrayOutputStream  buffer  [TYPE]  int  b  [CONTEXT]  }  if  (  printable  =  =  null  )  {  printable  =  PRINTABLE_CHARS  ;  }  ByteArrayOutputStream  buffer  =  new  ByteArrayOutputStream  (  )  ;    for  (  byte  c  :  bytes  )  {  int  b  =  c  ;  if  (  b  <  0  )  {  b  =  256  +  b  ;  }  if  (  printable  .  get  (  b  )  )  {  buffer  .  write  (  b  )  ;  }  else  {    encodeQuotedPrintable  (  b  ,  buffer  )  ;  }  }    [BUGGY]      	Codec_11_QuotedPrintableCodec_11_8	195	0	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
878	if  (pos  >  SAFE_LENGTH  -  2)  {  buffer.write(ESCAPE_CHAR);  buffer.write(CR);  buffer.write(LF);  }  for  (int  i  =  bytes.length  -  2;  i  <  bytes.length;  i++)  {  b  =  getUnsignedOctet(i,  bytes);  encode  =  !printable.get(b)  ||  (i  >  bytes.length  -  2  &&  isWhitespace(b));  encodeByte(b,  encode,  buffer);  }  	[BUGGY]  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [METHOD]  encodeQuotedPrintable  [TYPE]  byte[]  [PARAMETER]  BitSet  printable  byte[]  bytes  [CLASS]  QuotedPrintableCodec  [TYPE]  byte[]  bytes  [TYPE]  boolean  false  true  [TYPE]  byte  ESCAPE_CHAR  SPACE  TAB  c  [TYPE]  BitSet  PRINTABLE_CHARS  printable  [TYPE]  String  charset  [TYPE]  ByteArrayOutputStream  buffer  [TYPE]  int  b  [CONTEXT]  ByteArrayOutputStream  buffer  =  new  ByteArrayOutputStream  (  )  ;    for  (  byte  c  :  bytes  )  {  int  b  =  c  ;  if  (  b  <  0  )  {  b  =  256  +  b  ;  }  if  (  printable  .  get  (  b  )  )  {  buffer  .  write  (  b  )  ;  }  else  {    encodeQuotedPrintable  (  b  ,  buffer  )  ;  }  }        [BUGGY]  return  buffer  .  toByteArray  (  )  ;  }  	Codec_11_QuotedPrintableCodec_11_9	199	0	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
879	if  (bytes[++i]  ==  CR)  {  continue;  }  int  u  =  Utils.digit16(bytes[i]);  	[BUGGY]  int  u  =  Utils  .  digit16  (  bytes[++i]  )  ;  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [METHOD]  decodeQuotedPrintable  [TYPE]  byte[]  [PARAMETER]  byte[]  bytes  [CLASS]  QuotedPrintableCodec  [TYPE]  byte[]  bytes  [TYPE]  boolean  false  true  [TYPE]  byte  ESCAPE_CHAR  SPACE  TAB  [TYPE]  BitSet  PRINTABLE_CHARS  [TYPE]  String  charset  [TYPE]  ByteArrayOutputStream  buffer  [TYPE]  ArrayIndexOutOfBoundsException  e  [TYPE]  int  b  i  l  u  [CONTEXT]  public  static  final  byte[]  decodeQuotedPrintable  (  byte[]  bytes  )  throws  DecoderException  {  if  (  bytes  =  =  null  )  {  return  null  ;  }  ByteArrayOutputStream  buffer  =  new  ByteArrayOutputStream  (  )  ;  for  (  int  i  =  0  ;  i  <  bytes  .  length  ;  i++  )  {  final  int  b  =  bytes[i]  ;  if  (  b  =  =  ESCAPE_CHAR  )  {  try  {  [BUGGY]  int  u  =  Utils  .  digit16  (  bytes[++i]  )  ;  int  l  =  Utils  .  digit16  (  bytes[++i]  )  ;  buffer  .  write  (  (  char  )    (  (  u  <<  4  )  +  l  )  )  ;  }  catch  (  ArrayIndexOutOfBoundsException  e  )  {  throw  new  DecoderException  (   "Invalid  quoted-printable  encoding "  ,  e  )  ;  }  }  else  {  buffer  .  write  (  b  )  ;  }  }  return  buffer  .  toByteArray  (  )  ;  }  	Codec_11_QuotedPrintableCodec_11_10	229	1	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
880	}  else  if  (b  !=  CR  &&  b  !=  LF)  {  	[BUGGY]  }  else  {  [FE]  commonscodecDecoderException:  Invalid  URL  encoding:  not  a  valid  digit  (  radix  16  )  :  13  assertEquals  (  expected  ,  qpcodec  .  decode  (  encoded  )  )  ;  [METHOD]  decodeQuotedPrintable  [TYPE]  byte[]  [PARAMETER]  byte[]  bytes  [CLASS]  QuotedPrintableCodec  [TYPE]  byte[]  bytes  [TYPE]  boolean  false  true  [TYPE]  byte  ESCAPE_CHAR  SPACE  TAB  [TYPE]  BitSet  PRINTABLE_CHARS  [TYPE]  String  charset  [TYPE]  ByteArrayOutputStream  buffer  [TYPE]  ArrayIndexOutOfBoundsException  e  [TYPE]  int  b  i  l  u  [CONTEXT]  public  static  final  byte[]  decodeQuotedPrintable  (  byte[]  bytes  )  throws  DecoderException  {  if  (  bytes  =  =  null  )  {  return  null  ;  }  ByteArrayOutputStream  buffer  =  new  ByteArrayOutputStream  (  )  ;  for  (  int  i  =  0  ;  i  <  bytes  .  length  ;  i++  )  {  final  int  b  =  bytes[i]  ;  if  (  b  =  =  ESCAPE_CHAR  )  {  try  {  int  u  =  Utils  .  digit16  (  bytes[++i]  )  ;  int  l  =  Utils  .  digit16  (  bytes[++i]  )  ;  buffer  .  write  (  (  char  )    (  (  u  <<  4  )  +  l  )  )  ;  }  catch  (  ArrayIndexOutOfBoundsException  e  )  {  throw  new  DecoderException  (   "Invalid  quoted-printable  encoding "  ,  e  )  ;  }  [BUGGY]  }  else  {  buffer  .  write  (  b  )  ;  }  }  return  buffer  .  toByteArray  (  )  ;  }  	Codec_11_QuotedPrintableCodec_11_11	235	1	src/main/java/org/apache/commons/codec/net/QuotedPrintableCodec.java
881	@Override  public  long  skip(long  n)  throws  IOException  {  if  (n  <  0)  {  throw  new  IllegalArgumentException( "Negative  skip  length ");  }  final  byte[]  b  =  new  byte[512];  final  int  max  =  (int)  Math.min(n,  Integer.MAX_VALUE);  int  total  =  0;  while  (total  <  max)  {  int  len  =  max  -  total;  if  (len  >  b.length)  {  len  =  b.length;  }  len  =  read(b,  0,  len);  if  (len  ==  EOF)  {  break;  }  total  +=  len;  }    return  total;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<-1>  but  was:<183>  assertEquals  (  -1  ,  b32stream  .  read  (  )  )  ;  [CLASS]  [CONTEXT]  	Codec_12_BaseNCodecInputStream_3_1	142	0	src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
882	public  int  available()  throws  IOException  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<-1>  but  was:<183>  assertEquals  (  -1  ,  b32stream  .  read  (  )  )  ;  [CLASS]  [CONTEXT]  	Codec_12_BaseNCodecInputStream_3_2	152	0	src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
883	if  (baseNCodec.eof)  {  return  0;  }  else  {  return  1;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<-1>  but  was:<183>  assertEquals  (  -1  ,  b32stream  .  read  (  )  )  ;  [CLASS]  [CONTEXT]  	Codec_12_BaseNCodecInputStream_3_3	158	0	src/main/java/org/apache/commons/codec/binary/BaseNCodecInputStream.java
884	private  static  final  String  LANGUAGE_RULES_RN  =   "org/apache/commons/codec/language/bm/%s_lang.txt ";  	[BUGGY]  private  static  final  String  LANGUAGE_RULES_RN  =   "org/apache/commons/codec/language/bm/lang  .  txt "  ;  [FE]  AssertionFailedError:  expected:<dzn|bntsn|bnzn|vndzn[]>  but  was:<dzn|bntsn|bnzn|vndzn[|vntsn]>  assertEquals  (  encode  (  args  ,  true  ,   "Halpern "  )  ,   "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn "  )  ;  [CLASS]  [CONTEXT]  	Codec_14_Lang_2_1	98	1	src/main/java/org/apache/commons/codec/language/bm/Lang.java
885	Langs.put(s,  loadFromResource(String.format(LANGUAGE_RULES_RN,  s.getName()),  Languages.getInstance(s)));  	[BUGGY]  Langs  .  put  (  s  ,  loadFromResource  (  LANGUAGE_RULES_RN  ,  Languages  .  getInstance  (  s  )  )  )  ;  [FE]  AssertionFailedError:  expected:<dzn|bntsn|bnzn|vndzn[]>  but  was:<dzn|bntsn|bnzn|vndzn[|vntsn]>  assertEquals  (  encode  (  args  ,  true  ,   "Halpern "  )  ,   "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn "  )  ;  [CLASS]  [CONTEXT]  	Codec_14_Lang_2_2	102	1	src/main/java/org/apache/commons/codec/language/bm/Lang.java
886		[BUGGY]  [FE]  AssertionFailedError:  expected:<dzn|bntsn|bnzn|vndzn[]>  but  was:<dzn|bntsn|bnzn|vndzn[|vntsn]>  assertEquals  (  encode  (  args  ,  true  ,   "Halpern "  )  ,   "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn "  )  ;  [CLASS]  [CONTEXT]  	Codec_14_PhoneticEngine_3_1	31	0	src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java
887	final  Map<Rule.Phoneme,  Rule.Phoneme>  phonemes  =  new  TreeMap<Rule.Phoneme,  Rule.Phoneme>(Rule.Phoneme.COMPARATOR);  	[BUGGY]  final  Set<Rule  .  Phoneme>  phonemes  =  new  TreeSet<Rule  .  Phoneme>  (  Rule  .  Phoneme  .  COMPARATOR  )  ;  [FE]  AssertionFailedError:  expected:<dzn|bntsn|bnzn|vndzn[]>  but  was:<dzn|bntsn|bnzn|vndzn[|vntsn]>  assertEquals  (  encode  (  args  ,  true  ,   "Halpern "  )  ,   "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn "  )  ;  [METHOD]  applyFinalRules  [TYPE]  PhoneticEngine$PhonemeBuilder  [PARAMETER]  PhonemeBuilder  phonemeBuilder  Rule>>  finalRules  [CLASS]  PhoneticEngine  [TYPE]  PhonemeBuilder  phonemeBuilder  subBuilder  [TYPE]  Set  phonemes  [TYPE]  boolean  concat  false  found  true  [TYPE]  RulesApplication  rulesApplication  [TYPE]  CharSequence  input  [TYPE]  Lang  lang  [TYPE]  NameType  nameType  [TYPE]  RuleType  ruleType  [TYPE]  String  phonemeText  [TYPE]  Phoneme  phoneme  [TYPE]  Map  NAME_PREFIXES  finalRules  [TYPE]  int  DEFAULT_MAX_PHONEMES  i  maxPhonemes  [CONTEXT]  private  PhonemeBuilder  applyFinalRules  (  final  PhonemeBuilder  phonemeBuilder  ,  final  Map<String  ,  List<Rule>>  finalRules  )  {  if  (  finalRules  =  =  null  )  {  throw  new  NullPointerException  (   "finalRules  can  not  be  null "  )  ;  }  if  (  finalRules  .  isEmpty  (  )  )  {  return  phonemeBuilder  ;  }  [BUGGY]  final  Set<Rule  .  Phoneme>  phonemes  =  new  TreeSet<Rule  .  Phoneme>  (  Rule  .  Phoneme  .  COMPARATOR  )  ;  for  (  final  Rule  .  Phoneme  phoneme  :  phonemeBuilder  .  getPhonemes  (  )  )  {  PhonemeBuilder  subBuilder  =  PhonemeBuilder  .  empty  (  phoneme  .  getLanguages  (  )  )  ;  final  String  phonemeText  =  phoneme  .  getPhonemeText  (  )  .  toString  (  )  ;  	Codec_14_PhoneticEngine_3_2	338	1	src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java
888	for  (final  Rule.Phoneme  newPhoneme  :  subBuilder.getPhonemes())  {  if  (phonemes.containsKey(newPhoneme))  {  final  Rule.Phoneme  oldPhoneme  =  phonemes.remove(newPhoneme);  final  Rule.Phoneme  mergedPhoneme  =  oldPhoneme.mergeWithLanguage(newPhoneme.getLanguages());  phonemes.put(mergedPhoneme,  mergedPhoneme);  }  else  {  phonemes.put(newPhoneme,  newPhoneme);  }  }  return  new  PhonemeBuilder(phonemes.keySet());  	[BUGGY]  phonemes  .  addAll  (  subBuilder  .  getPhonemes  (  )  )  ;  return  new  PhonemeBuilder  (  phonemes  )  ;  [FE]  AssertionFailedError:  expected:<dzn|bntsn|bnzn|vndzn[]>  but  was:<dzn|bntsn|bnzn|vndzn[|vntsn]>  assertEquals  (  encode  (  args  ,  true  ,   "Halpern "  )  ,   "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn "  )  ;  [METHOD]  applyFinalRules  [TYPE]  PhoneticEngine$PhonemeBuilder  [PARAMETER]  PhonemeBuilder  phonemeBuilder  Rule>>  finalRules  [CLASS]  PhoneticEngine  [TYPE]  PhonemeBuilder  phonemeBuilder  subBuilder  [TYPE]  Set  phonemes  [TYPE]  boolean  concat  false  found  true  [TYPE]  RulesApplication  rulesApplication  [TYPE]  CharSequence  input  [TYPE]  Lang  lang  [TYPE]  NameType  nameType  [TYPE]  RuleType  ruleType  [TYPE]  String  phonemeText  [TYPE]  Phoneme  phoneme  [TYPE]  Map  NAME_PREFIXES  finalRules  [TYPE]  int  DEFAULT_MAX_PHONEMES  i  maxPhonemes  [CONTEXT]  }  final  Set<Rule  .  Phoneme>  phonemes  =  new  TreeSet<Rule  .  Phoneme>  (  Rule  .  Phoneme  .  COMPARATOR  )  ;  for  (  final  Rule  .  Phoneme  phoneme  :  phonemeBuilder  .  getPhonemes  (  )  )  {  PhonemeBuilder  subBuilder  =  PhonemeBuilder  .  empty  (  phoneme  .  getLanguages  (  )  )  ;  final  String  phonemeText  =  phoneme  .  getPhonemeText  (  )  .  toString  (  )  ;  for  (  int  i  =  0  ;  i  <  phonemeText  .  length  (  )  ;  )  {  final  RulesApplication  rulesApplication  =  new  RulesApplication  (  finalRules  ,  phonemeText  ,  subBuilder  ,  i  ,  maxPhonemes  )  .  invoke  (  )  ;  final  boolean  found  =  rulesApplication  .  isFound  (  )  ;  subBuilder  =  rulesApplication  .  getPhonemeBuilder  (  )  ;  if  (  !found  )  {  subBuilder  .  append  (  phonemeText  .  subSequence  (  i  ,  i  +  1  )  )  ;  }  i  =  rulesApplication  .  getI  (  )  ;  }    [BUGGY]  phonemes  .  addAll  (  subBuilder  .  getPhonemes  (  )  )  ;  }  return  new  PhonemeBuilder  (  phonemes  )  ;  }  	Codec_14_PhoneticEngine_3_3	361	2	src/main/java/org/apache/commons/codec/language/bm/PhoneticEngine.java
889	public  Phoneme  mergeWithLanguage(final  LanguageSet  lang)  {  return  new  Phoneme(this.phonemeText.toString(),  this.languages.merge(lang));  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<dzn|bntsn|bnzn|vndzn[]>  but  was:<dzn|bntsn|bnzn|vndzn[|vntsn]>  assertEquals  (  encode  (  args  ,  true  ,   "Halpern "  )  ,   "YlpYrn|Ylpirn|alpYrn|alpirn|olpYrn|olpirn|xalpirn|xolpirn "  )  ;  [CLASS]  [CONTEXT]  	Codec_14_Rule_1_1	158	0	src/main/java/org/apache/commons/codec/language/bm/Rule.java
890	final  char  prevChar  =  str.charAt(i);  if  (this.map(prevChar)==mappedChar)  {  }  	[BUGGY]  final  char  firstCode  =  this  .  map  (  preHWChar  )  ;  \n'  ,   "-        if  (  firstCode  =  =  mappedChar  ||  'H'  =  =  preHWChar  ||  'W'  =  =  preHWChar  )  {\n "  ,  '+      for  (  int  i  =  index-1  ;  i>  =  0  ;  i--  )  {  [FE]  AssertionFailedError:  expected:<Y3[3]0>  but  was:<Y3[0]0>  Assert  .  assertEquals  (   "Y330 "  ,  this  .  getStringEncoder  (  )  .  encode  (   "yhwdyt "  )  )  ;  [METHOD]  getMappingCode  [TYPE]  char  [PARAMETER]  String  str  final  int  index  [CLASS]  Soundex  [TYPE]  char  firstCode  hwChar  mappedChar  preHWChar  [TYPE]  Soundex  US_ENGLISH  [TYPE]  String  US_ENGLISH_MAPPING_STRING  str  [TYPE]  boolean  false  true  [TYPE]  int  index  maxLength  [TYPE]  char[]  US_ENGLISH_MAPPING  soundexMapping  [CONTEXT]  private  char  getMappingCode  (  final  String  str  ,  final  int  index  )  {  final  char  mappedChar  =  this  .  map  (  str  .  charAt  (  index  )  )  ;  if  (  index  >  1  &&  mappedChar  !  =  '0'  )  {  [BUGGY]  final  char  hwChar  =  str  .  charAt  (  index  -  1  )  ;  if  (  'H'  =  =  hwChar  ||  'W'  =  =  hwChar  )  {  final  char  preHWChar  =  str  .  charAt  (  index  -  2  )  ;  final  char  firstCode  =  this  .  map  (  preHWChar  )  ;  if  (  firstCode  =  =  mappedChar  ||  'H'  =  =  preHWChar  ||  'W'  =  =  preHWChar  )  {  return  0  ;  }  }  }  return  mappedChar  ;  }  	Codec_15_Soundex_1_1	188	1	src/main/java/org/apache/commons/codec/language/Soundex.java
891	25,  26,  27,  28,  29,  30,  31,                                                                            	[BUGGY]  25  ,  26  ,  27  ,  28  ,  29  ,  30  ,  31  ,  32  ,  [FE]  IllegalArgumentException:  pad  must  not  be  in  alphabet  or  whitespace  assertNotNull  (  codec  )  ;  [CLASS]  [CONTEXT]  	Codec_16_Base32_1_1	99	1	src/main/java/org/apache/commons/codec/binary/Base32.java
892	return  newString(bytes,  Charsets.ISO_8859_1);  	[BUGGY]  return  new  String  (  bytes  ,  Charsets  .  ISO_8859_1  )  ;  [FE]  NullPointerException  Assert  .  assertNull  (  StringUtils  .  newStringUtf16Le  (  null  )  )  ;  [METHOD]  newStringIso8859_1  [TYPE]  String  [PARAMETER]  final  byte[]  bytes  [CLASS]  StringUtils  [TYPE]  byte[]  bytes  [TYPE]  boolean  false  true  [CONTEXT]  public  static  String  newStringIso8859_1  (  final  byte[]  bytes  )  {  [BUGGY]  return  new  String  (  bytes  ,  Charsets  .  ISO_8859_1  )  ;  }  	Codec_17_StringUtils_1_1	339	1	src/main/java/org/apache/commons/codec/binary/StringUtils.java
893	return  cs1.length()  ==  cs2.length()  &&  CharSequenceUtils.regionMatches(cs1,  false,  0,  cs2,  0,  cs1.length());  	[BUGGY]  return  CharSequenceUtils  .  regionMatches  (  cs1  ,  false  ,  0  ,  cs2  ,  0  ,  Math  .  max  (  cs1  .  length  (  )  ,  cs2  .  length  (  )  )  )  ;  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  3  Assert  .  assertFalse  (  StringUtils  .  equals  (  new  StringBuilder  (   "abc "  )  ,  new  StringBuilder  (   "ABC "  )  )  )  ;  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  CharSequence  cs1  CharSequence  cs2  [CLASS]  StringUtils  [TYPE]  boolean  false  true  [TYPE]  CharSequence  cs1  cs2  [CONTEXT]  public  static  boolean  equals  (  final  CharSequence  cs1  ,  final  CharSequence  cs2  )  {  if  (  cs1  =  =  cs2  )  {  return  true  ;  }  if  (  cs1  =  =  null  ||  cs2  =  =  null  )  {  return  false  ;  }  if  (  cs1  instanceof  String  &&  cs2  instanceof  String  )  {  return  cs1  .  equals  (  cs2  )  ;  }  [BUGGY]  return  CharSequenceUtils  .  regionMatches  (  cs1  ,  false  ,  0  ,  cs2  ,  0  ,  Math  .  max  (  cs1  .  length  (  )  ,  cs2  .  length  (  )  )  )  ;  }  	Codec_18_StringUtils_1_1	81	1	src/main/java/org/apache/commons/codec/binary/StringUtils.java
894	private  ArArchiveEntry  currentEntry  =  null;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [CLASS]  [CONTEXT]  	Compress_2_ArArchiveInputStream_9_1	42	0	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
895	private  long  entryOffset  =  -1;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [CLASS]  [CONTEXT]  	Compress_2_ArArchiveInputStream_9_2	46	0	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
896	if  (currentEntry  !=  null)  {  final  long  entryEnd  =  entryOffset  +  currentEntry.getLength();  while  (offset  <  entryEnd)  {  int  x  =  read();  if  (x  ==  -1)  {  return  null;  }  }  currentEntry  =  null;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [METHOD]  getNextArEntry  [TYPE]  ArArchiveEntry  [PARAMETER]  [CLASS]  ArArchiveInputStream  [TYPE]  byte[]  expected  filemode  groupid  lastmodified  length  name  realized  userid  [TYPE]  boolean  closed  false  true  [TYPE]  InputStream  input  [TYPE]  long  offset  [TYPE]  int  i  read  [CONTEXT]  public  ArArchiveEntry  getNextArEntry  (  )  throws  IOException  {  [BUGGY]    if  (  offset  =  =  0  )  {  final  byte[]  expected  =  ArArchiveEntry  .  HEADER  .  getBytes  (  )  ;  final  byte[]  realized  =  new  byte[expected  .  length]  ;  	Compress_2_ArArchiveInputStream_9_3	60	0	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
897	if  (offset  %  2  !=  0)  {  if  (read()  <  0)  {  return  null;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [METHOD]  getNextArEntry  [TYPE]  ArArchiveEntry  [PARAMETER]  [CLASS]  ArArchiveInputStream  [TYPE]  byte[]  expected  filemode  groupid  lastmodified  length  name  realized  userid  [TYPE]  boolean  closed  false  true  [TYPE]  InputStream  input  [TYPE]  long  offset  [TYPE]  int  i  read  [CONTEXT]  public  ArArchiveEntry  getNextArEntry  (  )  throws  IOException  {    if  (  offset  =  =  0  )  {  final  byte[]  expected  =  ArArchiveEntry  .  HEADER  .  getBytes  (  )  ;  final  byte[]  realized  =  new  byte[expected  .  length]  ;  final  int  read  =  read  (  realized  )  ;  if  (  read  !  =  expected  .  length  )  {  throw  new  IOException  (   "failed  to  read  header "  )  ;  }  for  (  int  i  =  0  ;  i  <  expected  .  length  ;  i++  )  {  if  (  expected[i]  !  =  realized[i]  )  {  throw  new  IOException  (   "invalid  header   "  +  new  String  (  realized  )  )  ;  }  }  }  [BUGGY]  if  (  input  .  available  (  )  =  =  0  )  {  return  null  ;  }  	Compress_2_ArArchiveInputStream_9_4	77	0	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
898		[BUGGY]  if  (  offset  %  2  !  =  0  )  {  read  (  )  ;  }  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [METHOD]  getNextArEntry  [TYPE]  ArArchiveEntry  [PARAMETER]  [CLASS]  ArArchiveInputStream  [TYPE]  byte[]  expected  filemode  groupid  lastmodified  length  name  realized  userid  [TYPE]  boolean  closed  false  true  [TYPE]  InputStream  input  [TYPE]  long  offset  [TYPE]  int  i  read  [CONTEXT]  public  ArArchiveEntry  getNextArEntry  (  )  throws  IOException  {    if  (  offset  =  =  0  )  {  final  byte[]  expected  =  ArArchiveEntry  .  HEADER  .  getBytes  (  )  ;  final  byte[]  realized  =  new  byte[expected  .  length]  ;  final  int  read  =  read  (  realized  )  ;  if  (  read  !  =  expected  .  length  )  {  throw  new  IOException  (   "failed  to  read  header "  )  ;  }  for  (  int  i  =  0  ;  i  <  expected  .  length  ;  i++  )  {  if  (  expected[i]  !  =  realized[i]  )  {  throw  new  IOException  (   "invalid  header   "  +  new  String  (  realized  )  )  ;  }  }  }    if  (  input  .  available  (  )  =  =  0  )  {  return  null  ;  }  [BUGGY]  if  (  offset  %  2  !  =  0  )  {  read  (  )  ;  }  final  byte[]  name  =  new  byte[16]  ;  final  byte[]  lastmodified  =  new  byte[12]  ;  final  byte[]  userid  =  new  byte[6]  ;  	Compress_2_ArArchiveInputStream_9_5	83	3	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
899	entryOffset  =  offset;  currentEntry  =  new  ArArchiveEntry(new  String(name).trim(),  return  currentEntry;  	[BUGGY]  return  new  ArArchiveEntry  (  new  String  (  name  )  .  trim  (  )  ,  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [METHOD]  getNextArEntry  [TYPE]  ArArchiveEntry  [PARAMETER]  [CLASS]  ArArchiveInputStream  [TYPE]  byte[]  expected  filemode  groupid  lastmodified  length  name  realized  userid  [TYPE]  boolean  closed  false  true  [TYPE]  InputStream  input  [TYPE]  long  offset  [TYPE]  int  i  read  [CONTEXT]  final  byte[]  groupid  =  new  byte[6]  ;  final  byte[]  filemode  =  new  byte[8]  ;  final  byte[]  length  =  new  byte[10]  ;  read  (  name  )  ;  read  (  lastmodified  )  ;  read  (  userid  )  ;  read  (  groupid  )  ;  read  (  filemode  )  ;  read  (  length  )  ;  {  final  byte[]  expected  =  ArArchiveEntry  .  TRAILER  .  getBytes  (  )  ;  final  byte[]  realized  =  new  byte[expected  .  length]  ;  final  int  read  =  read  (  realized  )  ;  if  (  read  !  =  expected  .  length  )  {  throw  new  IOException  (   "failed  to  read  entry  header "  )  ;  }  for  (  int  i  =  0  ;  i  <  expected  .  length  ;  i++  )  {  if  (  expected[i]  !  =  realized[i]  )  {  throw  new  IOException  (   "invalid  entry  header  .  not  read  the  content? "  )  ;  }  }  }  [BUGGY]  return  new  ArArchiveEntry  (  new  String  (  name  )  .  trim  (  )  ,  Long  .  parseLong  (  new  String  (  length  )    .  trim  (  )  )  )  ;  }  	Compress_2_ArArchiveInputStream_9_6	114	1	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
900	currentEntry  =  null;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [CLASS]  [CONTEXT]  	Compress_2_ArArchiveInputStream_9_7	129	0	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
901	byte[]  single  =  new  byte[1];  int  num  =  read(single,  0,  1);  return  num  ==  -1  ?  -1  :  single[0]  &  0xff;  	[BUGGY]  final  int  ret  =  input  .  read  (  )  ;  offset  +  =  (  ret  >  0  ?  1  :  0  )  ;  return  ret  ;  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [METHOD]  read  [TYPE]  int  [PARAMETER]  [CLASS]  ArArchiveInputStream  [TYPE]  boolean  closed  false  true  [TYPE]  InputStream  input  [TYPE]  long  offset  [TYPE]  int  ret  [CONTEXT]  public  int  read  (  )  throws  IOException  {  [BUGGY]  final  int  ret  =  input  .  read  (  )  ;  offset  +  =  (  ret  >  0  ?  1  :  0  )  ;  return  ret  ;  }  	Compress_2_ArArchiveInputStream_9_8	132	3	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
902	if  (currentEntry  !=  null)  {  final  long  entryEnd  =  entryOffset  +  currentEntry.getLength();  if  (len  >  0  &&  entryEnd  >  offset)  {  toRead  =  (int)  Math.min(len,  entryEnd  -  offset);  }  else  {  return  -1;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  76  ,  sum  )  ;  [METHOD]  read  [TYPE]  int  [PARAMETER]  byte[]  b  final  int  off  final  int  len  [CLASS]  ArArchiveInputStream  [TYPE]  byte[]  b  [TYPE]  boolean  closed  false  true  [TYPE]  InputStream  input  [TYPE]  long  offset  [TYPE]  int  len  off  ret  toRead  [CONTEXT]  public  int  read  (  byte[]  b  ,  final  int  off  ,  final  int  len  )  throws  IOException  {  int  toRead  =  len  ;  [BUGGY]  final  int  ret  =  this  .  input  .  read  (  b  ,  off  ,  toRead  )  ;  offset  +  =  (  ret  >  0  ?  ret  :  0  )  ;  return  ret  ;  }  	Compress_2_ArArchiveInputStream_9_9	143	0	src/main/java/org/apache/commons/compress/archivers/ar/ArArchiveInputStream.java
903	private  boolean  haveUnclosedEntry  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  After  putArchive  should  follow  closeArchive  [CLASS]  [CONTEXT]  	Compress_3_TarArchiveOutputStream_4_1	55	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
904	if(haveUnclosedEntry)  {  throw  new  IOException( "This  archives  contains  unclosed  entries. ");  }  	[BUGGY]  [FE]  AssertionFailedError:  After  putArchive  should  follow  closeArchive  [METHOD]  finish  [TYPE]  void  [PARAMETER]  [CLASS]  TarArchiveOutputStream  [TYPE]  byte[]  assemBuf  recordBuf  [TYPE]  boolean  closed  false  true  [TYPE]  OutputStream  out  [TYPE]  TarBuffer  buffer  [TYPE]  String  currName  [TYPE]  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  longFileMode  [TYPE]  long  currBytes  currSize  [CONTEXT]  public  void  finish  (  )  throws  IOException  {  [BUGGY]  writeEOFRecord  (  )  ;  writeEOFRecord  (  )  ;  }  	Compress_3_TarArchiveOutputStream_4_2	112	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
905	haveUnclosedEntry  =  true;  	[BUGGY]  [FE]  AssertionFailedError:  After  putArchive  should  follow  closeArchive  [CLASS]  [CONTEXT]  	Compress_3_TarArchiveOutputStream_4_3	187	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
906	haveUnclosedEntry  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  After  putArchive  should  follow  closeArchive  [CLASS]  [CONTEXT]  	Compress_3_TarArchiveOutputStream_4_4	217	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
907		[BUGGY]  this  .  finish  (  )  ;  [FE]  IOException:  central  directory  is  empty  ,  can't  expand  corrupt  archive  assertEquals  (  0  ,  fes  .  length  )  ;  [METHOD]  close  [TYPE]  void  [PARAMETER]  [CLASS]  CpioArchiveOutputStream  [TYPE]  boolean  closed  false  finished  true  [TYPE]  HashMap  names  [TYPE]  OutputStream  out  [TYPE]  short  entryFormat  [TYPE]  CpioArchiveEntry  entry  [TYPE]  long  crc  written  [CONTEXT]  public  void  close  (  )  throws  IOException  {  if  (  !this  .  closed  )  {  [BUGGY]  this  .  finish  (  )  ;  out  .  close  (  )  ;  this  .  closed  =  true  ;  }  }  	Compress_4_CpioArchiveOutputStream_1_1	336	1	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
908		[BUGGY]  finish  (  )  ;  [FE]  IOException:  central  directory  is  empty  ,  can't  expand  corrupt  archive  assertEquals  (  0  ,  fes  .  length  )  ;  [METHOD]  close  [TYPE]  void  [PARAMETER]  [CLASS]  TarArchiveOutputStream  [TYPE]  byte[]  assemBuf  recordBuf  [TYPE]  boolean  closed  false  haveUnclosedEntry  true  [TYPE]  OutputStream  out  [TYPE]  TarBuffer  buffer  [TYPE]  String  currName  [TYPE]  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  assemLen  longFileMode  [TYPE]  long  currBytes  currSize  [CONTEXT]  public  void  close  (  )  throws  IOException  {  if  (  !closed  )  {  [BUGGY]  finish  (  )  ;  buffer  .  close  (  )  ;  out  .  close  (  )  ;  closed  =  true  ;  }  }  	Compress_4_TarArchiveOutputStream_1_1	126	1	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
909		[BUGGY]  finish  (  )  ;  [FE]  IOException:  central  directory  is  empty  ,  can't  expand  corrupt  archive  assertEquals  (  0  ,  fes  .  length  )  ;  [METHOD]  close  [TYPE]  void  [PARAMETER]  [CLASS]  ZipArchiveOutputStream  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  UnicodeExtraFieldPolicy  ALWAYS  NEVER  NOT_ENCODEABLE  createUnicodeExtraFields  [TYPE]  CRC32  crc  [TYPE]  OutputStream  out  [TYPE]  String  DEFAULT_ENCODING  comment  encoding  name  [TYPE]  int  BUFFER_SIZE  BYTE_MASK  DEFAULT_COMPRESSION  DEFLATED  DEFLATER_BLOCK_SIZE  EFS_FLAG  SHORT  STORED  WORD  level  method  [TYPE]  long  cdLength  cdOffset  dataStart  localDataStart  written  [TYPE]  byte[]  CFH_SIG  DD_SIG  EOCD_SIG  LFH_SIG  LZERO  ZERO  buf  [TYPE]  boolean  fallbackToUTF8  false  hasCompressionLevelChanged  true  useEFS  [TYPE]  Deflater  def  [TYPE]  RandomAccessFile  raf  [TYPE]  ZipArchiveEntry  entry  [TYPE]  List  entries  [TYPE]  Map  offsets  [CONTEXT]  public  void  close  (  )  throws  IOException  {  [BUGGY]  finish  (  )  ;  if  (  raf  !  =  null  )  {  raf  .  close  (  )  ;  }  if  (  out  !  =  null  )  {  out  .  close  (  )  ;  }  }  	Compress_4_ZipArchiveOutputStream_1_1	530	1	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java
910	out.finish();  	[BUGGY]  [FE]  IOException:  central  directory  is  empty  ,  can't  expand  corrupt  archive  assertEquals  (  0  ,  fes  .  length  )  ;  [METHOD]  perform  [TYPE]  ChangeSetResults  [PARAMETER]  ArchiveInputStream  in  ArchiveOutputStream  out  [CLASS]  ChangeSetPerformer  [TYPE]  ArchiveInputStream  in  [TYPE]  ChangeSetResults  results  [TYPE]  Set  changes  workingSet  [TYPE]  boolean  copy  false  true  [TYPE]  Iterator  it  [TYPE]  ArchiveEntry  entry  [TYPE]  Change  change  [TYPE]  String  name  [TYPE]  ArchiveOutputStream  out  [TYPE]  int  type  [CONTEXT]  break  ;  }  }  }  if  (  copy  )  {  if  (  !isDeletedLater  (  workingSet  ,  entry  )  &&  !results  .  hasBeenAdded  (  entry  .  getName  (  )  )  )  {  copyStream  (  in  ,  out  ,  entry  )  ;  results  .  addedFromStream  (  entry  .  getName  (  )  )  ;  }  }  }  for  (  Iterator  it  =  workingSet  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  {  Change  change  =  (  Change  )  it  .  next  (  )  ;  if  (  change  .  type  (  )  =  =  Change  .  TYPE_ADD  &&  !change  .  isReplaceMode  (  )  &&  !results  .  hasBeenAdded  (  change  .  getEntry  (  )  .  getName  (  )  )  )  {  copyStream  (  change  .  getInput  (  )  ,  out  ,  change  .  getEntry  (  )  )  ;  it  .  remove  (  )  ;  results  .  addedFromChangeSet  (  change  .  getEntry  (  )  .  getName  (  )  )  ;  }  }  [BUGGY]  return  results  ;  }    	Compress_4_ChangeSetPerformer_1_1	128	0	src/main/java/org/apache/commons/compress/changes/ChangeSetPerformer.java
911	if  (read  ==  0)  {  if  (inf.finished())  {  return  -1;  }  else  if  (lengthOfLastRead  ==  -1)  {  throw  new  IOException( "Truncated  ZIP  file ");  }  	[BUGGY]  if  (  read  =  =  0  &&  inf  .  finished  (  )  )  {  return  -1  ;  [FE]  AssertionFailedError:  shouldn't  be  able  to  read  from  truncated  entry  assertEquals  (   "Truncated  ZIP  file "  ,  e  .  getMessage  (  )  )  ;  [METHOD]  read  [TYPE]  int  [PARAMETER]  byte[]  buffer  int  start  int  length  [CLASS]  ZipArchiveInputStream  [TYPE]  byte[]  buf  buffer  [TYPE]  boolean  closed  false  hasDataDescriptor  hitCentralDirectory  true  useUnicodeExtraFields  [TYPE]  DataFormatException  e  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  CRC32  crc  [TYPE]  InputStream  in  [TYPE]  ZipArchiveEntry  current  [TYPE]  Inflater  inf  [TYPE]  int  LFH_LEN  SHORT  WORD  bytesReadFromStream  csize  length  lengthOfLastRead  offsetInBuffer  read  readBytesOfEntry  start  toRead  [CONTEXT]  }  int  toRead  =  length  >  lengthOfLastRead  ?  lengthOfLastRead  -  offsetInBuffer  :  length  ;  if  (  (  csize  -  readBytesOfEntry  )  <  toRead  )  {  toRead  =  csize  -  readBytesOfEntry  ;  }  System  .  arraycopy  (  buf  ,  offsetInBuffer  ,  buffer  ,  start  ,  toRead  )  ;  offsetInBuffer  +  =  toRead  ;  readBytesOfEntry  +  =  toRead  ;  crc  .  update  (  buffer  ,  start  ,  toRead  )  ;  return  toRead  ;  }  if  (  inf  .  needsInput  (  )  )  {  fill  (  )  ;  if  (  lengthOfLastRead  >  0  )  {  bytesReadFromStream  +  =  lengthOfLastRead  ;  }  }  int  read  =  0  ;  try  {  read  =  inf  .  inflate  (  buffer  ,  start  ,  length  )  ;  }  catch  (  DataFormatException  e  )  {  throw  new  ZipException  (  e  .  getMessage  (  )  )  ;  }  [BUGGY]  if  (  read  =  =  0  &&  inf  .  finished  (  )  )  {  return  -1  ;  }  crc  .  update  (  buffer  ,  start  ,  read  )  ;  return  read  ;  }  	Compress_5_ZipArchiveInputStream_1_1	239	2	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
912	setName(name);  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  entry1  .  equals  (  entry2  )  )  ;  [CLASS]  [CONTEXT]  	Compress_6_ZipArchiveEntry_2_1	64	0	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java
913	String  myName  =  getName();  String  otherName  =  other.getName();  if  (myName  ==  null)  {  if  (otherName  !=  null)  {  }  else  if  (!myName.equals(otherName))  {  	[BUGGY]  if  (  name  =  =  null  )  {  if  (  other  .  name  !  =  null  )  {  }  else  if  (  !name  .  equals  (  other  .  name  )  )  {  [FE]  AssertionFailedError  assertFalse  (  entry1  .  equals  (  entry2  )  )  ;  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  ZipArchiveEntry  [TYPE]  boolean  false  true  [TYPE]  ZipArchiveEntry  other  [TYPE]  Object  obj  [TYPE]  String  name  [TYPE]  int  PLATFORM_FAT  PLATFORM_UNIX  SHORT_MASK  SHORT_SHIFT  internalAttributes  method  platform  [TYPE]  long  externalAttributes  [TYPE]  LinkedHashMap  extraFields  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  {  return  true  ;  }  if  (  obj  =  =  null  ||  getClass  (  )  !  =  obj  .  getClass  (  )  )  {  return  false  ;  }  ZipArchiveEntry  other  =  (  ZipArchiveEntry  )  obj  ;  [BUGGY]  if  (  name  =  =  null  )  {  if  (  other  .  name  !  =  null  )  {  return  false  ;  }  }  else  if  (  !name  .  equals  (  other  .  name  )  )  {  return  false  ;  }  return  true  ;  }  	Compress_6_ZipArchiveEntry_2_2	462	3	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java
914	byte  b  =  buffer[i];  if  (b  ==  0)  {    result.append((char)  (b  &  0xFF));    	[BUGGY]  if  (  buffer[i]  =  =  0  )  {  result  .  append  (  (  char  )  buffer[i]  )  ;  [FE]  ComparisonFailure:  expected:<0302-0601-3[  assertEquals  (  string  ,  TarUtils  .  parseName  (  buff  ,  0  ,  len  )  )  ;  [METHOD]  parseName  [TYPE]  String  [PARAMETER]  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  StringBuffer  result  [TYPE]  boolean  false  true  [TYPE]  int  BYTE_MASK  end  i  length  offset  [CONTEXT]  public  static  String  parseName  (  byte[]  buffer  ,  final  int  offset  ,  final  int  length  )  {  StringBuffer  result  =  new  StringBuffer  (  length  )  ;  intend  =  offset  +  length  ;  for  (  int  i  =  offset  ;  i  <  end  ;  ++i  )  {  [BUGGY]  if  (  buffer[i]  =  =  0  )  {  break  ;  }  result  .  append  (  (  char  )  buffer[i]  )  ;  }  return  result  .  toString  (  )  ;  }  	Compress_7_TarUtils_1_1	98	2	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
915		[BUGGY]  boolean  stillPadding  =  true  ;  [FE]  AssertionFailedError:  Expected  IllegalArgumentException  -  should  be  at  least  2  bytes  long  assertEquals  (  value  ,  parseValue  )  ;  [METHOD]  parseOctal  [TYPE]  long  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  boolean  false  stillPadding  true  [TYPE]  int  BYTE_MASK  end  i  length  offset  start  [TYPE]  long  result  [TYPE]  byte  currentByte  [CONTEXT]  public  static  long  parseOctal  (  final  byte[]  buffer  ,  final  int  offset  ,  final  int  length  )  {  longresult  =  0  ;  [BUGGY]  boolean  stillPadding  =  true  ;  int  end  =  offset  +  length  ;  int  start  =  offset  ;  for  (  int  i  =  start  ;  i  <  end  ;  i++  )  {  final  byte  currentByte  =  buffer[i]  ;  	Compress_8_TarUtils_2_1	53	1	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
916	if  (length  <  2){  throw  new  IllegalArgumentException( "Length   "+length+ "  must  be  at  least  2 ");  }    boolean  allNUL  =  true;  if  (buffer[i]  !=  0){  allNUL  =  false;  }  if  (allNUL)  {  return  0L;  }  }  else  {  }  byte  trailer;  trailer  =  buffer[end-1];\n',   "+                if  (trailer  ==  0  ||  trailer  ==  '  '){\n ",  '+                        end--;  }  else  {  throw  new  IllegalArgumentException(  exceptionMessage(buffer,  offset,  length,  end-1,  trailer));  }  trailer  =  buffer[end-1];\n',   "+                if  (trailer  ==  0  ||  trailer  ==  '  '){\n ",  '+                        end--;  }  for  (  ;start  <  end;  start++)  {  final  byte  currentByte  =  buffer[start];  	[BUGGY]  final  byte  currentByte  =  buffer[i]  ;  if  (  currentByte  =  =  0  )  {  continue  ;  }\n'  ,   "-        if  (  currentByte  =  =  (  byte  )  '  '  )  {\n "  ,  '+    while  (  start  <  end  )  {\n'  ,   "+      if  (  buffer[start]  =  =  '  '  )  {\n "  ,  '+        start++  ;  }  stillPadding  =  false  ;  [FE]  AssertionFailedError:  Expected  IllegalArgumentException  -  should  be  at  least  2  bytes  long  assertEquals  (  value  ,  parseValue  )  ;  [METHOD]  parseOctal  [TYPE]  long  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  boolean  false  stillPadding  true  [TYPE]  int  BYTE_MASK  end  i  length  offset  start  [TYPE]  long  result  [TYPE]  byte  currentByte  [CONTEXT]  public  static  long  parseOctal  (  final  byte[]  buffer  ,  final  int  offset  ,  final  int  length  )  {  longresult  =  0  ;  boolean  stillPadding  =  true  ;  int  end  =  offset  +  length  ;  int  start  =  offset  ;  [BUGGY]  for  (  int  i  =  start  ;  i  <  end  ;  i++  )  {  final  byte  currentByte  =  buffer[i]  ;  if  (  currentByte  =  =  0  )  {  break  ;  }  	Compress_8_TarUtils_2_2	57	6	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
917	@Deprecated  @Override  public  int  getCount()  {  return  (int)  getBytesWritten();  }  @Override  public  long  getBytesWritten()  {  return  ((CountingOutputStream)  out).getBytesWritten();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<10240>  but  was:<76>  assertEquals  (  f  .  length  (  )  ,  tarOut  .  getBytesWritten  (  )  )  ;  [CLASS]  [CONTEXT]  	Compress_9_TarArchiveOutputStream_2_1	108	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
918		[BUGGY]  count  (  numToWrite  )  ;  [FE]  AssertionFailedError:  expected:<10240>  but  was:<76>  assertEquals  (  f  .  length  (  )  ,  tarOut  .  getBytesWritten  (  )  )  ;  [METHOD]  write  [TYPE]  void  [PARAMETER]  byte[]  wBuf  int  wOffset  int  numToWrite  [CLASS]  TarArchiveOutputStream  [TYPE]  byte[]  assemBuf  recordBuf  wBuf  [TYPE]  boolean  closed  false  finished  haveUnclosedEntry  true  [TYPE]  OutputStream  out  [TYPE]  TarBuffer  buffer  [TYPE]  String  currName  [TYPE]  int  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_TRUNCATE  aLen  assemLen  longFileMode  num  numToWrite  wOffset  [TYPE]  long  currBytes  currSize  [CONTEXT]  }      while  (  numToWrite  >  0  )  {  if  (  numToWrite  <  recordBuf  .  length  )  {  System  .  arraycopy  (  wBuf  ,  wOffset  ,  assemBuf  ,  assemLen  ,  numToWrite  )  ;  assemLen  +  =  numToWrite  ;  break  ;  }  buffer  .  writeRecord  (  wBuf  ,  wOffset  )  ;  int  num  =  recordBuf  .  length  ;  currBytes  +  =  num  ;  numToWrite  -  =  num  ;  wOffset  +  =  num  ;  }  [BUGGY]  count  (  numToWrite  )  ;  }    	Compress_9_TarArchiveOutputStream_2_2	330	1	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
919	Map<ZipArchiveEntry,  OffsetEntry>  origMap  =  new  LinkedHashMap<ZipArchiveEntry,  OffsetEntry>(entries);  entries.clear();  for  (ZipArchiveEntry  ze  :  origMap.keySet())  {  OffsetEntry  offsetEntry  =  origMap.get(ze);  	[BUGGY]  for  (  ZipArchiveEntry  ze  :  entries  .  keySet  (  )  )  {  OffsetEntry  offsetEntry  =  entries  .  get  (  ze  )  ;  [FE]  AssertionFailedError:  InputStream  is  null  assertEquals  (  ASCII_TXT  ,  zi  .  getNextEntry  (  )  .  getName  (  )  )  ;  [METHOD]  resolveLocalFileHeaderData  [TYPE]  void  [PARAMETER]  NameAndComment>  entriesWithoutUTF8Flag  [CLASS]  ZipFile  [TYPE]  byte[]  b  comment  localExtraData  name  [TYPE]  boolean  addDummyByte  closed  false  true  useUnicodeExtraFields  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  RandomAccessFile  archive  [TYPE]  OffsetEntry  offsetEntry  [TYPE]  ZipArchiveEntry  ze  [TYPE]  String  archiveName  encoding  orig  [TYPE]  NameAndComment  nc  [TYPE]  Map  entries  entriesWithoutUTF8Flag  nameMap  [TYPE]  int  BYTE_SHIFT  CFD_LOCATOR_OFFSET  CFH_LEN  HASH_SIZE  MAX_EOCD_SIZE  MIN_EOCD_SIZE  NIBLET_MASK  POS_0  POS_1  POS_2  POS_3  ZIP64_EOCDL_LENGTH  ZIP64_EOCDL_LOCATOR_OFFSET  ZIP64_EOCD_CFD_LOCATOR_OFFSET  extraFieldLen  fileNameLen  lenToSkip  skipped  [TYPE]  long  CFH_SIG  LFH_OFFSET_FOR_FILENAME_LENGTH  dataOffset  headerOffset  loc  offset  remaining  [TYPE]  Comparator  OFFSET_COMPARATOR  [CONTEXT]  private  void  resolveLocalFileHeaderData  (  Map<ZipArchiveEntry  ,  NameAndComment>  entriesWithoutUTF8Flag  )  throws  IOException  {      [BUGGY]  for  (  ZipArchiveEntry  ze  :  entries  .  keySet  (  )  )  {  OffsetEntry  offsetEntry  =  entries  .  get  (  ze  )  ;  long  offset  =  offsetEntry  .  headerOffset  ;  archive  .  seek  (  offset  +  LFH_OFFSET_FOR_FILENAME_LENGTH  )  ;  byte[]  b  =  new  byte[SHORT]  ;  archive  .  readFully  (  b  )  ;  	Compress_10_ZipFile_2_1	808	2	src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java
920	entries.put(ze,  offsetEntry);  	[BUGGY]  [FE]  AssertionFailedError:  InputStream  is  null  assertEquals  (  ASCII_TXT  ,  zi  .  getNextEntry  (  )  .  getName  (  )  )  ;  [METHOD]  resolveLocalFileHeaderData  [TYPE]  void  [PARAMETER]  NameAndComment>  entriesWithoutUTF8Flag  [CLASS]  ZipFile  [TYPE]  byte[]  b  comment  localExtraData  name  [TYPE]  boolean  addDummyByte  closed  false  true  useUnicodeExtraFields  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  RandomAccessFile  archive  [TYPE]  OffsetEntry  offsetEntry  [TYPE]  ZipArchiveEntry  ze  [TYPE]  String  archiveName  encoding  orig  [TYPE]  NameAndComment  nc  [TYPE]  Map  entries  entriesWithoutUTF8Flag  nameMap  [TYPE]  int  BYTE_SHIFT  CFD_LOCATOR_OFFSET  CFH_LEN  HASH_SIZE  MAX_EOCD_SIZE  MIN_EOCD_SIZE  NIBLET_MASK  POS_0  POS_1  POS_2  POS_3  ZIP64_EOCDL_LENGTH  ZIP64_EOCDL_LOCATOR_OFFSET  ZIP64_EOCD_CFD_LOCATOR_OFFSET  extraFieldLen  fileNameLen  lenToSkip  skipped  [TYPE]  long  CFH_SIG  LFH_OFFSET_FOR_FILENAME_LENGTH  dataOffset  headerOffset  loc  offset  remaining  [TYPE]  Comparator  OFFSET_COMPARATOR  [CONTEXT]  int  lenToSkip  =  fileNameLen  ;  while  (  lenToSkip  >  0  )  {  int  skipped  =  archive  .  skipBytes  (  lenToSkip  )  ;  if  (  skipped  <  =  0  )  {  throw  new  RuntimeException  (   "failed  to  skip  file  name  in "  +   "  local  file  header "  )  ;  }  lenToSkip  -  =  skipped  ;  }  byte[]  localExtraData  =  new  byte[extraFieldLen]  ;  archive  .  readFully  (  localExtraData  )  ;  ze  .  setExtra  (  localExtraData  )  ;  offsetEntry  .  dataOffset  =  offset  +  LFH_OFFSET_FOR_FILENAME_LENGTH  +  SHORT  +  SHORT  +  fileNameLen  +  extraFieldLen  ;  if  (  entriesWithoutUTF8Flag  .  containsKey  (  ze  )  )  {  String  orig  =  ze  .  getName  (  )  ;  NameAndComment  nc  =  entriesWithoutUTF8Flag  .  get  (  ze  )  ;  ZipUtil  .  setNameAndCommentFromExtraFields  (  ze  ,  nc  .  name  ,  nc  .  comment  )  ;  if  (  !orig  .  equals  (  ze  .  getName  (  )  )  )  {  nameMap  .  remove  (  orig  )  ;  nameMap  .  put  (  ze  .  getName  (  )  ,  ze  )  ;  }  }  [BUGGY]  }  }    	Compress_10_ZipFile_2_2	842	0	src/main/java/org/apache/commons/compress/archivers/zip/ZipFile.java
921	if  (signatureLength  >=  512)  {  	[BUGGY]  [FE]  AssertionFailedError:  created  an  input  stream  for  a  non-archive  assertTrue  (  ae  .  getMessage  (  )  .  startsWith  (   "No  Archiver  found "  )  )  ;  [METHOD]  createArchiveInputStream  [TYPE]  ArchiveInputStream  [PARAMETER]  InputStream  in  [CLASS]  ArchiveStreamFactory  [TYPE]  byte[]  dumpsig  signature  tarheader  [TYPE]  TarArchiveInputStream  tais  [TYPE]  boolean  false  true  [TYPE]  InputStream  in  [TYPE]  String  AR  CPIO  DUMP  JAR  TAR  ZIP  [TYPE]  IOException  e  [TYPE]  int  signatureLength  [TYPE]  Exception  e  [CONTEXT]  return  new  JarArchiveInputStream  (  in  )  ;  }  else  if  (  ArArchiveInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  return  new  ArArchiveInputStream  (  in  )  ;  }  else  if  (  CpioArchiveInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  return  new  CpioArchiveInputStream  (  in  )  ;  }  final  byte[]  dumpsig  =  new  byte[32]  ;  in  .  mark  (  dumpsig  .  length  )  ;  signatureLength  =  in  .  read  (  dumpsig  )  ;  in  .  reset  (  )  ;  if  (  DumpArchiveInputStream  .  matches  (  dumpsig  ,  signatureLength  )  )  {  return  new  DumpArchiveInputStream  (  in  )  ;  }  final  byte[]  tarheader  =  new  byte[512]  ;  in  .  mark  (  tarheader  .  length  )  ;  signatureLength  =  in  .  read  (  tarheader  )  ;  in  .  reset  (  )  ;  if  (  TarArchiveInputStream  .  matches  (  tarheader  ,  signatureLength  )  )  {  return  new  TarArchiveInputStream  (  in  )  ;  }  [BUGGY]  try  {  TarArchiveInputStream  tais  =  new  TarArchiveInputStream  (  new  ByteArrayInputStream  (  tarheader  )  )  ;  tais  .  getNextEntry  (  )  ;  return  new  TarArchiveInputStream  (  in  )  ;  }  catch  (  Exception  e  )  {  //  NOPMD  	Compress_11_ArchiveStreamFactory_2_1	240	0	src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java
922	}  	[BUGGY]  [FE]  AssertionFailedError:  created  an  input  stream  for  a  non-archive  assertTrue  (  ae  .  getMessage  (  )  .  startsWith  (   "No  Archiver  found "  )  )  ;  [METHOD]  createArchiveInputStream  [TYPE]  ArchiveInputStream  [PARAMETER]  InputStream  in  [CLASS]  ArchiveStreamFactory  [TYPE]  byte[]  dumpsig  signature  tarheader  [TYPE]  TarArchiveInputStream  tais  [TYPE]  boolean  false  true  [TYPE]  InputStream  in  [TYPE]  String  AR  CPIO  DUMP  JAR  TAR  ZIP  [TYPE]  IOException  e  [TYPE]  int  signatureLength  [TYPE]  Exception  e  [CONTEXT]  in  .  mark  (  dumpsig  .  length  )  ;  signatureLength  =  in  .  read  (  dumpsig  )  ;  in  .  reset  (  )  ;  if  (  DumpArchiveInputStream  .  matches  (  dumpsig  ,  signatureLength  )  )  {  return  new  DumpArchiveInputStream  (  in  )  ;  }  final  byte[]  tarheader  =  new  byte[512]  ;  in  .  mark  (  tarheader  .  length  )  ;  signatureLength  =  in  .  read  (  tarheader  )  ;  in  .  reset  (  )  ;  if  (  TarArchiveInputStream  .  matches  (  tarheader  ,  signatureLength  )  )  {  return  new  TarArchiveInputStream  (  in  )  ;  }  try  {  TarArchiveInputStream  tais  =  new  TarArchiveInputStream  (  new  ByteArrayInputStream  (  tarheader  )  )  ;  tais  .  getNextEntry  (  )  ;  return  new  TarArchiveInputStream  (  in  )  ;  }  catch  (  Exception  e  )  {  //  NOPMD    }  [BUGGY]  }  catch  (  IOException  e  )  {  throw  new  ArchiveException  (   "Could  not  use  reset  and  mark  operations  .   "  ,  e  )  ;  }  throw  new  ArchiveException  (   "No  Archiver  found  for  the  stream  signature "  )  ;  }  	Compress_11_ArchiveStreamFactory_2_2	249	0	src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java
923	try  {  currEntry  =  new  TarArchiveEntry(headerBuf);  }  catch  (IllegalArgumentException  e)  {  IOException  ioe  =  new  IOException( "Error  detected  parsing  the  header ");  ioe.initCause(e);  throw  ioe;  }  	[BUGGY]  currEntry  =  new  TarArchiveEntry  (  headerBuf  )  ;  [FE]  IllegalArgumentException:  Invalid  byte  0  at  offset  2  in  '00{NUL}0765{NUL}'  len  =  8  assertTrue  (   "Expected  cause  =  IllegalArgumentException "  ,  t  instanceof  IllegalArgumentException  )  ;  [METHOD]  getNextTarEntry  [TYPE]  TarArchiveEntry  [PARAMETER]  [CLASS]  TarArchiveInputStream  [TYPE]  byte[]  buf  headerBuf  readBuf  [TYPE]  StringBuffer  longName  [TYPE]  boolean  false  hasHitEOF  true  [TYPE]  TarBuffer  buffer  [TYPE]  int  BUFFER_SIZE  SMALL_BUFFER_SIZE  length  [TYPE]  long  entryOffset  entrySize  numToSkip  skipped  [TYPE]  TarArchiveEntry  currEntry  [CONTEXT]  if  (  hasHitEOF  )  {  return  null  ;  }  if  (  currEntry  !  =  null  )  {  long  numToSkip  =  entrySize  -  entryOffset  ;  while  (  numToSkip  >  0  )  {  long  skipped  =  skip  (  numToSkip  )  ;  if  (  skipped  <  =  0  )  {  throw  new  RuntimeException  (   "failed  to  skip  current  tar  entry "  )  ;  }  numToSkip  -  =  skipped  ;  }  readBuf  =  null  ;  }  byte[]  headerBuf  =  getRecord  (  )  ;  if  (  hasHitEOF  )  {  currEntry  =  null  ;  return  null  ;  }  [BUGGY]  currEntry  =  new  TarArchiveEntry  (  headerBuf  )  ;  entryOffset  =  0  ;  entrySize  =  currEntry  .  getSize  (  )  ;  if  (  currEntry  .  isGNULongNameEntry  (  )  )  {  	Compress_12_TarArchiveInputStream_1_1	198	1	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java
924	if  (name  !=  null  &&  getPlatform()  ==  PLATFORM_FAT  &&  name.indexOf( "/ ")  ==  -1)  {\n',   "+                        name  =  name.replace('\\\\',  '/');\n ",  '+                }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<  assertEquals  (   "\u00e4/ "  ,  zae  .  getName  (  )  )  ;  [METHOD]  setName  [TYPE]  void  [PARAMETER]  String  name  [CLASS]  ZipArchiveEntry  [TYPE]  byte[]  rawName  [TYPE]  boolean  false  true  [TYPE]  String  name  [TYPE]  GeneralPurposeBit  gpb  [TYPE]  UnparseableExtraFieldData  unparseableExtra  [TYPE]  int  PLATFORM_FAT  PLATFORM_UNIX  SHORT_MASK  SHORT_SHIFT  internalAttributes  method  platform  [TYPE]  long  externalAttributes  size  [TYPE]  LinkedHashMap  extraFields  [CONTEXT]  protected  void  setName  (  String  name  )  {  [BUGGY]  this  .  name  =  name  ;  }  	Compress_13_ZipArchiveEntry_1_1	512	0	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java
925	if  (buffer[start]  ==  0)  {  	[BUGGY]  boolean  allNUL  =  true  ;  for  (  int  i  =  start  ;  i  <  end  ;  i++  )  {  if  (  buffer[i]  !  =  0  )  {  allNUL  =  false  ;  break  ;  }  }  if  (  allNUL  )  {  [FE]  IOException:  Error  detected  parsing  the  header  assertTrue  (  tae  .  isSymbolicLink  (  )  )  ;  [METHOD]  parseOctal  [TYPE]  long  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  boolean  allNUL  false  true  [TYPE]  int  BYTE_MASK  end  i  length  offset  start  [TYPE]  long  result  [TYPE]  byte  currentByte  trailer  [CONTEXT]  public  static  long  parseOctal  (  final  byte[]  buffer  ,  final  int  offset  ,  final  int  length  )  {  longresult  =  0  ;  int  end  =  offset  +  length  ;  int  start  =  offset  ;  if  (  length  <  2  )  {  throw  new  IllegalArgumentException  (   "Length   "+length+ "  must  be  at  least  2 "  )  ;  }  [BUGGY]  boolean  allNUL  =  true  ;  for  (  int  i  =  start  ;  i  <  end  ;  i++  )  {  if  (  buffer[i]  !  =  0  )  {  allNUL  =  false  ;  break  ;  }  	Compress_14_TarUtils_1_1	65	8	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
926	myComment  =   " ";  }  if  (otherComment  ==  null)  {  otherComment  =   " ";  &&  myComment.equals(otherComment)  	[BUGGY]  if  (  otherComment  !  =  null  )  {  return  false  ;  }  }  else  if  (  !myComment  .  equals  (  otherComment  )  )  {  return  false  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<foo>  assertFalse  (  entry2  .  equals  (  entry3  )  )  ;  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  obj  [CLASS]  ZipArchiveEntry  [TYPE]  byte[]  rawName  [TYPE]  boolean  false  true  [TYPE]  ZipArchiveEntry  other  [TYPE]  Object  obj  [TYPE]  String  myComment  myName  name  otherComment  otherName  [TYPE]  GeneralPurposeBit  gpb  [TYPE]  UnparseableExtraFieldData  unparseableExtra  [TYPE]  int  PLATFORM_FAT  PLATFORM_UNIX  SHORT_MASK  SHORT_SHIFT  internalAttributes  method  platform  [TYPE]  long  externalAttributes  size  [TYPE]  LinkedHashMap  extraFields  [CONTEXT]  public  boolean  equals  (  Object  obj  )  {  if  (  this  =  =  obj  )  {  return  true  ;  }  if  (  obj  =  =  null  ||  getClass  (  )  !  =  obj  .  getClass  (  )  )  {  return  false  ;  }  ZipArchiveEntry  other  =  (  ZipArchiveEntry  )  obj  ;  String  myName  =  getName  (  )  ;  String  otherName  =  other  .  getName  (  )  ;  if  (  myName  =  =  null  )  {  if  (  otherName  !  =  null  )  {  return  false  ;  }  }  else  if  (  !myName  .  equals  (  otherName  )  )  {  return  false  ;  }  String  myComment  =  getComment  (  )  ;  String  otherComment  =  other  .  getComment  (  )  ;  if  (  myComment  =  =  null  )  {  [BUGGY]  if  (  otherComment  !  =  null  )  {  return  false  ;  }  }  else  if  (  !myComment  .  equals  (  otherComment  )  )  {  return  false  ;  }  	Compress_15_ZipArchiveEntry_1_1	669	5	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java
927	if  (tais.getNextTarEntry().isCheckSumOK())  {  }  	[BUGGY]  tais  .  getNextEntry  (  )  ;  [FE]  AssertionFailedError:  created  an  input  stream  for  a  non-archive  assertTrue  (  ae  .  getMessage  (  )  .  startsWith  (   "No  Archiver  found "  )  )  ;  [METHOD]  createArchiveInputStream  [TYPE]  ArchiveInputStream  [PARAMETER]  InputStream  in  [CLASS]  ArchiveStreamFactory  [TYPE]  byte[]  dumpsig  signature  tarheader  [TYPE]  TarArchiveInputStream  tais  [TYPE]  boolean  false  true  [TYPE]  InputStream  in  [TYPE]  String  AR  CPIO  DUMP  JAR  TAR  ZIP  [TYPE]  IOException  e  [TYPE]  int  signatureLength  [TYPE]  Exception  e  [CONTEXT]  return  new  CpioArchiveInputStream  (  in  )  ;  }  final  byte[]  dumpsig  =  new  byte[32]  ;  in  .  mark  (  dumpsig  .  length  )  ;  signatureLength  =  in  .  read  (  dumpsig  )  ;  in  .  reset  (  )  ;  if  (  DumpArchiveInputStream  .  matches  (  dumpsig  ,  signatureLength  )  )  {  return  new  DumpArchiveInputStream  (  in  )  ;  }  final  byte[]  tarheader  =  new  byte[512]  ;  in  .  mark  (  tarheader  .  length  )  ;  signatureLength  =  in  .  read  (  tarheader  )  ;  in  .  reset  (  )  ;  if  (  TarArchiveInputStream  .  matches  (  tarheader  ,  signatureLength  )  )  {  return  new  TarArchiveInputStream  (  in  )  ;  }  if  (  signatureLength  >  =  512  )  {  try  {  TarArchiveInputStream  tais  =  new  TarArchiveInputStream  (  new  ByteArrayInputStream  (  tarheader  )  )  ;  [BUGGY]  tais  .  getNextEntry  (  )  ;  return  new  TarArchiveInputStream  (  in  )  ;  }  catch  (  Exception  e  )  {  //  NOPMD    	Compress_16_ArchiveStreamFactory_1_1	244	1	src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java
928	trailer  =  buffer[end  -  1];  	[BUGGY]  [FE]  AssertionFailedError:  COMPRESS-197:  Error  detected  parsing  the  header  [METHOD]  parseOctal  [TYPE]  long  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  boolean  false  true  [TYPE]  ZipEncoding  DEFAULT_ENCODING  FALLBACK_ENCODING  [TYPE]  int  BYTE_MASK  end  length  offset  start  [TYPE]  long  result  [TYPE]  byte  currentByte  trailer  [CONTEXT]  if  (  buffer[start]  =  =  0  )  {  return  0L  ;  }  while  (  start  <  end  )  {  if  (  buffer[start]  =  =  '  '  )  {  start++  ;  }  else  {  break  ;  }  }  byte  trailer  ;  trailer  =  buffer[end-1]  ;  if  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  {  end--  ;  }  else  {  throw  new  IllegalArgumentException  (  exceptionMessage  (  buffer  ,  offset  ,  length  ,  end-1  ,  trailer  )  )  ;  }  trailer  =  buffer[end  -  1]  ;  [BUGGY]  if  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  {  end--  ;  }  for  (  ;  start  <  end  ;  start++  )  {  final  byte  currentByte  =  buffer[start]  ;  	Compress_17_TarUtils_1_1	135	0	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
929	while  (name.endsWith( "/ "))  {\n',   "                            name  =  name.substring(0,  name.length()  -  1);  }  	[BUGGY]  [FE]  IOException:  request  to  write  '15'  bytes  exceeds  size  in  header  of  '0'  bytes  for  entry  '/PaxHeadersX/fvv/'  assertTrue  (  e  .  isDirectory  (  )  )  ;  [METHOD]  writePaxHeaders  [TYPE]  void  [PARAMETER]  String  entryName  String>  headers  [CLASS]  TarArchiveOutputStream  [TYPE]  byte[]  assemBuf  data  recordBuf  [TYPE]  Entry  h  [TYPE]  boolean  addPaxHeadersForNonAsciiNames  closed  false  finished  haveUnclosedEntry  true  [TYPE]  ZipEncoding  ASCII  encoding  [TYPE]  StringWriter  w  [TYPE]  OutputStream  out  [TYPE]  TarBuffer  buffer  [TYPE]  String  currName  entryName  key  line  name  value  [TYPE]  Map  headers  [TYPE]  int  BIGNUMBER_ERROR  BIGNUMBER_POSIX  BIGNUMBER_STAR  LONGFILE_ERROR  LONGFILE_GNU  LONGFILE_POSIX  LONGFILE_TRUNCATE  actualLength  assemLen  bigNumberMode  len  longFileMode  [TYPE]  long  currBytes  currSize  [TYPE]  TarArchiveEntry  pex  [CONTEXT]  void  writePaxHeaders  (  String  entryName  ,  Map<String  ,  String>  headers  )  throws  IOException  {  String  name  =   "  .  /PaxHeaders  .  X/ "  +  stripTo7Bits  (  entryName  )  ;  [BUGGY]    if  (  name  .  length  (  )  >  =  TarConstants  .  NAMELEN  )  {  name  =  name  .  substring  (  0  ,  TarConstants  .  NAMELEN  -  1  )  ;  }  TarArchiveEntry  pex  =  new  TarArchiveEntry  (  name  ,  	Compress_18_TarArchiveOutputStream_1_1	457	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
930	if  (rawCentralDirectoryData.length  <  expectedLength)  {  	[BUGGY]  if  (  rawCentralDirectoryData  .  length  !  =  expectedLength  )  {  [FE]  zipZipException:  central  directory  zip64  extended  information  extra  field's  length  doesn't  match  central  directory  data  Expected  length  16  but  is  28  assertEquals  (   "src/main/java/org/apache/commons/compress/archivers/zip/ "  [METHOD]  reparseCentralDirectoryData  [TYPE]  void  [PARAMETER]  boolean  hasUncompressedSize  boolean  hasCompressedSize  boolean  hasRelativeHeaderOffset  boolean  hasDiskStart  [CLASS]  Zip64ExtendedInformationExtraField  [TYPE]  byte[]  EMPTY  rawCentralDirectoryData  [TYPE]  ZipLong  diskStart  [TYPE]  ZipShort  HEADER_ID  [TYPE]  boolean  false  hasCompressedSize  hasDiskStart  hasRelativeHeaderOffset  hasUncompressedSize  true  [TYPE]  String  LFH_MUST_HAVE_BOTH_SIZES_MSG  [TYPE]  ZipEightByteInteger  compressedSize  relativeHeaderOffset  size  [TYPE]  int  expectedLength  offset  [CONTEXT]  public  void  reparseCentralDirectoryData  (  boolean  hasUncompressedSize  ,  boolean  hasCompressedSize  ,  boolean  hasRelativeHeaderOffset  ,  boolean  hasDiskStart  )  throws  ZipException  {  if  (  rawCentralDirectoryData  !  =  null  )  {  int  expectedLength  =  (  hasUncompressedSize  ?  DWORD  :  0  )  +  (  hasCompressedSize  ?  DWORD  :  0  )  +  (  hasRelativeHeaderOffset  ?  DWORD  :  0  )  +  (  hasDiskStart  ?  WORD  :  0  )  ;  [BUGGY]  if  (  rawCentralDirectoryData  .  length  !  =  expectedLength  )  {  throw  new  ZipException  (   "central  directory  zip64  extended "  +   "  information  extra  field's  length "  +   "  doesn't  match  central  directory "  +   "  data  .  Expected  length   "  +  expectedLength  +   "  but  is   "  	Compress_19_Zip64ExtendedInformationExtraField_1_1	259	1	src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java
931	if  (CpioUtil.fileType(mode)  !=  0){    	[BUGGY]  if  (  mode  !  =  0  )  {  [FE]  IllegalArgumentException:  Unknown  mode  Full:  1a4  Masked:  0  assertEquals  (  count  ,  1  )  ;  [METHOD]  readNewEntry  [TYPE]  CpioArchiveEntry  [PARAMETER]  final  boolean  hasCrc  [CLASS]  CpioArchiveInputStream  [TYPE]  byte[]  FOUR_BYTES_BUF  SIX_BYTES_BUF  TWO_BYTES_BUF  tmpbuf  [TYPE]  boolean  closed  entryEOF  false  hasCrc  true  [TYPE]  InputStream  in  [TYPE]  String  name  [TYPE]  CpioArchiveEntry  entry  ret  [TYPE]  long  crc  entryBytesRead  mode  namesize  [TYPE]  int  blockSize  [CONTEXT]  private  CpioArchiveEntry  readNewEntry  (  final  boolean  hasCrc  )  throws  IOException  {  CpioArchiveEntry  ret  ;  if  (  hasCrc  )  {  ret  =  new  CpioArchiveEntry  (  FORMAT_NEW_CRC  )  ;  }  else  {  ret  =  new  CpioArchiveEntry  (  FORMAT_NEW  )  ;  }  ret  .  setInode  (  readAsciiLong  (  8  ,  16  )  )  ;  long  mode  =  readAsciiLong  (  8  ,  16  )  ;  [BUGGY]  if  (  mode  !  =  0  )  {  ret  .  setMode  (  mode  )  ;  }  ret  .  setUID  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setGID  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setNumberOfLinks  (  readAsciiLong  (  8  ,  16  )  )  ;  	Compress_20_CpioArchiveInputStream_6_1	331	1	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java
932	if  (CpioUtil.fileType(mode)  ==  0  &&  !name.equals(CPIO_TRAILER)){  	[BUGGY]  if  (  mode  =  =  0  &&  !name  .  equals  (  CPIO_TRAILER  )  )  {  [FE]  IllegalArgumentException:  Unknown  mode  Full:  1a4  Masked:  0  assertEquals  (  count  ,  1  )  ;  [METHOD]  readNewEntry  [TYPE]  CpioArchiveEntry  [PARAMETER]  final  boolean  hasCrc  [CLASS]  CpioArchiveInputStream  [TYPE]  byte[]  FOUR_BYTES_BUF  SIX_BYTES_BUF  TWO_BYTES_BUF  tmpbuf  [TYPE]  boolean  closed  entryEOF  false  hasCrc  true  [TYPE]  InputStream  in  [TYPE]  String  name  [TYPE]  CpioArchiveEntry  entry  ret  [TYPE]  long  crc  entryBytesRead  mode  namesize  [TYPE]  int  blockSize  [CONTEXT]  CpioArchiveEntry  ret  ;  if  (  hasCrc  )  {  ret  =  new  CpioArchiveEntry  (  FORMAT_NEW_CRC  )  ;  }  else  {  ret  =  new  CpioArchiveEntry  (  FORMAT_NEW  )  ;  }  ret  .  setInode  (  readAsciiLong  (  8  ,  16  )  )  ;  long  mode  =  readAsciiLong  (  8  ,  16  )  ;  if  (  mode  !  =  0  )  {  ret  .  setMode  (  mode  )  ;  }  ret  .  setUID  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setGID  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setNumberOfLinks  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setTime  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setSize  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setDeviceMaj  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setDeviceMin  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setRemoteDeviceMaj  (  readAsciiLong  (  8  ,  16  )  )  ;  ret  .  setRemoteDeviceMin  (  readAsciiLong  (  8  ,  16  )  )  ;  long  namesize  =  readAsciiLong  (  8  ,  16  )  ;  ret  .  setChksum  (  readAsciiLong  (  8  ,  16  )  )  ;  String  name  =  readCString  (  (  int  )  namesize  )  ;  ret  .  setName  (  name  )  ;  [BUGGY]  if  (  mode  =  =  0  &&  !name  .  equals  (  CPIO_TRAILER  )  )  {  throw  new  IOException  (   "Mode  0  only  allowed  in  the  trailer  .  Found  entry  name:   "+name  +   "  Occured  at  byte:   "  +  getBytesRead  (  )  )  ;  }  skip  (  ret  .  getHeaderPadCount  (  )  )  ;  return  ret  ;  	Compress_20_CpioArchiveInputStream_6_2	347	1	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java
933	if  (CpioUtil.fileType(mode)  !=  0)  {  	[BUGGY]  if  (  mode  !  =  0  )  {  [FE]  IllegalArgumentException:  Unknown  mode  Full:  1a4  Masked:  0  assertEquals  (  count  ,  1  )  ;  [METHOD]  readOldAsciiEntry  [TYPE]  CpioArchiveEntry  [PARAMETER]  [CLASS]  CpioArchiveInputStream  [TYPE]  byte[]  FOUR_BYTES_BUF  SIX_BYTES_BUF  TWO_BYTES_BUF  tmpbuf  [TYPE]  boolean  closed  entryEOF  false  true  [TYPE]  InputStream  in  [TYPE]  String  name  [TYPE]  CpioArchiveEntry  entry  ret  [TYPE]  long  crc  entryBytesRead  mode  namesize  [TYPE]  int  blockSize  [CONTEXT]  private  CpioArchiveEntry  readOldAsciiEntry  (  )  throws  IOException  {  CpioArchiveEntry  ret  =  new  CpioArchiveEntry  (  FORMAT_OLD_ASCII  )  ;  ret  .  setDevice  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setInode  (  readAsciiLong  (  6  ,  8  )  )  ;  final  long  mode  =  readAsciiLong  (  6  ,  8  )  ;  [BUGGY]  if  (  mode  !  =  0  )  {  ret  .  setMode  (  mode  )  ;  }  ret  .  setUID  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setGID  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setNumberOfLinks  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setRemoteDevice  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setTime  (  readAsciiLong  (  11  ,  8  )  )  ;  long  namesize  =  readAsciiLong  (  6  ,  8  )  ;  ret  .  setSize  (  readAsciiLong  (  11  ,  8  )  )  ;  final  String  name  =  readCString  (  (  int  )  namesize  )  ;  ret  .  setName  (  name  )  ;  if  (  mode  =  =  0  &&  !name  .  equals  (  CPIO_TRAILER  )  )  {  throw  new  IOException  (   "Mode  0  only  allowed  in  the  trailer  .  Found  entry:   "+  name  +   "  Occured  at  byte:   "  +  getBytesRead  (  )  )  ;  }  return  ret  ;  }  	Compress_20_CpioArchiveInputStream_6_3	361	1	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java
934	if  (CpioUtil.fileType(mode)  ==  0  &&  !name.equals(CPIO_TRAILER)){  	[BUGGY]  if  (  mode  =  =  0  &&  !name  .  equals  (  CPIO_TRAILER  )  )  {  [FE]  IllegalArgumentException:  Unknown  mode  Full:  1a4  Masked:  0  assertEquals  (  count  ,  1  )  ;  [METHOD]  readOldAsciiEntry  [TYPE]  CpioArchiveEntry  [PARAMETER]  [CLASS]  CpioArchiveInputStream  [TYPE]  byte[]  FOUR_BYTES_BUF  SIX_BYTES_BUF  TWO_BYTES_BUF  tmpbuf  [TYPE]  boolean  closed  entryEOF  false  true  [TYPE]  InputStream  in  [TYPE]  String  name  [TYPE]  CpioArchiveEntry  entry  ret  [TYPE]  long  crc  entryBytesRead  mode  namesize  [TYPE]  int  blockSize  [CONTEXT]  private  CpioArchiveEntry  readOldAsciiEntry  (  )  throws  IOException  {  CpioArchiveEntry  ret  =  new  CpioArchiveEntry  (  FORMAT_OLD_ASCII  )  ;  ret  .  setDevice  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setInode  (  readAsciiLong  (  6  ,  8  )  )  ;  final  long  mode  =  readAsciiLong  (  6  ,  8  )  ;  if  (  mode  !  =  0  )  {  ret  .  setMode  (  mode  )  ;  }  ret  .  setUID  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setGID  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setNumberOfLinks  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setRemoteDevice  (  readAsciiLong  (  6  ,  8  )  )  ;  ret  .  setTime  (  readAsciiLong  (  11  ,  8  )  )  ;  long  namesize  =  readAsciiLong  (  6  ,  8  )  ;  ret  .  setSize  (  readAsciiLong  (  11  ,  8  )  )  ;  final  String  name  =  readCString  (  (  int  )  namesize  )  ;  ret  .  setName  (  name  )  ;  [BUGGY]  if  (  mode  =  =  0  &&  !name  .  equals  (  CPIO_TRAILER  )  )  {  throw  new  IOException  (   "Mode  0  only  allowed  in  the  trailer  .  Found  entry:   "+  name  +   "  Occured  at  byte:   "  +  getBytesRead  (  )  )  ;  }  return  ret  ;  }  	Compress_20_CpioArchiveInputStream_6_4	373	1	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java
935	if  (CpioUtil.fileType(mode)  !=  0){  	[BUGGY]  if  (  mode  !  =  0  )  {  [FE]  IllegalArgumentException:  Unknown  mode  Full:  1a4  Masked:  0  assertEquals  (  count  ,  1  )  ;  [METHOD]  readOldBinaryEntry  [TYPE]  CpioArchiveEntry  [PARAMETER]  final  boolean  swapHalfWord  [CLASS]  CpioArchiveInputStream  [TYPE]  byte[]  FOUR_BYTES_BUF  SIX_BYTES_BUF  TWO_BYTES_BUF  tmpbuf  [TYPE]  boolean  closed  entryEOF  false  swapHalfWord  true  [TYPE]  InputStream  in  [TYPE]  String  name  [TYPE]  CpioArchiveEntry  entry  ret  [TYPE]  long  crc  entryBytesRead  mode  namesize  [TYPE]  int  blockSize  [CONTEXT]  private  CpioArchiveEntry  readOldBinaryEntry  (  final  boolean  swapHalfWord  )  throws  IOException  {  CpioArchiveEntry  ret  =  new  CpioArchiveEntry  (  FORMAT_OLD_BINARY  )  ;  ret  .  setDevice  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setInode  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  final  long  mode  =  readBinaryLong  (  2  ,  swapHalfWord  )  ;  [BUGGY]  if  (  mode  !  =  0  )  {  ret  .  setMode  (  mode  )  ;  }  ret  .  setUID  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setGID  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setNumberOfLinks  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setRemoteDevice  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setTime  (  readBinaryLong  (  4  ,  swapHalfWord  )  )  ;  long  namesize  =  readBinaryLong  (  2  ,  swapHalfWord  )  ;  ret  .  setSize  (  readBinaryLong  (  4  ,  swapHalfWord  )  )  ;  final  String  name  =  readCString  (  (  int  )  namesize  )  ;  ret  .  setName  (  name  )  ;  if  (  mode  =  =  0  &&  !name  .  equals  (  CPIO_TRAILER  )  )  {  throw  new  IOException  (   "Mode  0  only  allowed  in  the  trailer  .  Found  entry:   "+name  +   "Occured  at  byte:   "  +  getBytesRead  (  )  )  ;  }  skip  (  ret  .  getHeaderPadCount  (  )  )  ;  return  ret  ;  }  	Compress_20_CpioArchiveInputStream_6_5	387	1	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java
936	if  (CpioUtil.fileType(mode)  ==  0  &&  !name.equals(CPIO_TRAILER)){  	[BUGGY]  if  (  mode  =  =  0  &&  !name  .  equals  (  CPIO_TRAILER  )  )  {  [FE]  IllegalArgumentException:  Unknown  mode  Full:  1a4  Masked:  0  assertEquals  (  count  ,  1  )  ;  [METHOD]  readOldBinaryEntry  [TYPE]  CpioArchiveEntry  [PARAMETER]  final  boolean  swapHalfWord  [CLASS]  CpioArchiveInputStream  [TYPE]  byte[]  FOUR_BYTES_BUF  SIX_BYTES_BUF  TWO_BYTES_BUF  tmpbuf  [TYPE]  boolean  closed  entryEOF  false  swapHalfWord  true  [TYPE]  InputStream  in  [TYPE]  String  name  [TYPE]  CpioArchiveEntry  entry  ret  [TYPE]  long  crc  entryBytesRead  mode  namesize  [TYPE]  int  blockSize  [CONTEXT]  private  CpioArchiveEntry  readOldBinaryEntry  (  final  boolean  swapHalfWord  )  throws  IOException  {  CpioArchiveEntry  ret  =  new  CpioArchiveEntry  (  FORMAT_OLD_BINARY  )  ;  ret  .  setDevice  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setInode  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  final  long  mode  =  readBinaryLong  (  2  ,  swapHalfWord  )  ;  if  (  mode  !  =  0  )  {  ret  .  setMode  (  mode  )  ;  }  ret  .  setUID  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setGID  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setNumberOfLinks  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setRemoteDevice  (  readBinaryLong  (  2  ,  swapHalfWord  )  )  ;  ret  .  setTime  (  readBinaryLong  (  4  ,  swapHalfWord  )  )  ;  long  namesize  =  readBinaryLong  (  2  ,  swapHalfWord  )  ;  ret  .  setSize  (  readBinaryLong  (  4  ,  swapHalfWord  )  )  ;  final  String  name  =  readCString  (  (  int  )  namesize  )  ;  ret  .  setName  (  name  )  ;  [BUGGY]  if  (  mode  =  =  0  &&  !name  .  equals  (  CPIO_TRAILER  )  )  {  throw  new  IOException  (   "Mode  0  only  allowed  in  the  trailer  .  Found  entry:   "+name  +   "Occured  at  byte:   "  +  getBytesRead  (  )  )  ;  }  skip  (  ret  .  getHeaderPadCount  (  )  )  ;  return  ret  ;  }  	Compress_20_CpioArchiveInputStream_6_6	399	1	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java
937	if  (--shift  <  0)  {  	[BUGGY]  --shift  ;  if  (  shift  =  =  0  )  {  [FE]  IOException:  Unknown  property  128  [METHOD]  writeBits  [TYPE]  void  [PARAMETER]  DataOutput  header  BitSet  bits  final  int  length  [CLASS]  SevenZOutputFile  [TYPE]  DataOutput  header  [TYPE]  CountingOutputStream  currentOutputStream  [TYPE]  boolean  false  finished  true  [TYPE]  RandomAccessFile  file  [TYPE]  CRC32  compressedCrc32  crc32  [TYPE]  SevenZMethod  contentCompression  [TYPE]  BitSet  bits  [TYPE]  List  files  [TYPE]  int  cache  i  length  numNonEmptyStreams  shift  [TYPE]  long  fileBytesWritten  [CONTEXT]  private  void  writeBits  (  final  DataOutput  header  ,  final  BitSet  bits  ,  final  int  length  )  throws  IOException  {  int  cache  =  0  ;  int  shift  =  7  ;  for  (  int  i  =  0  ;  i  <  length  ;  i++  )  {  cache  |  =  (  (  bits  .  get  (  i  )  ?  1  :  0  )  <<  shift  )  ;  [BUGGY]  --shift  ;  if  (  shift  =  =  0  )  {  header  .  write  (  cache  )  ;  shift  =  7  ;  cache  =  0  ;  }  }  if  (  length  >  0  &&  shift  >  0  )  {  header  .  write  (  cache  )  ;  }  }  	Compress_21_SevenZOutputFile_2_1	639	2	src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java
938	if  (shift  !=  7)  {  	[BUGGY]  if  (  length  >  0  &&  shift  >  0  )  {  [FE]  IOException:  Unknown  property  128  [METHOD]  writeBits  [TYPE]  void  [PARAMETER]  DataOutput  header  BitSet  bits  final  int  length  [CLASS]  SevenZOutputFile  [TYPE]  DataOutput  header  [TYPE]  CountingOutputStream  currentOutputStream  [TYPE]  boolean  false  finished  true  [TYPE]  RandomAccessFile  file  [TYPE]  CRC32  compressedCrc32  crc32  [TYPE]  SevenZMethod  contentCompression  [TYPE]  BitSet  bits  [TYPE]  List  files  [TYPE]  int  cache  i  length  numNonEmptyStreams  shift  [TYPE]  long  fileBytesWritten  [CONTEXT]  private  void  writeBits  (  final  DataOutput  header  ,  final  BitSet  bits  ,  final  int  length  )  throws  IOException  {  int  cache  =  0  ;  int  shift  =  7  ;  for  (  int  i  =  0  ;  i  <  length  ;  i++  )  {  cache  |  =  (  (  bits  .  get  (  i  )  ?  1  :  0  )  <<  shift  )  ;  --shift  ;  if  (  shift  =  =  0  )  {  header  .  write  (  cache  )  ;  shift  =  7  ;  cache  =  0  ;  }  }  [BUGGY]  if  (  length  >  0  &&  shift  >  0  )  {  header  .  write  (  cache  )  ;  }  }  	Compress_21_SevenZOutputFile_2_2	646	1	src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java
939		[BUGGY]  private  int  currentChar  =  -1  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [CLASS]  [CONTEXT]  	Compress_22_BZip2CompressorInputStream_11_1	67	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
940		[BUGGY]  setupBlock  (  )  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [CLASS]  [CONTEXT]  	Compress_22_BZip2CompressorInputStream_11_2	135	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
941		[BUGGY]  final  int  retChar  =  this  .  currentChar  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  read0  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  retChar  storedBlockCRC  storedCombinedCRC  su_ch2  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  private  int  read0  (  )  throws  IOException  {  [BUGGY]  final  int  retChar  =  this  .  currentChar  ;  switch  (  currentState  )  {  case  EOF:  return  -1  ;  case  START_BLOCK_STATE:  	Compress_22_BZip2CompressorInputStream_11_3	199	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
942	return  setupBlock();  	[BUGGY]  throw  new  IllegalStateException  (  )  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  read0  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  retChar  storedBlockCRC  storedCombinedCRC  su_ch2  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  private  int  read0  (  )  throws  IOException  {  final  int  retChar  =  this  .  currentChar  ;  switch  (  currentState  )  {  case  EOF:  return  -1  ;  case  START_BLOCK_STATE:  [BUGGY]  throw  new  IllegalStateException  (  )  ;  case  RAND_PART_A_STATE:  throw  new  IllegalStateException  (  )  ;  case  RAND_PART_B_STATE:  	Compress_22_BZip2CompressorInputStream_11_4	205	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
943	return  setupRandPartB();  return  setupRandPartC();  	[BUGGY]  setupRandPartB  (  )  ;  break  ;  setupRandPartC  (  )  ;  break  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  read0  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  retChar  storedBlockCRC  storedCombinedCRC  su_ch2  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  private  int  read0  (  )  throws  IOException  {  final  int  retChar  =  this  .  currentChar  ;  switch  (  currentState  )  {  case  EOF:  return  -1  ;  case  START_BLOCK_STATE:  throw  new  IllegalStateException  (  )  ;  case  RAND_PART_A_STATE:  throw  new  IllegalStateException  (  )  ;  case  RAND_PART_B_STATE:  [BUGGY]  setupRandPartB  (  )  ;  break  ;  case  RAND_PART_C_STATE:  setupRandPartC  (  )  ;  break  ;  	Compress_22_BZip2CompressorInputStream_11_5	211	4	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
944	return  setupNoRandPartB();  return  setupNoRandPartC();  	[BUGGY]  setupNoRandPartB  (  )  ;  break  ;  setupNoRandPartC  (  )  ;  break  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  read0  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  retChar  storedBlockCRC  storedCombinedCRC  su_ch2  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  private  int  read0  (  )  throws  IOException  {  final  int  retChar  =  this  .  currentChar  ;  switch  (  currentState  )  {  case  EOF:  return  -1  ;  case  START_BLOCK_STATE:  throw  new  IllegalStateException  (  )  ;  case  RAND_PART_A_STATE:  throw  new  IllegalStateException  (  )  ;  case  RAND_PART_B_STATE:  setupRandPartB  (  )  ;  break  ;  case  RAND_PART_C_STATE:  setupRandPartC  (  )  ;  break  ;  case  NO_RAND_PART_A_STATE:  throw  new  IllegalStateException  (  )  ;  case  NO_RAND_PART_B_STATE:  [BUGGY]  setupNoRandPartB  (  )  ;  break  ;  case  NO_RAND_PART_C_STATE:  setupNoRandPartC  (  )  ;  break  ;  	Compress_22_BZip2CompressorInputStream_11_6	222	4	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
945		[BUGGY]  return  retChar  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  read0  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  retChar  storedBlockCRC  storedCombinedCRC  su_ch2  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  case  RAND_PART_A_STATE:  throw  new  IllegalStateException  (  )  ;  case  RAND_PART_B_STATE:  setupRandPartB  (  )  ;  break  ;  case  RAND_PART_C_STATE:  setupRandPartC  (  )  ;  break  ;  case  NO_RAND_PART_A_STATE:  throw  new  IllegalStateException  (  )  ;  case  NO_RAND_PART_B_STATE:  setupNoRandPartB  (  )  ;  break  ;  case  NO_RAND_PART_C_STATE:  setupNoRandPartC  (  )  ;  break  ;  default:  throw  new  IllegalStateException  (  )  ;  }  [BUGGY]  return  retChar  ;  }  private  boolean  init  (  boolean  isFirstStream  )  throws  IOException  {  if  (  null  =  =  in  )  {  throw  new  IOException  (   "No  InputStream "  )  ;  	Compress_22_BZip2CompressorInputStream_11_7	232	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
946		[BUGGY]  this  .  currentChar  =  su_ch2Shadow  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  setupRandPartA  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  storedBlockCRC  storedCombinedCRC  su_ch2  su_ch2Shadow  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  private  int  setupRandPartA  (  )  throws  IOException  {  if  (  this  .  su_i2  <  =  this  .  last  )  {  this  .  su_chPrev  =  this  .  su_ch2  ;  int  su_ch2Shadow  =  this  .  data  .  ll8[this  .  su_tPos]  &  0xff  ;  this  .  su_tPos  =  this  .  data  .  tt[this  .  su_tPos]  ;  if  (  this  .  su_rNToGo  =  =  0  )  {  this  .  su_rNToGo  =  Rand  .  rNums  (  this  .  su_rTPos  )  -  1  ;  if  (  ++this  .  su_rTPos  =  =  512  )  {  this  .  su_rTPos  =  0  ;  }  }  else  {  this  .  su_rNToGo--  ;  }  this  .  su_ch2  =  su_ch2Shadow  ^  =  (  this  .  su_rNToGo  =  =  1  )  ?  1  :  0  ;  this  .  su_i2++  ;  [BUGGY]  this  .  currentChar  =  su_ch2Shadow  ;  this  .  currentState  =  RAND_PART_B_STATE  ;  this  .  crc  .  updateCRC  (  su_ch2Shadow  )  ;  return  su_ch2Shadow  ;  }  else  {  endBlock  (  )  ;  initBlock  (  )  ;  return  setupBlock  (  )  ;  }  }  	Compress_22_BZip2CompressorInputStream_11_8	853	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
947		[BUGGY]  this  .  currentChar  =  su_ch2Shadow  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  setupNoRandPartA  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  storedBlockCRC  storedCombinedCRC  su_ch2  su_ch2Shadow  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  private  int  setupNoRandPartA  (  )  throws  IOException  {  if  (  this  .  su_i2  <  =  this  .  last  )  {  this  .  su_chPrev  =  this  .  su_ch2  ;  int  su_ch2Shadow  =  this  .  data  .  ll8[this  .  su_tPos]  &  0xff  ;  this  .  su_ch2  =  su_ch2Shadow  ;  this  .  su_tPos  =  this  .  data  .  tt[this  .  su_tPos]  ;  this  .  su_i2++  ;  [BUGGY]  this  .  currentChar  =  su_ch2Shadow  ;  this  .  currentState  =  NO_RAND_PART_B_STATE  ;  this  .  crc  .  updateCRC  (  su_ch2Shadow  )  ;  return  su_ch2Shadow  ;  }  else  {  this  .  currentState  =  NO_RAND_PART_A_STATE  ;  endBlock  (  )  ;  initBlock  (  )  ;  return  setupBlock  (  )  ;  }  }  	Compress_22_BZip2CompressorInputStream_11_9	871	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
948		[BUGGY]  this  .  currentChar  =  this  .  su_ch2  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  setupRandPartC  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  storedBlockCRC  storedCombinedCRC  su_ch2  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  private  int  setupRandPartC  (  )  throws  IOException  {  if  (  this  .  su_j2  <  this  .  su_z  )  {  [BUGGY]  this  .  currentChar  =  this  .  su_ch2  ;  this  .  crc  .  updateCRC  (  this  .  su_ch2  )  ;  this  .  su_j2++  ;  return  this  .  su_ch2  ;  }  else  {  this  .  currentState  =  RAND_PART_A_STATE  ;  this  .  su_i2++  ;  this  .  su_count  =  0  ;  return  setupRandPartA  (  )  ;  }  }  	Compress_22_BZip2CompressorInputStream_11_10	913	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
949		[BUGGY]  this  .  currentChar  =  su_ch2Shadow  ;  [FE]  IOException:  unexpected  end  of  stream  assertArrayEquals  (  Arrays  .  copyOfRange  (  TEXT  .  getBytes  (  )  ,  0  ,  length  )  ,  [METHOD]  setupNoRandPartC  [TYPE]  int  [PARAMETER]  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  blockSize100k  bsBuff  bsLive  computedBlockCRC  computedCombinedCRC  currentChar  currentState  last  nInUse  origPtr  storedBlockCRC  storedCombinedCRC  su_ch2  su_ch2Shadow  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  private  int  setupNoRandPartC  (  )  throws  IOException  {  if  (  this  .  su_j2  <  this  .  su_z  )  {  int  su_ch2Shadow  =  this  .  su_ch2  ;  [BUGGY]  this  .  currentChar  =  su_ch2Shadow  ;  this  .  crc  .  updateCRC  (  su_ch2Shadow  )  ;  this  .  su_j2++  ;  this  .  currentState  =  NO_RAND_PART_C_STATE  ;  return  su_ch2Shadow  ;  }  else  {  this  .  su_i2++  ;  this  .  su_count  =  0  ;  return  setupNoRandPartA  (  )  ;  }  }  	Compress_22_BZip2CompressorInputStream_11_11	942	1	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
950	dictSize  |=  (coder.properties[i  +  1]  &  0xffl)  <<  (8  *  i);  	[BUGGY]  dictSize  |  =  (  coder  .  properties[i  +  1]  <<  (  8  *  i  )  )  ;  [FE]  xzUnsupportedOptionsException:  LZMA  dictionary  is  too  big  for  this  implementation  assertNull  (  sevenZFile  .  getNextEntry  (  )  )  ;  [METHOD]  decode  [TYPE]  InputStream  [PARAMETER]  InputStream  in  Coder  coder  byte[]  password  [CLASS]  LZMADecoder  [TYPE]  byte[]  password  [TYPE]  Coder  coder  [TYPE]  boolean  false  true  [TYPE]  InputStream  in  [TYPE]  byte  propsByte  [TYPE]  long  dictSize  [TYPE]  int  i  [CONTEXT]  InputStream  decode  (  final  InputStream  in  ,  final  Coder  coder  ,  byte[]  password  )  throws  IOException  {  byte  propsByte  =  coder  .  properties[0]  ;  long  dictSize  =  coder  .  properties[1]  ;  for  (  int  i  =  1  ;  i  <  4  ;  i++  )  {  [BUGGY]  dictSize  |  =  (  coder  .  properties[i  +  1]  <<  (  8  *  i  )  )  ;  }  if  (  dictSize  >  LZMAInputStream  .  DICT_SIZE_MAX  )  {  throw  new  IOException  (   "Dictionary  larger  than  4GiB  maximum  size "  )  ;  }  return  new  LZMAInputStream  (  in  ,  -1  ,  propsByte  ,  (  int  )  dictSize  )  ;  }  	Compress_23_Coders_1_1	112	1	src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java
951		[BUGGY]  }  else  {  throw  new  IllegalArgumentException  (  exceptionMessage  (  buffer  ,  offset  ,  length  ,  end-1  ,  trailer  )  )  ;  }  trailer  =  buffer[end  -  1]  ;  \n'  ,   "-    while  (  start  <  end  -  1  &&  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  )  {\n "  ,   "+    while  (  start  <  end  &&  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  )  {\n "  ,  '        end--  ;  [FE]  IllegalArgumentException:  Invalid  byte  55  at  offset  11  in  '777777777777'  len  =  12  assertEquals  (  value  ,  parseValue  )  ;  [METHOD]  parseOctal  [TYPE]  long  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  boolean  false  true  [TYPE]  ZipEncoding  DEFAULT_ENCODING  FALLBACK_ENCODING  [TYPE]  int  BYTE_MASK  end  length  offset  start  [TYPE]  long  result  [TYPE]  byte  currentByte  trailer  [CONTEXT]  int  end  =  offset  +  length  ;  int  start  =  offset  ;  if  (  length  <  2  )  {  throw  new  IllegalArgumentException  (   "Length   "+length+ "  must  be  at  least  2 "  )  ;  }  if  (  buffer[start]  =  =  0  )  {  return  0L  ;  }  while  (  start  <  end  )  {  if  (  buffer[start]  =  =  '  '  )  {  start++  ;  }  else  {  break  ;  }  }      byte  trailer  =  buffer[end  -  1]  ;  [BUGGY]  if  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  {  end--  ;  }  else  {  throw  new  IllegalArgumentException  (  exceptionMessage  (  buffer  ,  offset  ,  length  ,  end-1  ,  trailer  )  )  ;  }  	Compress_24_TarUtils_2_1	129	5	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
952	if  (start  ==  end)  {  throw  new  IllegalArgumentException(  exceptionMessage(buffer,  offset,  length,  start,  trailer));  }  	[BUGGY]  [FE]  IllegalArgumentException:  Invalid  byte  55  at  offset  11  in  '777777777777'  len  =  12  assertEquals  (  value  ,  parseValue  )  ;  [METHOD]  parseOctal  [TYPE]  long  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  boolean  false  true  [TYPE]  ZipEncoding  DEFAULT_ENCODING  FALLBACK_ENCODING  [TYPE]  int  BYTE_MASK  end  length  offset  start  [TYPE]  long  result  [TYPE]  byte  currentByte  trailer  [CONTEXT]  while  (  start  <  end  )  {  if  (  buffer[start]  =  =  '  '  )  {  start++  ;  }  else  {  break  ;  }  }      byte  trailer  =  buffer[end  -  1]  ;  if  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  {  end--  ;  }  else  {  throw  new  IllegalArgumentException  (  exceptionMessage  (  buffer  ,  offset  ,  length  ,  end-1  ,  trailer  )  )  ;  }  trailer  =  buffer[end  -  1]  ;  while  (  start  <  end  -  1  &&  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  )  {  end--  ;  trailer  =  buffer[end  -  1]  ;  }  [BUGGY]  for  (  ;  start  <  end  ;  start++  )  {  final  byte  currentByte  =  buffer[start]  ;  if  (  currentByte  <  '0'  ||  currentByte  >  '7'  )  {  throw  new  IllegalArgumentException  (  	Compress_24_TarUtils_2_2	140	0	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
953		[BUGGY]  [FE]  AssertionFailedError:  arrays  first  differed  at  element  [0]  ;  expected:<100>  but  was:<0>  assertArrayEquals  (  new  byte[]  {'d'  ,  'a'  ,  't'  ,  'a'  ,  '\n'}  ,  [CLASS]  [CONTEXT]  	Compress_25_ZipArchiveInputStream_1_1	184	0	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
954	if  (numToSkip  >  0)  {  byte[]  skipBuf  =  new  byte[SKIP_BUF_SIZE];  while  (numToSkip  >  0)  {  int  read  =  readFully(input,  skipBuf,  0,  (int)  Math.min(numToSkip,  SKIP_BUF_SIZE));  if  (read  <  1)  {  break;  }  numToSkip  -=  read;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<10>  but  was:<0>  [METHOD]  skip  [TYPE]  long  [PARAMETER]  InputStream  input  long  numToSkip  [CLASS]  IOUtils  [TYPE]  boolean  false  true  [TYPE]  int  COPY_BUF_SIZE  SKIP_BUF_SIZE  [TYPE]  InputStream  input  [TYPE]  long  available  numToSkip  skipped  [CONTEXT]  public  static  long  skip  (  InputStream  input  ,  long  numToSkip  )  throws  IOException  {  long  available  =  numToSkip  ;  while  (  numToSkip  >  0  )  {  long  skipped  =  input  .  skip  (  numToSkip  )  ;  if  (  skipped  =  =  0  )  {  break  ;  }  numToSkip  -  =  skipped  ;  }  [BUGGY]  return  available  -  numToSkip  ;  }  	Compress_26_IOUtils_1_1	104	0	src/main/java/org/apache/commons/compress/utils/IOUtils.java
955		[BUGGY]  if  (  start  =  =  end  )  {  throw  new  IllegalArgumentException  (  exceptionMessage  (  buffer  ,  offset  ,  length  ,  start  ,  trailer  )  )  ;  }  [FE]  IllegalArgumentException:  Invalid  byte  32  at  offset  1  in  '  {NUL}'  len  =  2  assertEquals  (  value  ,  parseValue  )  ;  [METHOD]  parseOctal  [TYPE]  long  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  boolean  false  true  [TYPE]  ZipEncoding  DEFAULT_ENCODING  FALLBACK_ENCODING  [TYPE]  int  BYTE_MASK  end  length  offset  start  [TYPE]  long  result  [TYPE]  byte  currentByte  trailer  [CONTEXT]  throw  new  IllegalArgumentException  (   "Length   "+length+ "  must  be  at  least  2 "  )  ;  }  if  (  buffer[start]  =  =  0  )  {  return  0L  ;  }  while  (  start  <  end  )  {  if  (  buffer[start]  =  =  '  '  )  {  start++  ;  }  else  {  break  ;  }  }      byte  trailer  =  buffer[end  -  1]  ;  while  (  start  <  end  &&  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  )  {  end--  ;  trailer  =  buffer[end  -  1]  ;  }  [BUGGY]  if  (  start  =  =  end  )  {  throw  new  IllegalArgumentException  (  exceptionMessage  (  buffer  ,  offset  ,  length  ,  start  ,  trailer  )  )  ;  }  for  (  ;  start  <  end  ;  start++  )  {  	Compress_27_TarUtils_1_1	133	4	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
956	if  (numToRead  >  0)  {  throw  new  IOException( "Truncated  TAR  archive ");  }  count(totalRead);  	[BUGGY]  count  (  totalRead  )  ;  [FE]  AssertionFailedError:  Expected  exception:  javaioIOException  [METHOD]  read  [TYPE]  int  [PARAMETER]  byte[]  buf  int  offset  int  numToRead  [CLASS]  TarArchiveInputStream  [TYPE]  byte[]  SMALL_BUF  buf  [TYPE]  boolean  false  hasHitEOF  true  [TYPE]  ZipEncoding  encoding  [TYPE]  InputStream  is  [TYPE]  int  SMALL_BUFFER_SIZE  blockSize  numToRead  offset  recordSize  totalRead  [TYPE]  long  entryOffset  entrySize  [TYPE]  TarArchiveEntry  currEntry  [CONTEXT]  public  int  read  (  byte[]  buf  ,  int  offset  ,  int  numToRead  )  throws  IOException  {  int  totalRead  =  0  ;  if  (  hasHitEOF  ||  entryOffset  >  =  entrySize  )  {  return  -1  ;  }  if  (  currEntry  =  =  null  )  {  throw  new  IllegalStateException  (   "No  current  tar  entry "  )  ;  }  numToRead  =  Math  .  min  (  numToRead  ,  available  (  )  )  ;  totalRead  =  is  .  read  (  buf  ,  offset  ,  numToRead  )  ;  [BUGGY]  count  (  totalRead  )  ;  if  (  totalRead  =  =  -1  )  {  hasHitEOF  =  true  ;  }  else  {  entryOffset  +  =  totalRead  ;  }  return  totalRead  ;  }  	Compress_28_TarArchiveInputStream_1_1	583	1	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java
957	if  (entryEncoding  !=  null)  {  return  new  JarArchiveOutputStream(out,  entryEncoding);  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [METHOD]  createArchiveOutputStream  [TYPE]  ArchiveOutputStream  [PARAMETER]  String  archiverName  OutputStream  out  [CLASS]  ArchiveStreamFactory  [TYPE]  ZipArchiveOutputStream  zip  [TYPE]  String  AR  ARJ  CPIO  DUMP  JAR  SEVEN_Z  TAR  ZIP  archiverName  encoding  entryEncoding  [TYPE]  boolean  false  true  [TYPE]  OutputStream  out  [CONTEXT]  if  (  archiverName  =  =  null  )  {  throw  new  IllegalArgumentException  (   "Archivername  must  not  be  null  .   "  )  ;  }  if  (  out  =  =  null  )  {  throw  new  IllegalArgumentException  (   "OutputStream  must  not  be  null  .   "  )  ;  }  if  (  AR  .  equalsIgnoreCase  (  archiverName  )  )  {  return  new  ArArchiveOutputStream  (  out  )  ;  }  if  (  ZIP  .  equalsIgnoreCase  (  archiverName  )  )  {  ZipArchiveOutputStream  zip  =  new  ZipArchiveOutputStream  (  out  )  ;  if  (  entryEncoding  !  =  null  )  {  zip  .  setEncoding  (  entryEncoding  )  ;  }  return  zip  ;  }  if  (  TAR  .  equalsIgnoreCase  (  archiverName  )  )  {  if  (  entryEncoding  !  =  null  )  {  return  new  TarArchiveOutputStream  (  out  ,  entryEncoding  )  ;  }  else  {  return  new  TarArchiveOutputStream  (  out  )  ;  }  }  if  (  JAR  .  equalsIgnoreCase  (  archiverName  )  )  {  [BUGGY]  return  new  JarArchiveOutputStream  (  out  )  ;  }  if  (  CPIO  .  equalsIgnoreCase  (  archiverName  )  )  {  if  (  entryEncoding  !  =  null  )  {  return  new  CpioArchiveOutputStream  (  out  ,  entryEncoding  )  ;  }  else  {  	Compress_29_ArchiveStreamFactory_2_1	297	0	src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java
958	if  (entryEncoding  !=  null)  {  return  new  ArjArchiveInputStream(in,  entryEncoding);  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [METHOD]  createArchiveInputStream  [TYPE]  ArchiveInputStream  [PARAMETER]  InputStream  in  [CLASS]  ArchiveStreamFactory  [TYPE]  byte[]  dumpsig  signature  tarheader  [TYPE]  TarArchiveInputStream  tais  [TYPE]  boolean  false  true  [TYPE]  InputStream  in  [TYPE]  String  AR  ARJ  CPIO  DUMP  JAR  SEVEN_Z  TAR  ZIP  encoding  entryEncoding  [TYPE]  IOException  e  [TYPE]  int  signatureLength  [TYPE]  Exception  e  [CONTEXT]  in  .  mark  (  signature  .  length  )  ;  try  {  int  signatureLength  =  IOUtils  .  readFully  (  in  ,  signature  )  ;  in  .  reset  (  )  ;  if  (  ZipArchiveInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  if  (  entryEncoding  !  =  null  )  {  return  new  ZipArchiveInputStream  (  in  ,  entryEncoding  )  ;  }  else  {  return  new  ZipArchiveInputStream  (  in  )  ;  }  }  else  if  (  JarArchiveInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  if  (  entryEncoding  !  =  null  )  {  return  new  JarArchiveInputStream  (  in  ,  entryEncoding  )  ;  }  else  {  return  new  JarArchiveInputStream  (  in  )  ;  }  }  else  if  (  ArArchiveInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  return  new  ArArchiveInputStream  (  in  )  ;  }  else  if  (  CpioArchiveInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  if  (  entryEncoding  !  =  null  )  {  return  new  CpioArchiveInputStream  (  in  ,  entryEncoding  )  ;  }  else  {  return  new  CpioArchiveInputStream  (  in  )  ;  }  }  else  if  (  ArjArchiveInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  [BUGGY]  return  new  ArjArchiveInputStream  (  in  )  ;  }  else  if  (  SevenZFile  .  matches  (  signature  ,  signatureLength  )  )  {  throw  new  StreamingNotSupportedException  (  SEVEN_Z  )  ;  }  	Compress_29_ArchiveStreamFactory_2_2	360	0	src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java
959	final  String  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_CpioArchiveInputStream_2_1	97	0	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java
960	this.encoding  =  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_CpioArchiveInputStream_2_2	155	0	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveInputStream.java
961	final  String  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_CpioArchiveOutputStream_2_1	98	0	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
962	this.encoding  =  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_CpioArchiveOutputStream_2_2	162	0	src/main/java/org/apache/commons/compress/archivers/cpio/CpioArchiveOutputStream.java
963	final  String  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_DumpArchiveInputStream_2_1	80	0	src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java
964	this.encoding  =  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_DumpArchiveInputStream_2_2	104	0	src/main/java/org/apache/commons/compress/archivers/dump/DumpArchiveInputStream.java
965	final  String  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_TarArchiveInputStream_2_1	79	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java
966	this.encoding  =  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_TarArchiveInputStream_2_2	142	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java
967	final  String  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_TarArchiveOutputStream_2_1	90	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
968	this.encoding  =  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_TarArchiveOutputStream_2_2	155	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveOutputStream.java
969	final  String  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_ZipArchiveInputStream_2_1	65	0	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
970	this.encoding  =  encoding;  	[BUGGY]  [FE]  AssertionFailedError:  Tests  failed:  20  [CLASS]  [CONTEXT]  	Compress_29_ZipArchiveInputStream_2_2	184	0	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
971	if  (len  ==  0)  {  return  0;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<0>  but  was:<-1>  Assert  .  assertEquals  (  1024  ,  bzipIn  .  read  (  buffer  ,  0  ,  1024  )  )  ;  [METHOD]  read  [TYPE]  int  [PARAMETER]  final  byte[]  dest  final  int  offs  final  int  len  [CLASS]  BZip2CompressorInputStream  [TYPE]  int[][]  base  limit  perm  [TYPE]  InputStream  in  [TYPE]  char[][]  temp_charArray2d  [TYPE]  Data  data  [TYPE]  int[]  cftab  minLens  tt  unzftab  [TYPE]  int  EOF  NO_RAND_PART_A_STATE  NO_RAND_PART_B_STATE  NO_RAND_PART_C_STATE  RAND_PART_A_STATE  RAND_PART_B_STATE  RAND_PART_C_STATE  START_BLOCK_STATE  b  blockSize100k  bsBuff  bsLive  c  computedBlockCRC  computedCombinedCRC  currentState  destOffs  hi  last  len  nInUse  offs  origPtr  storedBlockCRC  storedCombinedCRC  su_ch2  su_chPrev  su_count  su_i2  su_j2  su_rNToGo  su_rTPos  su_tPos  [TYPE]  char[]  getAndMoveToFrontDecode_yy  [TYPE]  byte[]  dest  ll8  recvDecodingTables_pos  selector  selectorMtf  seqToUnseq  [TYPE]  boolean  blockRandomised  decompressConcatenated  false  true  [TYPE]  CRC  crc  [TYPE]  char  su_z  [TYPE]  boolean[]  inUse  [CONTEXT]  public  int  read  (  final  byte[]  dest  ,  final  int  offs  ,  final  int  len  )  throws  IOException  {  if  (  offs  <  0  )  {  throw  new  IndexOutOfBoundsException  (   "offs  (   "  +  offs  +   "  )  <  0  .   "  )  ;  }  if  (  len  <  0  )  {  throw  new  IndexOutOfBoundsException  (   "len  (   "  +  len  +   "  )  <  0  .   "  )  ;  }  if  (  offs  +  len  >  dest  .  length  )  {  throw  new  IndexOutOfBoundsException  (   "offs  (   "  +  offs  +   "  )  +  len  (   "  +  len  +   "  )  >  dest  .  length  (   "  +  dest  .  length  +   "  )  .   "  )  ;  }  if  (  this  .  in  =  =  null  )  {  throw  new  IOException  (   "stream  closed "  )  ;  }  [BUGGY]  final  int  hi  =  offs  +  len  ;  int  destOffs  =  offs  ;  int  b  ;  while  (  destOffs  <  hi  &&  (  (  b  =  read0  (  )  )  >  =  0  )  )  {  dest[destOffs++]  =  (  byte  )  b  ;  count  (  1  )  ;  }  int  c  =  (  destOffs  =  =  offs  )  ?  -1  :  (  destOffs  -  offs  )  ;  return  c  ;  }  	Compress_30_BZip2CompressorInputStream_1_1	168	0	src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java
972		[BUGGY]  if  (  currentByte  =  =  0  )  {  break  ;  }  [FE]  AssertionFailedError:  Expected  IOException  assertTrue  (   "Expected  cause  =  IllegalArgumentException "  ,  t  instanceof  IllegalArgumentException  )  ;  [METHOD]  parseOctal  [TYPE]  long  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buffer  [TYPE]  boolean  false  true  [TYPE]  ZipEncoding  DEFAULT_ENCODING  FALLBACK_ENCODING  [TYPE]  int  BYTE_MASK  end  length  offset  start  [TYPE]  long  result  [TYPE]  byte  currentByte  trailer  [CONTEXT]  if  (  buffer[start]  =  =  0  )  {  return  0L  ;  }  while  (  start  <  end  )  {  if  (  buffer[start]  =  =  '  '  )  {  start++  ;  }  else  {  break  ;  }  }      byte  trailer  =  buffer[end  -  1]  ;  while  (  start  <  end  &&  (  trailer  =  =  0  ||  trailer  =  =  '  '  )  )  {  end--  ;  trailer  =  buffer[end  -  1]  ;  }  for  (  ;  start  <  end  ;  start++  )  {  final  byte  currentByte  =  buffer[start]  ;  [BUGGY]  if  (  currentByte  =  =  0  )  {  break  ;  }  if  (  currentByte  <  '0'  ||  currentByte  >  '7'  )  {  throw  new  IllegalArgumentException  (  	Compress_31_TarUtils_1_1	135	3	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
973	currEntry.setGroupId(Long.parseLong(val));  	[BUGGY]  currEntry  .  setGroupId  (  Integer  .  parseInt  (  val  )  )  ;  [FE]  NumberFormatException:  For  input  string:   "4294967294 "  assertEquals  (  4294967294l  ,  t  .  getLongGroupId  (  )  )  ;  [METHOD]  applyPaxHeadersToCurrentEntry  [TYPE]  void  [PARAMETER]  String>  headers  [CLASS]  TarArchiveInputStream  [TYPE]  byte[]  SMALL_BUF  [TYPE]  Entry  ent  [TYPE]  boolean  false  hasHitEOF  true  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  InputStream  is  [TYPE]  String  encoding  key  val  [TYPE]  Map  headers  [TYPE]  int  SMALL_BUFFER_SIZE  blockSize  recordSize  [TYPE]  long  entryOffset  entrySize  [TYPE]  TarArchiveEntry  currEntry  [CONTEXT]  private  void  applyPaxHeadersToCurrentEntry  (  Map<String  ,  String>  headers  )  {            for  (  Entry<String  ,  String>  ent  :  headers  .  entrySet  (  )  )  {  String  key  =  ent  .  getKey  (  )  ;  String  val  =  ent  .  getValue  (  )  ;  if  (   "path "  .  equals  (  key  )  )  {  currEntry  .  setName  (  val  )  ;  }  else  if  (   "linkpath "  .  equals  (  key  )  )  {  currEntry  .  setLinkName  (  val  )  ;  }  else  if  (   "gid "  .  equals  (  key  )  )  {  [BUGGY]  currEntry  .  setGroupId  (  Integer  .  parseInt  (  val  )  )  ;  }  else  if  (   "gname "  .  equals  (  key  )  )  {  currEntry  .  setGroupName  (  val  )  ;  }  else  if  (   "uid "  .  equals  (  key  )  )  {  currEntry  .  setUserId  (  Integer  .  parseInt  (  val  )  )  ;  }  else  if  (   "uname "  .  equals  (  key  )  )  {  	Compress_32_TarArchiveInputStream_2_1	501	1	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java
974	currEntry.setUserId(Long.parseLong(val));  	[BUGGY]  currEntry  .  setUserId  (  Integer  .  parseInt  (  val  )  )  ;  [FE]  NumberFormatException:  For  input  string:   "4294967294 "  assertEquals  (  4294967294l  ,  t  .  getLongGroupId  (  )  )  ;  [METHOD]  applyPaxHeadersToCurrentEntry  [TYPE]  void  [PARAMETER]  String>  headers  [CLASS]  TarArchiveInputStream  [TYPE]  byte[]  SMALL_BUF  [TYPE]  Entry  ent  [TYPE]  boolean  false  hasHitEOF  true  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  InputStream  is  [TYPE]  String  encoding  key  val  [TYPE]  Map  headers  [TYPE]  int  SMALL_BUFFER_SIZE  blockSize  recordSize  [TYPE]  long  entryOffset  entrySize  [TYPE]  TarArchiveEntry  currEntry  [CONTEXT]  private  void  applyPaxHeadersToCurrentEntry  (  Map<String  ,  String>  headers  )  {            for  (  Entry<String  ,  String>  ent  :  headers  .  entrySet  (  )  )  {  String  key  =  ent  .  getKey  (  )  ;  String  val  =  ent  .  getValue  (  )  ;  if  (   "path "  .  equals  (  key  )  )  {  currEntry  .  setName  (  val  )  ;  }  else  if  (   "linkpath "  .  equals  (  key  )  )  {  currEntry  .  setLinkName  (  val  )  ;  }  else  if  (   "gid "  .  equals  (  key  )  )  {  currEntry  .  setGroupId  (  Integer  .  parseInt  (  val  )  )  ;  }  else  if  (   "gname "  .  equals  (  key  )  )  {  currEntry  .  setGroupName  (  val  )  ;  }  else  if  (   "uid "  .  equals  (  key  )  )  {  [BUGGY]  currEntry  .  setUserId  (  Integer  .  parseInt  (  val  )  )  ;  }  else  if  (   "uname "  .  equals  (  key  )  )  {  currEntry  .  setUserName  (  val  )  ;  }  else  if  (   "size "  .  equals  (  key  )  )  {  currEntry  .  setSize  (  Long  .  parseLong  (  val  )  )  ;  }  else  if  (   "mtime "  .  equals  (  key  )  )  {  	Compress_32_TarArchiveInputStream_2_2	505	1	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java
975	if  (DeflateCompressorInputStream.matches(signature,  signatureLength))  {  return  new  DeflateCompressorInputStream(in);  }  	[BUGGY]  [FE]  commonscompresscompressorsCompressorException:  No  Compressor  found  for  the  stream  signature  assertTrue  (  zlib  instanceof  DeflateCompressorInputStream  )  ;  [METHOD]  createCompressorInputStream  [TYPE]  CompressorInputStream  [PARAMETER]  InputStream  in  [CLASS]  CompressorStreamFactory  [TYPE]  byte[]  signature  [TYPE]  boolean  decompressConcatenated  false  true  [TYPE]  InputStream  in  [TYPE]  String  BZIP2  DEFLATE  GZIP  LZMA  PACK200  SNAPPY_FRAMED  SNAPPY_RAW  XZ  Z  [TYPE]  IOException  e  [TYPE]  Boolean  decompressUntilEOF  [TYPE]  int  signatureLength  [CONTEXT]  in  .  mark  (  signature  .  length  )  ;  try  {  int  signatureLength  =  IOUtils  .  readFully  (  in  ,  signature  )  ;  in  .  reset  (  )  ;  if  (  BZip2CompressorInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  return  new  BZip2CompressorInputStream  (  in  ,  decompressConcatenated  )  ;  }  if  (  GzipCompressorInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  return  new  GzipCompressorInputStream  (  in  ,  decompressConcatenated  )  ;  }  if  (  Pack200CompressorInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  return  new  Pack200CompressorInputStream  (  in  )  ;  }  if  (  FramedSnappyCompressorInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  return  new  FramedSnappyCompressorInputStream  (  in  )  ;  }  if  (  ZCompressorInputStream  .  matches  (  signature  ,  signatureLength  )  )  {  return  new  ZCompressorInputStream  (  in  )  ;  }  [BUGGY]  if  (  XZUtils  .  matches  (  signature  ,  signatureLength  )  &&  XZUtils  .  isXZCompressionAvailable  (  )  )  {  return  new  XZCompressorInputStream  (  in  ,  decompressConcatenated  )  ;  }  	Compress_33_CompressorStreamFactory_1_1	240	0	src/main/java/org/apache/commons/compress/compressors/CompressorStreamFactory.java
976	private  static  final  int  MAGIC_1  =  0x78;  private  static  final  int  MAGIC_2a  =  0x01;  private  static  final  int  MAGIC_2b  =  0x5e;  private  static  final  int  MAGIC_2c  =  0x9c;  private  static  final  int  MAGIC_2d  =  0xda;  	[BUGGY]  [FE]  commonscompresscompressorsCompressorException:  No  Compressor  found  for  the  stream  signature  assertTrue  (  zlib  instanceof  DeflateCompressorInputStream  )  ;  [CLASS]  [CONTEXT]  	Compress_33_DeflateCompressorInputStream_2_1	33	0	src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java
977	public  static  boolean  matches(byte[]  signature,  int  length)  {  return  length  >  3  &&  signature[0]  ==  MAGIC_1  &&  (  signature[1]  ==  (byte)  MAGIC_2a  ||  signature[1]  ==  (byte)  MAGIC_2b  ||  signature[1]  ==  (byte)  MAGIC_2c  ||  signature[1]  ==  (byte)  MAGIC_2d);  }  	[BUGGY]  [FE]  commonscompresscompressorsCompressorException:  No  Compressor  found  for  the  stream  signature  assertTrue  (  zlib  instanceof  DeflateCompressorInputStream  )  ;  [CLASS]  [CONTEXT]  	Compress_33_DeflateCompressorInputStream_2_2	106	0	src/main/java/org/apache/commons/compress/compressors/deflate/DeflateCompressorInputStream.java
978	private  static  final  ZipShort  ZERO  =  new  ZipShort(0);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<0>  but  was:<5>  assertEquals  (  expectedGID  ,  xf  .  getGID  (  )  )  ;  [CLASS]  [CONTEXT]  	Compress_34_X7875_NewUnix_2_1	58	0	src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java
979	return  ZERO;  	[BUGGY]  return  getLocalFileDataLength  (  )  ;  [FE]  AssertionFailedError:  expected:<0>  but  was:<5>  assertEquals  (  expectedGID  ,  xf  .  getGID  (  )  )  ;  [METHOD]  getCentralDirectoryLength  [TYPE]  ZipShort  [PARAMETER]  [CLASS]  X7875_NewUnix  [TYPE]  BigInteger  ONE_THOUSAND  gid  uid  [TYPE]  ZipShort  HEADER_ID  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  version  [CONTEXT]  public  ZipShort  getCentralDirectoryLength  (  )  {  [BUGGY]  return  getLocalFileDataLength  (  )  ;  }  	Compress_34_X7875_NewUnix_2_2	146	1	src/main/java/org/apache/commons/compress/archivers/zip/X7875_NewUnix.java
980	long  storedSum  =  parseOctal(header,  CHKSUM_OFFSET,  CHKSUMLEN);  	[BUGGY]  long  storedSum  =  0  ;  [FE]  commonscompressarchiversArchiveException:  No  Archiver  found  for  the  stream  signature  assertTrue  (  tar  instanceof  TarArchiveInputStream  )  ;  [METHOD]  verifyCheckSum  [TYPE]  boolean  [PARAMETER]  byte[]  header  [CLASS]  TarUtils  [TYPE]  byte[]  header  [TYPE]  boolean  false  true  [TYPE]  ZipEncoding  DEFAULT_ENCODING  FALLBACK_ENCODING  [TYPE]  int  BYTE_MASK  digits  i  [TYPE]  long  signedSum  storedSum  unsignedSum  [TYPE]  byte  b  [CONTEXT]  public  static  boolean  verifyCheckSum  (  byte[]  header  )  {  [BUGGY]  long  storedSum  =  0  ;  long  unsignedSum  =  0  ;  long  signedSum  =  0  ;  int  digits  =  0  ;  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  byte  b  =  header[i]  ;  if  (  CHKSUM_OFFSET<  =  i  &&  i  <  CHKSUM_OFFSET  +  CHKSUMLEN  )  {  if  (  '0'  <  =  b  &&  b  <  =  '7'  &&  digits++  <  6  )  {  storedSum  =  storedSum  *  8  +  b  -  '0'  ;  }  else  if  (  digits  >  0  )  {  digits  =  6  ;  }  b  =  '  '  ;  }  unsignedSum  +  =  0xff  &  b  ;  signedSum  +  =  b  ;  }  return  storedSum  =  =  unsignedSum  ||  storedSum  =  =  signedSum  ;  }  	Compress_35_TarUtils_2_1	594	1	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
981		[BUGGY]  digits  =  6  ;  }\n'  ,   "          b  =  '  '  ;  \n "]  [FE]  commonscompressarchiversArchiveException:  No  Archiver  found  for  the  stream  signature  assertTrue  (  tar  instanceof  TarArchiveInputStream  )  ;  [METHOD]  verifyCheckSum  [TYPE]  boolean  [PARAMETER]  byte[]  header  [CLASS]  TarUtils  [TYPE]  byte[]  header  [TYPE]  boolean  false  true  [TYPE]  ZipEncoding  DEFAULT_ENCODING  FALLBACK_ENCODING  [TYPE]  int  BYTE_MASK  digits  i  [TYPE]  long  signedSum  storedSum  unsignedSum  [TYPE]  byte  b  [CONTEXT]  public  static  boolean  verifyCheckSum  (  byte[]  header  )  {  long  storedSum  =  0  ;  long  unsignedSum  =  0  ;  long  signedSum  =  0  ;  int  digits  =  0  ;  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  byte  b  =  header[i]  ;  if  (  CHKSUM_OFFSET<  =  i  &&  i  <  CHKSUM_OFFSET  +  CHKSUMLEN  )  {  [BUGGY]  if  (  '0'  <  =  b  &&  b  <  =  '7'  &&  digits++  <  6  )  {  storedSum  =  storedSum  *  8  +  b  -  '0'  ;  }  else  if  (  digits  >  0  )  {  digits  =  6  ;  }  b  =  '  '  ;  }  unsignedSum  +  =  0xff  &  b  ;  signedSum  +  =  b  ;  }  return  storedSum  =  =  unsignedSum  ||  storedSum  =  =  signedSum  ;  }  	Compress_35_TarUtils_2_2	602	2	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
982	if  (archive.files[currentEntryIndex].getSize()  ==  0)  {  return  new  ByteArrayInputStream(new  byte[0]);  }  	[BUGGY]  [FE]  IllegalStateException:  No  current  7z  entry  (  call  getNextEntry  (  )  first  )  assertNull  (  sevenZFile  .  getNextEntry  (  )  )  ;  [METHOD]  getCurrentStream  [TYPE]  InputStream  [PARAMETER]  [CLASS]  SevenZFile  [TYPE]  byte[]  password  sevenZSignature  [TYPE]  Archive  archive  [TYPE]  boolean  false  true  [TYPE]  RandomAccessFile  file  [TYPE]  InputStream  currentFolderInputStream  stream  [TYPE]  ArrayList  deferredBlockStreams  [TYPE]  String  fileName  [TYPE]  int  SIGNATURE_HEADER_SIZE  currentEntryIndex  currentFolderIndex  [CONTEXT]  private  InputStream  getCurrentStream  (  )  throws  IOException  {  [BUGGY]  if  (  deferredBlockStreams  .  isEmpty  (  )  )  {  throw  new  IllegalStateException  (   "No  current  7z  entry  (  call  getNextEntry  (  )  first  )  .   "  )  ;  }  while  (  deferredBlockStreams  .  size  (  )  >  1  )  {    final  InputStream  stream  =  deferredBlockStreams  .  remove  (  0  )  ;  IOUtils  .  skip  (  stream  ,  Long  .  MAX_VALUE  )  ;  stream  .  close  (  )  ;  }  return  deferredBlockStreams  .  get  (  0  )  ;  }  	Compress_36_SevenZFile_1_1	902	0	src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZFile.java
983		[BUGGY]  [FE]  NegativeArraySizeException  assertNull  (  is  .  getNextTarEntry  (  )  )  ;  [METHOD]  parsePaxHeaders  [TYPE]  Map  [PARAMETER]  InputStream  i  [CLASS]  TarArchiveInputStream  [TYPE]  byte[]  SMALL_BUF  rest  [TYPE]  boolean  false  hasHitEOF  true  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  InputStream  i  is  [TYPE]  String  encoding  keyword  value  [TYPE]  ByteArrayOutputStream  coll  [TYPE]  Map  globalPaxHeaders  headers  [TYPE]  int  SMALL_BUFFER_SIZE  blockSize  ch  got  len  read  recordSize  restLen  [TYPE]  long  entryOffset  entrySize  [TYPE]  TarArchiveEntry  currEntry  [CONTEXT]  Map<String  ,  String>  parsePaxHeaders  (  final  InputStream  i  )  throws  IOException  {  final  Map<String  ,  String>  headers  =  new  HashMap<String  ,  String>  (  globalPaxHeaders  )  ;  while  (  true  )  {  //  get  length  int  ch  ;  int  len  =  0  ;  int  read  =  0  ;  while  (  (  ch  =  i  .  read  (  )  )  !  =  -1  )  {  read++  ;  [BUGGY]  if  (  ch  =  =  '  '  )  {  final  ByteArrayOutputStream  coll  =  new  ByteArrayOutputStream  (  )  ;  while  (  (  ch  =  i  .  read  (  )  )  !  =  -1  )  {  read++  ;  if  (  ch  =  =  '  =  '  )  {  //  end  of  keyword  	Compress_37_TarArchiveInputStream_1_1	462	0	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java
984	if  (!isPaxHeader()  &&  !isGlobalPaxHeader()  &&  getName().endsWith( "/ "))  {  	[BUGGY]  if  (  getName  (  )  .  endsWith  (   "/ "  )  )  {  [FE]  IOException:  Error  detected  parsing  the  header  assertNull  (  is  .  getNextTarEntry  (  )  )  ;  [METHOD]  isDirectory  [TYPE]  boolean  [PARAMETER]  [CLASS]  TarArchiveEntry  [TYPE]  boolean  checkSumOK  false  isExtended  paxGNUSparse  preserveLeadingSlashes  starSparse  true  [TYPE]  byte  linkFlag  [TYPE]  String  groupName  linkName  magic  name  userName  version  [TYPE]  File  file  [TYPE]  int  DEFAULT_DIR_MODE  DEFAULT_FILE_MODE  MAX_NAMELEN  MILLIS_PER_SECOND  devMajor  devMinor  mode  [TYPE]  long  groupId  modTime  realSize  size  userId  [TYPE]  TarArchiveEntry[]  EMPTY_TAR_ARCHIVE_ENTRIES  [CONTEXT]  public  boolean  isDirectory  (  )  {  if  (  file  !  =  null  )  {  return  file  .  isDirectory  (  )  ;  }  if  (  linkFlag  =  =  LF_DIR  )  {  return  true  ;  }  [BUGGY]  if  (  getName  (  )  .  endsWith  (   "/ "  )  )  {  return  true  ;  }  return  false  ;  }  	Compress_38_TarArchiveEntry_1_1	859	1	src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java
985	private  static  final  int  MAX_SANITIZED_NAME_LENGTH  =  255;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<23456789012345678901[]>  but  was:<23456789012345678901[234567890123456789012345678901234567890123456789]>  assertFalse  (  inputString  .  equals  (  ArchiveUtils  .  toAsciiString  (  ArchiveUtils  .  toAsciiBytes  (  inputString  )  )  )  )  ;  [CLASS]  [CONTEXT]  	Compress_39_ArchiveUtils_2_1	31	0	src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java
986	final  char[]  cs  =  s.toCharArray();  final  char[]  chars  =  cs.length  <=  MAX_SANITIZED_NAME_LENGTH  ?  cs  :  Arrays.copyOf(cs,  MAX_SANITIZED_NAME_LENGTH);  if  (cs.length  >  MAX_SANITIZED_NAME_LENGTH)  {  for  (int  i  =  MAX_SANITIZED_NAME_LENGTH  -  3;  i  <  MAX_SANITIZED_NAME_LENGTH;  i++)  {\n',   "+                                chars[i]  =  '.';\n ",  '+                        }  }  	[BUGGY]  final  char[]  chars  =  s  .  toCharArray  (  )  ;  [FE]  AssertionFailedError:  expected:<23456789012345678901[]>  but  was:<23456789012345678901[234567890123456789012345678901234567890123456789]>  assertFalse  (  inputString  .  equals  (  ArchiveUtils  .  toAsciiString  (  ArchiveUtils  .  toAsciiBytes  (  inputString  )  )  )  )  ;  [METHOD]  sanitize  [TYPE]  String  [PARAMETER]  String  s  [CLASS]  ArchiveUtils  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  UnicodeBlock  block  [TYPE]  char  c  [TYPE]  String  s  [TYPE]  int  i  len  [TYPE]  char[]  chars  [CONTEXT]  public  static  String  sanitize  (  String  s  )  {  [BUGGY]  final  char[]  chars  =  s  .  toCharArray  (  )  ;  final  int  len  =  chars  .  length  ;  final  StringBuilder  sb  =  new  StringBuilder  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  final  char  c  =  chars[i]  ;  if  (  !Character  .  isISOControl  (  c  )  )  {  Character  .  UnicodeBlock  block  =  Character  .  UnicodeBlock  .  of  (  c  )  ;  if  (  block  !  =  null  &&  block  !  =  Character  .  UnicodeBlock  .  SPECIALS  )  {  sb  .  append  (  c  )  ;  continue  ;  }  }  sb  .  append  (  '?'  )  ;  }  return  sb  .  toString  (  )  ;  }  	Compress_39_ArchiveUtils_2_2	273	1	src/main/java/org/apache/commons/compress/utils/ArchiveUtils.java
987	while  (bitsCachedSize  <  count  &&  bitsCachedSize  <  57)  {  	[BUGGY]  while  (  bitsCachedSize  <  count  )  {  [FE]  AssertionFailedError:  expected:<1186>  but  was:<1184>  assertEquals  (  -1  ,  bin  .  readBits  (  1  )  )  ;  [METHOD]  readBits  [TYPE]  long  [PARAMETER]  final  int  count  [CLASS]  BitInputStream  [TYPE]  ByteOrder  byteOrder  [TYPE]  boolean  false  true  [TYPE]  long[]  MASKS  [TYPE]  InputStream  in  [TYPE]  int  MAXIMUM_CACHE_SIZE  bitsCachedSize  count  [TYPE]  long  bitsCached  bitsOut  nextByte  [CONTEXT]  public  long  readBits  (  final  int  count  )  throws  IOException  {  if  (  count  <  0  ||  count  >  MAXIMUM_CACHE_SIZE  )  {  throw  new  IllegalArgumentException  (   "count  must  not  be  negative  or  greater  than   "  +  MAXIMUM_CACHE_SIZE  )  ;  }  [BUGGY]  while  (  bitsCachedSize  <  count  )  {  final  long  nextByte  =  in  .  read  (  )  ;  if  (  nextByte  <  0  )  {  return  nextByte  ;  }  if  (  byteOrder  =  =  ByteOrder  .  LITTLE_ENDIAN  )  {  bitsCached  |  =  (  nextByte  <<  bitsCachedSize  )  ;  }  else  {  bitsCached  <<  =  8  ;  bitsCached  |  =  nextByte  ;  }  bitsCachedSize  +  =  8  ;  }  final  long  bitsOut  ;  if  (  byteOrder  =  =  ByteOrder  .  LITTLE_ENDIAN  )  {  bitsOut  =  (  bitsCached  &  MASKS[count]  )  ;  bitsCached  >>>  =  count  ;  }  else  {  bitsOut  =  (  bitsCached  >>  (  bitsCachedSize  -  count  )  )  &  MASKS[count]  ;  }  bitsCachedSize  -  =  count  ;  return  bitsOut  ;  }  	Compress_40_BitInputStream_3_1	85	1	src/main/java/org/apache/commons/compress/utils/BitInputStream.java
988	int  overflowBits  =  0;  long  overflow  =  0l;  if  (bitsCachedSize  <  count)  {  int  bitsToAddCount  =  count  -  bitsCachedSize;  overflowBits  =  8  -  bitsToAddCount;  final  long  nextByte  =  in.read();  if  (nextByte  <  0)  {  return  nextByte;  }  if  (byteOrder  ==  ByteOrder.LITTLE_ENDIAN)  {  long  bitsToAdd  =  nextByte  &  MASKS[bitsToAddCount];  bitsCached  |=  (bitsToAdd  <<  bitsCachedSize);  overflow  =  (nextByte  >>>  bitsToAddCount)  &  MASKS[overflowBits];  }  else  {  bitsCached  <<=  bitsToAddCount;  long  bitsToAdd  =  (nextByte  >>>  (overflowBits))  &  MASKS[bitsToAddCount];  bitsCached  |=  bitsToAdd;  overflow  =  nextByte  &  MASKS[overflowBits];  }  bitsCachedSize  =  count;  }  if  (overflowBits  ==  0)  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1186>  but  was:<1184>  assertEquals  (  -1  ,  bin  .  readBits  (  1  )  )  ;  [METHOD]  readBits  [TYPE]  long  [PARAMETER]  final  int  count  [CLASS]  BitInputStream  [TYPE]  ByteOrder  byteOrder  [TYPE]  boolean  false  true  [TYPE]  long[]  MASKS  [TYPE]  InputStream  in  [TYPE]  int  MAXIMUM_CACHE_SIZE  bitsCachedSize  count  [TYPE]  long  bitsCached  bitsOut  nextByte  [CONTEXT]  public  long  readBits  (  final  int  count  )  throws  IOException  {  if  (  count  <  0  ||  count  >  MAXIMUM_CACHE_SIZE  )  {  throw  new  IllegalArgumentException  (   "count  must  not  be  negative  or  greater  than   "  +  MAXIMUM_CACHE_SIZE  )  ;  }  while  (  bitsCachedSize  <  count  )  {  final  long  nextByte  =  in  .  read  (  )  ;  if  (  nextByte  <  0  )  {  return  nextByte  ;  }  if  (  byteOrder  =  =  ByteOrder  .  LITTLE_ENDIAN  )  {  bitsCached  |  =  (  nextByte  <<  bitsCachedSize  )  ;  }  else  {  bitsCached  <<  =  8  ;  bitsCached  |  =  nextByte  ;  }  bitsCachedSize  +  =  8  ;  }  [BUGGY]  final  long  bitsOut  ;  if  (  byteOrder  =  =  ByteOrder  .  LITTLE_ENDIAN  )  {  bitsOut  =  (  bitsCached  &  MASKS[count]  )  ;  bitsCached  >>>  =  count  ;  }  else  {  bitsOut  =  (  bitsCached  >>  (  bitsCachedSize  -  count  )  )  &  MASKS[count]  ;  }  bitsCachedSize  -  =  count  ;  return  bitsOut  ;  }  	Compress_40_BitInputStream_3_2	98	0	src/main/java/org/apache/commons/compress/utils/BitInputStream.java
989	}  else  {  bitsOut  =  bitsCached  &  MASKS[count];  bitsCached  =  overflow;  bitsCachedSize  =  overflowBits;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1186>  but  was:<1184>  assertEquals  (  -1  ,  bin  .  readBits  (  1  )  )  ;  [METHOD]  readBits  [TYPE]  long  [PARAMETER]  final  int  count  [CLASS]  BitInputStream  [TYPE]  ByteOrder  byteOrder  [TYPE]  boolean  false  true  [TYPE]  long[]  MASKS  [TYPE]  InputStream  in  [TYPE]  int  MAXIMUM_CACHE_SIZE  bitsCachedSize  count  [TYPE]  long  bitsCached  bitsOut  nextByte  [CONTEXT]  public  long  readBits  (  final  int  count  )  throws  IOException  {  if  (  count  <  0  ||  count  >  MAXIMUM_CACHE_SIZE  )  {  throw  new  IllegalArgumentException  (   "count  must  not  be  negative  or  greater  than   "  +  MAXIMUM_CACHE_SIZE  )  ;  }  while  (  bitsCachedSize  <  count  )  {  final  long  nextByte  =  in  .  read  (  )  ;  if  (  nextByte  <  0  )  {  return  nextByte  ;  }  if  (  byteOrder  =  =  ByteOrder  .  LITTLE_ENDIAN  )  {  bitsCached  |  =  (  nextByte  <<  bitsCachedSize  )  ;  }  else  {  bitsCached  <<  =  8  ;  bitsCached  |  =  nextByte  ;  }  bitsCachedSize  +  =  8  ;  }  final  long  bitsOut  ;  if  (  byteOrder  =  =  ByteOrder  .  LITTLE_ENDIAN  )  {  bitsOut  =  (  bitsCached  &  MASKS[count]  )  ;  bitsCached  >>>  =  count  ;  }  else  {  bitsOut  =  (  bitsCached  >>  (  bitsCachedSize  -  count  )  )  &  MASKS[count]  ;  }  bitsCachedSize  -  =  count  ;  [BUGGY]  return  bitsOut  ;  }  	Compress_40_BitInputStream_3_3	108	0	src/main/java/org/apache/commons/compress/utils/BitInputStream.java
990	return  null;  throw  new  ZipException(String.format( "Unexpected  record  signature:  0X%X ",  sig.getValue()));  	[BUGGY]  return  null  ;  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  1  ,  expectedExceptions  .  size  (  )  )  ;  [METHOD]  getNextZipEntry  [TYPE]  ZipArchiveEntry  [PARAMETER]  [CLASS]  ZipArchiveInputStream  [TYPE]  ZipEncoding  entryEncoding  zipEncoding  [TYPE]  CRC32  crc  [TYPE]  InputStream  in  [TYPE]  String  encoding  [TYPE]  GeneralPurposeBit  gpFlag  [TYPE]  ByteBuffer  buf  [TYPE]  int  CFH_LEN  LFH_LEN  entriesRead  extraLen  fileNameLen  off  versionMadeBy  [TYPE]  long  TWO_EXP_32  bytesRead  bytesReadFromStream  max  pos  time  [TYPE]  byte[]  CFH  DD  LFH  LFH_BUF  SHORT_BUF  SKIP_BUF  TWO_DWORD_BUF  WORD_BUF  extraData  fileName  [TYPE]  CurrentEntry  current  [TYPE]  ZipLong  cSize  sig  size  [TYPE]  boolean  allowStoredEntriesWithDataDescriptor  closed  false  firstEntry  hasDataDescriptor  hasUTF8Flag  hitCentralDirectory  true  useUnicodeExtraFields  usesZip64  [TYPE]  ByteArrayInputStream  lastStoredEntry  [TYPE]  EOFException  e  [TYPE]  ZipArchiveEntry  entry  [TYPE]  Inflater  inf  [CONTEXT]  return  null  ;  }  if  (  current  !  =  null  )  {  closeEntry  (  )  ;  firstEntry  =  false  ;  }  try  {  if  (  firstEntry  )  {      readFirstLocalFileHeader  (  LFH_BUF  )  ;  }  else  {  readFully  (  LFH_BUF  )  ;  }  }  catch  (  final  EOFException  e  )  {  return  null  ;  }  final  ZipLong  sig  =  new  ZipLong  (  LFH_BUF  )  ;  if  (  sig  .  equals  (  ZipLong  .  CFH_SIG  )  ||  sig  .  equals  (  ZipLong  .  AED_SIG  )  )  {  hitCentralDirectory  =  true  ;  skipRemainderOfArchive  (  )  ;  [BUGGY]  }  if  (  !sig  .  equals  (  ZipLong  .  LFH_SIG  )  )  {  return  null  ;  }  int  off  =  WORD  ;  	Compress_41_ZipArchiveInputStream_1_1	247	1	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
991	int  FILE_TYPE_FLAG  =  0170000;  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  ze  .  isUnixSymlink  (  )  )  ;  [CLASS]  [CONTEXT]  	Compress_42_UnixStat_1_1	35	0	src/main/java/org/apache/commons/compress/archivers/zip/UnixStat.java
992	return  (getUnixMode()  &  UnixStat.FILE_TYPE_FLAG)  ==  UnixStat.LINK_FLAG;  	[BUGGY]  return  (  getUnixMode  (  )  &  UnixStat  .  LINK_FLAG  )  =  =  UnixStat  .  LINK_FLAG  ;  [FE]  AssertionFailedError  assertFalse  (  ze  .  isUnixSymlink  (  )  )  ;  [METHOD]  isUnixSymlink  [TYPE]  boolean  [PARAMETER]  [CLASS]  ZipArchiveEntry  [TYPE]  byte[]  EMPTY  rawName  [TYPE]  boolean  false  true  [TYPE]  ZipExtraField[]  extraFields  noExtraFields  [TYPE]  String  name  [TYPE]  GeneralPurposeBit  gpb  [TYPE]  UnparseableExtraFieldData  unparseableExtra  [TYPE]  int  CRC_UNKNOWN  PLATFORM_FAT  PLATFORM_UNIX  SHORT_MASK  SHORT_SHIFT  internalAttributes  method  platform  rawFlag  versionMadeBy  versionRequired  [TYPE]  long  externalAttributes  size  [CONTEXT]  public  boolean  isUnixSymlink  (  )  {  [BUGGY]  return  (  getUnixMode  (  )  &  UnixStat  .  LINK_FLAG  )  =  =  UnixStat  .  LINK_FLAG  ;  }  	Compress_42_ZipArchiveEntry_1_1	297	1	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java
993	metaData.put(ze,  new  EntryMetaData(localHeaderStart,  usesDataDescriptor(ze.getMethod(),  phased)));  	[BUGGY]  metaData  .  put  (  ze  ,  new  EntryMetaData  (  localHeaderStart  ,  usesDataDescriptor  (  ze  .  getMethod  (  )  )  )  )  ;  [FE]  AssertionFailedError:  arrays  first  differed  at  element  [0]  ;  expected:<0>  but  was:<8>  assertEquals  (  sizeFromLFH  ,  sizeFromCDH  )  ;  [METHOD]  writeLocalFileHeader  [TYPE]  void  [PARAMETER]  ZipArchiveEntry  ze  final  boolean  phased  [CLASS]  ZipArchiveOutputStream  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  UnicodeExtraFieldPolicy  ALWAYS  NEVER  NOT_ENCODEABLE  createUnicodeExtraFields  [TYPE]  OutputStream  out  [TYPE]  Calendar  calendarInstance  [TYPE]  Zip64Mode  zip64Mode  [TYPE]  String  DEFAULT_ENCODING  comment  encoding  name  [TYPE]  StreamCompressor  streamCompressor  [TYPE]  ByteBuffer  name  [TYPE]  int  BUFFER_SIZE  CFH_COMMENT_LENGTH_OFFSET  CFH_COMPRESSED_SIZE_OFFSET  CFH_CRC_OFFSET  CFH_DISK_NUMBER_OFFSET  CFH_EXTERNAL_ATTRIBUTES_OFFSET  CFH_EXTRA_LENGTH_OFFSET  CFH_FILENAME_LENGTH_OFFSET  CFH_FILENAME_OFFSET  CFH_GPB_OFFSET  CFH_INTERNAL_ATTRIBUTES_OFFSET  CFH_LFH_OFFSET  CFH_METHOD_OFFSET  CFH_ORIGINAL_SIZE_OFFSET  CFH_SIG_OFFSET  CFH_TIME_OFFSET  CFH_VERSION_MADE_BY_OFFSET  CFH_VERSION_NEEDED_OFFSET  DEFAULT_COMPRESSION  DEFLATED  EFS_FLAG  LFH_COMPRESSED_SIZE_OFFSET  LFH_CRC_OFFSET  LFH_EXTRA_LENGTH_OFFSET  LFH_FILENAME_LENGTH_OFFSET  LFH_FILENAME_OFFSET  LFH_GPB_OFFSET  LFH_METHOD_OFFSET  LFH_ORIGINAL_SIZE_OFFSET  LFH_SIG_OFFSET  LFH_TIME_OFFSET  LFH_VERSION_NEEDED_OFFSET  STORED  level  method  [TYPE]  long  bytesRead  cdLength  cdOffset  dataStart  localDataStart  localHeaderStart  offset  [TYPE]  byte[]  CFH_SIG  DD_SIG  EMPTY  EOCD_SIG  LFH_SIG  LZERO  ONE  ZERO  ZIP64_EOCD_LOC_SIG  ZIP64_EOCD_SIG  copyBuffer  localHeader  [TYPE]  SeekableByteChannel  channel  [TYPE]  CurrentEntry  entry  [TYPE]  boolean  causedUseOfZip64  encodable  fallbackToUTF8  false  finished  hasCompressionLevelChanged  hasUsedZip64  hasWritten  phased  true  useUTF8Flag  usesDataDescriptor  [TYPE]  Deflater  def  [TYPE]  ZipArchiveEntry  entry  ze  [TYPE]  List  entries  [TYPE]  Map  metaData  [CONTEXT]  private  void  writeLocalFileHeader  (  final  ZipArchiveEntry  ze  ,  final  boolean  phased  )  throws  IOException  {  final  boolean  encodable  =  zipEncoding  .  canEncode  (  ze  .  getName  (  )  )  ;  final  ByteBuffer  name  =  getName  (  ze  )  ;  if  (  createUnicodeExtraFields  !  =  UnicodeExtraFieldPolicy  .  NEVER  )  {  addUnicodeExtraFields  (  ze  ,  encodable  ,  name  )  ;  }  final  long  localHeaderStart  =  streamCompressor  .  getTotalBytesWritten  (  )  ;  final  byte[]  localHeader  =  createLocalFileHeader  (  ze  ,  name  ,  encodable  ,  phased  ,  localHeaderStart  )  ;  [BUGGY]  metaData  .  put  (  ze  ,  new  EntryMetaData  (  localHeaderStart  ,  usesDataDescriptor  (  ze  .  getMethod  (  )  )  )  )  ;  entry  .  localDataStart  =  localHeaderStart  +  LFH_CRC_OFFSET  ;  //  At  crc  offset  writeCounted  (  localHeader  )  ;  entry  .  dataStart  =  streamCompressor  .  getTotalBytesWritten  (  )  ;  }  	Compress_43_ZipArchiveOutputStream_4_1	1034	1	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java
994	final  boolean  dataDescriptor  =  usesDataDescriptor(zipMethod,  phased);  	[BUGGY]  final  boolean  dataDescriptor  =  usesDataDescriptor  (  zipMethod  )  ;  [FE]  AssertionFailedError:  arrays  first  differed  at  element  [0]  ;  expected:<0>  but  was:<8>  assertEquals  (  sizeFromLFH  ,  sizeFromCDH  )  ;  [METHOD]  createLocalFileHeader  [TYPE]  byte[]  [PARAMETER]  ZipArchiveEntry  ze  ByteBuffer  name  final  boolean  encodable  final  boolean  phased  long  archiveOffset  [CLASS]  ZipArchiveOutputStream  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  UnicodeExtraFieldPolicy  ALWAYS  NEVER  NOT_ENCODEABLE  createUnicodeExtraFields  [TYPE]  OutputStream  out  [TYPE]  Calendar  calendarInstance  [TYPE]  Zip64Mode  zip64Mode  [TYPE]  ResourceAlignmentExtraField  oldAlignmentEx  [TYPE]  String  DEFAULT_ENCODING  comment  encoding  name  [TYPE]  GeneralPurposeBit  generalPurposeBit  [TYPE]  StreamCompressor  streamCompressor  [TYPE]  ByteBuffer  name  [TYPE]  int  BUFFER_SIZE  CFH_COMMENT_LENGTH_OFFSET  CFH_COMPRESSED_SIZE_OFFSET  CFH_CRC_OFFSET  CFH_DISK_NUMBER_OFFSET  CFH_EXTERNAL_ATTRIBUTES_OFFSET  CFH_EXTRA_LENGTH_OFFSET  CFH_FILENAME_LENGTH_OFFSET  CFH_FILENAME_OFFSET  CFH_GPB_OFFSET  CFH_INTERNAL_ATTRIBUTES_OFFSET  CFH_LFH_OFFSET  CFH_METHOD_OFFSET  CFH_ORIGINAL_SIZE_OFFSET  CFH_SIG_OFFSET  CFH_TIME_OFFSET  CFH_VERSION_MADE_BY_OFFSET  CFH_VERSION_NEEDED_OFFSET  DEFAULT_COMPRESSION  DEFLATED  EFS_FLAG  LFH_COMPRESSED_SIZE_OFFSET  LFH_CRC_OFFSET  LFH_EXTRA_LENGTH_OFFSET  LFH_FILENAME_LENGTH_OFFSET  LFH_FILENAME_OFFSET  LFH_GPB_OFFSET  LFH_METHOD_OFFSET  LFH_ORIGINAL_SIZE_OFFSET  LFH_SIG_OFFSET  LFH_TIME_OFFSET  LFH_VERSION_NEEDED_OFFSET  STORED  alignment  len  level  method  nameLen  oldLength  padding  zipMethod  [TYPE]  long  archiveOffset  bytesRead  cdLength  cdOffset  dataStart  localDataStart  offset  [TYPE]  byte[]  CFH_SIG  DD_SIG  EMPTY  EOCD_SIG  LFH_SIG  LZERO  ONE  ZERO  ZIP64_EOCD_LOC_SIG  ZIP64_EOCD_SIG  buf  copyBuffer  extra  [TYPE]  SeekableByteChannel  channel  [TYPE]  CurrentEntry  entry  [TYPE]  boolean  causedUseOfZip64  dataDescriptor  encodable  fallbackToUTF8  false  finished  hasCompressionLevelChanged  hasUsedZip64  hasWritten  phased  true  useUTF8Flag  usesDataDescriptor  [TYPE]  Deflater  def  [TYPE]  ZipArchiveEntry  entry  ze  [TYPE]  List  entries  [TYPE]  Map  metaData  [CONTEXT]  if  (  alignment  <  =  0  &&  oldAlignmentEx  !  =  null  )  {  alignment  =  oldAlignmentEx  .  getAlignment  (  )  ;  }  if  (  alignment  >  1  ||  (  oldAlignmentEx  !  =  null  &&  !oldAlignmentEx  .  allowMethodChange  (  )  )  )  {  int  oldLength  =  LFH_FILENAME_OFFSET  +  name  .  limit  (  )  -  name  .  position  (  )  +  ze  .  getLocalFileDataExtra  (  )  .  length  ;  int  padding  =  (  int  )    (  (  -archiveOffset  -  oldLength  -  ZipExtraField  .  EXTRAFIELD_HEADER_SIZE  -  ResourceAlignmentExtraField  .  BASE_SIZE  )  &  (  alignment  -  1  )  )  ;  ze  .  addExtraField  (  new  ResourceAlignmentExtraField  (  alignment  ,  oldAlignmentEx  !  =  null  &&  oldAlignmentEx  .  allowMethodChange  (  )  ,  padding  )  )  ;  }  final  byte[]  extra  =  ze  .  getLocalFileDataExtra  (  )  ;  final  int  nameLen  =  name  .  limit  (  )  -  name  .  position  (  )  ;  final  int  len  =  LFH_FILENAME_OFFSET  +  nameLen  +  extra  .  length  ;  final  byte[]  buf  =  new  byte[len]  ;  System  .  arraycopy  (  LFH_SIG  ,  0  ,  buf  ,  LFH_SIG_OFFSET  ,  WORD  )  ;    final  int  zipMethod  =  ze  .  getMethod  (  )  ;  [BUGGY]  final  boolean  dataDescriptor  =  usesDataDescriptor  (  zipMethod  )  ;  putShort  (  versionNeededToExtract  (  zipMethod  ,  hasZip64Extra  (  ze  )  ,  dataDescriptor  )  ,  buf  ,  LFH_VERSION_NEEDED_OFFSET  )  ;  final  GeneralPurposeBit  generalPurposeBit  =  getGeneralPurposeBits  (  !encodable  &&  fallbackToUTF8  ,  dataDescriptor  )  ;  generalPurposeBit  .  encode  (  buf  ,  LFH_GPB_OFFSET  )  ;  	Compress_43_ZipArchiveOutputStream_4_2	1075	1	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java
995	if  (!usesDataDescriptor(ze.getMethod(),  false))  {  	[BUGGY]  if  (  ze  .  getMethod  (  )  !  =  DEFLATED  ||  channel  !  =  null  )  {  [FE]  AssertionFailedError:  arrays  first  differed  at  element  [0]  ;  expected:<0>  but  was:<8>  assertEquals  (  sizeFromLFH  ,  sizeFromCDH  )  ;  [METHOD]  writeDataDescriptor  [TYPE]  void  [PARAMETER]  ZipArchiveEntry  ze  [CLASS]  ZipArchiveOutputStream  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  UnicodeExtraFieldPolicy  ALWAYS  NEVER  NOT_ENCODEABLE  createUnicodeExtraFields  [TYPE]  OutputStream  out  [TYPE]  Calendar  calendarInstance  [TYPE]  Zip64Mode  zip64Mode  [TYPE]  String  DEFAULT_ENCODING  comment  encoding  name  [TYPE]  StreamCompressor  streamCompressor  [TYPE]  int  BUFFER_SIZE  CFH_COMMENT_LENGTH_OFFSET  CFH_COMPRESSED_SIZE_OFFSET  CFH_CRC_OFFSET  CFH_DISK_NUMBER_OFFSET  CFH_EXTERNAL_ATTRIBUTES_OFFSET  CFH_EXTRA_LENGTH_OFFSET  CFH_FILENAME_LENGTH_OFFSET  CFH_FILENAME_OFFSET  CFH_GPB_OFFSET  CFH_INTERNAL_ATTRIBUTES_OFFSET  CFH_LFH_OFFSET  CFH_METHOD_OFFSET  CFH_ORIGINAL_SIZE_OFFSET  CFH_SIG_OFFSET  CFH_TIME_OFFSET  CFH_VERSION_MADE_BY_OFFSET  CFH_VERSION_NEEDED_OFFSET  DEFAULT_COMPRESSION  DEFLATED  EFS_FLAG  LFH_COMPRESSED_SIZE_OFFSET  LFH_CRC_OFFSET  LFH_EXTRA_LENGTH_OFFSET  LFH_FILENAME_LENGTH_OFFSET  LFH_FILENAME_OFFSET  LFH_GPB_OFFSET  LFH_METHOD_OFFSET  LFH_ORIGINAL_SIZE_OFFSET  LFH_SIG_OFFSET  LFH_TIME_OFFSET  LFH_VERSION_NEEDED_OFFSET  STORED  level  method  [TYPE]  long  bytesRead  cdLength  cdOffset  dataStart  localDataStart  offset  [TYPE]  byte[]  CFH_SIG  DD_SIG  EMPTY  EOCD_SIG  LFH_SIG  LZERO  ONE  ZERO  ZIP64_EOCD_LOC_SIG  ZIP64_EOCD_SIG  copyBuffer  [TYPE]  SeekableByteChannel  channel  [TYPE]  CurrentEntry  entry  [TYPE]  boolean  causedUseOfZip64  fallbackToUTF8  false  finished  hasCompressionLevelChanged  hasUsedZip64  hasWritten  true  useUTF8Flag  usesDataDescriptor  [TYPE]  Deflater  def  [TYPE]  ZipArchiveEntry  entry  ze  [TYPE]  List  entries  [TYPE]  Map  metaData  [CONTEXT]  protected  void  writeDataDescriptor  (  final  ZipArchiveEntry  ze  )  throws  IOException  {  [BUGGY]  if  (  ze  .  getMethod  (  )  !  =  DEFLATED  ||  channel  !  =  null  )  {  return  ;  }  writeCounted  (  DD_SIG  )  ;  writeCounted  (  ZipLong  .  getBytes  (  ze  .  getCrc  (  )  )  )  ;  if  (  !hasZip64Extra  (  ze  )  )  {  writeCounted  (  ZipLong  .  getBytes  (  ze  .  getCompressedSize  (  )  )  )  ;  writeCounted  (  ZipLong  .  getBytes  (  ze  .  getSize  (  )  )  )  ;  }  else  {  writeCounted  (  ZipEightByteInteger  .  getBytes  (  ze  .  getCompressedSize  (  )  )  )  ;  writeCounted  (  ZipEightByteInteger  .  getBytes  (  ze  .  getSize  (  )  )  )  ;  }  }  	Compress_43_ZipArchiveOutputStream_4_3	1171	1	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java
996	private  boolean  usesDataDescriptor(final  int  zipMethod,  boolean  phased)  {  return  !phased  &&  zipMethod  ==  DEFLATED  &&  channel  ==  null;  	[BUGGY]  private  boolean  usesDataDescriptor  (  final  int  zipMethod  )  {  return  zipMethod  =  =  DEFLATED  &&  channel  =  =  null  ;  [FE]  AssertionFailedError:  arrays  first  differed  at  element  [0]  ;  expected:<0>  but  was:<8>  assertEquals  (  sizeFromLFH  ,  sizeFromCDH  )  ;  [CLASS]  [CONTEXT]  	Compress_43_ZipArchiveOutputStream_4_4	1492	2	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveOutputStream.java
997	if  (  checksum  ==  null  ){  throw  new  NullPointerException( "Parameter  checksum  must  not  be  null ");  }  if  (  in  ==  null  ){  throw  new  NullPointerException( "Parameter  in  must  not  be  null ");  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exception:  javalangNullPointerException  [CLASS]  [CONTEXT]  	Compress_44_ChecksumCalculatingInputStream_1_1	35	0	src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java
998	}  else  {  formatBigIntegerBinary(value,  buf,  offset,  length,  negative);  	[BUGGY]  formatBigIntegerBinary  (  value  ,  buf  ,  offset  ,  length  ,  negative  )  ;  [FE]  IllegalArgumentException:  Value  -72057594037927935  is  too  large  for  8  byte  field  [METHOD]  formatLongOctalOrBinaryBytes  [TYPE]  int  [PARAMETER]  final  long  value  final  byte[]  buf  final  int  offset  final  int  length  [CLASS]  TarUtils  [TYPE]  byte[]  buf  [TYPE]  boolean  false  negative  true  [TYPE]  ZipEncoding  DEFAULT_ENCODING  FALLBACK_ENCODING  [TYPE]  int  BYTE_MASK  length  offset  [TYPE]  long  maxAsOctalChar  value  [CONTEXT]  public  static  int  formatLongOctalOrBinaryBytes  (  final  long  value  ,  final  byte[]  buf  ,  final  int  offset  ,  final  int  length  )  {  final  long  maxAsOctalChar  =  length  =  =  TarConstants  .  UIDLEN  ?  TarConstants  .  MAXID  :  TarConstants  .  MAXSIZE  ;  final  boolean  negative  =  value  <  0  ;  if  (  !negative  &&  value  <  =  maxAsOctalChar  )  {  //  OK  to  store  as  octal  chars  return  formatLongOctalBytes  (  value  ,  buf  ,  offset  ,  length  )  ;  }  if  (  length  <  9  )  {  formatLongBinary  (  value  ,  buf  ,  offset  ,  length  ,  negative  )  ;  [BUGGY]  }  formatBigIntegerBinary  (  value  ,  buf  ,  offset  ,  length  ,  negative  )  ;  buf[offset]  =  (  byte  )    (  negative  ?  0xff  :  0x80  )  ;  return  offset  +  length  ;  }  	Compress_45_TarUtils_1_1	487	1	src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java
999	if  (l  <  Integer.MIN_VALUE  ||  l  >  Integer.MAX_VALUE)  {  	[BUGGY]  final  long  TWO_TO_32  =  0x100000000L  ;  if  (  l  >  =  TWO_TO_32  )  {  [FE]  AssertionFailedError:  Time  too  big  for  32  bits!  assertEquals  (  5  ,  xf  .  getCentralDirectoryLength  (  )  .  getValue  (  )  )  ;  [METHOD]  unixTimeToZipLong  [TYPE]  ZipLong  [PARAMETER]  long  l  [CLASS]  X5455_ExtendedTimestamp  [TYPE]  ZipLong  accessTime  createTime  modifyTime  [TYPE]  ZipShort  HEADER_ID  [TYPE]  boolean  bit0_modifyTimePresent  bit1_accessTimePresent  bit2_createTimePresent  false  true  [TYPE]  byte  ACCESS_TIME_BIT  CREATE_TIME_BIT  MODIFY_TIME_BIT  flags  [TYPE]  long  TWO_TO_32  l  serialVersionUID  [CONTEXT]  private  static  ZipLong  unixTimeToZipLong  (  long  l  )  {  [BUGGY]  final  long  TWO_TO_32  =  0x100000000L  ;  if  (  l  >  =  TWO_TO_32  )  {  throw  new  IllegalArgumentException  (   "X5455  timestamps  must  fit  in  a  signed  32  bit  integer:   "  +  l  )  ;  }  return  new  ZipLong  (  l  )  ;  }  	Compress_46_X5455_ExtendedTimestamp_1_1	529	2	src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java
1000	&&  supportsDataDescriptorFor(ze)  &&  supportsCompressedSizeFor(ze);  	[BUGGY]  &&  supportsDataDescriptorFor  (  ze  )  ;  [FE]  AssertionFailedError  assertEquals  (  expected  ,  ze  .  getNameSource  (  )  )  ;  [METHOD]  canReadEntryData  [TYPE]  boolean  [PARAMETER]  ArchiveEntry  ae  [CLASS]  ZipArchiveInputStream  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  CRC32  crc  [TYPE]  InputStream  in  [TYPE]  ArchiveEntry  ae  [TYPE]  String  encoding  [TYPE]  ByteBuffer  buf  [TYPE]  int  CFH_LEN  LFH_LEN  entriesRead  [TYPE]  long  TWO_EXP_32  bytesRead  bytesReadFromStream  max  pos  [TYPE]  byte[]  CFH  DD  LFH  lfhBuf  shortBuf  skipBuf  twoDwordBuf  wordBuf  [TYPE]  CurrentEntry  current  [TYPE]  boolean  allowStoredEntriesWithDataDescriptor  closed  false  hasDataDescriptor  hitCentralDirectory  true  useUnicodeExtraFields  usesZip64  [TYPE]  ByteArrayInputStream  lastStoredEntry  [TYPE]  ZipArchiveEntry  entry  ze  [TYPE]  Inflater  inf  [CONTEXT]  public  boolean  canReadEntryData  (  final  ArchiveEntry  ae  )  {  if  (  ae  instanceof  ZipArchiveEntry  )  {  final  ZipArchiveEntry  ze  =  (  ZipArchiveEntry  )  ae  ;  return  ZipUtil  .  canHandleEntryData  (  ze  )  [BUGGY]  &&  supportsDataDescriptorFor  (  ze  )  ;  }  return  false  ;  }  	Compress_47_ZipArchiveInputStream_3_1	415	1	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
1001	if  (!supportsCompressedSizeFor(current.entry))  {  throw  new  UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE,  current.entry);  }  	[BUGGY]  [FE]  AssertionFailedError  assertEquals  (  expected  ,  ze  .  getNameSource  (  )  )  ;  [METHOD]  read  [TYPE]  int  [PARAMETER]  final  byte[]  buffer  final  int  offset  final  int  length  [CLASS]  ZipArchiveInputStream  [TYPE]  ZipEncoding  zipEncoding  [TYPE]  CRC32  crc  [TYPE]  InputStream  in  [TYPE]  String  encoding  [TYPE]  ByteBuffer  buf  [TYPE]  int  CFH_LEN  LFH_LEN  entriesRead  length  offset  read  [TYPE]  long  TWO_EXP_32  bytesRead  bytesReadFromStream  max  pos  [TYPE]  byte[]  CFH  DD  LFH  buffer  lfhBuf  shortBuf  skipBuf  twoDwordBuf  wordBuf  [TYPE]  CurrentEntry  current  [TYPE]  boolean  allowStoredEntriesWithDataDescriptor  closed  false  hasDataDescriptor  hitCentralDirectory  true  useUnicodeExtraFields  usesZip64  [TYPE]  ByteArrayInputStream  lastStoredEntry  [TYPE]  ZipArchiveEntry  entry  [TYPE]  Inflater  inf  [CONTEXT]  public  int  read  (  final  byte[]  buffer  ,  final  int  offset  ,  final  int  length  )  throws  IOException  {  if  (  closed  )  {  throw  new  IOException  (   "The  stream  is  closed "  )  ;  }  if  (  current  =  =  null  )  {  return  -1  ;  }  if  (  offset  >  buffer  .  length  ||  length  <  0  ||  offset  <  0  ||  buffer  .  length  -  offset  <  length  )  {  throw  new  ArrayIndexOutOfBoundsException  (  )  ;  }  ZipUtil  .  checkRequestedFeatures  (  current  .  entry  )  ;  if  (  !supportsDataDescriptorFor  (  current  .  entry  )  )  {  throw  new  UnsupportedZipFeatureException  (  UnsupportedZipFeatureException  .  Feature  .  DATA_DESCRIPTOR  ,  current  .  entry  )  ;  }  [BUGGY]  int  read  ;  if  (  current  .  entry  .  getMethod  (  )  =  =  ZipArchiveOutputStream  .  STORED  )  {  read  =  readStored  (  buffer  ,  offset  ,  length  )  ;  }  else  if  (  current  .  entry  .  getMethod  (  )  =  =  ZipArchiveOutputStream  .  DEFLATED  )  {  read  =  readDeflated  (  buffer  ,  offset  ,  length  )  ;  	Compress_47_ZipArchiveInputStream_3_2	440	0	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
1002	private  boolean  supportsCompressedSizeFor(final  ZipArchiveEntry  entry)  {  return  entry.getCompressedSize()  !=  ArchiveEntry.SIZE_UNKNOWN  ||  entry.getMethod()  ==  ZipEntry.DEFLATED  ||  entry.getMethod()  ==  ZipMethod.ENHANCED_DEFLATED.getCode()  ||  (entry.getGeneralPurposeBit().usesDataDescriptor()  &&  allowStoredEntriesWithDataDescriptor  &&  entry.getMethod()  ==  ZipEntry.STORED);  }  	[BUGGY]  [FE]  AssertionFailedError  assertEquals  (  expected  ,  ze  .  getNameSource  (  )  )  ;  [CLASS]  [CONTEXT]  	Compress_47_ZipArchiveInputStream_3_3	809	0	src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java
1003	try  {  }  catch  (ArrayIndexOutOfBoundsException  e)  {  throw  new  IllegalArgumentException(  String.format(   "Index  for  header  \'%s\'  is  %d  but  CSVRecord  only  has  %d  values! ",  name,  index.intValue(),  values.length));  }  	[BUGGY]  [FE]  Exception:  Unexpected  exception  ,  expected<javalangIllegalArgumentException>  but  was<javalangArrayIndexOutOfBoundsException>  [METHOD]  get  [TYPE]  String  [PARAMETER]  String  name  [CLASS]  CSVRecord  [TYPE]  Integer  index  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  comment  name  [TYPE]  boolean  false  true  [TYPE]  Map  mapping  [TYPE]  long  recordNumber  serialVersionUID  [CONTEXT]  public  String  get  (  final  String  name  )  {  if  (  mapping  =  =  null  )  {  throw  new  IllegalStateException  (   "No  header  mapping  was  specified  ,  the  record  values  can't  be  accessed  by  name "  )  ;  }  final  Integer  index  =  mapping  .  get  (  name  )  ;  [BUGGY]  return  index  !  =  null  ?  values[index  .  intValue  (  )  ]  :  null  ;  }  	Csv_2_CSVRecord_1_1	85	0	src/main/java/org/apache/commons/csv/CSVRecord.java
1004	if  (isDelimiter(c)  ||  isEscape(c)  ||  isQuoteChar(c)  ||  isCommentStart(c))  {  }  return  END_OF_STREAM;  	[BUGGY]  [FE]  AssertionFailedError:  assertThat  (  lexer  .  nextToken  (  new  Token  (  )  )  ,  hasContent  (   "character\\NEscaped "  )  )  ;  [METHOD]  readEscape  [TYPE]  int  [PARAMETER]  [CLASS]  Lexer  [TYPE]  char  DISABLED  commmentStart  delimiter  escape  quoteChar  [TYPE]  ExtendedBufferedReader  in  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  ignoreEmptyLines  ignoreSurroundingSpaces  true  [TYPE]  int  c  [CONTEXT]  int  readEscape  (  )  throws  IOException  {  final  int  c  =  in  .  read  (  )  ;  switch  (  c  )  {  case  'r':  return  CR  ;  case  'n':  return  LF  ;  case  't':  return  TAB  ;  case  'b':  return  BACKSPACE  ;  case  'f':  return  FF  ;  case  CR:  case  LF:  case  FF:  //  TODO  is  this  correct?  case  TAB:  //  TODO  is  this  correct?  Do  tabs  need  to  be  escaped?  case  BACKSPACE:  //  TODO  is  this  correct?  return  c  ;  case  END_OF_STREAM:  throw  new  IOException  (   "EOF  whilst  processing  escape  sequence "  )  ;  default:  [BUGGY]  return  c  ;  }  }  	Csv_3_Lexer_1_1	111	0	src/main/java/org/apache/commons/csv/Lexer.java
1005	return  this.headerMap  ==  null  ?  null  :  new  LinkedHashMap<String,  Integer>(this.headerMap);  	[BUGGY]  return  new  LinkedHashMap<String  ,  Integer>  (  this  .  headerMap  )  ;  [FE]  NullPointerException  Assert  .  assertNull  (  parser  .  getHeaderMap  (  )  )  ;  [METHOD]  getHeaderMap  [TYPE]  Map  [PARAMETER]  [CLASS]  CSVParser  [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  CSVFormat  format  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  [TYPE]  Map  headerMap  [TYPE]  long  recordNumber  [CONTEXT]  public  Map<String  ,  Integer>  getHeaderMap  (  )  {  [BUGGY]  return  new  LinkedHashMap<String  ,  Integer>  (  this  .  headerMap  )  ;  }  	Csv_4_CSVParser_1_1	288	1	src/main/java/org/apache/commons/csv/CSVParser.java
1006	if  (recordSeparator  !=  null)  {  }  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  formatStr  .  endsWith  (   "null "  )  )  ;  [METHOD]  println  [TYPE]  void  [PARAMETER]  [CLASS]  CSVPrinter  [TYPE]  CSVFormat  format  [TYPE]  boolean  false  newRecord  true  [TYPE]  String  recordSeparator  [TYPE]  Appendable  out  [CONTEXT]  public  void  println  (  )  throws  IOException  {  final  String  recordSeparator  =  format  .  getRecordSeparator  (  )  ;  [BUGGY]  out  .  append  (  recordSeparator  )  ;  newRecord  =  true  ;  }  	Csv_5_CSVPrinter_1_1	325	0	src/main/java/org/apache/commons/csv/CSVPrinter.java
1007	if  (col  <  values.length)  {  }  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  2  assertEquals  (  null  ,  map  .  get  (   "fourth "  )  )  ;  [METHOD]  putIn  [TYPE]  <M  [PARAMETER]  final  M  map  [CLASS]  CSVRecord  [TYPE]  Entry  entry  [TYPE]  boolean  false  true  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  comment  [TYPE]  Map  mapping  [TYPE]  M  map  [TYPE]  long  recordNumber  serialVersionUID  [TYPE]  int  col  [CONTEXT]  <M  extends  Map<String  ,  String>>  M  putIn  (  final  M  map  )  {  for  (  final  Entry<String  ,  Integer>  entry  :  mapping  .  entrySet  (  )  )  {  final  int  col  =  entry  .  getValue  (  )  .  intValue  (  )  ;  [BUGGY]  map  .  put  (  entry  .  getKey  (  )  ,  values[col]  )  ;  }  return  map  ;  }  	Csv_6_CSVRecord_1_1	182	0	src/main/java/org/apache/commons/csv/CSVRecord.java
1008		[BUGGY]  [FE]  AssertionFailedError:  Expected  exception:  javalangIllegalStateException  [CLASS]  [CONTEXT]  	Csv_7_CSVParser_2_1	32	0	src/main/java/org/apache/commons/csv/CSVParser.java
1009	if  (hdrMap.containsKey(header[i]))  {  throw  new  IllegalStateException( "The  header  contains  duplicate  names:   "  +  Arrays.toString(header));  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exception:  javalangIllegalStateException  [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  [CLASS]  CSVParser  [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  CSVFormat  format  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  nextRecord  [TYPE]  String[]  formatHeader  header  [TYPE]  Map  hdrMap  headerMap  [TYPE]  long  recordNumber  [TYPE]  int  i  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  final  String[]  formatHeader  =  this  .  format  .  getHeader  (  )  ;  if  (  formatHeader  !  =  null  )  {  hdrMap  =  new  LinkedHashMap<String  ,  Integer>  (  )  ;  String[]  header  =  null  ;  if  (  formatHeader  .  length  =  =  0  )  {  final  CSVRecord  nextRecord  =  this  .  nextRecord  (  )  ;  if  (  nextRecord  !  =  null  )  {  header  =  nextRecord  .  values  (  )  ;  }  }  else  {  if  (  this  .  format  .  getSkipHeaderRecord  (  )  )  {  this  .  nextRecord  (  )  ;  }  header  =  formatHeader  ;  }  if  (  header  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  header  .  length  ;  i++  )  {  [BUGGY]  hdrMap  .  put  (  header[i]  ,  Integer  .  valueOf  (  i  )  )  ;  }  }  }  return  hdrMap  ;  }  	Csv_7_CSVParser_2_2	371	0	src/main/java/org/apache/commons/csv/CSVParser.java
1010	\tSet<String>  dupCheck  =  new  HashSet<String>();  \tfor(String  hdr  :  header)  {  \t\tif  (!dupCheck.add(hdr))  {  \t\t\tthrow  new  IllegalArgumentException( "The  header  contains  a  duplicate  entry:  \' "  +  hdr  +   "\'  in   "  +  Arrays.toString(header));  \t\t}  \t}  	[BUGGY]  [FE]  Exception:  Unexpected  exception  ,  expected<javalangIllegalArgumentException>  but  was<javalangIllegalStateException>  [CLASS]  [CONTEXT]  	Csv_8_CSVFormat_2_1	316	0	src/main/java/org/apache/commons/csv/CSVFormat.java
1011		[BUGGY]  if  (  header  !  =  null  )  {  final  Set<String>  set  =  new  HashSet<String>  (  header  .  length  )  ;  set  .  addAll  (  Arrays  .  asList  (  header  )  )  ;  if  (  set  .  size  (  )  !  =  header  .  length  )  {  throw  new  IllegalStateException  (   "The  header  contains  duplicate  names:   "  +  Arrays  .  toString  (  header  )  )  ;  }  }  [FE]  Exception:  Unexpected  exception  ,  expected<javalangIllegalArgumentException>  but  was<javalangIllegalStateException>  [METHOD]  validate  [TYPE]  void  [PARAMETER]  [CLASS]  CSVFormat  [TYPE]  Quote  quotePolicy  [TYPE]  boolean  false  ignoreEmptyLines  ignoreSurroundingSpaces  skipHeaderRecord  true  [TYPE]  Set  set  [TYPE]  Character  commentStart  escape  quoteChar  [TYPE]  char  delimiter  [TYPE]  CSVFormat  DEFAULT  EXCEL  MYSQL  RFC4180  TDF  [TYPE]  String  nullString  recordSeparator  [TYPE]  String[]  header  [TYPE]  long  serialVersionUID  [CONTEXT]  if  (  escape  !  =  null  &&  delimiter  =  =  escape  .  charValue  (  )  )  {  throw  new  IllegalStateException  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  ' "  +  escape  +   "'  )   "  )  ;  }  if  (  commentStart  !  =  null  &&  delimiter  =  =  commentStart  .  charValue  (  )  )  {  throw  new  IllegalStateException  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  ' "  +  commentStart  +   "'  )   "  )  ;  }  if  (  quoteChar  !  =  null  &&  quoteChar  .  equals  (  commentStart  )  )  {  throw  new  IllegalStateException  (   "The  comment  start  character  and  the  quoteChar  cannot  be  the  same  (  ' "  +  commentStart  +   "'  )   "  )  ;  }  if  (  escape  !  =  null  &&  escape  .  equals  (  commentStart  )  )  {  throw  new  IllegalStateException  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  ' "  +  commentStart  +   "'  )   "  )  ;  }  if  (  escape  =  =  null  &&  quotePolicy  =  =  Quote  .  NONE  )  {  throw  new  IllegalStateException  (   "No  quotes  mode  set  but  no  escape  character  is  set "  )  ;  }  [BUGGY]  if  (  header  !  =  null  )  {  final  Set<String>  set  =  new  HashSet<String>  (  header  .  length  )  ;  set  .  addAll  (  Arrays  .  asList  (  header  )  )  ;  if  (  set  .  size  (  )  !  =  header  .  length  )  {  throw  new  IllegalStateException  (   "The  header  contains  duplicate  names:   "  +  Arrays  .  toString  (  header  )  )  ;  }  	Csv_8_CSVFormat_2_2	665	7	src/main/java/org/apache/commons/csv/CSVFormat.java
1012	if  (mapping  ==  null)  {  return  map;  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  null  ,  map  .  get  (   "fourth "  )  )  ;  [METHOD]  putIn  [TYPE]  <M  [PARAMETER]  final  M  map  [CLASS]  CSVRecord  [TYPE]  Entry  entry  [TYPE]  boolean  false  true  [TYPE]  String[]  EMPTY_STRING_ARRAY  values  [TYPE]  String  comment  [TYPE]  Map  mapping  [TYPE]  M  map  [TYPE]  long  recordNumber  serialVersionUID  [TYPE]  int  col  [CONTEXT]  <M  extends  Map<String  ,  String>>  M  putIn  (  final  M  map  )  {  [BUGGY]  for  (  final  Entry<String  ,  Integer>  entry  :  mapping  .  entrySet  (  )  )  {  final  int  col  =  entry  .  getValue  (  )  .  intValue  (  )  ;  if  (  col  <  values  .  length  )  {  map  .  put  (  entry  .  getKey  (  )  ,  values[col]  )  ;  }  }  return  map  ;  }  	Csv_9_CSVRecord_1_1	180	0	src/main/java/org/apache/commons/csv/CSVRecord.java
1013	if  (format.getHeader()  !=  null)  {  this.printRecord((Object[])  format.getHeader());  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[C1  ,  C2  ,  C3  assertEquals  (   "C1  ,  C2  ,  C3\r\na  ,  b  ,  c\r\nx  ,  y  ,  z\r\n "  ,  sw  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Csv_10_CSVPrinter_1_1	70	0	src/main/java/org/apache/commons/csv/CSVPrinter.java
1014	final  boolean  emptyHeader  =  header  ==  null  ||  header.trim().isEmpty();  	[BUGGY]  final  boolean  emptyHeader  =  header  .  trim  (  )  .  isEmpty  (  )  ;  [FE]  NullPointerException  [METHOD]  initializeHeader  [TYPE]  Map  [PARAMETER]  [CLASS]  CSVParser  [TYPE]  Lexer  lexer  [TYPE]  boolean  containsHeader  emptyHeader  false  true  [TYPE]  CSVFormat  format  [TYPE]  List  record  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  nextRecord  [TYPE]  String[]  formatHeader  headerRecord  [TYPE]  String  header  [TYPE]  Map  hdrMap  headerMap  [TYPE]  long  recordNumber  [TYPE]  int  i  [CONTEXT]  private  Map<String  ,  Integer>  initializeHeader  (  )  throws  IOException  {  Map<String  ,  Integer>  hdrMap  =  null  ;  final  String[]  formatHeader  =  this  .  format  .  getHeader  (  )  ;  if  (  formatHeader  !  =  null  )  {  hdrMap  =  new  LinkedHashMap<String  ,  Integer>  (  )  ;  String[]  headerRecord  =  null  ;  if  (  formatHeader  .  length  =  =  0  )  {  final  CSVRecord  nextRecord  =  this  .  nextRecord  (  )  ;  if  (  nextRecord  !  =  null  )  {  headerRecord  =  nextRecord  .  values  (  )  ;  }  }  else  {  if  (  this  .  format  .  getSkipHeaderRecord  (  )  )  {  this  .  nextRecord  (  )  ;  }  headerRecord  =  formatHeader  ;  }  if  (  headerRecord  !  =  null  )  {  for  (  int  i  =  0  ;  i  <  headerRecord  .  length  ;  i++  )  {  final  String  header  =  headerRecord[i]  ;  final  boolean  containsHeader  =  hdrMap  .  containsKey  (  header  )  ;  [BUGGY]  final  boolean  emptyHeader  =  header  .  trim  (  )  .  isEmpty  (  )  ;  if  (  containsHeader  &&  (  !emptyHeader  ||  (  emptyHeader  &&  !this  .  format  .  getIgnoreEmptyHeaders  (  )  )  )  )  {  throw  new  IllegalArgumentException  (   "The  header  contains  a  duplicate  name:  \ " "  +  header  +   "\ "  in   "  +  Arrays  .  toString  (  headerRecord  )  )  ;  }  hdrMap  .  put  (  header  ,  Integer  .  valueOf  (  i  )  )  ;  	Csv_11_CSVParser_1_1	384	1	src/main/java/org/apache/commons/csv/CSVParser.java
1015	public  static  final  CSVFormat  EXCEL  =  DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);  	[BUGGY]  public  static  final  CSVFormat  EXCEL  =  DEFAULT  .  withIgnoreEmptyLines  (  false  )  ;  [FE]  IllegalArgumentException:  The  header  contains  a  duplicate  name:   " "  in  [A  ,  B  ,  C  ,  ,  ]  Assert  .  assertEquals  (   "c "  ,  record  .  get  (   "C "  )  )  ;  [CLASS]  [CONTEXT]  	Csv_12_CSVFormat_1_1	219	1	src/main/java/org/apache/commons/csv/CSVFormat.java
1016	.withQuote(null).withRecordSeparator(LF).withNullString( "\\\\N ");  	[BUGGY]  .  withQuote  (  null  )  .  withRecordSeparator  (  LF  )  ;  [FE]  AssertionFailedError:  expected:< "NULL "  assertArrayEquals  (  expectNulls  (  s  ,  format  )  ,  record0  )  ;  [CLASS]  [CONTEXT]  	Csv_13_CSVFormat_1_1	319	1	src/main/java/org/apache/commons/csv/CSVFormat.java
1017	if  (object  ==  null)  {  out.append(value);  }  else  if  (format.isQuoteCharacterSet())  {  	[BUGGY]  if  (  format  .  isQuoteCharacterSet  (  )  )  {  [FE]  AssertionFailedError:  expected:< "NULL "  assertArrayEquals  (  expectNulls  (  s  ,  format  )  ,  record0  )  ;  [METHOD]  print  [TYPE]  void  [PARAMETER]  Object  object  CharSequence  value  final  int  offset  final  int  len  [CLASS]  CSVPrinter  [TYPE]  CharSequence  value  [TYPE]  CSVFormat  format  [TYPE]  Object  object  [TYPE]  boolean  false  newRecord  true  [TYPE]  int  len  offset  [TYPE]  Appendable  out  [CONTEXT]  private  void  print  (  final  Object  object  ,  final  CharSequence  value  ,  final  int  offset  ,  final  int  len  )  throws  IOException  {  if  (  !newRecord  )  {  out  .  append  (  format  .  getDelimiter  (  )  )  ;  }  [BUGGY]  if  (  format  .  isQuoteCharacterSet  (  )  )  {  printAndQuote  (  object  ,  value  ,  offset  ,  len  )  ;  }  else  if  (  format  .  isEscapeCharacterSet  (  )  )  {  printAndEscape  (  value  ,  offset  ,  len  )  ;  }  else  {  out  .  append  (  value  ,  offset  ,  offset  +  len  )  ;  }  newRecord  =  false  ;  }  	Csv_13_CSVPrinter_1_1	139	1	src/main/java/org/apache/commons/csv/CSVPrinter.java
1018		[BUGGY]  [FE]  AssertionFailedError:  expected:<[  assertEquals  (   "\\ "  ,  sw  .  toString  (  )  )  ;  [METHOD]  printAndQuote  [TYPE]  void  [PARAMETER]  Object  object  CharSequence  value  final  int  offset  final  int  len  Appendable  out  final  boolean  newRecord  [CLASS]  CSVFormat  [TYPE]  Character  commentMarker  escapeCharacter  quoteCharacter  [TYPE]  Appendable  out  [TYPE]  CharSequence  value  [TYPE]  String[]  header  headerComments  [TYPE]  String  nullString  recordSeparator  [TYPE]  long  serialVersionUID  [TYPE]  int  end  len  offset  pos  start  [TYPE]  boolean  allowMissingColumnNames  false  ignoreEmptyLines  ignoreHeaderCase  ignoreSurroundingSpaces  newRecord  quote  skipHeaderRecord  trailingDelimiter  trim  true  [TYPE]  QuoteMode  quoteMode  quoteModePolicy  [TYPE]  char  c  delimChar  delimiter  quoteChar  [TYPE]  CSVFormat  DEFAULT  EXCEL  INFORMIX_UNLOAD  INFORMIX_UNLOAD_CSV  MYSQL  RFC4180  TDF  format  [TYPE]  Object  object  [TYPE]  Predefined  Default  Excel  InformixUnload  InformixUnloadCsv  MySQL  RFC4180  TDF  [CONTEXT]  }  switch  (  quoteModePolicy  )  {  case  ALL:  quote  =  true  ;  break  ;  case  NON_NUMERIC:  quote  =  !  (  object  instanceof  Number  )  ;  break  ;  case  NONE:  printAndEscape  (  value  ,  offset  ,  len  ,  out  )  ;  return  ;  case  MINIMAL:  if  (  len  <  =  0  )  {      if  (  newRecord  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;    [BUGGY]  if  (  newRecord  &&  (  c  <  '0'  ||  c  >  '9'  &&  c  <  'A'  ||  c  >  'Z'  &&  c  <  'a'  ||  c  >  'z'  )  )  {  quote  =  true  ;  }  else  if  (  c  <  =  COMMENT  )  {    	Csv_14_CSVFormat_1_1	1039	0	src/main/java/org/apache/commons/csv/CSVFormat.java
1019	if  (c  <=  COMMENT)  {  	[BUGGY]  if  (  newRecord  &&  (  c  <  0x20  ||  c  >  0x21  &&  c  <  0x23  ||  c  >  0x2B  &&  c  <  0x2D  ||  c  >  0x7E  )  )  {  quote  =  true  ;  }  else  if  (  c  <  =  COMMENT  )  {  [FE]  AssertionFailedError:  expected:<[  assertEquals  (  EURO_CH  +   "  ,  Deux "  +  recordSeparator  ,  sw  .  toString  (  )  )  ;  [METHOD]  printAndQuote  [TYPE]  void  [PARAMETER]  Object  object  CharSequence  value  final  int  offset  final  int  len  Appendable  out  final  boolean  newRecord  [CLASS]  CSVFormat  [TYPE]  Character  commentMarker  escapeCharacter  quoteCharacter  [TYPE]  Appendable  out  [TYPE]  CharSequence  value  [TYPE]  String[]  header  headerComments  [TYPE]  String  nullString  recordSeparator  [TYPE]  long  serialVersionUID  [TYPE]  int  end  len  offset  pos  start  [TYPE]  boolean  allowMissingColumnNames  autoFlush  false  ignoreEmptyLines  ignoreHeaderCase  ignoreSurroundingSpaces  newRecord  quote  skipHeaderRecord  trailingDelimiter  trim  true  [TYPE]  QuoteMode  quoteMode  quoteModePolicy  [TYPE]  char  c  delimChar  delimiter  quoteChar  [TYPE]  CSVFormat  DEFAULT  EXCEL  INFORMIX_UNLOAD  INFORMIX_UNLOAD_CSV  MYSQL  POSTGRESQL_CSV  POSTGRESQL_TEXT  RFC4180  TDF  format  [TYPE]  Object  object  [TYPE]  Predefined  Default  Excel  InformixUnload  InformixUnloadCsv  MySQL  PostgreSQLCsv  PostgreSQLText  RFC4180  TDF  [CONTEXT]  }  switch  (  quoteModePolicy  )  {  case  ALL:  case  ALL_NON_NULL:  quote  =  true  ;  break  ;  case  NON_NUMERIC:  quote  =  !  (  object  instanceof  Number  )  ;  break  ;  case  NONE:  printAndEscape  (  value  ,  offset  ,  len  ,  out  )  ;  return  ;  case  MINIMAL:  if  (  len  <  =  0  )  {      if  (  newRecord  )  {  quote  =  true  ;  }  }  else  {  char  c  =  value  .  charAt  (  pos  )  ;  [BUGGY]  if  (  newRecord  &&  (  c  <  0x20  ||  c  >  0x21  &&  c  <  0x23  ||  c  >  0x2B  &&  c  <  0x2D  ||  c  >  0x7E  )  )  {  quote  =  true  ;  }  else  if  (  c  <  =  COMMENT  )  {    	Csv_15_CSVFormat_1_1	1189	3	src/main/java/org/apache/commons/csv/CSVFormat.java
1020	private  final  CSVRecordIterator  csvRecordIterator;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[3]>  but  was:<[4]>  assertEquals  (   "\u00c4 "  ,  record  .  get  (  0  )  )  ;  [CLASS]  [CONTEXT]  	Csv_16_CSVParser_4_1	289	0	src/main/java/org/apache/commons/csv/CSVParser.java
1021	this.csvRecordIterator  =  new  CSVRecordIterator();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[3]>  but  was:<[4]>  assertEquals  (   "\u00c4 "  ,  record  .  get  (  0  )  )  ;  [CLASS]  [CONTEXT]  	Csv_16_CSVParser_4_2	357	0	src/main/java/org/apache/commons/csv/CSVParser.java
1022	return  csvRecordIterator;  }    class  CSVRecordIterator  implements  Iterator<CSVRecord>  {  	[BUGGY]  return  new  Iterator<CSVRecord>  (  )  {  [FE]  AssertionFailedError:  expected:<[3]>  but  was:<[4]>  assertEquals  (   "\u00c4 "  ,  record  .  get  (  0  )  )  ;  [METHOD]  iterator  [TYPE]  Iterator  [PARAMETER]  [CLASS]  CSVParser  [TYPE]  Lexer  lexer  [TYPE]  boolean  false  true  [TYPE]  CSVFormat  format  [TYPE]  List  recordList  [TYPE]  Token  reusableToken  [TYPE]  CSVRecord  current  next  [TYPE]  IOException  e  [TYPE]  Map  headerMap  [TYPE]  long  characterOffset  recordNumber  [CONTEXT]  public  Iterator<CSVRecord>  iterator  (  )  {  [BUGGY]  return  new  Iterator<CSVRecord>  (  )  {  private  CSVRecord  current  ;  private  CSVRecord  getNextRecord  (  )  {  try  {  return  CSVParser  .  this  .  nextRecord  (  )  ;  	Csv_16_CSVParser_4_3	523	1	src/main/java/org/apache/commons/csv/CSVParser.java
1023		[BUGGY]  }  [FE]  AssertionFailedError:  expected:<[3]>  but  was:<[4]>  assertEquals  (   "\u00c4 "  ,  record  .  get  (  0  )  )  ;  [CLASS]  [CONTEXT]  	Csv_16_CSVParser_4_4	571	1	src/main/java/org/apache/commons/csv/CSVParser.java
1024	return  (TypeAdapter<T2>)  new  TypeAdapter<T1>()  {  @Override  public  void  write(JsonWriter  out,  T1  value)  throws  IOException  {  typeAdapter.write(out,  value);  }  @Override  public  T1  read(JsonReader  in)  throws  IOException  {  T1  result  =  typeAdapter.read(in);  if  (result  !=  null  &&  !requestedType.isInstance(result))  {  throw  new  JsonSyntaxException( "Expected  a   "  +  requestedType.getName()  +   "  but  was   "  +  result.getClass().getName());  }  return  result;  }  };  	[BUGGY]  return  (  TypeAdapter<T2>  )  typeAdapter  ;  [FE]  ClassCastException:  Cannot  cast  comgooglegsonJsonPrimitive  to  comgooglegsonJsonObject  assertEquals  (   "Expected  a  com  .  google  .  gson  .  JsonObject  but  was  com  .  google  .  gson  .  JsonPrimitive "  ,  [METHOD]  create  [TYPE]  <T2>  [PARAMETER]  Gson  gson  TypeToken<T2>  typeToken  [CLASS]  31  [TYPE]  boolean  false  true  [TYPE]  TypeToken  typeToken  [TYPE]  Gson  gson  [TYPE]  Class  requestedType  [CONTEXT]  public  <T2>  TypeAdapter<T2>  create  (  Gson  gson  ,  TypeToken<T2>  typeToken  )  {  final  Class<?  super  T2>  requestedType  =  typeToken  .  getRawType  (  )  ;  if  (  !clazz  .  isAssignableFrom  (  requestedType  )  )  {  return  null  ;  }  [BUGGY]  return  (  TypeAdapter<T2>  )  typeAdapter  ;  }  	Gson_2_TypeAdapters_1_1	833	1	gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
1025		[BUGGY]  [FE]  ClassCastException:  javautilLinkedHashMap  cannot  be  cast  to  javautilconcurrentConcurrentMap  assertEquals  (   "{\ "123\ ":\ "456\ "} "  ,  json  )  ;  [CLASS]  [CONTEXT]  	Gson_3_ConstructorConstructor_2_1	36	0	gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
1026	if  (ConcurrentNavigableMap.class.isAssignableFrom(rawType))  {  return  new  ObjectConstructor<T>()  {  @Override  public  T  construct()  {  return  (T)  new  ConcurrentSkipListMap<Object,  Object>();  }  };  }  else  if  (ConcurrentMap.class.isAssignableFrom(rawType))  {  return  new  ObjectConstructor<T>()  {  @Override  public  T  construct()  {  return  (T)  new  ConcurrentHashMap<Object,  Object>();  }  };  }  else  if  (SortedMap.class.isAssignableFrom(rawType))  {  	[BUGGY]  if  (  SortedMap  .  class  .  isAssignableFrom  (  rawType  )  )  {  [FE]  ClassCastException:  javautilLinkedHashMap  cannot  be  cast  to  javautilconcurrentConcurrentMap  assertEquals  (   "{\ "123\ ":\ "456\ "} "  ,  json  )  ;  [METHOD]  newDefaultImplementationConstructor  [TYPE]  <T>  [PARAMETER]  Type  type  Class<?  super  T>  rawType  [CLASS]  ConstructorConstructor  [TYPE]  Type  elementType  type  [TYPE]  Class  rawType  [TYPE]  UnsafeAllocator  unsafeAllocator  [TYPE]  boolean  false  true  [TYPE]  Map  instanceCreators  [CONTEXT]  }  }  }  ;  }  else  if  (  Set  .  class  .  isAssignableFrom  (  rawType  )  )  {  return  new  ObjectConstructor<T>  (  )  {  @Override  public  T  construct  (  )  {  return  (  T  )  new  LinkedHashSet<Object>  (  )  ;  }  }  ;  }  else  if  (  Queue  .  class  .  isAssignableFrom  (  rawType  )  )  {  return  new  ObjectConstructor<T>  (  )  {  @Override  public  T  construct  (  )  {  return  (  T  )  new  LinkedList<Object>  (  )  ;  }  }  ;  }  else  {  return  new  ObjectConstructor<T>  (  )  {  @Override  public  T  construct  (  )  {  return  (  T  )  new  ArrayList<Object>  (  )  ;  }  }  ;  }  }  if  (  Map  .  class  .  isAssignableFrom  (  rawType  )  )  {  [BUGGY]  if  (  SortedMap  .  class  .  isAssignableFrom  (  rawType  )  )  {  return  new  ObjectConstructor<T>  (  )  {  @Override  public  T  construct  (  )  {  return  (  T  )  new  TreeMap<Object  ,  Object>  (  )  ;  }  }  ;  	Gson_3_ConstructorConstructor_2_2	175	1	gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java
1027	timezoneOffset  =  timezoneOffset.length()  >=  5  ?  timezoneOffset  :  timezoneOffset  +   "00 ";  	[BUGGY]  [FE]  gsonJsonSyntaxException:  1970-01-01T01:00:00+01  assertParsed  (   "1970-01-01T01:00:00+01 "  ,  adapter  )  ;  [METHOD]  parse  [TYPE]  Date  [PARAMETER]  String  date  ParsePosition  pos  [CLASS]  ISO8601Utils  [TYPE]  TimeZone  TIMEZONE_UTC  timezone  [TYPE]  boolean  false  hasT  true  [TYPE]  IndexOutOfBoundsException  e  [TYPE]  Calendar  calendar  [TYPE]  char  c  timezoneIndicator  [TYPE]  NumberFormatException  e  [TYPE]  String  UTC_ID  act  cleaned  date  input  msg  timezoneId  timezoneOffset  [TYPE]  ParseException  ex  [TYPE]  Exception  fail  [TYPE]  int  day  endOffset  fraction  hour  milliseconds  minutes  month  offset  parseEndOffset  seconds  year  [TYPE]  IllegalArgumentException  e  [TYPE]  ParsePosition  pos  [CONTEXT]  break  ;  default:  milliseconds  =  fraction  ;  }  offset  =  endOffset  ;  }  }  }  }  if  (  date  .  length  (  )  <  =  offset  )  {  throw  new  IllegalArgumentException  (   "No  time  zone  indicator "  )  ;  }  TimeZone  timezone  =  null  ;  char  timezoneIndicator  =  date  .  charAt  (  offset  )  ;  if  (  timezoneIndicator  =  =  'Z'  )  {  timezone  =  TIMEZONE_UTC  ;  offset  +  =  1  ;  }  else  if  (  timezoneIndicator  =  =  '+'  ||  timezoneIndicator  =  =  '-'  )  {  String  timezoneOffset  =  date  .  substring  (  offset  )  ;    [BUGGY]  offset  +  =  timezoneOffset  .  length  (  )  ;  if  (   "+0000 "  .  equals  (  timezoneOffset  )  ||   "+00:00 "  .  equals  (  timezoneOffset  )  )  {  timezone  =  TIMEZONE_UTC  ;  }  else  {  	Gson_5_ISO8601Utils_1_1	214	0	gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java
1028	if  (typeAdapter  !=  null)  {  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (   "ec57803e2 "  ,  device  .  id  )  ;  [METHOD]  getTypeAdapter  [TYPE]  TypeAdapter  [PARAMETER]  ConstructorConstructor  constructorConstructor  Gson  gson  TypeToken<?>  fieldType  JsonAdapter  annotation  [CLASS]  JsonAdapterAnnotationTypeAdapterFactory  [TYPE]  ConstructorConstructor  constructorConstructor  [TYPE]  boolean  false  true  [TYPE]  TypeToken  fieldType  [TYPE]  TypeAdapter  typeAdapter  [TYPE]  Gson  gson  [TYPE]  Class  typeAdapterClass  typeAdapterFactory  value  [TYPE]  JsonAdapter  annotation  [CONTEXT]  static  TypeAdapter<?>  getTypeAdapter  (  ConstructorConstructor  constructorConstructor  ,  Gson  gson  ,  TypeToken<?>  fieldType  ,  JsonAdapter  annotation  )  {  Class<?>  value  =  annotation  .  value  (  )  ;  TypeAdapter<?>  typeAdapter  ;  if  (  TypeAdapter  .  class  .  isAssignableFrom  (  value  )  )  {  Class<TypeAdapter<?>>  typeAdapterClass  =  (  Class<TypeAdapter<?>>  )  value  ;  typeAdapter  =  constructorConstructor  .  get  (  TypeToken  .  get  (  typeAdapterClass  )  )  .  construct  (  )  ;  }  else  if  (  TypeAdapterFactory  .  class  .  isAssignableFrom  (  value  )  )  {  Class<TypeAdapterFactory>  typeAdapterFactory  =  (  Class<TypeAdapterFactory>  )  value  ;  typeAdapter  =  constructorConstructor  .  get  (  TypeToken  .  get  (  typeAdapterFactory  )  )    .  construct  (  )    .  create  (  gson  ,  fieldType  )  ;  }  else  {  throw  new  IllegalArgumentException  (   "@JsonAdapter  value  must  be  TypeAdapter  or  TypeAdapterFactory  reference  .   "  )  ;  }  [BUGGY]  typeAdapter  =  typeAdapter  .  nullSafe  (  )  ;  return  typeAdapter  ;  }  	Gson_6_JsonAdapterAnnotationTypeAdapterFactory_1_1	67	0	gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java
1029	}  else  if  (p  ==  PEEKED_SINGLE_QUOTED  ||  p  ==  PEEKED_DOUBLE_QUOTED  ||  p  ==  PEEKED_UNQUOTED)  {  if  (p  ==  PEEKED_UNQUOTED)  {  peekedString  =  nextUnquotedValue();  }  else  {  }  	[BUGGY]  }  else  if  (  p  =  =  PEEKED_SINGLE_QUOTED  ||  p  =  =  PEEKED_DOUBLE_QUOTED  )  {  [FE]  gsonJsonSyntaxException:  javalangIllegalStateException:  Expected  a  long  but  was  STRING  at  line  1  column  2  path  $  assertEquals  (   "456 "  ,  map  .  get  (  longKey  )  )  ;  [METHOD]  nextLong  [TYPE]  long  [PARAMETER]  [CLASS]  JsonReader  [TYPE]  boolean  false  lenient  true  [TYPE]  double  asDouble  [TYPE]  Reader  in  [TYPE]  NumberFormatException  ignored  [TYPE]  int[]  pathIndices  stack  [TYPE]  String  peekedString  [TYPE]  String[]  pathNames  [TYPE]  long  MIN_INCOMPLETE_INTEGER  peekedLong  result  [TYPE]  int  NUMBER_CHAR_DECIMAL  NUMBER_CHAR_DIGIT  NUMBER_CHAR_EXP_DIGIT  NUMBER_CHAR_EXP_E  NUMBER_CHAR_EXP_SIGN  NUMBER_CHAR_FRACTION_DIGIT  NUMBER_CHAR_NONE  NUMBER_CHAR_SIGN  PEEKED_BEGIN_ARRAY  PEEKED_BEGIN_OBJECT  PEEKED_BUFFERED  PEEKED_DOUBLE_QUOTED  PEEKED_DOUBLE_QUOTED_NAME  PEEKED_END_ARRAY  PEEKED_END_OBJECT  PEEKED_EOF  PEEKED_FALSE  PEEKED_LONG  PEEKED_NONE  PEEKED_NULL  PEEKED_NUMBER  PEEKED_SINGLE_QUOTED  PEEKED_SINGLE_QUOTED_NAME  PEEKED_TRUE  PEEKED_UNQUOTED  PEEKED_UNQUOTED_NAME  limit  lineNumber  lineStart  p  peeked  peekedNumberLength  pos  stackSize  [TYPE]  char[]  NON_EXECUTE_PREFIX  buffer  [CONTEXT]  public  long  nextLong  (  )  throws  IOException  {  int  p  =  peeked  ;  if  (  p  =  =  PEEKED_NONE  )  {  p  =  doPeek  (  )  ;  }  if  (  p  =  =  PEEKED_LONG  )  {  peeked  =  PEEKED_NONE  ;  pathIndices[stackSize  -  1]++  ;  return  peekedLong  ;  }  if  (  p  =  =  PEEKED_NUMBER  )  {  peekedString  =  new  String  (  buffer  ,  pos  ,  peekedNumberLength  )  ;  pos  +  =  peekedNumberLength  ;  [BUGGY]  }  else  if  (  p  =  =  PEEKED_SINGLE_QUOTED  ||  p  =  =  PEEKED_DOUBLE_QUOTED  )  {  peekedString  =  nextQuotedValue  (  p  =  =  PEEKED_SINGLE_QUOTED  ?  '\''  :  ' "'  )  ;  try  {  long  result  =  Long  .  parseLong  (  peekedString  )  ;  peeked  =  PEEKED_NONE  ;  pathIndices[stackSize  -  1]++  ;  	Gson_7_JsonReader_2_1	954	1	gson/src/main/java/com/google/gson/stream/JsonReader.java
1030	}  else  if  (p  ==  PEEKED_SINGLE_QUOTED  ||  p  ==  PEEKED_DOUBLE_QUOTED  ||  p  ==  PEEKED_UNQUOTED)  {  if  (p  ==  PEEKED_UNQUOTED)  {  peekedString  =  nextUnquotedValue();  }  else  {  }  	[BUGGY]  }  else  if  (  p  =  =  PEEKED_SINGLE_QUOTED  ||  p  =  =  PEEKED_DOUBLE_QUOTED  )  {  [FE]  gsonJsonSyntaxException:  javalangIllegalStateException:  Expected  a  long  but  was  STRING  at  line  1  column  2  path  $  assertEquals  (   "456 "  ,  map  .  get  (  longKey  )  )  ;  [METHOD]  nextInt  [TYPE]  int  [PARAMETER]  [CLASS]  JsonReader  [TYPE]  boolean  false  lenient  true  [TYPE]  double  asDouble  [TYPE]  Reader  in  [TYPE]  NumberFormatException  ignored  [TYPE]  int[]  pathIndices  stack  [TYPE]  String  peekedString  [TYPE]  String[]  pathNames  [TYPE]  long  MIN_INCOMPLETE_INTEGER  peekedLong  [TYPE]  int  NUMBER_CHAR_DECIMAL  NUMBER_CHAR_DIGIT  NUMBER_CHAR_EXP_DIGIT  NUMBER_CHAR_EXP_E  NUMBER_CHAR_EXP_SIGN  NUMBER_CHAR_FRACTION_DIGIT  NUMBER_CHAR_NONE  NUMBER_CHAR_SIGN  PEEKED_BEGIN_ARRAY  PEEKED_BEGIN_OBJECT  PEEKED_BUFFERED  PEEKED_DOUBLE_QUOTED  PEEKED_DOUBLE_QUOTED_NAME  PEEKED_END_ARRAY  PEEKED_END_OBJECT  PEEKED_EOF  PEEKED_FALSE  PEEKED_LONG  PEEKED_NONE  PEEKED_NULL  PEEKED_NUMBER  PEEKED_SINGLE_QUOTED  PEEKED_SINGLE_QUOTED_NAME  PEEKED_TRUE  PEEKED_UNQUOTED  PEEKED_UNQUOTED_NAME  limit  lineNumber  lineStart  p  peeked  peekedNumberLength  pos  result  stackSize  [TYPE]  char[]  NON_EXECUTE_PREFIX  buffer  [CONTEXT]  public  int  nextInt  (  )  throws  IOException  {  int  p  =  peeked  ;  if  (  p  =  =  PEEKED_NONE  )  {  p  =  doPeek  (  )  ;  }  int  result  ;  if  (  p  =  =  PEEKED_LONG  )  {  result  =  (  int  )  peekedLong  ;  if  (  peekedLong  !  =  result  )  {  //  Make  sure  no  precision  was  lost  casting  to  'int'  .  throw  new  NumberFormatException  (   "Expected  an  int  but  was   "  +  peekedLong  +   "  at  line   "  +  getLineNumber  (  )  +   "  column   "  +  getColumnNumber  (  )  +   "  path   "  +  getPath  (  )  )  ;  }  peeked  =  PEEKED_NONE  ;  pathIndices[stackSize  -  1]++  ;  return  result  ;  }  if  (  p  =  =  PEEKED_NUMBER  )  {  peekedString  =  new  String  (  buffer  ,  pos  ,  peekedNumberLength  )  ;  pos  +  =  peekedNumberLength  ;  [BUGGY]  }  else  if  (  p  =  =  PEEKED_SINGLE_QUOTED  ||  p  =  =  PEEKED_DOUBLE_QUOTED  )  {  peekedString  =  nextQuotedValue  (  p  =  =  PEEKED_SINGLE_QUOTED  ?  '\''  :  ' "'  )  ;  try  {  result  =  Integer  .  parseInt  (  peekedString  )  ;  peeked  =  PEEKED_NONE  ;  pathIndices[stackSize  -  1]++  ;  	Gson_7_JsonReader_2_2	1182	1	gson/src/main/java/com/google/gson/stream/JsonReader.java
1031		[BUGGY]  [FE]  AssertionFailedError:  expected:<class  javalangreflectInvocationTargetException>  but  was:<class  javalangUnsupportedOperationException>  assertEquals  (  e  .  getClass  (  )  ,  UnsupportedOperationException  .  class  )  ;  [CLASS]  [CONTEXT]  	Gson_8_UnsafeAllocator_5_1	23	0	gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
1032	assertInstantiable(c);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<class  javalangreflectInvocationTargetException>  but  was:<class  javalangUnsupportedOperationException>  assertEquals  (  e  .  getClass  (  )  ,  UnsupportedOperationException  .  class  )  ;  [METHOD]  newInstance  [TYPE]  <T>  [PARAMETER]  Class<T>  c  [CLASS]  1  [TYPE]  boolean  false  true  [TYPE]  Class  c  [CONTEXT]  public  <T>  T  newInstance  (  Class<T>  c  )  throws  Exception  {  [BUGGY]  return  (  T  )  allocateInstance  .  invoke  (  unsafe  ,  c  )  ;  }  	Gson_8_UnsafeAllocator_5_2	48	0	gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
1033	assertInstantiable(c);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<class  javalangreflectInvocationTargetException>  but  was:<class  javalangUnsupportedOperationException>  assertEquals  (  e  .  getClass  (  )  ,  UnsupportedOperationException  .  class  )  ;  [METHOD]  newInstance  [TYPE]  <T>  [PARAMETER]  Class<T>  c  [CLASS]  2  [TYPE]  boolean  false  true  [TYPE]  Class  c  [CONTEXT]  public  <T>  T  newInstance  (  Class<T>  c  )  throws  Exception  {  [BUGGY]  return  (  T  )  newInstance  .  invoke  (  null  ,  c  ,  constructorId  )  ;  }  	Gson_8_UnsafeAllocator_5_3	71	0	gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
1034	assertInstantiable(c);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<class  javalangreflectInvocationTargetException>  but  was:<class  javalangUnsupportedOperationException>  assertEquals  (  e  .  getClass  (  )  ,  UnsupportedOperationException  .  class  )  ;  [METHOD]  newInstance  [TYPE]  <T>  [PARAMETER]  Class<T>  c  [CLASS]  3  [TYPE]  boolean  false  true  [TYPE]  Class  c  [CONTEXT]  public  <T>  T  newInstance  (  Class<T>  c  )  throws  Exception  {  [BUGGY]  return  (  T  )  newInstance  .  invoke  (  null  ,  c  ,  Object  .  class  )  ;  }  	Gson_8_UnsafeAllocator_5_4	90	0	gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
1035	private  static  void  assertInstantiable(Class<?>  c)  {  int  modifiers  =  c.getModifiers();  if  (Modifier.isInterface(modifiers))  {  throw  new  UnsupportedOperationException( "Interface  can\'t  be  instantiated!  Interface  name:   "  +  c.getName());  }  if  (Modifier.isAbstract(modifiers))  {  throw  new  UnsupportedOperationException( "Abstract  class  can\'t  be  instantiated!  Class  name:   "  +  c.getName());  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<class  javalangreflectInvocationTargetException>  but  was:<class  javalangUnsupportedOperationException>  assertEquals  (  e  .  getClass  (  )  ,  UnsupportedOperationException  .  class  )  ;  [CLASS]  [CONTEXT]  	Gson_8_UnsafeAllocator_5_5	110	0	gson/src/main/java/com/google/gson/internal/UnsafeAllocator.java
1036	@Override  public  JsonWriter  value(Boolean  value)  throws  IOException  {  if  (value  ==  null)  {  return  nullValue();  }  put(new  JsonPrimitive(value));  return  this;  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (   "[true  ,  false  ,  null] "  ,  stringWriter  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Gson_9_JsonTreeWriter_1_1	162	0	gson/src/main/java/com/google/gson/internal/bind/JsonTreeWriter.java
1037		[BUGGY]  if  (  value  =  =  null  )  {  out  .  nullValue  (  )  ;  return  ;  }  [FE]  NullPointerException  assertEquals  (   "[true  ,  false  ,  null] "  ,  stringWriter  .  toString  (  )  )  ;  [METHOD]  write  [TYPE]  void  [PARAMETER]  JsonWriter  out  Boolean  value  [CLASS]  3  [TYPE]  boolean  false  true  [TYPE]  Boolean  value  [TYPE]  JsonWriter  out  [CONTEXT]  public  void  write  (  JsonWriter  out  ,  Boolean  value  )  throws  IOException  {  [BUGGY]  if  (  value  =  =  null  )  {  out  .  nullValue  (  )  ;  return  ;  }  out  .  value  (  value  )  ;  }  	Gson_9_TypeAdapters_1_1	165	4	gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
1038	public  JsonWriter  value(Boolean  value)  throws  IOException  {  if  (value  ==  null)  {  return  nullValue();  }  writeDeferredName();  beforeValue();  out.write(value  ?   "true "  :   "false ");  return  this;  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (   "[true  ,  false  ,  null] "  ,  stringWriter  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Gson_9_JsonWriter_1_1	476	0	gson/src/main/java/com/google/gson/stream/JsonWriter.java
1039	TypeAdapter  t  =  jsonAdapterPresent  ?  typeAdapter  :  new  TypeAdapterRuntimeTypeWrapper(context,  typeAdapter,  fieldType.getType());  	[BUGGY]  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper  (  context  ,  typeAdapter  ,  fieldType  .  getType  (  )  )  ;  [FE]  ComparisonFailure:  expected:<{ "part ":[ "42 "]}>  but  was:<{ "part ":[42]}>  assertEquals  (  42  ,  gadget  .  part  )  ;  [METHOD]  write  [TYPE]  void  [PARAMETER]  JsonWriter  writer  Object  value  [CLASS]  1  [TYPE]  boolean  false  true  [TYPE]  TypeAdapter  t  [TYPE]  Object  fieldValue  value  [TYPE]  JsonWriter  writer  [CONTEXT]  @Override  void  write  (  JsonWriter  writer  ,  Object  value  )  throws  IOException  ,  IllegalAccessException  {  Object  fieldValue  =  field  .  get  (  value  )  ;  [BUGGY]  TypeAdapter  t  =  new  TypeAdapterRuntimeTypeWrapper  (  context  ,  typeAdapter  ,  fieldType  .  getType  (  )  )  ;  t  .  write  (  writer  ,  fieldValue  )  ;  }  	Gson_10_ReflectiveTypeAdapterFactory_1_1	122	2	gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java
1040	case  STRING:  	[BUGGY]  [FE]  gsonJsonSyntaxException:  Expecting  number  ,  got:  STRING  assertEquals  (  18  ,  value  .  intValue  (  )  )  ;  [METHOD]  read  [TYPE]  Number  [PARAMETER]  JsonReader  in  [CLASS]  14  [TYPE]  boolean  false  true  [TYPE]  JsonReader  in  [TYPE]  JsonToken  jsonToken  [CONTEXT]  public  Number  read  (  JsonReader  in  )  throws  IOException  {  JsonToken  jsonToken  =  in  .  peek  (  )  ;  switch  (  jsonToken  )  {  case  NULL:  in  .  nextNull  (  )  ;  return  null  ;  case  NUMBER:  [BUGGY]  return  new  LazilyParsedNumber  (  in  .  nextString  (  )  )  ;  default:  throw  new  JsonSyntaxException  (   "Expecting  number  ,  got:   "  +  jsonToken  )  ;  }  }  	Gson_11_TypeAdapters_1_1	371	0	gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java
1041	if  (stackSize  >  0)  {  }  if  (stackSize  >  0)  {  }  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  -1  assertEquals  (  JsonToken  .  END_DOCUMENT  ,  in  .  peek  (  )  )  ;  [METHOD]  skipValue  [TYPE]  void  [PARAMETER]  [CLASS]  JsonTreeReader  [TYPE]  boolean  false  true  [TYPE]  Reader  UNREADABLE_READER  [TYPE]  Object  SENTINEL_CLOSED  [TYPE]  int[]  pathIndices  [TYPE]  String[]  pathNames  [TYPE]  Object[]  stack  [TYPE]  int  stackSize  [CONTEXT]  @Override  public  void  skipValue  (  )  throws  IOException  {  if  (  peek  (  )  =  =  JsonToken  .  NAME  )  {  nextName  (  )  ;  pathNames[stackSize  -  2]  =   "null "  ;  }  else  {  popStack  (  )  ;  [BUGGY]  pathNames[stackSize  -  1]  =   "null "  ;  }  pathIndices[stackSize  -  1]++  ;  }  	Gson_12_JsonTreeReader_1_1	262	0	gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java
1042	if  (last  ==  NUMBER_CHAR_DIGIT  &&  fitsInLong  &&  (value  !=  Long.MIN_VALUE  ||  negative)  &&  (value!=0  ||  false==negative))  {  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[-]0>  but  was:<[]0>  assertEquals  (   "-0 "  ,  reader  .  nextString  (  )  )  ;  [METHOD]  peekNumber  [TYPE]  int  [PARAMETER]  [CLASS]  JsonReader  [TYPE]  boolean  false  fitsInLong  lenient  negative  true  [TYPE]  char  c  [TYPE]  Reader  in  [TYPE]  int[]  pathIndices  stack  [TYPE]  String  peekedString  [TYPE]  String[]  pathNames  [TYPE]  long  MIN_INCOMPLETE_INTEGER  newValue  peekedLong  value  [TYPE]  int  NUMBER_CHAR_DECIMAL  NUMBER_CHAR_DIGIT  NUMBER_CHAR_EXP_DIGIT  NUMBER_CHAR_EXP_E  NUMBER_CHAR_EXP_SIGN  NUMBER_CHAR_FRACTION_DIGIT  NUMBER_CHAR_NONE  NUMBER_CHAR_SIGN  PEEKED_BEGIN_ARRAY  PEEKED_BEGIN_OBJECT  PEEKED_BUFFERED  PEEKED_DOUBLE_QUOTED  PEEKED_DOUBLE_QUOTED_NAME  PEEKED_END_ARRAY  PEEKED_END_OBJECT  PEEKED_EOF  PEEKED_FALSE  PEEKED_LONG  PEEKED_NONE  PEEKED_NULL  PEEKED_NUMBER  PEEKED_SINGLE_QUOTED  PEEKED_SINGLE_QUOTED_NAME  PEEKED_TRUE  PEEKED_UNQUOTED  PEEKED_UNQUOTED_NAME  i  l  last  limit  lineNumber  lineStart  p  peeked  peekedNumberLength  pos  stackSize  [TYPE]  char[]  NON_EXECUTE_PREFIX  buffer  [CONTEXT]  if  (  !isLiteral  (  c  )  )  {  break  charactersOfNumber  ;  }  return  PEEKED_NONE  ;  }  if  (  last  =  =  NUMBER_CHAR_SIGN  ||  last  =  =  NUMBER_CHAR_NONE  )  {  value  =  -  (  c  -  '0'  )  ;  last  =  NUMBER_CHAR_DIGIT  ;  }  else  if  (  last  =  =  NUMBER_CHAR_DIGIT  )  {  if  (  value  =  =  0  )  {  return  PEEKED_NONE  ;  //  Leading  '0'  prefix  is  not  allowed  (  since  it  could  be  octal  )  .  }  long  newValue  =  value  *  10  -  (  c  -  '0'  )  ;  fitsInLong  &  =  value  >  MIN_INCOMPLETE_INTEGER  ||  (  value  =  =  MIN_INCOMPLETE_INTEGER  &&  newValue  <  value  )  ;  value  =  newValue  ;  }  else  if  (  last  =  =  NUMBER_CHAR_DECIMAL  )  {  last  =  NUMBER_CHAR_FRACTION_DIGIT  ;  }  else  if  (  last  =  =  NUMBER_CHAR_EXP_E  ||  last  =  =  NUMBER_CHAR_EXP_SIGN  )  {  last  =  NUMBER_CHAR_EXP_DIGIT  ;  }  }  }  [BUGGY]  if  (  last  =  =  NUMBER_CHAR_DIGIT  &&  fitsInLong  &&  (  value  !  =  Long  .  MIN_VALUE  ||  negative  )  )  {  peekedLong  =  negative  ?  value  :  -value  ;  pos  +  =  i  ;  return  peeked  =  PEEKED_LONG  ;  }  else  if  (  last  =  =  NUMBER_CHAR_DIGIT  ||  last  =  =  NUMBER_CHAR_FRACTION_DIGIT  ||  last  =  =  NUMBER_CHAR_EXP_DIGIT  )  {  	Gson_13_JsonReader_1_1	731	0	gson/src/main/java/com/google/gson/stream/JsonReader.java
1043	if  (!lenient  &&  (Double.isNaN(value)  ||  Double.isInfinite(value)))  {  	[BUGGY]  if  (  Double  .  isNaN  (  value  )  ||  Double  .  isInfinite  (  value  )  )  {  [FE]  IllegalArgumentException:  Numeric  values  must  be  finite  ,  but  was  NaN  assertEquals  (   "[NaN  ,  -Infinity  ,  Infinity] "  ,  stringWriter  .  toString  (  )  )  ;  [METHOD]  value  [TYPE]  JsonWriter  [PARAMETER]  double  value  [CLASS]  JsonWriter  [TYPE]  boolean  false  htmlSafe  lenient  serializeNulls  true  [TYPE]  double  value  [TYPE]  int[]  stack  [TYPE]  String[]  HTML_SAFE_REPLACEMENT_CHARS  REPLACEMENT_CHARS  [TYPE]  String  deferredName  indent  separator  [TYPE]  Writer  out  [TYPE]  int  stackSize  [CONTEXT]  public  JsonWriter  value  (  double  value  )  throws  IOException  {  writeDeferredName  (  )  ;  [BUGGY]  if  (  Double  .  isNaN  (  value  )  ||  Double  .  isInfinite  (  value  )  )  {  throw  new  IllegalArgumentException  (   "Numeric  values  must  be  finite  ,  but  was   "  +  value  )  ;  }  beforeValue  (  )  ;  out  .  append  (  Double  .  toString  (  value  )  )  ;  return  this  ;  }  	Gson_15_JsonWriter_1_1	495	1	gson/src/main/java/com/google/gson/stream/JsonWriter.java
1044	if  (in.peek()  ==  JsonToken.NULL)  {  in.nextNull();  return  null;  	[BUGGY]  if  (  in  .  peek  (  )  !  =  JsonToken  .  STRING  )  {  throw  new  JsonParseException  (   "The  date  should  be  a  string  value "  )  ;  [FE]  gsonJsonParseException:  The  date  should  be  a  string  value  assertEquals  (   "ISO  8601 "  ,  new  Date  (  0  )  ,  adapter  .  fromJson  (  toLiteral  (   "1970-01-01T00:00:00Z "  )  )  )  ;  [METHOD]  read  [TYPE]  Date  [PARAMETER]  JsonReader  in  [CLASS]  DefaultDateTypeAdapter  [TYPE]  JsonReader  in  [TYPE]  Class  dateType  [TYPE]  String  SIMPLE_NAME  [TYPE]  boolean  false  true  [TYPE]  Date  date  [TYPE]  DateFormat  enUsFormat  localFormat  [CONTEXT]  public  Date  read  (  JsonReader  in  )  throws  IOException  {  [BUGGY]  if  (  in  .  peek  (  )  !  =  JsonToken  .  STRING  )  {  throw  new  JsonParseException  (   "The  date  should  be  a  string  value "  )  ;  }  Date  date  =  deserializeToDate  (  in  .  nextString  (  )  )  ;  if  (  dateType  =  =  Date  .  class  )  {  return  date  ;  }  else  if  (  dateType  =  =  Timestamp  .  class  )  {  return  new  Timestamp  (  date  .  getTime  (  )  )  ;  }  else  if  (  dateType  =  =  java  .  sql  .  Date  .  class  )  {  return  new  java  .  sql  .  Date  (  date  .  getTime  (  )  )  ;  }  else  {  throw  new  AssertionError  (  )  ;  }  }  	Gson_17_DefaultDateTypeAdapter_1_1	99	2	gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java
1045	if  (_parsingContext.inRoot())  {  _verifyRootSpace(c);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  have  gotten  an  exception  ;  instead  got  token:  VALUE_NUMBER_INT  [METHOD]  _parseNumber2  [TYPE]  JsonToken  [PARAMETER]  boolean  negative  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _tokenIncomplete  eof  false  negative  true  [TYPE]  char  c  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  _icWS  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  _hashSeed  expLen  fractLen  intLen  outPtr  [TYPE]  char[]  _inputBuffer  outBuf  [CONTEXT]  }  exp_loop:  while  (  c  <  =  INT_9  &&  c  >  =  INT_0  )  {  ++expLen  ;  if  (  outPtr  >  =  outBuf  .  length  )  {  outBuf  =  _textBuffer  .  finishCurrentSegment  (  )  ;  outPtr  =  0  ;  }  outBuf[outPtr++]  =  c  ;  if  (  _inputPtr  >  =  _inputEnd  &&  !loadMore  (  )  )  {  eof  =  true  ;  break  exp_loop  ;  }  c  =  _inputBuffer[_inputPtr++]  ;  }  if  (  expLen  =  =  0  )  {  reportUnexpectedNumberChar  (  c  ,   "Exponent  indicator  not  followed  by  a  digit "  )  ;  }  }  if  (  !eof  )  {  --_inputPtr  ;  [BUGGY]  }  _textBuffer  .  setCurrentLength  (  outPtr  )  ;  return  reset  (  negative  ,  intLen  ,  fractLen  ,  expLen  )  ;  }  	JacksonCore_2_ReaderBasedJsonParser_3_2	1081	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1046	private  final  void  _verifyRootSpace(int  ch)  throws  IOException  {  ++_inputPtr;  switch  (ch)  {\n',   "+                case  '  ':\n ",   "+                case  '\\t':\n ",  '+                        return;\n',   "+                case  '\\r':\n ",  '+                        _skipCR();  return;\n',   "+                case  '\\n':\n ",  '+                        ++_currInputRow;  _currInputRowStart  =  _inputPtr;  return;  }  _reportMissingRootWS(ch);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  have  gotten  an  exception  ;  instead  got  token:  VALUE_NUMBER_INT  [CLASS]  [CONTEXT]  	JacksonCore_2_ReaderBasedJsonParser_3_3	1162	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1047	if  (_parsingContext.inRoot())  {  _verifyRootSpace(c);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  have  gotten  an  exception  ;  instead  got  token:  VALUE_NUMBER_INT  [METHOD]  _parseNumber  [TYPE]  JsonToken  [PARAMETER]  int  c  [CLASS]  UTF8StreamJsonParser  [TYPE]  byte[]  _inputBuffer  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  negative  true  [TYPE]  byte  BYTE_LF  [TYPE]  InputStream  _inputStream  [TYPE]  BytesToNameCanonicalizer  _symbols  [TYPE]  int[]  _icLatin1  _icUTF8  _icWS  _quadBuffer  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  int  _quad1  c  end  intLen  outPtr  [TYPE]  char[]  outBuf  [CONTEXT]  while  (  true  )  {  if  (  _inputPtr  >  =  end  )  {  return  _parserNumber2  (  outBuf  ,  outPtr  ,  negative  ,  intLen  )  ;  }  c  =  (  int  )  _inputBuffer[_inputPtr++]  &  0xFF  ;  if  (  c  <  INT_0  ||  c  >  INT_9  )  {  break  ;  }  ++intLen  ;  if  (  outPtr  >  =  outBuf  .  length  )  {  outBuf  =  _textBuffer  .  finishCurrentSegment  (  )  ;  outPtr  =  0  ;  }  outBuf[outPtr++]  =  (  char  )  c  ;  }  if  (  c  =  =  '  .  '  ||  c  =  =  'e'  ||  c  =  =  'E'  )  {  return  _parseFloat  (  outBuf  ,  outPtr  ,  c  ,  negative  ,  intLen  )  ;  }  --_inputPtr  ;  //  to  push  back  trailing  char  (  comma  etc  )  _textBuffer  .  setCurrentLength  (  outPtr  )  ;  [BUGGY]  return  resetInt  (  negative  ,  intLen  )  ;  }  	JacksonCore_2_UTF8StreamJsonParser_5_1	1244	0	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1048	if  (_parsingContext.inRoot())  {  _verifyRootSpace(_inputBuffer[_inputPtr++]  &  0xFF);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  have  gotten  an  exception  ;  instead  got  token:  VALUE_NUMBER_INT  [METHOD]  _parserNumber2  [TYPE]  JsonToken  [PARAMETER]  char[]  outBuf  int  outPtr  boolean  negative  int  intPartLength  [CLASS]  UTF8StreamJsonParser  [TYPE]  byte[]  _inputBuffer  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  negative  true  [TYPE]  byte  BYTE_LF  [TYPE]  InputStream  _inputStream  [TYPE]  BytesToNameCanonicalizer  _symbols  [TYPE]  int[]  _icLatin1  _icUTF8  _icWS  _quadBuffer  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  int  _quad1  c  intPartLength  outPtr  [TYPE]  char[]  outBuf  [CONTEXT]  throws  IOException  ,  JsonParseException  {  while  (  true  )  {  if  (  _inputPtr  >  =  _inputEnd  &&  !loadMore  (  )  )  {  _textBuffer  .  setCurrentLength  (  outPtr  )  ;  return  resetInt  (  negative  ,  intPartLength  )  ;  }  int  c  =  (  int  )  _inputBuffer[_inputPtr++]  &  0xFF  ;  if  (  c  >  INT_9  ||  c  <  INT_0  )  {  if  (  c  =  =  '  .  '  ||  c  =  =  'e'  ||  c  =  =  'E'  )  {  return  _parseFloat  (  outBuf  ,  outPtr  ,  c  ,  negative  ,  intPartLength  )  ;  }  break  ;  }  if  (  outPtr  >  =  outBuf  .  length  )  {  outBuf  =  _textBuffer  .  finishCurrentSegment  (  )  ;  outPtr  =  0  ;  }  outBuf[outPtr++]  =  (  char  )  c  ;  ++intPartLength  ;  }  --_inputPtr  ;  //  to  push  back  trailing  char  (  comma  etc  )  _textBuffer  .  setCurrentLength  (  outPtr  )  ;  [BUGGY]  return  resetInt  (  negative  ,  intPartLength  )  ;  }  	JacksonCore_2_UTF8StreamJsonParser_5_2	1280	0	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1049	if  (_parsingContext.inRoot())  {  _verifyRootSpace(c);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  have  gotten  an  exception  ;  instead  got  token:  VALUE_NUMBER_INT  [METHOD]  _parseFloat  [TYPE]  JsonToken  [PARAMETER]  char[]  outBuf  int  outPtr  int  c  boolean  negative  int  integerPartLength  [CLASS]  UTF8StreamJsonParser  [TYPE]  byte[]  _inputBuffer  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  eof  false  negative  true  [TYPE]  byte  BYTE_LF  [TYPE]  InputStream  _inputStream  [TYPE]  BytesToNameCanonicalizer  _symbols  [TYPE]  int[]  _icLatin1  _icUTF8  _icWS  _quadBuffer  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  int  _quad1  c  expLen  fractLen  integerPartLength  outPtr  [TYPE]  char[]  outBuf  [CONTEXT]  exp_loop:  while  (  c  <  =  INT_9  &&  c  >  =  INT_0  )  {  ++expLen  ;  if  (  outPtr  >  =  outBuf  .  length  )  {  outBuf  =  _textBuffer  .  finishCurrentSegment  (  )  ;  outPtr  =  0  ;  }  outBuf[outPtr++]  =  (  char  )  c  ;  if  (  _inputPtr  >  =  _inputEnd  &&  !loadMore  (  )  )  {  eof  =  true  ;  break  exp_loop  ;  }  c  =  (  int  )  _inputBuffer[_inputPtr++]  &  0xFF  ;  }  if  (  expLen  =  =  0  )  {  reportUnexpectedNumberChar  (  c  ,   "Exponent  indicator  not  followed  by  a  digit "  )  ;  }  }  if  (  !eof  )  {  --_inputPtr  ;  [BUGGY]  }  _textBuffer  .  setCurrentLength  (  outPtr  )  ;    return  resetFloat  (  negative  ,  integerPartLength  ,  fractLen  ,  expLen  )  ;  }  	JacksonCore_2_UTF8StreamJsonParser_5_3	1407	0	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1050	private  final  void  _verifyRootSpace(int  ch)  throws  IOException  {  ++_inputPtr;  switch  (ch)  {\n',   "+                case  '  ':\n ",   "+                case  '\\t':\n ",  '+                        return;\n',   "+                case  '\\r':\n ",  '+                        _skipCR();  return;\n',   "+                case  '\\n':\n ",  '+                        ++_currInputRow;  _currInputRowStart  =  _inputPtr;  return;  }  _reportMissingRootWS(ch);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  have  gotten  an  exception  ;  instead  got  token:  VALUE_NUMBER_INT  [CLASS]  [CONTEXT]  	JacksonCore_2_UTF8StreamJsonParser_5_4	1421	0	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1051		[BUGGY]  if  (  i  <  32  )  {  _throwInvalidSpace  (  i  )  ;  }  [FE]  AssertionFailedError:  Should  have  gotten  an  exception  ;  instead  got  token:  VALUE_NUMBER_INT  [METHOD]  _skipWSOrEnd  [TYPE]  int  [PARAMETER]  [CLASS]  UTF8StreamJsonParser  [TYPE]  byte[]  _inputBuffer  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  byte  BYTE_LF  [TYPE]  InputStream  _inputStream  [TYPE]  BytesToNameCanonicalizer  _symbols  [TYPE]  int[]  _icLatin1  _icUTF8  _icWS  _quadBuffer  codes  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  int  _quad1  i  [CONTEXT]  case  2:  //  2-byte  UTF  _skipUtf8_2  (  i  )  ;  break  ;  case  3:  //  3-byte  UTF  _skipUtf8_3  (  i  )  ;  break  ;  case  4:  //  4-byte  UTF  _skipUtf8_4  (  i  )  ;  break  ;  case  INT_LF:  ++_currInputRow  ;  _currInputRowStart  =  _inputPtr  ;  break  ;  case  INT_CR:  _skipCR  (  )  ;  break  ;  case  '/':  _skipComment  (  )  ;  break  ;  case  '#':  if  (  !_skipYAMLComment  (  )  )  {  return  i  ;  }  break  ;  default:  //  e  .  g  .  -1  [BUGGY]  if  (  i  <  32  )  {  _throwInvalidSpace  (  i  )  ;  }  _reportInvalidChar  (  i  )  ;  }  }  	JacksonCore_2_UTF8StreamJsonParser_5_5	2575	3	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1052	_currInputRowStart  =  start;  _currInputProcessed  =  -start;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<0>  but  was:<3>  assertEquals  (  2  ,  loc  .  getColumnNr  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonCore_3_UTF8StreamJsonParser_1_1	125	0	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1053	int  newLen  =  len  +  (len  >>  1);  if  (newLen  >  MAX_SEGMENT_LEN)  {  newLen  =  len  +  (len  >>  2);  }  	[BUGGY]  int  newLen  =  (  len  =  =  MAX_SEGMENT_LEN  )  ?  (  MAX_SEGMENT_LEN+1  )  :  Math  .  min  (  MAX_SEGMENT_LEN  ,  len  +  (  len  >>  1  )  )  ;  [FE]  AssertionFailedError:  Expected  buffer  of  262145  to  expand  ,  did  not  ,  length  now  262144  [METHOD]  expandCurrentSegment  [TYPE]  char[]  [PARAMETER]  [CLASS]  TextBuffer  [TYPE]  boolean  _hasSegments  false  true  [TYPE]  BufferRecycler  _allocator  [TYPE]  ArrayList  _segments  [TYPE]  String  _resultString  [TYPE]  int  MAX_SEGMENT_LEN  MIN_SEGMENT_LEN  _currentSize  _inputLen  _inputStart  _segmentSize  len  newLen  [TYPE]  char[]  NO_CHARS  _currentSegment  _inputBuffer  _resultArray  curr  [CONTEXT]  public  char[]  expandCurrentSegment  (  )  {  final  char[]  curr  =  _currentSegment  ;  final  int  len  =  curr  .  length  ;  [BUGGY]  int  newLen  =  (  len  =  =  MAX_SEGMENT_LEN  )  ?  (  MAX_SEGMENT_LEN+1  )  :  Math  .  min  (  MAX_SEGMENT_LEN  ,  len  +  (  len  >>  1  )  )  ;  return  (  _currentSegment  =  Arrays  .  copyOf  (  curr  ,  newLen  )  )  ;  }  	JacksonCore_4_TextBuffer_1_1	585	1	src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java
1054	char  c  =  str.charAt(i);\n',   "                          if  (c  >  '9'  ||  c  <  '0')  {\n "]  	[BUGGY]  char  c  =  str  .  charAt  (  i++  )  ;  [FE]  NumberFormatException:  For  input  string:   "1e0 "  assertFalse  (  ptr  .  matches  (  )  )  ;  [METHOD]  _parseIndex  [TYPE]  int  [PARAMETER]  String  str  [CLASS]  JsonPointer  [TYPE]  char  c  [TYPE]  JsonPointer  EMPTY  _nextSegment  [TYPE]  String  _asString  _matchingPropertyName  str  [TYPE]  boolean  false  true  [TYPE]  int  _matchingElementIndex  i  len  [TYPE]  long  l  [CONTEXT]  private  final  static  int  _parseIndex  (  String  str  )  {  final  int  len  =  str  .  length  (  )  ;    if  (  len  =  =  0  ||  len  >  10  )  {  return  -1  ;  }  for  (  int  i  =  0  ;  i  <  len  ;  ++i  )  {  [BUGGY]  char  c  =  str  .  charAt  (  i++  )  ;  if  (  c  >  '9'  ||  c  <  '0'  )  {  return  -1  ;  }  }  if  (  len  =  =  10  )  {  long  l  =  NumberInput  .  parseLong  (  str  )  ;  if  (  l  >  Integer  .  MAX_VALUE  )  {  return  -1  ;  }  }  return  NumberInput  .  parseInt  (  str  )  ;  }  	JacksonCore_5_JsonPointer_1_1	193	1	src/main/java/com/fasterxml/jackson/core/JsonPointer.java
1055	char  c  =  str.charAt(0);\n',   "+                if  (c  <=  '0')  {\n ",   "+                        return  (len  ==  1  &&  c  ==  '0')  ?  0  :  -1;\n ",  '+                }\n',   "+                if  (c  >  '9')  {\n ",  '+                        return  -1;  }  for  (int  i  =  1;  i  <  len;  ++i)  {  c  =  str.charAt(i);\n',   "                          if  (c  >  '9'  ||  c  <  '0')  {\n "]  	[BUGGY]  for  (  int  i  =  0  ;  i  <  len  ;  ++i  )  {  char  c  =  str  .  charAt  (  i  )  ;  [FE]  AssertionFailedError:  expected:<-1>  but  was:<0>  assertEquals  (  -1  ,  ptr  .  getMatchingIndex  (  )  )  ;  [METHOD]  _parseIndex  [TYPE]  int  [PARAMETER]  String  str  [CLASS]  JsonPointer  [TYPE]  char  c  [TYPE]  JsonPointer  EMPTY  _nextSegment  [TYPE]  String  _asString  _matchingPropertyName  str  [TYPE]  boolean  false  true  [TYPE]  int  _matchingElementIndex  i  len  [TYPE]  long  l  [CONTEXT]  private  final  static  int  _parseIndex  (  String  str  )  {  final  int  len  =  str  .  length  (  )  ;    if  (  len  =  =  0  ||  len  >  10  )  {  return  -1  ;  }  [BUGGY]  for  (  int  i  =  0  ;  i  <  len  ;  ++i  )  {  char  c  =  str  .  charAt  (  i  )  ;  if  (  c  >  '9'  ||  c  <  '0'  )  {  return  -1  ;  }  }  if  (  len  =  =  10  )  {  long  l  =  NumberInput  .  parseLong  (  str  )  ;  if  (  l  >  Integer  .  MAX_VALUE  )  {  return  -1  ;  }  }  return  NumberInput  .  parseInt  (  str  )  ;  }  	JacksonCore_6_JsonPointer_1_1	193	2	src/main/java/com/fasterxml/jackson/core/JsonPointer.java
1056	if  (!_gotName)  {  return  STATUS_EXPECT_NAME;  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  not  have  let  comfasterxmljacksoncorejsonUTF8JsonGeneratorwriteString  (  )  be  used  in  place  of  [METHOD]  writeValue  [TYPE]  int  [PARAMETER]  [CLASS]  JsonWriteContext  [TYPE]  DupDetector  _dups  [TYPE]  boolean  _gotName  false  true  [TYPE]  JsonWriteContext  _child  _parent  [TYPE]  Object  _currentValue  [TYPE]  String  _currentName  [TYPE]  int  STATUS_EXPECT_NAME  STATUS_EXPECT_VALUE  STATUS_OK_AFTER_COLON  STATUS_OK_AFTER_COMMA  STATUS_OK_AFTER_SPACE  STATUS_OK_AS_IS  ix  [CONTEXT]  public  int  writeValue  (  )  {  if  (  _type  =  =  TYPE_OBJECT  )  {  [BUGGY]  _gotName  =  false  ;  ++_index  ;  return  STATUS_OK_AFTER_COLON  ;  }  if  (  _type  =  =  TYPE_ARRAY  )  {  int  ix  =  _index  ;  ++_index  ;  return  (  ix  <  0  )  ?  STATUS_OK_AS_IS  :  STATUS_OK_AFTER_COMMA  ;  }    ++_index  ;  return  (  _index  =  =  0  )  ?  STATUS_OK_AS_IS  :  STATUS_OK_AFTER_SPACE  ;  }  	JacksonCore_7_JsonWriteContext_1_1	169	0	src/main/java/com/fasterxml/jackson/core/json/JsonWriteContext.java
1057	if  (!_hasSegments  &&  _currentSegment  !=  null)    return  _currentSegment;  	[BUGGY]  if  (  !_hasSegments  )  return  _currentSegment  ;  [FE]  NullPointerException  assertTrue  (  tb  .  getTextBuffer  (  )  .  length  =  =  0  )  ;  [METHOD]  getTextBuffer  [TYPE]  char[]  [PARAMETER]  [CLASS]  TextBuffer  [TYPE]  boolean  _hasSegments  false  true  [TYPE]  BufferRecycler  _allocator  [TYPE]  ArrayList  _segments  [TYPE]  String  _resultString  [TYPE]  int  MAX_SEGMENT_LEN  MIN_SEGMENT_LEN  _currentSize  _inputLen  _inputStart  _segmentSize  [TYPE]  char[]  NO_CHARS  _currentSegment  _inputBuffer  _resultArray  [CONTEXT]  public  char[]  getTextBuffer  (  )  {  if  (  _inputStart  >  =  0  )  return  _inputBuffer  ;  if  (  _resultArray  !  =  null  )  return  _resultArray  ;  if  (  _resultString  !  =  null  )  {  return  (  _resultArray  =  _resultString  .  toCharArray  (  )  )  ;  }  [BUGGY]  if  (  !_hasSegments  )  return  _currentSegment  ;  return  contentsAsArray  (  )  ;  }  	JacksonCore_8_TextBuffer_1_1	307	1	src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java
1058	if  (_currToken  ==  JsonToken.FIELD_NAME)  {  return  getCurrentName();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<a>  but  was:<null>  [METHOD]  getValueAsString  [TYPE]  String  [PARAMETER]  [CLASS]  ParserMinimalBase  [TYPE]  JsonToken  _currToken  _lastClearedToken  [TYPE]  int  INT_BACKSLASH  INT_COLON  INT_COMMA  INT_CR  INT_E  INT_HASH  INT_LBRACKET  INT_LCURLY  INT_LF  INT_PERIOD  INT_QUOTE  INT_RBRACKET  INT_RCURLY  INT_SLASH  INT_SPACE  INT_TAB  INT_e  [TYPE]  boolean  false  true  [CONTEXT]  public  String  getValueAsString  (  )  throws  IOException  {  if  (  _currToken  =  =  JsonToken  .  VALUE_STRING  )  {  return  getText  (  )  ;  }  [BUGGY]  return  getValueAsString  (  null  )  ;  }  	JacksonCore_9_ParserMinimalBase_2_1	392	0	src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
1059	if  (_currToken  ==  JsonToken.FIELD_NAME)  {  return  getCurrentName();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<a>  but  was:<null>  [METHOD]  getValueAsString  [TYPE]  String  [PARAMETER]  String  defaultValue  [CLASS]  ParserMinimalBase  [TYPE]  JsonToken  _currToken  _lastClearedToken  [TYPE]  String  defaultValue  [TYPE]  boolean  false  true  [TYPE]  int  INT_BACKSLASH  INT_COLON  INT_COMMA  INT_CR  INT_E  INT_HASH  INT_LBRACKET  INT_LCURLY  INT_LF  INT_PERIOD  INT_QUOTE  INT_RBRACKET  INT_RCURLY  INT_SLASH  INT_SPACE  INT_TAB  INT_e  [CONTEXT]  public  String  getValueAsString  (  String  defaultValue  )  throws  IOException  {  if  (  _currToken  =  =  JsonToken  .  VALUE_STRING  )  {  return  getText  (  )  ;  }  [BUGGY]  if  (  _currToken  =  =  null  ||  _currToken  =  =  JsonToken  .  VALUE_NULL  ||  !_currToken  .  isScalarValue  (  )  )  {  return  defaultValue  ;  }  return  getText  (  )  ;  }  	JacksonCore_9_ParserMinimalBase_2_2	400	0	src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
1060	if  (_currToken  ==  JsonToken.FIELD_NAME)  {  return  getCurrentName();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<a>  but  was:<null>  [METHOD]  getValueAsString  [TYPE]  String  [PARAMETER]  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  _hashSeed  [TYPE]  char[]  _inputBuffer  [CONTEXT]  public  final  String  getValueAsString  (  )  throws  IOException  {  if  (  _currToken  =  =  JsonToken  .  VALUE_STRING  )  {  if  (  _tokenIncomplete  )  {  _tokenIncomplete  =  false  ;  _finishString  (  )  ;  //  only  strings  can  be  incomplete  }  return  _textBuffer  .  contentsAsString  (  )  ;  }  [BUGGY]  return  super  .  getValueAsString  (  null  )  ;  }  	JacksonCore_9_ReaderBasedJsonParser_2_1	253	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1061	if  (_currToken  ==  JsonToken.FIELD_NAME)  {  return  getCurrentName();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<a>  but  was:<null>  [METHOD]  getValueAsString  [TYPE]  String  [PARAMETER]  String  defValue  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  String  defValue  [TYPE]  int  _hashSeed  [TYPE]  char[]  _inputBuffer  [CONTEXT]  public  final  String  getValueAsString  (  String  defValue  )  throws  IOException  {  if  (  _currToken  =  =  JsonToken  .  VALUE_STRING  )  {  if  (  _tokenIncomplete  )  {  _tokenIncomplete  =  false  ;  _finishString  (  )  ;  //  only  strings  can  be  incomplete  }  return  _textBuffer  .  contentsAsString  (  )  ;  }  [BUGGY]  return  super  .  getValueAsString  (  defValue  )  ;  }  	JacksonCore_9_ReaderBasedJsonParser_2_2	266	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1062	if  (_currToken  ==  JsonToken.FIELD_NAME)  {  return  getCurrentName();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<a>  but  was:<null>  [METHOD]  getValueAsString  [TYPE]  String  [PARAMETER]  [CLASS]  UTF8StreamJsonParser  [TYPE]  byte[]  _inputBuffer  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  byte  BYTE_LF  [TYPE]  InputStream  _inputStream  [TYPE]  ByteQuadsCanonicalizer  _symbols  [TYPE]  int[]  _icLatin1  _icUTF8  _quadBuffer  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  int  _quad1  [CONTEXT]  public  String  getValueAsString  (  )  throws  IOException  {  if  (  _currToken  =  =  JsonToken  .  VALUE_STRING  )  {  if  (  _tokenIncomplete  )  {  _tokenIncomplete  =  false  ;  return  _finishAndReturnString  (  )  ;  //  only  strings  can  be  incomplete  }  return  _textBuffer  .  contentsAsString  (  )  ;  }  [BUGGY]  return  super  .  getValueAsString  (  null  )  ;  }  	JacksonCore_9_UTF8StreamJsonParser_2_1	305	0	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1063	if  (_currToken  ==  JsonToken.FIELD_NAME)  {  return  getCurrentName();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<a>  but  was:<null>  [METHOD]  getValueAsString  [TYPE]  String  [PARAMETER]  String  defValue  [CLASS]  UTF8StreamJsonParser  [TYPE]  byte[]  _inputBuffer  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  byte  BYTE_LF  [TYPE]  InputStream  _inputStream  [TYPE]  ByteQuadsCanonicalizer  _symbols  [TYPE]  int[]  _icLatin1  _icUTF8  _quadBuffer  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  String  defValue  [TYPE]  int  _quad1  [CONTEXT]  public  String  getValueAsString  (  String  defValue  )  throws  IOException  {  if  (  _currToken  =  =  JsonToken  .  VALUE_STRING  )  {  if  (  _tokenIncomplete  )  {  _tokenIncomplete  =  false  ;  return  _finishAndReturnString  (  )  ;  //  only  strings  can  be  incomplete  }  return  _textBuffer  .  contentsAsString  (  )  ;  }  [BUGGY]  return  super  .  getValueAsString  (  defValue  )  ;  }  	JacksonCore_9_UTF8StreamJsonParser_2_2	319	0	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1064	final  int  end  =  (_hashSize  <<  3);  if  (_spilloverEnd  >=  end)  {  	[BUGGY]  if  (  _spilloverEnd  >  =  hashArea  .  length  )  {  [FE]  ArrayIndexOutOfBoundsException:  256  [METHOD]  _findOffsetForAdd  [TYPE]  int  [PARAMETER]  int  hash  [CLASS]  ByteQuadsCanonicalizer  [TYPE]  boolean  _failOnDoS  _hashShared  _intern  _needRehash  false  true  [TYPE]  ByteQuadsCanonicalizer  _parent  [TYPE]  AtomicReference  _tableInfo  [TYPE]  int[]  _hashArea  hashArea  mainHash  [TYPE]  String[]  _names  names  [TYPE]  int  DEFAULT_T_SIZE  MAX_ENTRIES_FOR_REUSE  MAX_T_SIZE  MIN_HASH_SIZE  MULT  MULT2  MULT3  _count  _hashSize  _longNameOffset  _secondaryStart  _seed  _spilloverEnd  _tertiaryShift  _tertiaryStart  bucketSize  count  end  hash  longNameOffset  offset  offset2  size  spilloverEnd  tertiaryShift  [CONTEXT]  return  offset2  ;  }  offset2  =  _tertiaryStart  +  (  (  offset  >>  (  _tertiaryShift  +  2  )  )  <<  _tertiaryShift  )  ;  final  int  bucketSize  =  (  1  <<  _tertiaryShift  )  ;  for  (  int  end  =  offset2  +  bucketSize  ;  offset2  <  end  ;  offset2  +  =  4  )  {  if  (  hashArea[offset2+3]  =  =  0  )  {  return  offset2  ;  }  }  offset  =  _spilloverEnd  ;  _spilloverEnd  +  =  4  ;          [BUGGY]  if  (  _spilloverEnd  >  =  hashArea  .  length  )  {  if  (  _failOnDoS  )  {  _reportTooManyCollisions  (  )  ;  }    	JacksonCore_10_ByteQuadsCanonicalizer_2_1	925	1	src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java
1065	hash  ^=  (hash  <<  3);    hash  +=  (hash  >>>  12);    	[BUGGY]  hash  ^  =  (  hash  >>>  12  )  ;  [FE]  ArrayIndexOutOfBoundsException:  256  [METHOD]  calcHash  [TYPE]  int  [PARAMETER]  int  q1  [CLASS]  ByteQuadsCanonicalizer  [TYPE]  boolean  _failOnDoS  _hashShared  _intern  _needRehash  false  true  [TYPE]  ByteQuadsCanonicalizer  _parent  [TYPE]  AtomicReference  _tableInfo  [TYPE]  int[]  _hashArea  mainHash  [TYPE]  String[]  _names  names  [TYPE]  int  DEFAULT_T_SIZE  MAX_ENTRIES_FOR_REUSE  MAX_T_SIZE  MIN_HASH_SIZE  MULT  MULT2  MULT3  _count  _hashSize  _longNameOffset  _secondaryStart  _seed  _spilloverEnd  _tertiaryShift  _tertiaryStart  count  hash  longNameOffset  q1  size  spilloverEnd  tertiaryShift  [CONTEXT]  public  int  calcHash  (  int  q1  )  {  int  hash  =  q1  ^  _seed  ;      hash  +  =  (  hash  >>>  16  )  ;  //  to  xor  hi-  and  low-  16-bits  [BUGGY]  hash  ^  =  (  hash  >>>  12  )  ;  return  hash  ;  }  	JacksonCore_10_ByteQuadsCanonicalizer_2_2	984	1	src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java
1066	_verifyNeedForRehash();  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  512  assertEquals  (  50  ,  syms  .  size  (  )  )  ;  [METHOD]  _verifySharing  [TYPE]  void  [PARAMETER]  [CLASS]  ByteQuadsCanonicalizer  [TYPE]  boolean  _failOnDoS  _hashShared  _intern  _needRehash  false  true  [TYPE]  ByteQuadsCanonicalizer  _parent  [TYPE]  AtomicReference  _tableInfo  [TYPE]  int[]  _hashArea  mainHash  [TYPE]  String[]  _names  names  [TYPE]  int  DEFAULT_T_SIZE  MAX_ENTRIES_FOR_REUSE  MAX_T_SIZE  MIN_HASH_SIZE  MULT  MULT2  MULT3  _count  _hashSize  _longNameOffset  _secondaryStart  _seed  _spilloverEnd  _tertiaryShift  _tertiaryStart  count  longNameOffset  size  spilloverEnd  tertiaryShift  [CONTEXT]  private  void  _verifySharing  (  )  {  if  (  _hashShared  )  {  _hashArea  =  Arrays  .  copyOf  (  _hashArea  ,  _hashArea  .  length  )  ;  _names  =  Arrays  .  copyOf  (  _names  ,  _names  .  length  )  ;  _hashShared  =  false  ;    [BUGGY]  }  if  (  _needRehash  )  {  rehash  (  )  ;  }  }  	JacksonCore_11_ByteQuadsCanonicalizer_1_1	882	0	src/main/java/com/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer.java
1067		[BUGGY]  _updateLocation  (  )  ;  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  nextToken  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  inObject  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  JsonToken  t  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  String  name  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  i  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  _binaryValue  =  null  ;    if  (  i  =  =  INT_RBRACKET  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inArray  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  '}'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  return  (  _currToken  =  JsonToken  .  END_ARRAY  )  ;  }  if  (  i  =  =  INT_RCURLY  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  ']'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  return  (  _currToken  =  JsonToken  .  END_OBJECT  )  ;  }  if  (  _parsingContext  .  expectComma  (  )  )  {  i  =  _skipComma  (  i  )  ;  }  [BUGGY]  _updateLocation  (  )  ;      boolean  inObject  =  _parsingContext  .  inObject  (  )  ;  	JacksonCore_12_ReaderBasedJsonParser_11_1	622	1	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1068	_updateNameLocation();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  nextToken  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  inObject  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  JsonToken  t  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  String  name  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  i  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  return  (  _currToken  =  JsonToken  .  END_ARRAY  )  ;  }  if  (  i  =  =  INT_RCURLY  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  ']'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  return  (  _currToken  =  JsonToken  .  END_OBJECT  )  ;  }  if  (  _parsingContext  .  expectComma  (  )  )  {  i  =  _skipComma  (  i  )  ;  }  _updateLocation  (  )  ;      boolean  inObject  =  _parsingContext  .  inObject  (  )  ;  if  (  inObject  )  {  [BUGGY]  String  name  =  (  i  =  =  INT_QUOTE  )  ?  _parseName  (  )  :  _handleOddName  (  i  )  ;  _parsingContext  .  setCurrentName  (  name  )  ;  _currToken  =  JsonToken  .  FIELD_NAME  ;  i  =  _skipColon  (  )  ;  }  	JacksonCore_12_ReaderBasedJsonParser_11_2	630	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1069	_updateLocation();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  nextToken  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  inObject  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  JsonToken  t  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  String  name  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  i  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  ']'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  return  (  _currToken  =  JsonToken  .  END_OBJECT  )  ;  }  if  (  _parsingContext  .  expectComma  (  )  )  {  i  =  _skipComma  (  i  )  ;  }  _updateLocation  (  )  ;      boolean  inObject  =  _parsingContext  .  inObject  (  )  ;  if  (  inObject  )  {  String  name  =  (  i  =  =  INT_QUOTE  )  ?  _parseName  (  )  :  _handleOddName  (  i  )  ;  _parsingContext  .  setCurrentName  (  name  )  ;  _currToken  =  JsonToken  .  FIELD_NAME  ;  i  =  _skipColon  (  )  ;  }  [BUGGY]    JsonToken  t  ;  switch  (  i  )  {  	JacksonCore_12_ReaderBasedJsonParser_11_3	635	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1070	_updateLocation();  	[BUGGY]  _updateLocation  (  )  ;  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  nextFieldName  [TYPE]  boolean  [PARAMETER]  SerializableString  sstr  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  SerializableString  sstr  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  end  i  len  offset  ptr  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  nameChars  [CONTEXT]  return  false  ;  }  _binaryValue  =  null  ;  if  (  i  =  =  INT_RBRACKET  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inArray  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  '}'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_ARRAY  ;  return  false  ;  }  if  (  i  =  =  INT_RCURLY  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  ']'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_OBJECT  ;  return  false  ;  }  if  (  _parsingContext  .  expectComma  (  )  )  {  i  =  _skipComma  (  i  )  ;  }  [BUGGY]  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _nextTokenNotInObject  (  i  )  ;  return  false  ;  }  	JacksonCore_12_ReaderBasedJsonParser_11_4	773	1	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1071	_updateNameLocation();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  nextFieldName  [TYPE]  boolean  [PARAMETER]  SerializableString  sstr  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  SerializableString  sstr  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  end  i  len  offset  ptr  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  nameChars  [CONTEXT]  _reportMismatchedEndMarker  (  i  ,  '}'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_ARRAY  ;  return  false  ;  }  if  (  i  =  =  INT_RCURLY  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  ']'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_OBJECT  ;  return  false  ;  }  if  (  _parsingContext  .  expectComma  (  )  )  {  i  =  _skipComma  (  i  )  ;  }  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _nextTokenNotInObject  (  i  )  ;  return  false  ;  }  [BUGGY]  if  (  i  =  =  INT_QUOTE  )  {  char[]  nameChars  =  sstr  .  asQuotedChars  (  )  ;  final  int  len  =  nameChars  .  length  ;    	JacksonCore_12_ReaderBasedJsonParser_11_5	780	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1072	_updateLocation();  	[BUGGY]  _updateLocation  (  )  ;  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  nextFieldName  [TYPE]  String  [PARAMETER]  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  JsonToken  t  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  String  name  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  i  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  _currToken  =  null  ;  return  null  ;  }  _binaryValue  =  null  ;  if  (  i  =  =  INT_RBRACKET  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inArray  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  '}'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_ARRAY  ;  return  null  ;  }  if  (  i  =  =  INT_RCURLY  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  ']'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_OBJECT  ;  return  null  ;  }  if  (  _parsingContext  .  expectComma  (  )  )  {  i  =  _skipComma  (  i  )  ;  }  [BUGGY]  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _nextTokenNotInObject  (  i  )  ;  return  null  ;  }  	JacksonCore_12_ReaderBasedJsonParser_11_6	851	1	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1073	_updateNameLocation();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  nextFieldName  [TYPE]  String  [PARAMETER]  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  JsonToken  t  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  String  name  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  i  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  if  (  !_parsingContext  .  inArray  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  '}'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_ARRAY  ;  return  null  ;  }  if  (  i  =  =  INT_RCURLY  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  ']'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_OBJECT  ;  return  null  ;  }  if  (  _parsingContext  .  expectComma  (  )  )  {  i  =  _skipComma  (  i  )  ;  }  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _nextTokenNotInObject  (  i  )  ;  return  null  ;  }  [BUGGY]  String  name  =  (  i  =  =  INT_QUOTE  )  ?  _parseName  (  )  :  _handleOddName  (  i  )  ;  _parsingContext  .  setCurrentName  (  name  )  ;  _currToken  =  JsonToken  .  FIELD_NAME  ;  i  =  _skipColon  (  )  ;  if  (  i  =  =  INT_QUOTE  )  {  	JacksonCore_12_ReaderBasedJsonParser_11_7	857	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1074	_updateLocation();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  nextFieldName  [TYPE]  String  [PARAMETER]  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  JsonToken  t  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  String  name  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  i  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  return  null  ;  }  if  (  i  =  =  INT_RCURLY  )  {  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _reportMismatchedEndMarker  (  i  ,  ']'  )  ;  }  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _currToken  =  JsonToken  .  END_OBJECT  ;  return  null  ;  }  if  (  _parsingContext  .  expectComma  (  )  )  {  i  =  _skipComma  (  i  )  ;  }  _updateLocation  (  )  ;  if  (  !_parsingContext  .  inObject  (  )  )  {  _nextTokenNotInObject  (  i  )  ;  return  null  ;  }  String  name  =  (  i  =  =  INT_QUOTE  )  ?  _parseName  (  )  :  _handleOddName  (  i  )  ;  _parsingContext  .  setCurrentName  (  name  )  ;  _currToken  =  JsonToken  .  FIELD_NAME  ;  i  =  _skipColon  (  )  ;  [BUGGY]  if  (  i  =  =  INT_QUOTE  )  {  _tokenIncomplete  =  true  ;  _nextToken  =  JsonToken  .  VALUE_STRING  ;  return  name  ;  }  	JacksonCore_12_ReaderBasedJsonParser_11_8	862	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1075	_updateLocation();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  _isNextTokenNameYes  [TYPE]  void  [PARAMETER]  int  i  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  i  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  private  final  void  _isNextTokenNameYes  (  int  i  )  throws  IOException  {  _currToken  =  JsonToken  .  FIELD_NAME  ;  [BUGGY]  switch  (  i  )  {  case  ' "':  _tokenIncomplete  =  true  ;  _nextToken  =  JsonToken  .  VALUE_STRING  ;  return  ;  	JacksonCore_12_ReaderBasedJsonParser_11_9	917	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1076	_updateLocation();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  _isNextTokenNameMaybe  [TYPE]  boolean  [PARAMETER]  int  i  String  nameToMatch  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  JsonToken  t  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  String  name  nameToMatch  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  i  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  protected  boolean  _isNextTokenNameMaybe  (  int  i  ,  String  nameToMatch  )  throws  IOException  {  String  name  =  (  i  =  =  INT_QUOTE  )  ?  _parseName  (  )  :  _handleOddName  (  i  )  ;  _parsingContext  .  setCurrentName  (  name  )  ;  _currToken  =  JsonToken  .  FIELD_NAME  ;  i  =  _skipColon  (  )  ;  [BUGGY]  if  (  i  =  =  INT_QUOTE  )  {  _tokenIncomplete  =  true  ;  _nextToken  =  JsonToken  .  VALUE_STRING  ;  return  nameToMatch  .  equals  (  name  )  ;  }  	JacksonCore_12_ReaderBasedJsonParser_11_10	967	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1077	if  (_currToken  ==  JsonToken.FIELD_NAME)  {  return  new  JsonLocation(src,  -1L,  _nameInputTotal,  _nameInputRow,  _tokenInputCol);  }  -1L,  _tokenInputTotal,  _tokenInputRow,  	[BUGGY]  -1L  ,  getTokenCharacterOffset  (  )  ,  getTokenLineNr  (  )  ,  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  getTokenLocation  [TYPE]  JsonLocation  [PARAMETER]  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  Object  src  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  _hashSeed  _nameInputCol  _nameInputRow  [TYPE]  long  _nameInputTotal  [TYPE]  char[]  _inputBuffer  [CONTEXT]  public  JsonLocation  getTokenLocation  (  )  {  final  Object  src  =  _ioContext  .  getSourceReference  (  )  ;  [BUGGY]  return  new  JsonLocation  (  src  ,  -1L  ,  getTokenCharacterOffset  (  )  ,  getTokenLineNr  (  )  ,  getTokenColumnNr  (  )  )  ;  }  	JacksonCore_12_ReaderBasedJsonParser_11_11	2671	2	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1078	_tokenInputTotal,  -1L,  _tokenInputRow,  	[BUGGY]  getTokenCharacterOffset  (  )  ,  -1L  ,  getTokenLineNr  (  )  ,  [FE]  AssertionFailedError:  expected:<6>  but  was:<1>  assertEquals  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  getTokenLocation  [TYPE]  JsonLocation  [PARAMETER]  [CLASS]  UTF8StreamJsonParser  [TYPE]  byte[]  _inputBuffer  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  byte  BYTE_LF  [TYPE]  InputStream  _inputStream  [TYPE]  ByteQuadsCanonicalizer  _symbols  [TYPE]  int[]  _icLatin1  _icUTF8  _quadBuffer  [TYPE]  Object  src  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  int  _nameInputCol  _nameInputRow  _quad1  [TYPE]  long  _nameInputTotal  [CONTEXT]  public  JsonLocation  getTokenLocation  (  )  {  final  Object  src  =  _ioContext  .  getSourceReference  (  )  ;  if  (  _currToken  =  =  JsonToken  .  FIELD_NAME  )  {  return  new  JsonLocation  (  src  ,  _nameInputTotal  ,  -1L  ,  _nameInputRow  ,  _tokenInputCol  )  ;  }  return  new  JsonLocation  (  src  ,  [BUGGY]  getTokenCharacterOffset  (  )  ,  -1L  ,  getTokenLineNr  (  )  ,  getTokenColumnNr  (  )  )  ;  }  	JacksonCore_12_UTF8StreamJsonParser_1_1	3622	1	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1079	@Override  public  JsonGenerator  disable(Feature  f)  {  super.disable(f);  if  (f  ==  Feature.QUOTE_FIELD_NAMES)  {  _cfgUnqNames  =  true;  }  return  this;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[foo]:1}>  but  was:<{[ "foo "]:1}>  assertEquals  (   "{\ "double\ ":NaN}  {\ "float\ ":NaN} "  ,  result  )  ;  [CLASS]  [CONTEXT]  	JacksonCore_13_JsonGeneratorImpl_1_1	127	0	src/main/java/com/fasterxml/jackson/core/json/JsonGeneratorImpl.java
1080	if  ((toRelease  !=  src)  &&  (toRelease.length  <  src.length))  {  throw  wrongBuf();  }  	[BUGGY]  if  (  (  toRelease  !  =  src  )  &&  (  toRelease  .  length  <  =  src  .  length  )  )  {  throw  wrongBuf  (  )  ;  }  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [smaller  than  original]  )  :  got  one  with  message   "Trying  to  release  buffer  not  owned  by  the  context "  assertNotNull  (  ctxt  .  allocNameCopyBuffer  (  100  )  )  ;  [METHOD]  _verifyRelease  [TYPE]  void  [PARAMETER]  byte[]  toRelease  byte[]  src  [CLASS]  IOContext  [TYPE]  byte[]  _base64Buffer  _readIOBuffer  _writeEncodingBuffer  src  toRelease  [TYPE]  boolean  _managedResource  false  true  [TYPE]  JsonEncoding  _encoding  [TYPE]  BufferRecycler  _bufferRecycler  [TYPE]  Object  _sourceRef  [TYPE]  char[]  _concatCBuffer  _nameCopyBuffer  _tokenCBuffer  [CONTEXT]  protected  final  void  _verifyRelease  (  byte[]  toRelease  ,  byte[]  src  )  {  [BUGGY]  if  (  (  toRelease  !  =  src  )  &&  (  toRelease  .  length  <  =  src  .  length  )  )  {  throw  wrongBuf  (  )  ;  }  }  	JacksonCore_14_IOContext_3_1	274	1	src/main/java/com/fasterxml/jackson/core/io/IOContext.java
1081	if  ((toRelease  !=  src)  &&  (toRelease.length  <  src.length))  {  throw  wrongBuf();  }  	[BUGGY]  if  (  (  toRelease  !  =  src  )  &&  (  toRelease  .  length  <  =  src  .  length  )  )  {  throw  wrongBuf  (  )  ;  }  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [smaller  than  original]  )  :  got  one  with  message   "Trying  to  release  buffer  not  owned  by  the  context "  assertNotNull  (  ctxt  .  allocNameCopyBuffer  (  100  )  )  ;  [METHOD]  _verifyRelease  [TYPE]  void  [PARAMETER]  char[]  toRelease  char[]  src  [CLASS]  IOContext  [TYPE]  byte[]  _base64Buffer  _readIOBuffer  _writeEncodingBuffer  [TYPE]  boolean  _managedResource  false  true  [TYPE]  JsonEncoding  _encoding  [TYPE]  BufferRecycler  _bufferRecycler  [TYPE]  Object  _sourceRef  [TYPE]  char[]  _concatCBuffer  _nameCopyBuffer  _tokenCBuffer  src  toRelease  [CONTEXT]  protected  final  void  _verifyRelease  (  char[]  toRelease  ,  char[]  src  )  {  [BUGGY]  if  (  (  toRelease  !  =  src  )  &&  (  toRelease  .  length  <  =  src  .  length  )  )  {  throw  wrongBuf  (  )  ;  }  }  	JacksonCore_14_IOContext_3_2	279	1	src/main/java/com/fasterxml/jackson/core/io/IOContext.java
1082	return  new  IllegalArgumentException( "Trying  to  release  buffer  smaller  than  original ");  	[BUGGY]  return  new  IllegalArgumentException  (   "Trying  to  release  buffer  not  owned  by  the  context "  )  ;  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [smaller  than  original]  )  :  got  one  with  message   "Trying  to  release  buffer  not  owned  by  the  context "  assertNotNull  (  ctxt  .  allocNameCopyBuffer  (  100  )  )  ;  [METHOD]  wrongBuf  [TYPE]  IllegalArgumentException  [PARAMETER]  [CLASS]  IOContext  [TYPE]  byte[]  _base64Buffer  _readIOBuffer  _writeEncodingBuffer  [TYPE]  boolean  _managedResource  false  true  [TYPE]  JsonEncoding  _encoding  [TYPE]  BufferRecycler  _bufferRecycler  [TYPE]  Object  _sourceRef  [TYPE]  char[]  _concatCBuffer  _nameCopyBuffer  _tokenCBuffer  [CONTEXT]  private  IllegalArgumentException  wrongBuf  (  )  {  [BUGGY]  return  new  IllegalArgumentException  (   "Trying  to  release  buffer  not  owned  by  the  context "  )  ;  }  	JacksonCore_14_IOContext_3_3	284	1	src/main/java/com/fasterxml/jackson/core/io/IOContext.java
1083	\tif(!_allowMultipleMatches  &&  _currToken  !=  null  &&  _exposedContext  ==  null){  \t\tif((_currToken.isStructEnd()    &&  _headContext.isStartHandled())  ){  \t\t\treturn  (_currToken  =  null);  \t\t}  \t\telse  if(_currToken.isScalarValue()  &&  !_headContext.isStartHandled()  &&  !_includePath  \t\t\t\t&&  _itemFilter  ==  TokenFilter.INCLUDE_ALL)  {  \t\t\treturn  (_currToken  =  null);  \t\t}  \t}  	[BUGGY]  [FE]  ComparisonFailure:  expected:<3[]>  but  was:<3[  4]>  assertEquals  (  aposToQuotes  (   "3 "  )  ,  result  )  ;  [METHOD]  nextToken  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  ctxt  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  public  JsonToken  nextToken  (  )  throws  IOException  {    [BUGGY]      TokenFilterContext  ctxt  =  _exposedContext  ;  	JacksonCore_15_FilteringParserDelegate_1_1	227	0	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1084	protected  boolean  _suppressNextToken;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (  3  ,  seq  .  getIntValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonCore_16_JsonParserSequence_3_1	35	0	src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java
1085	_suppressNextToken  =  delegate.hasCurrentToken();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (  3  ,  seq  .  getIntValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonCore_16_JsonParserSequence_3_2	45	0	src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java
1086	public  JsonToken  nextToken()  throws  IOException  if  (delegate  ==  null)  {  return  null;  }  if  (_suppressNextToken)  {  _suppressNextToken  =  false;  return  delegate.currentToken();  }  while  ((t  ==  null)  &&  switchToNext())  {  t  =  delegate.hasCurrentToken()  ?  delegate.currentToken()  :  delegate.nextToken();  return  t;  	[BUGGY]  public  JsonToken  nextToken  (  )  throws  IOException  ,  JsonParseException  if  (  t  !  =  null  )  return  t  ;  while  (  switchToNext  (  )  )  {  t  =  delegate  .  nextToken  (  )  ;  if  (  t  !  =  null  )  return  t  ;  return  null  ;  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (  3  ,  seq  .  getIntValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonCore_16_JsonParserSequence_3_3	104	6	src/main/java/com/fasterxml/jackson/core/util/JsonParserSequence.java
1087	if  (len  <=  buf.length)  {  text.getChars(offset,  offset+len,  buf,  0);  _writeRawSegment(buf,  0,  len);  return;  }  	[BUGGY]  [FE]  jacksoncoreJsonGenerationException:  Split  surrogate  on  writeRaw  (  )  input  (  last  character  )  [METHOD]  writeRaw  [TYPE]  void  [PARAMETER]  String  text  int  offset  int  len  [CLASS]  UTF8JsonGenerator  [TYPE]  byte[]  FALSE_BYTES  HEX_CHARS  NULL_BYTES  TRUE_BYTES  _entityBuffer  _outputBuffer  [TYPE]  boolean  _bufferRecyclable  false  true  [TYPE]  byte  BYTE_0  BYTE_BACKSLASH  BYTE_COLON  BYTE_COMMA  BYTE_LBRACKET  BYTE_LCURLY  BYTE_QUOTE  BYTE_RBRACKET  BYTE_RCURLY  BYTE_u  [TYPE]  OutputStream  _outputStream  [TYPE]  String  text  [TYPE]  int  MAX_BYTES_TO_BUFFER  _charBufferLength  _outputEnd  _outputMaxContiguous  _outputTail  len  len2  offset  [TYPE]  char[]  _charBuffer  buf  [CONTEXT]  public  void  writeRaw  (  String  text  ,  int  offset  ,  int  len  )  throws  IOException  {  final  char[]  buf  =  _charBuffer  ;    [BUGGY]      while  (  len  >  0  )  {  int  len2  =  Math  .  min  (  buf  .  length  ,  len  )  ;  text  .  getChars  (  offset  ,  offset+len2  ,  buf  ,  0  )  ;  writeRaw  (  buf  ,  0  ,  len2  )  ;    offset  +  =  len2  ;  len  -  =  len2  ;  }  }  	JacksonCore_17_UTF8JsonGenerator_4_1	528	0	src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java
1088	final  int  maxChunk  =  (_outputEnd  >>  2)  +  (_outputEnd  >>  4);    final  int  maxBytes  =  maxChunk  *  3;  int  len2  =  Math.min(maxChunk,  len);  if  ((_outputTail  +  maxBytes)  >  _outputEnd)  {  _flushBuffer();  }  if  (len  >  0)  {  char  ch  =  buf[len2-1];  if  ((ch  >=  SURR1_FIRST)  &&  (ch  <=  SURR1_LAST))  {  --len2;  }  }  _writeRawSegment(buf,  0,  len2);  	[BUGGY]  int  len2  =  Math  .  min  (  buf  .  length  ,  len  )  ;  writeRaw  (  buf  ,  0  ,  len2  )  ;  [FE]  jacksoncoreJsonGenerationException:  Split  surrogate  on  writeRaw  (  )  input  (  last  character  )  [METHOD]  writeRaw  [TYPE]  void  [PARAMETER]  String  text  int  offset  int  len  [CLASS]  UTF8JsonGenerator  [TYPE]  byte[]  FALSE_BYTES  HEX_CHARS  NULL_BYTES  TRUE_BYTES  _entityBuffer  _outputBuffer  [TYPE]  boolean  _bufferRecyclable  false  true  [TYPE]  byte  BYTE_0  BYTE_BACKSLASH  BYTE_COLON  BYTE_COMMA  BYTE_LBRACKET  BYTE_LCURLY  BYTE_QUOTE  BYTE_RBRACKET  BYTE_RCURLY  BYTE_u  [TYPE]  OutputStream  _outputStream  [TYPE]  String  text  [TYPE]  int  MAX_BYTES_TO_BUFFER  _charBufferLength  _outputEnd  _outputMaxContiguous  _outputTail  len  len2  offset  [TYPE]  char[]  _charBuffer  buf  [CONTEXT]  public  void  writeRaw  (  String  text  ,  int  offset  ,  int  len  )  throws  IOException  {  final  char[]  buf  =  _charBuffer  ;      [BUGGY]  while  (  len  >  0  )  {  int  len2  =  Math  .  min  (  buf  .  length  ,  len  )  ;  text  .  getChars  (  offset  ,  offset+len2  ,  buf  ,  0  )  ;  writeRaw  (  buf  ,  0  ,  len2  )  ;    offset  +  =  len2  ;  len  -  =  len2  ;  }  }  	JacksonCore_17_UTF8JsonGenerator_4_2	532	2	src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java
1089	private  void  _writeRawSegment(char[]  cbuf,  int  offset,  int  end)  throws  IOException  {  main_loop:  while  (offset  <  end)  {  inner_loop:  while  (true)  {  int  ch  =  (int)  cbuf[offset];  if  (ch  >  0x7F)  {  break  inner_loop;  }  _outputBuffer[_outputTail++]  =  (byte)  ch;  if  (++offset  >=  end)  {  break  main_loop;  }  }  char  ch  =  cbuf[offset++];  if  (ch  <  0x800)  {    _outputBuffer[_outputTail++]  =  (byte)  (0xc0  |  (ch  >>  6));  _outputBuffer[_outputTail++]  =  (byte)  (0x80  |  (ch  &  0x3f));  }  else  {  offset  =  _outputRawMultiByteChar(ch,  cbuf,  offset,  end);  }  }  }  	[BUGGY]  [FE]  jacksoncoreJsonGenerationException:  Split  surrogate  on  writeRaw  (  )  input  (  last  character  )    [CLASS]  [CONTEXT]  	JacksonCore_17_UTF8JsonGenerator_4_3	672	0	src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java
1090	_reportError(String.format(   "Split  surrogate  on  writeRaw()  input  (last  character):  first  character  0x%4x ",  ch));  	[BUGGY]  _reportError  (   "Split  surrogate  on  writeRaw  (  )  input  (  last  character  )   "  )  ;  [FE]  jacksoncoreJsonGenerationException:  Split  surrogate  on  writeRaw  (  )  input  (  last  character  )  [METHOD]  _outputRawMultiByteChar  [TYPE]  int  [PARAMETER]  int  ch  char[]  cbuf  int  inputOffset  int  inputEnd  [CLASS]  UTF8JsonGenerator  [TYPE]  byte[]  FALSE_BYTES  HEX_CHARS  NULL_BYTES  TRUE_BYTES  _entityBuffer  _outputBuffer  bbuf  [TYPE]  boolean  _bufferRecyclable  false  true  [TYPE]  byte  BYTE_0  BYTE_BACKSLASH  BYTE_COLON  BYTE_COMMA  BYTE_LBRACKET  BYTE_LCURLY  BYTE_QUOTE  BYTE_RBRACKET  BYTE_RCURLY  BYTE_u  [TYPE]  OutputStream  _outputStream  [TYPE]  int  MAX_BYTES_TO_BUFFER  _charBufferLength  _outputEnd  _outputMaxContiguous  _outputTail  ch  inputEnd  inputOffset  [TYPE]  char[]  _charBuffer  cbuf  [CONTEXT]  private  final  int  _outputRawMultiByteChar  (  int  ch  ,  char[]  cbuf  ,  int  inputOffset  ,  int  inputEnd  )  throws  IOException  {  if  (  ch  >  =  SURR1_FIRST  )  {  if  (  ch  <  =  SURR2_LAST  )  {  //  yes  ,  outside  of  BMP  if  (  inputOffset  >  =  inputEnd  ||  cbuf  =  =  null  )  {  //  nope  .  .  .  have  to  note  down  [BUGGY]  _reportError  (   "Split  surrogate  on  writeRaw  (  )  input  (  last  character  )   "  )  ;  }  _outputSurrogates  (  ch  ,  cbuf[inputOffset]  )  ;  return  inputOffset+1  ;  }  }  final  byte[]  bbuf  =  _outputBuffer  ;  bbuf[_outputTail++]  =  (  byte  )    (  0xe0  |  (  ch  >>  12  )  )  ;  bbuf[_outputTail++]  =  (  byte  )    (  0x80  |  (  (  ch  >>  6  )  &  0x3f  )  )  ;  bbuf[_outputTail++]  =  (  byte  )    (  0x80  |  (  ch  &  0x3f  )  )  ;  return  inputOffset  ;  }  	JacksonCore_17_UTF8JsonGenerator_4_4	1887	1	src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java
1091	protected  final  static  int  MAX_BIG_DECIMAL_SCALE  =  9999;  	[BUGGY]  [FE]  AssertionFailedError:  Should  not  have  written  without  exception:  1E+10000  [CLASS]  [CONTEXT]  	JacksonCore_18_GeneratorBase_2_1	53	0	src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java
1092	if  (Feature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_features))  {  int  scale  =  value.scale();  if  ((scale  <  -MAX_BIG_DECIMAL_SCALE)  ||  (scale  >  MAX_BIG_DECIMAL_SCALE))  {  _reportError(String.format(   "Attempt  to  write  plain  `java.math.BigDecimal`  (see  JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)  with  illegal  scale  (%d):  needs  to  be  between  [-%d,  %d] ",  scale,  MAX_BIG_DECIMAL_SCALE,  MAX_BIG_DECIMAL_SCALE));  }  return  value.toPlainString();  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  not  have  written  without  exception:  1E+10000  [METHOD]  _asString  [TYPE]  String  [PARAMETER]  BigDecimal  value  [CLASS]  GeneratorBase  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  boolean  _cfgNumbersAsStrings  _closed  false  true  [TYPE]  String  WRITE_BINARY  WRITE_BOOLEAN  WRITE_NULL  WRITE_NUMBER  WRITE_RAW  WRITE_STRING  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  int  DERIVED_FEATURES_MASK  SURR1_FIRST  SURR1_LAST  SURR2_FIRST  SURR2_LAST  _features  [TYPE]  BigDecimal  value  [CONTEXT]  protected  String  _asString  (  BigDecimal  value  )  throws  IOException  {  [BUGGY]  return  value  .  toString  (  )  ;  }  	JacksonCore_18_GeneratorBase_2_2	434	0	src/main/java/com/fasterxml/jackson/core/base/GeneratorBase.java
1093	_writeQuotedRaw(_asString(value));  	[BUGGY]  String  raw  =  Feature  .  WRITE_BIGDECIMAL_AS_PLAIN  .  enabledIn  (  _features  )  ?  value  .  toPlainString  (  )  :  value  .  toString  (  )  ;  _writeQuotedRaw  (  raw  )  ;  }  else  if  (  Feature  .  WRITE_BIGDECIMAL_AS_PLAIN  .  enabledIn  (  _features  )  )  {  writeRaw  (  value  .  toPlainString  (  )  )  ;  [FE]  AssertionFailedError:  Should  not  have  written  without  exception:  1E+10000  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  BigDecimal  value  [CLASS]  UTF8JsonGenerator  [TYPE]  byte[]  FALSE_BYTES  HEX_CHARS  NULL_BYTES  TRUE_BYTES  _entityBuffer  _outputBuffer  [TYPE]  boolean  _bufferRecyclable  false  true  [TYPE]  byte  BYTE_0  BYTE_BACKSLASH  BYTE_COLON  BYTE_COMMA  BYTE_LBRACKET  BYTE_LCURLY  BYTE_QUOTE  BYTE_RBRACKET  BYTE_RCURLY  BYTE_u  [TYPE]  OutputStream  _outputStream  [TYPE]  String  raw  [TYPE]  int  MAX_BYTES_TO_BUFFER  _charBufferLength  _outputEnd  _outputMaxContiguous  _outputTail  [TYPE]  BigDecimal  value  [TYPE]  char[]  _charBuffer  [CONTEXT]  public  void  writeNumber  (  BigDecimal  value  )  throws  IOException  {  _verifyValueWrite  (  WRITE_NUMBER  )  ;  if  (  value  =  =  null  )  {  _writeNull  (  )  ;  }  elseif  (  _cfgNumbersAsStrings  )  {  [BUGGY]  String  raw  =  Feature  .  WRITE_BIGDECIMAL_AS_PLAIN  .  enabledIn  (  _features  )  ?  value  .  toPlainString  (  )  :  value  .  toString  (  )  ;  _writeQuotedRaw  (  raw  )  ;  }  else  if  (  Feature  .  WRITE_BIGDECIMAL_AS_PLAIN  .  enabledIn  (  _features  )  )  {  writeRaw  (  value  .  toPlainString  (  )  )  ;  }  else  {  writeRaw  (  _asString  (  value  )  )  ;  }  }  	JacksonCore_18_UTF8JsonGenerator_1_1	910	4	src/main/java/com/fasterxml/jackson/core/json/UTF8JsonGenerator.java
1094	_writeQuotedRaw(_asString(value));  	[BUGGY]  String  raw  =  isEnabled  (  Feature  .  WRITE_BIGDECIMAL_AS_PLAIN  )  ?  value  .  toPlainString  (  )  :  value  .  toString  (  )  ;  _writeQuotedRaw  (  raw  )  ;  }  else  if  (  isEnabled  (  Feature  .  WRITE_BIGDECIMAL_AS_PLAIN  )  )  {  writeRaw  (  value  .  toPlainString  (  )  )  ;  [FE]  AssertionFailedError:  Should  not  have  written  without  exception:  1E+10000  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  BigDecimal  value  [CLASS]  WriterBasedJsonGenerator  [TYPE]  SerializableString  _currentEscape  [TYPE]  boolean  false  true  [TYPE]  String  raw  [TYPE]  int  SHORT_WRITE  _outputEnd  _outputHead  _outputTail  [TYPE]  Writer  _writer  [TYPE]  BigDecimal  value  [TYPE]  char[]  HEX_CHARS  _entityBuffer  _outputBuffer  [CONTEXT]  public  void  writeNumber  (  BigDecimal  value  )  throws  IOException  {  _verifyValueWrite  (  WRITE_NUMBER  )  ;  if  (  value  =  =  null  )  {  _writeNull  (  )  ;  }  elseif  (  _cfgNumbersAsStrings  )  {  [BUGGY]  String  raw  =  isEnabled  (  Feature  .  WRITE_BIGDECIMAL_AS_PLAIN  )  ?  value  .  toPlainString  (  )  :  value  .  toString  (  )  ;  _writeQuotedRaw  (  raw  )  ;  }  else  if  (  isEnabled  (  Feature  .  WRITE_BIGDECIMAL_AS_PLAIN  )  )  {  writeRaw  (  value  .  toPlainString  (  )  )  ;  }  else  {  writeRaw  (  _asString  (  value  )  )  ;  }  }  	JacksonCore_18_WriterBasedJsonGenerator_1_1	687	4	src/main/java/com/fasterxml/jackson/core/json/WriterBasedJsonGenerator.java
1095	outBuf  =  _textBuffer.finishCurrentSegment();  outPtr  =  0;  }  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  200  assertNull  (  p  .  nextToken  (  )  )  ;  [METHOD]  _parseNumber2  [TYPE]  JsonToken  [PARAMETER]  boolean  neg  int  startPtr  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  eof  false  neg  true  [TYPE]  char  c  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  _hashSeed  _nameStartCol  _nameStartRow  expLen  fractLen  intLen  outPtr  startPtr  [TYPE]  long  _nameStartOffset  [TYPE]  char[]  _inputBuffer  outBuf  [CONTEXT]  int_loop:  while  (  c  >  =  '0'  &&  c  <  =  '9'  )  {  ++intLen  ;  if  (  outPtr  >  =  outBuf  .  length  )  {  outBuf  =  _textBuffer  .  finishCurrentSegment  (  )  ;  outPtr  =  0  ;  }  outBuf[outPtr++]  =  c  ;  if  (  _inputPtr  >  =  _inputEnd  &&  !loadMore  (  )  )  {  c  =  CHAR_NULL  ;  eof  =  true  ;  break  int_loop  ;  }  c  =  _inputBuffer[_inputPtr++]  ;  }  if  (  intLen  =  =  0  )  {  return  _handleInvalidNumberStart  (  c  ,  neg  )  ;  }  int  fractLen  =  0  ;  if  (  c  =  =  '  .  '  )  {  //  yes  ,  fraction  [BUGGY]  outBuf[outPtr++]  =  c  ;  fract_loop:  while  (  true  )  {  if  (  _inputPtr  >  =  _inputEnd  &&  !loadMore  (  )  )  {  eof  =  true  ;  	JacksonCore_19_ReaderBasedJsonParser_1_1	1418	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1096	if  (outPtr  >=  outBuf.length)  {  outBuf  =  _textBuffer.finishCurrentSegment();  outPtr  =  0;  }  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  200  assertNull  (  p  .  nextToken  (  )  )  ;  [METHOD]  _parseFloat  [TYPE]  JsonToken  [PARAMETER]  char[]  outBuf  int  outPtr  int  c  boolean  negative  int  integerPartLength  [CLASS]  UTF8StreamJsonParser  [TYPE]  byte[]  _inputBuffer  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  eof  false  negative  true  [TYPE]  byte  BYTE_LF  [TYPE]  InputStream  _inputStream  [TYPE]  ByteQuadsCanonicalizer  _symbols  [TYPE]  int[]  _icLatin1  _icUTF8  _quadBuffer  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  int  _nameStartCol  _nameStartOffset  _nameStartRow  _quad1  c  expLen  fractLen  integerPartLength  outPtr  [TYPE]  char[]  outBuf  [CONTEXT]  private  final  JsonToken  _parseFloat  (  char[]  outBuf  ,  int  outPtr  ,  int  c  ,  boolean  negative  ,  int  integerPartLength  )  throws  IOException  {  int  fractLen  =  0  ;  boolean  eof  =  false  ;    if  (  c  =  =  INT_PERIOD  )  {  //  yes  ,  fraction  [BUGGY]  outBuf[outPtr++]  =  (  char  )  c  ;  fract_loop:  while  (  true  )  {  if  (  _inputPtr  >  =  _inputEnd  &&  !loadMore  (  )  )  {  eof  =  true  ;  	JacksonCore_19_UTF8StreamJsonParser_1_1	1544	0	src/main/java/com/fasterxml/jackson/core/json/UTF8StreamJsonParser.java
1097	if  (object  ==  null)  {  writeNull();  return;  }  if  (object  instanceof  byte[])  {  writeBinary((byte[])  object);  return;  }  throw  new  JsonGenerationException( "No  native  support  for  writing  embedded  objects  of  type   "  +object.getClass().getName(),  	[BUGGY]  throw  new  JsonGenerationException  (   "No  native  support  for  writing  embedded  objects "  ,  [FE]  jacksoncoreJsonGenerationException:  No  native  support  for  writing  embedded  objects  assertEquals  (  EXP_OUTPUT  ,  JSON  )  ;  [METHOD]  writeEmbeddedObject  [TYPE]  void  [PARAMETER]  Object  object  [CLASS]  JsonGenerator  [TYPE]  PrettyPrinter  _cfgPrettyPrinter  [TYPE]  Object  object  [TYPE]  boolean  _defaultState  false  true  [TYPE]  Feature  AUTO_CLOSE_JSON_CONTENT  AUTO_CLOSE_TARGET  ESCAPE_NON_ASCII  FLUSH_PASSED_TO_STREAM  IGNORE_UNKNOWN  QUOTE_FIELD_NAMES  QUOTE_NON_NUMERIC_NUMBERS  STRICT_DUPLICATE_DETECTION  WRITE_BIGDECIMAL_AS_PLAIN  WRITE_NUMBERS_AS_STRINGS  [TYPE]  int  _mask  [CONTEXT]  public  void  writeEmbeddedObject  (  Object  object  )  throws  IOException  {  [BUGGY]  throw  new  JsonGenerationException  (   "No  native  support  for  writing  embedded  objects "  ,  this  )  ;  }  	JacksonCore_20_JsonGenerator_1_1	1330	1	src/main/java/com/fasterxml/jackson/core/JsonGenerator.java
1098	if  (!_includePath)  {  	[BUGGY]  [FE]  AssertionFailedError:  Expected  token  END_OBJECT  ,  current  token  null  assertNull  (  p  .  getCurrentToken  (  )  )  ;  [METHOD]  nextToken  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  ctxt  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  public  JsonToken  nextToken  (  )  throws  IOException  {        if  (  !_allowMultipleMatches  &&  (  _currToken  !  =  null  )  &&  (  _exposedContext  =  =  null  )  )  {  [BUGGY]  if  (  _currToken  .  isStructEnd  (  )  )  {  if  (  _headContext  .  isStartHandled  (  )  )  {  return  (  _currToken  =  null  )  ;  }  }  else  if  (  _currToken  .  isScalarValue  (  )  )  {  	JacksonCore_21_FilteringParserDelegate_2_1	238	0	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1099	}  	[BUGGY]  [FE]  AssertionFailedError:  Expected  token  END_OBJECT  ,  current  token  null  assertNull  (  p  .  getCurrentToken  (  )  )  ;  [METHOD]  nextToken  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  ctxt  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  public  JsonToken  nextToken  (  )  throws  IOException  {        if  (  !_allowMultipleMatches  &&  (  _currToken  !  =  null  )  &&  (  _exposedContext  =  =  null  )  )  {  if  (  _currToken  .  isStructEnd  (  )  )  {  if  (  _headContext  .  isStartHandled  (  )  )  {  return  (  _currToken  =  null  )  ;  }  }  else  if  (  _currToken  .  isScalarValue  (  )  )  {    if  (  !_headContext  .  isStartHandled  (  )  &&  (  _itemFilter  =  =  TokenFilter  .  INCLUDE_ALL  )  )  {  return  (  _currToken  =  null  )  ;  }  [BUGGY]  }  }  TokenFilterContext  ctxt  =  _exposedContext  ;  if  (  ctxt  !  =  null  )  {  	JacksonCore_21_FilteringParserDelegate_2_2	248	0	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1100	if  (_verifyAllowedMatches()  &&  _includePath)  {  	[BUGGY]  if  (  _includePath  )  {  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  1  ,  p  .  getMatchCount  (  )  )  ;  [METHOD]  nextToken  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  ctxt  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  _itemFilter  =  f  ;  if  (  !_includePath  )  {    if  (  _includeImmediateParent  &&  !_headContext  .  isStartHandled  (  )  )  {  t  =  _headContext  .  nextTokenToRead  (  )  ;  //  returns  START_OBJECT  but  also  marks  it  handled  _exposedContext  =  _headContext  ;  }  }  return  (  _currToken  =  t  )  ;  }  if  (  f  =  =  null  )  {  delegate  .  nextToken  (  )  ;  delegate  .  skipChildren  (  )  ;  break  ;  }  f  =  f  .  includeProperty  (  name  )  ;  if  (  f  =  =  null  )  {  delegate  .  nextToken  (  )  ;  delegate  .  skipChildren  (  )  ;  break  ;  }  _itemFilter  =  f  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  [BUGGY]  if  (  _includePath  )  {  return  (  _currToken  =  t  )  ;  }  }  if  (  _includePath  )  {  t  =  _nextTokenWithBuffering  (  _headContext  )  ;  	JacksonCore_22_FilteringParserDelegate_7_1	417	1	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1101	if  (_verifyAllowedMatches())  {  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  1  ,  p  .  getMatchCount  (  )  )  ;  [METHOD]  nextToken  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  ctxt  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  _itemFilter  =  f  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  if  (  _includePath  )  {  return  (  _currToken  =  t  )  ;  }  }  if  (  _includePath  )  {  t  =  _nextTokenWithBuffering  (  _headContext  )  ;  if  (  t  !  =  null  )  {  _currToken  =  t  ;  return  t  ;  }  }  break  ;  }  default:  //  scalar  value  f  =  _itemFilter  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  return  (  _currToken  =  t  )  ;  }  if  (  f  !  =  null  )  {  f  =  _headContext  .  checkValue  (  f  )  ;  if  (  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  ||  (  (  f  !  =  null  )  &&  f  .  includeValue  (  delegate  )  )  )  {  [BUGGY]  return  (  _currToken  =  t  )  ;  }  }  break  ;  }  	JacksonCore_22_FilteringParserDelegate_7_2	440	0	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1102	if  (_verifyAllowedMatches()  &&  _includePath)  {  	[BUGGY]  if  (  _includePath  )  {  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  1  ,  p  .  getMatchCount  (  )  )  ;  [METHOD]  _nextToken2  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  }  }  continue  main_loop  ;  case  ID_FIELD_NAME:  {  final  String  name  =  delegate  .  getCurrentName  (  )  ;  f  =  _headContext  .  setFieldName  (  name  )  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  _itemFilter  =  f  ;  return  (  _currToken  =  t  )  ;  }  if  (  f  =  =  null  )  {  //  filter  out  the  value  delegate  .  nextToken  (  )  ;  delegate  .  skipChildren  (  )  ;  continue  main_loop  ;  }  f  =  f  .  includeProperty  (  name  )  ;  if  (  f  =  =  null  )  {  //  filter  out  the  value  delegate  .  nextToken  (  )  ;  delegate  .  skipChildren  (  )  ;  continue  main_loop  ;  }  _itemFilter  =  f  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  [BUGGY]  if  (  _includePath  )  {  return  (  _currToken  =  t  )  ;  }  continue  main_loop  ;  }  	JacksonCore_22_FilteringParserDelegate_7_3	575	1	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1103	if  (_verifyAllowedMatches())  {  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  1  ,  p  .  getMatchCount  (  )  )  ;  [METHOD]  _nextToken2  [TYPE]  JsonToken  [PARAMETER]  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  if  (  _includePath  )  {  return  (  _currToken  =  t  )  ;  }  continue  main_loop  ;  }  if  (  _includePath  )  {  t  =  _nextTokenWithBuffering  (  _headContext  )  ;  if  (  t  !  =  null  )  {  _currToken  =  t  ;  return  t  ;  }  }  }  continue  main_loop  ;  default:  //  scalar  value  f  =  _itemFilter  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  return  (  _currToken  =  t  )  ;  }  if  (  f  !  =  null  )  {  f  =  _headContext  .  checkValue  (  f  )  ;  if  (  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  ||  (  (  f  !  =  null  )  &&  f  .  includeValue  (  delegate  )  )  )  {  [BUGGY]  return  (  _currToken  =  t  )  ;  }  }  break  ;  }  	JacksonCore_22_FilteringParserDelegate_7_4	600	0	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1104	if  (f  ==  TokenFilter.INCLUDE_ALL  &&  _verifyAllowedMatches())  {  	[BUGGY]  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  1  ,  p  .  getMatchCount  (  )  )  ;  [METHOD]  _nextTokenWithBuffering  [TYPE]  JsonToken  [PARAMETER]  TokenFilterContext  buffRoot  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  gotEnd  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  buffRoot  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  return  null  ;  }  }  continue  main_loop  ;  case  ID_FIELD_NAME:  {  final  String  name  =  delegate  .  getCurrentName  (  )  ;  f  =  _headContext  .  setFieldName  (  name  )  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  _itemFilter  =  f  ;  return  _nextBuffered  (  buffRoot  )  ;  }  if  (  f  =  =  null  )  {  //  filter  out  the  value  delegate  .  nextToken  (  )  ;  delegate  .  skipChildren  (  )  ;  continue  main_loop  ;  }  f  =  f  .  includeProperty  (  name  )  ;  if  (  f  =  =  null  )  {  //  filter  out  the  value  delegate  .  nextToken  (  )  ;  delegate  .  skipChildren  (  )  ;  continue  main_loop  ;  }  _itemFilter  =  f  ;  [BUGGY]  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  return  _nextBuffered  (  buffRoot  )  ;  }  }  continue  main_loop  ;  	JacksonCore_22_FilteringParserDelegate_7_5	717	1	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1105	if  (_verifyAllowedMatches())  {  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  1  ,  p  .  getMatchCount  (  )  )  ;  [METHOD]  _nextTokenWithBuffering  [TYPE]  JsonToken  [PARAMETER]  TokenFilterContext  buffRoot  [CLASS]  FilteringParserDelegate  [TYPE]  JsonToken  _currToken  _lastClearedToken  t  [TYPE]  boolean  _allowMultipleMatches  _includeImmediateParent  _includePath  false  gotEnd  returnEnd  true  [TYPE]  String  name  [TYPE]  TokenFilterContext  _exposedContext  _headContext  buffRoot  [TYPE]  int  _matchCount  [TYPE]  TokenFilter  _itemFilter  f  rootFilter  [CONTEXT]  delegate  .  skipChildren  (  )  ;  continue  main_loop  ;  }  f  =  f  .  includeProperty  (  name  )  ;  if  (  f  =  =  null  )  {  //  filter  out  the  value  delegate  .  nextToken  (  )  ;  delegate  .  skipChildren  (  )  ;  continue  main_loop  ;  }  _itemFilter  =  f  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  return  _nextBuffered  (  buffRoot  )  ;  }  }  continue  main_loop  ;  default:  //  scalar  value  f  =  _itemFilter  ;  if  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  {  return  _nextBuffered  (  buffRoot  )  ;  }  if  (  f  !  =  null  )  {  f  =  _headContext  .  checkValue  (  f  )  ;  if  (  (  f  =  =  TokenFilter  .  INCLUDE_ALL  )  ||  (  (  f  !  =  null  )  &&  f  .  includeValue  (  delegate  )  )  )  {  [BUGGY]  return  _nextBuffered  (  buffRoot  )  ;  }  }  continue  main_loop  ;  }  	JacksonCore_22_FilteringParserDelegate_7_6	732	0	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1106	private  final  boolean  _verifyAllowedMatches()  throws  IOException  {  if  (_matchCount  ==  0  ||  _allowMultipleMatches)  {  ++_matchCount;  return  true;  }  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertEquals  (  1  ,  p  .  getMatchCount  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonCore_22_FilteringParserDelegate_7_7	771	0	src/main/java/com/fasterxml/jackson/core/filter/FilteringParserDelegate.java
1107	if  (getClass()  !=  DefaultPrettyPrinter.class)  {    throw  new  IllegalStateException( "Failed  `createInstance()`:   "+getClass().getName()  + "  does  not  override  method;  it  has  to ");  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  not  pass  [METHOD]  createInstance  [TYPE]  DefaultPrettyPrinter  [PARAMETER]  [CLASS]  DefaultPrettyPrinter  [TYPE]  SerializedString  DEFAULT_ROOT_VALUE_SEPARATOR  [TYPE]  Indenter  _arrayIndenter  _objectIndenter  [TYPE]  SerializableString  _rootSeparator  [TYPE]  boolean  _spacesInObjectEntries  false  true  [TYPE]  NopIndenter  instance  [TYPE]  Separators  _separators  [TYPE]  String  _objectFieldValueSeparatorWithSpaces  [TYPE]  FixedSpaceIndenter  instance  [TYPE]  long  serialVersionUID  [TYPE]  int  _nesting  [CONTEXT]  public  DefaultPrettyPrinter  createInstance  (  )  {  [BUGGY]  return  new  DefaultPrettyPrinter  (  this  )  ;  }  	JacksonCore_23_DefaultPrettyPrinter_1_1	255	0	src/main/java/com/fasterxml/jackson/core/util/DefaultPrettyPrinter.java
1108	if  (expType  ==  NR_INT)  {  reportOverflowInt(rawNum);  }  else  {  reportOverflowLong(rawNum);  }  	[BUGGY]  final  String  numDesc  =  _longIntegerDesc  (  rawNum  )  ;  _reportError  (   "Numeric  value  (  %s  )  out  of  range  of  %s "  ,  numDesc  ,  (  expType  =  =  NR_LONG  )  ?   "long "  :   "int "  )  ;  [FE]  jacksoncoreJsonParseException:  Numeric  value  (  9223372036854775817  )  out  of  range  of  long  (  -9223372036854775808  -  9223372036854775807  )  assertEquals  (  Long  .  TYPE  ,  e  .  getTargetType  (  )  )  ;  [METHOD]  _reportTooLongIntegral  [TYPE]  void  [PARAMETER]  int  expType  String  rawNum  [CLASS]  ParserBase  [TYPE]  double  _numberDouble  [TYPE]  ByteArrayBuilder  _byteArrayBuilder  [TYPE]  String  numDesc  rawNum  [TYPE]  int  _currInputRow  _currInputRowStart  _expLength  _fractLength  _inputEnd  _inputPtr  _intLength  _numTypesValid  _numberInt  _tokenInputCol  _tokenInputRow  expType  [TYPE]  long  _currInputProcessed  _numberLong  _tokenInputTotal  [TYPE]  BigDecimal  _numberBigDecimal  [TYPE]  char[]  _nameCopyBuffer  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  byte[]  _binaryValue  [TYPE]  boolean  _closed  _nameCopied  _numberNegative  false  true  [TYPE]  TextBuffer  _textBuffer  [TYPE]  IOContext  _ioContext  [TYPE]  BigInteger  _numberBigInt  [TYPE]  JsonToken  _nextToken  [CONTEXT]  protected  void  _reportTooLongIntegral  (  int  expType  ,  String  rawNum  )  throws  IOException  {  [BUGGY]  final  String  numDesc  =  _longIntegerDesc  (  rawNum  )  ;  _reportError  (   "Numeric  value  (  %s  )  out  of  range  of  %s "  ,  numDesc  ,  (  expType  =  =  NR_LONG  )  ?   "long "  :   "int "  )  ;  }  	JacksonCore_24_ParserBase_2_1	869	3	src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
1109	reportOverflowInt(getText(),  currentToken());  	[BUGGY]  _reportError  (   "Numeric  value  (   "+getText  (  )  + "  )  out  of  range  of  int "  )  ;  [FE]  jacksoncoreJsonParseException:  Numeric  value  (  9223372036854775817  )  out  of  range  of  long  (  -9223372036854775808  -  9223372036854775807  )  assertEquals  (  Long  .  TYPE  ,  e  .  getTargetType  (  )  )  ;  [METHOD]  convertNumberToInt  [TYPE]  void  [PARAMETER]  [CLASS]  ParserBase  [TYPE]  double  _numberDouble  [TYPE]  ByteArrayBuilder  _byteArrayBuilder  [TYPE]  int  _currInputRow  _currInputRowStart  _expLength  _fractLength  _inputEnd  _inputPtr  _intLength  _numTypesValid  _numberInt  _tokenInputCol  _tokenInputRow  result  [TYPE]  long  _currInputProcessed  _numberLong  _tokenInputTotal  [TYPE]  BigDecimal  _numberBigDecimal  [TYPE]  char[]  _nameCopyBuffer  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  byte[]  _binaryValue  [TYPE]  boolean  _closed  _nameCopied  _numberNegative  false  true  [TYPE]  TextBuffer  _textBuffer  [TYPE]  IOContext  _ioContext  [TYPE]  BigInteger  _numberBigInt  [TYPE]  JsonToken  _nextToken  [CONTEXT]  protected  void  convertNumberToInt  (  )  throws  IOException  {  if  (  (  _numTypesValid  &  NR_LONG  )  !  =  0  )  {  int  result  =  (  int  )  _numberLong  ;  if  (  (  (  long  )  result  )  !  =  _numberLong  )  {  [BUGGY]  _reportError  (   "Numeric  value  (   "+getText  (  )  + "  )  out  of  range  of  int "  )  ;  }  _numberInt  =  result  ;  }  else  if  (  (  _numTypesValid  &  NR_BIGINT  )  !  =  0  )  {  if  (  BI_MIN_INT  .  compareTo  (  _numberBigInt  )  >  0  ||  BI_MAX_INT  .  compareTo  (  _numberBigInt  )  <  0  )  {  	JacksonCore_24_ParserBase_2_2	887	1	src/main/java/com/fasterxml/jackson/core/base/ParserBase.java
1110	reportOverflowInt(numDesc,  JsonToken.VALUE_NUMBER_INT);  	[BUGGY]  _reportError  (  String  .  format  (   "Numeric  value  (  %s  )  out  of  range  of  int  (  %d  -  %s  )   "  ,  _longIntegerDesc  (  numDesc  )  ,  Integer  .  MIN_VALUE  ,  Integer  .  MAX_VALUE  )  )  ;  [FE]  jacksoncoreJsonParseException:  Numeric  value  (  9223372036854775817  )  out  of  range  of  long  (  -9223372036854775808  -  9223372036854775807  )  assertEquals  (  Long  .  TYPE  ,  e  .  getTargetType  (  )  )  ;  [METHOD]  reportOverflowInt  [TYPE]  void  [PARAMETER]  String  numDesc  [CLASS]  ParserMinimalBase  [TYPE]  byte[]  NO_BYTES  [TYPE]  boolean  false  true  [TYPE]  double  MAX_INT_D  MAX_LONG_D  MIN_INT_D  MIN_LONG_D  [TYPE]  char  CHAR_NULL  [TYPE]  BigInteger  BI_MAX_INT  BI_MAX_LONG  BI_MIN_INT  BI_MIN_LONG  [TYPE]  int[]  NO_INTS  [TYPE]  JsonToken  _currToken  _lastClearedToken  [TYPE]  String  numDesc  [TYPE]  int  INT_0  INT_9  INT_APOS  INT_ASTERISK  INT_BACKSLASH  INT_COLON  INT_COMMA  INT_CR  INT_E  INT_HASH  INT_LBRACKET  INT_LCURLY  INT_LF  INT_MINUS  INT_PERIOD  INT_PLUS  INT_QUOTE  INT_RBRACKET  INT_RCURLY  INT_SLASH  INT_SPACE  INT_TAB  INT_e  MAX_ERROR_TOKEN_LENGTH  NR_BIGDECIMAL  NR_BIGINT  NR_DOUBLE  NR_FLOAT  NR_INT  NR_LONG  NR_UNKNOWN  [TYPE]  BigDecimal  BD_MAX_INT  BD_MAX_LONG  BD_MIN_INT  BD_MIN_LONG  [TYPE]  long  MAX_INT_L  MIN_INT_L  [CONTEXT]  protected  void  reportOverflowInt  (  String  numDesc  )  throws  IOException  {  [BUGGY]  _reportError  (  String  .  format  (   "Numeric  value  (  %s  )  out  of  range  of  int  (  %d  -  %s  )   "  ,  _longIntegerDesc  (  numDesc  )  ,  Integer  .  MIN_VALUE  ,  Integer  .  MAX_VALUE  )  )  ;  }  	JacksonCore_24_ParserMinimalBase_4_1	565	2	src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
1111	protected  void  reportOverflowInt(String  numDesc,  JsonToken  inputType)  throws  IOException  {  _reportInputCoercion(String.format( "Numeric  value  (%s)  out  of  range  of  int  (%d  -  %s) ",  _longIntegerDesc(numDesc),  Integer.MIN_VALUE,  Integer.MAX_VALUE),  inputType,  Integer.TYPE);  }  	[BUGGY]  [FE]  jacksoncoreJsonParseException:  Numeric  value  (  9223372036854775817  )  out  of  range  of  long  (  -9223372036854775808  -  9223372036854775807  )  assertEquals  (  Long  .  TYPE  ,  e  .  getTargetType  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonCore_24_ParserMinimalBase_4_2	570	0	src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
1112	reportOverflowLong(numDesc,  JsonToken.VALUE_NUMBER_INT);  	[BUGGY]  _reportError  (  String  .  format  (   "Numeric  value  (  %s  )  out  of  range  of  long  (  %d  -  %s  )   "  ,  _longIntegerDesc  (  numDesc  )  ,  Long  .  MIN_VALUE  ,  Long  .  MAX_VALUE  )  )  ;  [FE]  jacksoncoreJsonParseException:  Numeric  value  (  9223372036854775817  )  out  of  range  of  long  (  -9223372036854775808  -  9223372036854775807  )  assertEquals  (  Long  .  TYPE  ,  e  .  getTargetType  (  )  )  ;  [METHOD]  reportOverflowLong  [TYPE]  void  [PARAMETER]  String  numDesc  [CLASS]  ParserMinimalBase  [TYPE]  byte[]  NO_BYTES  [TYPE]  boolean  false  true  [TYPE]  double  MAX_INT_D  MAX_LONG_D  MIN_INT_D  MIN_LONG_D  [TYPE]  char  CHAR_NULL  [TYPE]  BigInteger  BI_MAX_INT  BI_MAX_LONG  BI_MIN_INT  BI_MIN_LONG  [TYPE]  int[]  NO_INTS  [TYPE]  JsonToken  _currToken  _lastClearedToken  [TYPE]  String  numDesc  [TYPE]  int  INT_0  INT_9  INT_APOS  INT_ASTERISK  INT_BACKSLASH  INT_COLON  INT_COMMA  INT_CR  INT_E  INT_HASH  INT_LBRACKET  INT_LCURLY  INT_LF  INT_MINUS  INT_PERIOD  INT_PLUS  INT_QUOTE  INT_RBRACKET  INT_RCURLY  INT_SLASH  INT_SPACE  INT_TAB  INT_e  MAX_ERROR_TOKEN_LENGTH  NR_BIGDECIMAL  NR_BIGINT  NR_DOUBLE  NR_FLOAT  NR_INT  NR_LONG  NR_UNKNOWN  [TYPE]  BigDecimal  BD_MAX_INT  BD_MAX_LONG  BD_MIN_INT  BD_MIN_LONG  [TYPE]  long  MAX_INT_L  MIN_INT_L  [CONTEXT]  protected  void  reportOverflowLong  (  String  numDesc  )  throws  IOException  {  [BUGGY]  _reportError  (  String  .  format  (   "Numeric  value  (  %s  )  out  of  range  of  long  (  %d  -  %s  )   "  ,  _longIntegerDesc  (  numDesc  )  ,  Long  .  MIN_VALUE  ,  Long  .  MAX_VALUE  )  )  ;  }  	JacksonCore_24_ParserMinimalBase_4_3	582	2	src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
1113	protected  void  reportOverflowLong(String  numDesc,  JsonToken  inputType)  throws  IOException  {  _reportInputCoercion(String.format( "Numeric  value  (%s)  out  of  range  of  long  (%d  -  %s) ",  _longIntegerDesc(numDesc),  Long.MIN_VALUE,  Long.MAX_VALUE),  inputType,  Long.TYPE);  }  	[BUGGY]  [FE]  jacksoncoreJsonParseException:  Numeric  value  (  9223372036854775817  )  out  of  range  of  long  (  -9223372036854775808  -  9223372036854775807  )  assertEquals  (  Long  .  TYPE  ,  e  .  getTargetType  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonCore_24_ParserMinimalBase_4_4	587	0	src/main/java/com/fasterxml/jackson/core/base/ParserMinimalBase.java
1114	if  (i  <  maxCode)  {  	[BUGGY]  if  (  i  <  =  maxCode  )  {  [FE]  ArrayIndexOutOfBoundsException:  256  assertToken  (  JsonToken  .  END_OBJECT  ,  p  .  nextToken  (  )  )  ;  [METHOD]  _handleOddName2  [TYPE]  String  [PARAMETER]  int  startPtr  int  hash  int[]  codes  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _bufferRecyclable  _tokenIncomplete  false  true  [TYPE]  TextBuffer  tb  [TYPE]  char  c  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  codes  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  FEAT_MASK_TRAILING_COMMA  _hashSeed  _nameStartCol  _nameStartRow  hash  i  len  maxCode  outPtr  start  startPtr  [TYPE]  long  _nameStartOffset  [TYPE]  char[]  _inputBuffer  buf  outBuf  [CONTEXT]  private  String  _handleOddName2  (  int  startPtr  ,  int  hash  ,  int[]  codes  )  throws  IOException  {  _textBuffer  .  resetWithShared  (  _inputBuffer  ,  startPtr  ,  (  _inputPtr  -  startPtr  )  )  ;  char[]  outBuf  =  _textBuffer  .  getCurrentSegment  (  )  ;  int  outPtr  =  _textBuffer  .  getCurrentSegmentSize  (  )  ;  final  int  maxCode  =  codes  .  length  ;  while  (  true  )  {  if  (  _inputPtr  >  =  _inputEnd  )  {  if  (  !_loadMore  (  )  )  {  //  acceptable  for  now  (  will  error  out  later  )  break  ;  }  }  char  c  =  _inputBuffer[_inputPtr]  ;  int  i  =  (  int  )  c  ;  [BUGGY]  if  (  i  <  =  maxCode  )  {  if  (  codes[i]  !  =  0  )  {  break  ;  }  }  else  if  (  !Character  .  isJavaIdentifierPart  (  c  )  )  {  break  ;  	JacksonCore_25_ReaderBasedJsonParser_1_1	1963	1	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1115	_currBufferStart  =  start;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<3>  assertEquals  (  2  ,  parser  .  getTokenLocation  (  )  .  getColumnNr  (  )  )  ;  [METHOD]  feedInput  [TYPE]  void  [PARAMETER]  byte[]  buf  int  start  int  end  [CLASS]  NonBlockingJsonParser  [TYPE]  byte[]  _inputBuffer  buf  [TYPE]  int[]  _icLatin1  _icUTF8  [TYPE]  boolean  false  true  [TYPE]  int  FEAT_MASK_ALLOW_JAVA_COMMENTS  FEAT_MASK_ALLOW_MISSING  FEAT_MASK_ALLOW_SINGLE_QUOTES  FEAT_MASK_ALLOW_UNQUOTED_NAMES  FEAT_MASK_ALLOW_YAML_COMMENTS  FEAT_MASK_LEADING_ZEROS  FEAT_MASK_TRAILING_COMMA  _origBufferLen  end  start  [CONTEXT]  public  void  feedInput  (  byte[]  buf  ,  int  start  ,  int  end  )  throws  IOException  {  if  (  _inputPtr  <  _inputEnd  )  {  _reportError  (   "Still  have  %d  undecoded  bytes  ,  should  not  call  'feedInput' "  ,  _inputEnd  -  _inputPtr  )  ;  }  if  (  end  <  start  )  {  _reportError  (   "Input  end  (  %d  )  may  not  be  before  start  (  %d  )   "  ,  end  ,  start  )  ;  }  if  (  _endOfInput  )  {  _reportError  (   "Already  closed  ,  can  not  feed  more  input "  )  ;  }  _currInputProcessed  +  =  _origBufferLen  ;    _currInputRowStart  =  start  -  (  _inputEnd  -  _currInputRowStart  )  ;    [BUGGY]  _inputBuffer  =  buf  ;  _inputPtr  =  start  ;  _inputEnd  =  end  ;  _origBufferLen  =  end  -  start  ;  }  	JacksonCore_26_NonBlockingJsonParser_1_1	108	0	src/main/java/com/fasterxml/jackson/core/json/async/NonBlockingJsonParser.java
1116	if  (value  ==  null)  {  writeNull();  return;  }  Class<?>  raw  =  value.getClass();  if  (raw  ==  byte[].class)  {  return;  }  else  if  (_objectCodec  ==  null)  {  	[BUGGY]  [FE]  AssertionFailedError:  Expected  Object  ,  got  POJO  assertEquals  (  EXP  ,  MAPPER  .  writeValueAsString  (  tree  )  )  ;  [METHOD]  writeObject  [TYPE]  void  [PARAMETER]  Object  value  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  value  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeObject  (  Object  value  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  value  )  ;      }  	JacksonDatabind_2_TokenBuffer_3_1	783	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1117	_append(JsonToken.VALUE_EMBEDDED_OBJECT,  value);  }  else  {  _objectCodec.writeValue(this,  value);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  Object  ,  got  POJO  assertEquals  (  EXP  ,  MAPPER  .  writeValueAsString  (  tree  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_2_TokenBuffer_3_2	788	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1118	if  (node  ==  null)  {  writeNull();  return;  }  if  (_objectCodec  ==  null)  {\n',   "                            }  else  {  _objectCodec.writeTree(this,  node);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  Object  ,  got  POJO  assertEquals  (  EXP  ,  MAPPER  .  writeValueAsString  (  tree  )  )  ;  [METHOD]  writeTree  [TYPE]  void  [PARAMETER]  TreeNode  node  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  TreeNode  node  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeTree  (  TreeNode  node  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  node  )  ;  }  	JacksonDatabind_2_TokenBuffer_3_3	793	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1119		[BUGGY]  value  =  _elementDeserializer  .  getNullValue  (  )  ;  \n'  ,   "+        value  =  null  ;  [FE]  NullPointerException  assertNull  (  result[0]  )  ;  [METHOD]  deserialize  [TYPE]  String[]  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  [CLASS]  StringArrayDeserializer  [TYPE]  ObjectBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  StringArrayDeserializer  instance  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  String  value  [TYPE]  String[]  result  [TYPE]  JsonDeserializer  _elementDeserializer  [TYPE]  long  serialVersionUID  [TYPE]  Object[]  chunk  [TYPE]  int  ix  [TYPE]  JsonParser  jp  [CONTEXT]  public  String[]  deserialize  (  JsonParser  jp  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  !jp  .  isExpectedStartArrayToken  (  )  )  {  return  handleNonArray  (  jp  ,  ctxt  )  ;  }  if  (  _elementDeserializer  !  =  null  )  {  return  _deserializeCustom  (  jp  ,  ctxt  )  ;  }  final  ObjectBuffer  buffer  =  ctxt  .  leaseObjectBuffer  (  )  ;  Object[]  chunk  =  buffer  .  resetAndStart  (  )  ;  int  ix  =  0  ;  JsonToken  t  ;  while  (  (  t  =  jp  .  nextToken  (  )  )  !  =  JsonToken  .  END_ARRAY  )  {  String  value  ;  if  (  t  =  =  JsonToken  .  VALUE_STRING  )  {  value  =  jp  .  getText  (  )  ;  }  else  if  (  t  =  =  JsonToken  .  VALUE_NULL  )  {  [BUGGY]  value  =  _elementDeserializer  .  getNullValue  (  )  ;  }  else  {  value  =  _parseString  (  jp  ,  ctxt  )  ;  }  if  (  ix  >  =  chunk  .  length  )  {  chunk  =  buffer  .  appendCompletedChunk  (  chunk  )  ;  	JacksonDatabind_3_StringArrayDeserializer_2_1	66	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
1120	String  value  =  (t  ==  JsonToken.VALUE_NULL)  ?  deser.getNullValue()  :  deser.deserialize(jp,  ctxt);  	[BUGGY]  String  value  =  (  t  =  =  JsonToken  .  VALUE_NULL  )  ?  null  :  deser  .  deserialize  (  jp  ,  ctxt  )  ;  [FE]  NullPointerException  assertNull  (  result[0]  )  ;  [METHOD]  _deserializeCustom  [TYPE]  String[]  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  [CLASS]  StringArrayDeserializer  [TYPE]  ObjectBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  StringArrayDeserializer  instance  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  String  value  [TYPE]  String[]  result  [TYPE]  JsonDeserializer  _elementDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  Object[]  chunk  [TYPE]  int  ix  [TYPE]  JsonParser  jp  [CONTEXT]  protected  final  String[]  _deserializeCustom  (  JsonParser  jp  ,  DeserializationContext  ctxt  )  throws  IOException  {  final  ObjectBuffer  buffer  =  ctxt  .  leaseObjectBuffer  (  )  ;  Object[]  chunk  =  buffer  .  resetAndStart  (  )  ;  final  JsonDeserializer<String>  deser  =  _elementDeserializer  ;  int  ix  =  0  ;  JsonToken  t  ;  while  (  (  t  =  jp  .  nextToken  (  )  )  !  =  JsonToken  .  END_ARRAY  )  {  [BUGGY]  String  value  =  (  t  =  =  JsonToken  .  VALUE_NULL  )  ?  null  :  deser  .  deserialize  (  jp  ,  ctxt  )  ;  if  (  ix  >  =  chunk  .  length  )  {  chunk  =  buffer  .  appendCompletedChunk  (  chunk  )  ;  ix  =  0  ;  }  chunk[ix++]  =  value  ;  }  String[]  result  =  buffer  .  completeAndClearBuffer  (  chunk  ,  ix  ,  String  .  class  )  ;  ctxt  .  returnObjectBuffer  (  buffer  )  ;  return  result  ;  }  	JacksonDatabind_3_StringArrayDeserializer_2_2	95	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
1121	try  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertNull  (  refs  .  get  (  1  )  .  getFieldName  (  )  )  ;  [METHOD]  deserialize  [TYPE]  String[]  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  [CLASS]  StringArrayDeserializer  [TYPE]  ObjectBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  StringArrayDeserializer  instance  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  String  value  [TYPE]  String[]  result  [TYPE]  JsonDeserializer  _elementDeserializer  [TYPE]  long  serialVersionUID  [TYPE]  Object[]  chunk  [TYPE]  int  ix  [TYPE]  JsonParser  jp  [CONTEXT]  public  String[]  deserialize  (  JsonParser  jp  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  !jp  .  isExpectedStartArrayToken  (  )  )  {  return  handleNonArray  (  jp  ,  ctxt  )  ;  }  if  (  _elementDeserializer  !  =  null  )  {  return  _deserializeCustom  (  jp  ,  ctxt  )  ;  }  final  ObjectBuffer  buffer  =  ctxt  .  leaseObjectBuffer  (  )  ;  Object[]  chunk  =  buffer  .  resetAndStart  (  )  ;  int  ix  =  0  ;  JsonToken  t  ;  [BUGGY]  while  (  (  t  =  jp  .  nextToken  (  )  )  !  =  JsonToken  .  END_ARRAY  )  {  String  value  ;  if  (  t  =  =  JsonToken  .  VALUE_STRING  )  {  value  =  jp  .  getText  (  )  ;  }  else  if  (  t  =  =  JsonToken  .  VALUE_NULL  )  {  	JacksonDatabind_4_StringArrayDeserializer_4_1	59	0	src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
1122	}  catch  (Exception  e)  {  throw  JsonMappingException.wrapWithPath(e,  String.class,  ix);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertNull  (  refs  .  get  (  1  )  .  getFieldName  (  )  )  ;  [METHOD]  deserialize  [TYPE]  String[]  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  [CLASS]  StringArrayDeserializer  [TYPE]  ObjectBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  StringArrayDeserializer  instance  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  String  value  [TYPE]  String[]  result  [TYPE]  JsonDeserializer  _elementDeserializer  [TYPE]  long  serialVersionUID  [TYPE]  Object[]  chunk  [TYPE]  int  ix  [TYPE]  JsonParser  jp  [CONTEXT]  return  _deserializeCustom  (  jp  ,  ctxt  )  ;  }  final  ObjectBuffer  buffer  =  ctxt  .  leaseObjectBuffer  (  )  ;  Object[]  chunk  =  buffer  .  resetAndStart  (  )  ;  int  ix  =  0  ;  JsonToken  t  ;  while  (  (  t  =  jp  .  nextToken  (  )  )  !  =  JsonToken  .  END_ARRAY  )  {  String  value  ;  if  (  t  =  =  JsonToken  .  VALUE_STRING  )  {  value  =  jp  .  getText  (  )  ;  }  else  if  (  t  =  =  JsonToken  .  VALUE_NULL  )  {  value  =  null  ;  //  since  we  have  established  that  '_elementDeserializer  =  =  null'  earlier  }  else  {  value  =  _parseString  (  jp  ,  ctxt  )  ;  }  if  (  ix  >  =  chunk  .  length  )  {  chunk  =  buffer  .  appendCompletedChunk  (  chunk  )  ;  ix  =  0  ;  }  chunk[ix++]  =  value  ;  }  [BUGGY]  String[]  result  =  buffer  .  completeAndClearBuffer  (  chunk  ,  ix  ,  String  .  class  )  ;  ctxt  .  returnObjectBuffer  (  buffer  )  ;  return  result  ;  }  	JacksonDatabind_4_StringArrayDeserializer_4_2	75	0	src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
1123	try  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertNull  (  refs  .  get  (  1  )  .  getFieldName  (  )  )  ;  [METHOD]  _deserializeCustom  [TYPE]  String[]  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  [CLASS]  StringArrayDeserializer  [TYPE]  ObjectBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  StringArrayDeserializer  instance  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  String  value  [TYPE]  String[]  result  [TYPE]  JsonDeserializer  _elementDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  Object[]  chunk  [TYPE]  int  ix  [TYPE]  JsonParser  jp  [CONTEXT]  protected  final  String[]  _deserializeCustom  (  JsonParser  jp  ,  DeserializationContext  ctxt  )  throws  IOException  {  final  ObjectBuffer  buffer  =  ctxt  .  leaseObjectBuffer  (  )  ;  Object[]  chunk  =  buffer  .  resetAndStart  (  )  ;  final  JsonDeserializer<String>  deser  =  _elementDeserializer  ;  int  ix  =  0  ;  JsonToken  t  ;  [BUGGY]  while  (  (  t  =  jp  .  nextToken  (  )  )  !  =  JsonToken  .  END_ARRAY  )  {  String  value  =  (  t  =  =  JsonToken  .  VALUE_NULL  )  ?  deser  .  getNullValue  (  )  :  deser  .  deserialize  (  jp  ,  ctxt  )  ;  if  (  ix  >  =  chunk  .  length  )  {  chunk  =  buffer  .  appendCompletedChunk  (  chunk  )  ;  ix  =  0  ;  }  chunk[ix++]  =  value  ;  }  String[]  result  =  buffer  .  completeAndClearBuffer  (  chunk  ,  ix  ,  String  .  class  )  ;  ctxt  .  returnObjectBuffer  (  buffer  )  ;  return  result  ;  }  	JacksonDatabind_4_StringArrayDeserializer_4_3	93	0	src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
1124	}  catch  (Exception  e)  {  throw  JsonMappingException.wrapWithPath(e,  String.class,  ix);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<0>  assertNull  (  refs  .  get  (  1  )  .  getFieldName  (  )  )  ;  [METHOD]  _deserializeCustom  [TYPE]  String[]  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  [CLASS]  StringArrayDeserializer  [TYPE]  ObjectBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  StringArrayDeserializer  instance  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  String  value  [TYPE]  String[]  result  [TYPE]  JsonDeserializer  _elementDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  Object[]  chunk  [TYPE]  int  ix  [TYPE]  JsonParser  jp  [CONTEXT]  protected  final  String[]  _deserializeCustom  (  JsonParser  jp  ,  DeserializationContext  ctxt  )  throws  IOException  {  final  ObjectBuffer  buffer  =  ctxt  .  leaseObjectBuffer  (  )  ;  Object[]  chunk  =  buffer  .  resetAndStart  (  )  ;  final  JsonDeserializer<String>  deser  =  _elementDeserializer  ;  int  ix  =  0  ;  JsonToken  t  ;  while  (  (  t  =  jp  .  nextToken  (  )  )  !  =  JsonToken  .  END_ARRAY  )  {  String  value  =  (  t  =  =  JsonToken  .  VALUE_NULL  )  ?  deser  .  getNullValue  (  )  :  deser  .  deserialize  (  jp  ,  ctxt  )  ;  if  (  ix  >  =  chunk  .  length  )  {  chunk  =  buffer  .  appendCompletedChunk  (  chunk  )  ;  ix  =  0  ;  }  chunk[ix++]  =  value  ;  }  [BUGGY]  String[]  result  =  buffer  .  completeAndClearBuffer  (  chunk  ,  ix  ,  String  .  class  )  ;  ctxt  .  returnObjectBuffer  (  buffer  )  ;  return  result  ;  }  	JacksonDatabind_4_StringArrayDeserializer_4_4	102	0	src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java
1125	am  =  mixIns.find(m);  if  (am  !=  null)  {  _addMixUnders(m,  am);  }  else  {  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindintrospectTestMixinMerging$PersonImpl  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "city\ ":\ "Seattle\ "} "  ,  mapper  .  writeValueAsString  (  new  PersonImpl  (  )  )  )  ;  [METHOD]  _addMethodMixIns  [TYPE]  void  [PARAMETER]  Class<?>  targetClass  AnnotatedMethodMap  methods  Class<?>  mixInCls  AnnotatedMethodMap  mixIns  [CLASS]  AnnotatedClass  [TYPE]  AnnotationMap[]  NO_ANNOTATION_MAPS  [TYPE]  MixInResolver  _mixInResolver  [TYPE]  boolean  _creatorsResolved  false  true  [TYPE]  AnnotatedConstructor  _defaultConstructor  [TYPE]  AnnotationMap  _classAnnotations  [TYPE]  AnnotatedMethod  am  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  Class  _class  _primaryMixIn  mixInCls  mixin  targetClass  [TYPE]  List  _constructors  _creatorMethods  _fields  _superTypes  parents  [TYPE]  AnnotatedMethodMap  _memberMethods  methods  mixIns  [TYPE]  Method  m  [CONTEXT]  protected  void  _addMethodMixIns  (  Class<?>  targetClass  ,  AnnotatedMethodMap  methods  ,  Class<?>  mixInCls  ,  AnnotatedMethodMap  mixIns  )  {  List<Class<?>>  parents  =  new  ArrayList<Class<?>>  (  )  ;  parents  .  add  (  mixInCls  )  ;  ClassUtil  .  findSuperTypes  (  mixInCls  ,  targetClass  ,  parents  )  ;  for  (  Class<?>  mixin  :  parents  )  {  for  (  Method  m  :  mixin  .  getDeclaredMethods  (  )  )  {  if  (  !_isIncludableMemberMethod  (  m  )  )  {  continue  ;  }  AnnotatedMethod  am  =  methods  .  find  (  m  )  ;      if  (  am  !  =  null  )  {  _addMixUnders  (  m  ,  am  )  ;      }  else  {  [BUGGY]  mixIns  .  add  (  _constructMethod  (  m  )  )  ;  }  }  }  }  	JacksonDatabind_5_AnnotatedClass_1_1	658	0	src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java
1126	int  offset  =  len  -  5;    switch  (timeLen)  {  case  11:\n',   "+                                                sb.insert(offset,  '0');  break;\n ",  '+                                        case  10:  sb.insert(offset,   "00 ");  break;  case  9:    sb.insert(offset,   "000 ");  break;  case  8:  sb.insert(offset,   ".000 ");  break;  case  7:    break;\n',   "+                                        case  6:    case  5:    sb.insert(offset,   ":00.000 ");  }  	[BUGGY]  if  (  Character  .  isDigit  (  c  )  )  {\n'  ,   "+        int  timeLen  =  len  -  dateStr  .  lastIndexOf  (  'T'  )  -  6  ;  \n "  ,  '+        if  (  timeLen  <  12  )  {  sb  .  insert  (  len-5  ,   "  .  000 "  )  ;  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  construct  instance  of  javautilDate  from  String  value  assertEquals  (  0  ,  c  .  get  (  Calendar  .  MILLISECOND  )  )  ;  [METHOD]  parseAsISO8601  [TYPE]  Date  [PARAMETER]  String  dateStr  ParsePosition  pos  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_ISO8601_Z  DATE_FORMAT_PLAIN  DATE_FORMAT_RFC1123  _formatISO8601  _formatISO8601_z  _formatPlain  _formatRFC1123  df  [TYPE]  char  c  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_ISO8601_Z  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  dateStr  [TYPE]  String[]  ALL_FORMATS  [TYPE]  int  len  timeLen  [TYPE]  ParsePosition  pos  [CONTEXT]  if  (  df  =  =  null  )  {  df  =  _formatISO8601_z  =  _cloneFormat  (  DATE_FORMAT_ISO8601_Z  ,  DATE_FORMAT_STR_ISO8601_Z  ,  _timezone  ,  _locale  )  ;  }  if  (  dateStr  .  charAt  (  len-4  )  =  =  ':'  )  {  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  sb  .  insert  (  len-1  ,   "  .  000 "  )  ;  dateStr  =  sb  .  toString  (  )  ;  }  }  else  {  if  (  hasTimeZone  (  dateStr  )  )  {  c  =  dateStr  .  charAt  (  len-3  )  ;  if  (  c  =  =  ':'  )  {  //  remove  optional  colon  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  sb  .  delete  (  len-3  ,  len-2  )  ;  dateStr  =  sb  .  toString  (  )  ;  }  else  if  (  c  =  =  '+'  ||  c  =  =  '-'  )  {  //  missing  minutes  dateStr  +  =   "00 "  ;  }  len  =  dateStr  .  length  (  )  ;  [BUGGY]  c  =  dateStr  .  charAt  (  len-9  )  ;  if  (  Character  .  isDigit  (  c  )  )  {  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  sb  .  insert  (  len-5  ,   "  .  000 "  )  ;  dateStr  =  sb  .  toString  (  )  ;  }  	JacksonDatabind_6_StdDateFormat_2_1	406	2	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1127	if  (timeLen  <  12)  {    switch  (timeLen)  {\n',   "+                                        case  11:  sb.append('0');\n ",   "+                                        case  10:  sb.append('0');\n ",   "+                                        case  9:  sb.append('0');\n ",  '+                                                break;  default:  }  	[BUGGY]  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  construct  instance  of  javautilDate  from  String  value  assertEquals  (  0  ,  c  .  get  (  Calendar  .  MILLISECOND  )  )  ;  [METHOD]  parseAsISO8601  [TYPE]  Date  [PARAMETER]  String  dateStr  ParsePosition  pos  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_ISO8601_Z  DATE_FORMAT_PLAIN  DATE_FORMAT_RFC1123  _formatISO8601  _formatISO8601_z  _formatPlain  _formatRFC1123  df  [TYPE]  char  c  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_ISO8601_Z  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  dateStr  [TYPE]  String[]  ALL_FORMATS  [TYPE]  int  len  timeLen  [TYPE]  ParsePosition  pos  [CONTEXT]  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  sb  .  delete  (  len-3  ,  len-2  )  ;  dateStr  =  sb  .  toString  (  )  ;  }  else  if  (  c  =  =  '+'  ||  c  =  =  '-'  )  {  //  missing  minutes  dateStr  +  =   "00 "  ;  }  len  =  dateStr  .  length  (  )  ;  c  =  dateStr  .  charAt  (  len-9  )  ;  if  (  Character  .  isDigit  (  c  )  )  {  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  sb  .  insert  (  len-5  ,   "  .  000 "  )  ;  dateStr  =  sb  .  toString  (  )  ;  }  df  =  _formatISO8601  ;  if  (  _formatISO8601  =  =  null  )  {  df  =  _formatISO8601  =  _cloneFormat  (  DATE_FORMAT_ISO8601  ,  DATE_FORMAT_STR_ISO8601  ,  _timezone  ,  _locale  )  ;  }  }  else  {  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  int  timeLen  =  len  -  dateStr  .  lastIndexOf  (  'T'  )  -  1  ;  [BUGGY]  if  (  timeLen  <  =  8  )  {  sb  .  append  (   "  .  000 "  )  ;  }  sb  .  append  (  'Z'  )  ;  dateStr  =  sb  .  toString  (  )  ;  df  =  _formatISO8601_z  ;  	JacksonDatabind_6_StdDateFormat_2_2	421	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1128	if  (jp.getCurrentTokenId()  !=  JsonToken.FIELD_NAME.id())  {  return  this;  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  token  START_OBJECT  ,  current  token  FIELD_NAME  assertToken  (  JsonToken  .  END_OBJECT  ,  jp  .  nextToken  (  )  )  ;  [METHOD]  deserialize  [TYPE]  TokenBuffer  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [TYPE]  JsonParser  jp  [CONTEXT]  public  TokenBuffer  deserialize  (  JsonParser  jp  ,  DeserializationContext  ctxt  )  throws  IOException  {  [BUGGY]  copyCurrentStructure  (  jp  )  ;      return  this  ;  }  	JacksonDatabind_7_TokenBuffer_2_1	405	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1129	JsonToken  t;  writeStartObject();  do  {  copyCurrentStructure(jp);  }  while  ((t  =  jp.nextToken())  ==  JsonToken.FIELD_NAME);  if  (t  !=  JsonToken.END_OBJECT)  {  throw  ctxt.mappingException( "Expected  END_OBJECT  after  copying  contents  of  a  JsonParser  into  TokenBuffer,  got   "+t);  }  writeEndObject();  	[BUGGY]  [FE]  AssertionFailedError:  Expected  token  START_OBJECT  ,  current  token  FIELD_NAME  assertToken  (  JsonToken  .  END_OBJECT  ,  jp  .  nextToken  (  )  )  ;  [METHOD]  deserialize  [TYPE]  TokenBuffer  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [TYPE]  JsonParser  jp  [CONTEXT]  public  TokenBuffer  deserialize  (  JsonParser  jp  ,  DeserializationContext  ctxt  )  throws  IOException  {  copyCurrentStructure  (  jp  )  ;      [BUGGY]  return  this  ;  }  	JacksonDatabind_7_TokenBuffer_2_2	410	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1130	boolean  verify;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Conflicting  String  creators:  already  had  explicitly  marked  [constructor  for  javalangStringBuilder  ,  annotations:  [null]]  ,  encountered  [constructor  for  javalangStringBuilder  ,  annotations:  [null]]  assertEquals  (   "abc "  ,  sb  .  toString  (  )  )  ;  [METHOD]  verifyNonDup  [TYPE]  void  [PARAMETER]  AnnotatedWithParams  newOne  int  typeIndex  boolean  explicit  [CLASS]  CreatorCollector  [TYPE]  CreatorProperty[]  _delegateArgs  _propertyBasedArgs  [TYPE]  AnnotatedWithParams  newOne  oldOne  [TYPE]  boolean  _canFixAccess  _hasNonDefaultCreator  explicit  false  true  [TYPE]  AnnotatedParameter  _incompleteParameter  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotatedWithParams[]  _creators  [TYPE]  String[]  TYPE_DESCS  [TYPE]  int  C_BOOLEAN  C_DEFAULT  C_DELEGATE  C_DOUBLE  C_INT  C_LONG  C_PROPS  C_STRING  TYPE_COLLECTION  TYPE_HASH_MAP  TYPE_MAP  _explicitCreators  _type  mask  typeIndex  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  void  verifyNonDup  (  AnnotatedWithParams  newOne  ,  int  typeIndex  ,  boolean  explicit  )  {  final  int  mask  =  (  1  <<  typeIndex  )  ;  _hasNonDefaultCreator  =  true  ;  AnnotatedWithParams  oldOne  =  _creators[typeIndex]  ;  if  (  oldOne  !  =  null  )  {  [BUGGY]  if  (  (  _explicitCreators  &  mask  )  !  =  0  )  {  //  already  had  explicitly  annotated  ,  leave  as-is  if  (  !explicit  )  {  return  ;  }  	JacksonDatabind_8_CreatorCollector_3_1	283	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1131	verify  =  true;  }  else  {  verify  =  !explicit;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Conflicting  String  creators:  already  had  explicitly  marked  [constructor  for  javalangStringBuilder  ,  annotations:  [null]]  ,  encountered  [constructor  for  javalangStringBuilder  ,  annotations:  [null]]  assertEquals  (   "abc "  ,  sb  .  toString  (  )  )  ;  [METHOD]  verifyNonDup  [TYPE]  void  [PARAMETER]  AnnotatedWithParams  newOne  int  typeIndex  boolean  explicit  [CLASS]  CreatorCollector  [TYPE]  CreatorProperty[]  _delegateArgs  _propertyBasedArgs  [TYPE]  AnnotatedWithParams  newOne  oldOne  [TYPE]  boolean  _canFixAccess  _hasNonDefaultCreator  explicit  false  true  [TYPE]  AnnotatedParameter  _incompleteParameter  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotatedWithParams[]  _creators  [TYPE]  String[]  TYPE_DESCS  [TYPE]  int  C_BOOLEAN  C_DEFAULT  C_DELEGATE  C_DOUBLE  C_INT  C_LONG  C_PROPS  C_STRING  TYPE_COLLECTION  TYPE_HASH_MAP  TYPE_MAP  _explicitCreators  _type  mask  typeIndex  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  void  verifyNonDup  (  AnnotatedWithParams  newOne  ,  int  typeIndex  ,  boolean  explicit  )  {  final  int  mask  =  (  1  <<  typeIndex  )  ;  _hasNonDefaultCreator  =  true  ;  AnnotatedWithParams  oldOne  =  _creators[typeIndex]  ;  if  (  oldOne  !  =  null  )  {  if  (  (  _explicitCreators  &  mask  )  !  =  0  )  {  //  already  had  explicitly  annotated  ,  leave  as-is  if  (  !explicit  )  {  return  ;  }  [BUGGY]  }  if  (  oldOne  .  getClass  (  )  =  =  newOne  .  getClass  (  )  )  {  	JacksonDatabind_8_CreatorCollector_3_2	290	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1132	if  (verify  &&  (oldOne.getClass()  ==  newOne.getClass()))  {  Class<?>  oldType  =  oldOne.getRawParameterType(0);  Class<?>  newType  =  newOne.getRawParameterType(0);  if  (oldType  ==  newType)  {  }  if  (newType.isAssignableFrom(oldType))  {  return;  }  	[BUGGY]  if  (  oldOne  .  getClass  (  )  =  =  newOne  .  getClass  (  )  )  {  [FE]  jacksondatabindJsonMappingException:  Conflicting  String  creators:  already  had  explicitly  marked  [constructor  for  javalangStringBuilder  ,  annotations:  [null]]  ,  encountered  [constructor  for  javalangStringBuilder  ,  annotations:  [null]]  assertEquals  (   "abc "  ,  sb  .  toString  (  )  )  ;  [METHOD]  verifyNonDup  [TYPE]  void  [PARAMETER]  AnnotatedWithParams  newOne  int  typeIndex  boolean  explicit  [CLASS]  CreatorCollector  [TYPE]  CreatorProperty[]  _delegateArgs  _propertyBasedArgs  [TYPE]  AnnotatedWithParams  newOne  oldOne  [TYPE]  boolean  _canFixAccess  _hasNonDefaultCreator  explicit  false  true  [TYPE]  AnnotatedParameter  _incompleteParameter  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotatedWithParams[]  _creators  [TYPE]  String[]  TYPE_DESCS  [TYPE]  int  C_BOOLEAN  C_DEFAULT  C_DELEGATE  C_DOUBLE  C_INT  C_LONG  C_PROPS  C_STRING  TYPE_COLLECTION  TYPE_HASH_MAP  TYPE_MAP  _explicitCreators  _type  mask  typeIndex  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  void  verifyNonDup  (  AnnotatedWithParams  newOne  ,  int  typeIndex  ,  boolean  explicit  )  {  final  int  mask  =  (  1  <<  typeIndex  )  ;  _hasNonDefaultCreator  =  true  ;  AnnotatedWithParams  oldOne  =  _creators[typeIndex]  ;  if  (  oldOne  !  =  null  )  {  if  (  (  _explicitCreators  &  mask  )  !  =  0  )  {  //  already  had  explicitly  annotated  ,  leave  as-is  if  (  !explicit  )  {  return  ;  }    }  [BUGGY]  if  (  oldOne  .  getClass  (  )  =  =  newOne  .  getClass  (  )  )  {  throw  new  IllegalArgumentException  (   "Conflicting   "+TYPE_DESCS[typeIndex]  + "  creators:  already  had  explicitly  marked   "+oldOne+ "  ,  encountered   "+newOne  )  ;  	JacksonDatabind_8_CreatorCollector_3_3	294	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1133	Class<?>  cls  =  value.getClass();  if  (cls  ==  String.class)  {  str  =  (String)  value;  }  else  if  (Date.class.isAssignableFrom(cls))  {  }  else  if  (cls  ==  Class.class)  {  str  =  ((Class<?>)  value).getName();  	[BUGGY]  if  (  value  instanceof  Date  )  {  [FE]  ComparisonFailure:  expected:<{ "[]javalangString ":2}>  but  was:<{ "[class  ]javalangString ":2}>  assertEquals  (  aposToQuotes  (   "{'java  .  lang  .  String':2} "  )  ,  json  )  ;  [METHOD]  serialize  [TYPE]  void  [PARAMETER]  Object  value  JsonGenerator  jgen  SerializerProvider  provider  [CLASS]  StdKeySerializer  [TYPE]  boolean  false  true  [TYPE]  JsonGenerator  jgen  [TYPE]  Object  value  [TYPE]  String  str  [TYPE]  SerializerProvider  provider  [CONTEXT]  public  void  serialize  (  Object  value  ,  JsonGenerator  jgen  ,  SerializerProvider  provider  )  throws  IOException  {  String  str  ;  [BUGGY]  if  (  value  instanceof  Date  )  {  provider  .  defaultSerializeDateKey  (  (  Date  )  value  ,  jgen  )  ;  return  ;  }  else  {  str  =  value  .  toString  (  )  ;  }  jgen  .  writeFieldName  (  str  )  ;  }  	JacksonDatabind_9_StdKeySerializer_1_1	27	1	src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java
1134	protected  JsonSerializer<Object>  _serializer;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "[stuff ": "[key/value]] "}>  but  was:<{ "[key ": "value] "}>  assertEquals  (   "{\ "stuff\ ":\ "[key/value]\ "} "  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_10_AnyGetterWriter_6_1	24	0	src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java
1135	AnnotatedMember  accessor,  JsonSerializer<?>  serializer)  	[BUGGY]  AnnotatedMember  accessor  ,  MapSerializer  serializer  )  [FE]  ComparisonFailure:  expected:<{ "[stuff ": "[key/value]] "}>  but  was:<{ "[key ": "value] "}>  assertEquals  (   "{\ "stuff\ ":\ "[key/value]\ "} "  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_10_AnyGetterWriter_6_2	29	1	src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java
1136	_serializer  =  (JsonSerializer<Object>)  serializer;  if  (serializer  instanceof  MapSerializer)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "[stuff ": "[key/value]] "}>  but  was:<{ "[key ": "value] "}>  assertEquals  (   "{\ "stuff\ ":\ "[key/value]\ "} "  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_10_AnyGetterWriter_6_3	33	0	src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java
1137	_serializer.serialize(value,  gen,  provider);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "[stuff ": "[key/value]] "}>  but  was:<{ "[key ": "value] "}>  assertEquals  (   "{\ "stuff\ ":\ "[key/value]\ "} "  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_10_AnyGetterWriter_6_4	52	0	src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java
1138	_serializer.serialize(value,  gen,  provider);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "[stuff ": "[key/value]] "}>  but  was:<{ "[key ": "value] "}>  assertEquals  (   "{\ "stuff\ ":\ "[key/value]\ "} "  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_10_AnyGetterWriter_6_5	75	0	src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java
1139	if  (_serializer  instanceof  ContextualSerializer)  {  JsonSerializer<?>  ser  =  provider.handlePrimaryContextualization(_serializer,  _property);  _serializer  =  (JsonSerializer<Object>)  ser;  if  (ser  instanceof  MapSerializer)  {  _mapSerializer  =  (MapSerializer)  ser;  }  }  	[BUGGY]  _mapSerializer  =  (  MapSerializer  )  provider  .  handlePrimaryContextualization  (  _mapSerializer  ,  _property  )  ;  [FE]  ComparisonFailure:  expected:<{ "[stuff ": "[key/value]] "}>  but  was:<{ "[key ": "value] "}>  assertEquals  (   "{\ "stuff\ ":\ "[key/value]\ "} "  ,  json  )  ;  [METHOD]  resolve  [TYPE]  void  [PARAMETER]  SerializerProvider  provider  [CLASS]  AnyGetterWriter  [TYPE]  AnnotatedMember  _accessor  [TYPE]  MapSerializer  _mapSerializer  [TYPE]  boolean  false  true  [TYPE]  SerializerProvider  provider  [TYPE]  BeanProperty  _property  [CONTEXT]  public  void  resolve  (  SerializerProvider  provider  )  throws  JsonMappingException  {  [BUGGY]  _mapSerializer  =  (  MapSerializer  )  provider  .  handlePrimaryContextualization  (  _mapSerializer  ,  _property  )  ;  }  	JacksonDatabind_10_AnyGetterWriter_6_6	82	1	src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java
1140	JsonSerializer<?>  anySer  =  findSerializerFromAnnotation(prov,  anyGetter);  if  (anySer  ==  null)  {\n',   "                                    typeSer,  null,  null,  /*filterId*/  null);  }  	[BUGGY]  MapSerializer  anySer  =  MapSerializer  .  construct  (  null  ,  type  ,  staticTyping  ,  typeSer  ,  null  ,  null  ,  null  )  ;  [FE]  ComparisonFailure:  expected:<{ "[stuff ": "[key/value]] "}>  but  was:<{ "[key ": "value] "}>  assertEquals  (   "{\ "stuff\ ":\ "[key/value]\ "} "  ,  json  )  ;  [METHOD]  constructBeanSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  BeanDescription  beanDesc  [CLASS]  BeanSerializerFactory  [TYPE]  PropertyName  name  [TYPE]  Std  anyProp  [TYPE]  BeanSerializerBuilder  builder  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  AnnotatedMember  anyGetter  [TYPE]  BeanSerializerFactory  instance  [TYPE]  JsonSerializer  ser  [TYPE]  long  serialVersionUID  [TYPE]  JavaType  type  valueType  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  typeSer  [TYPE]  List  props  [TYPE]  MapSerializer  anySer  [TYPE]  SerializerProvider  prov  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  props  =  mod  .  orderProperties  (  config  ,  beanDesc  ,  props  )  ;  }  }      builder  .  setObjectIdWriter  (  constructObjectIdHandler  (  prov  ,  beanDesc  ,  props  )  )  ;  builder  .  setProperties  (  props  )  ;  builder  .  setFilterId  (  findFilterId  (  config  ,  beanDesc  )  )  ;  AnnotatedMember  anyGetter  =  beanDesc  .  findAnyGetter  (  )  ;  if  (  anyGetter  !  =  null  )  {  if  (  config  .  canOverrideAccessModifiers  (  )  )  {  anyGetter  .  fixAccess  (  )  ;  }  JavaType  type  =  anyGetter  .  getType  (  beanDesc  .  bindingsForBeanType  (  )  )  ;  boolean  staticTyping  =  config  .  isEnabled  (  MapperFeature  .  USE_STATIC_TYPING  )  ;  JavaType  valueType  =  type  .  getContentType  (  )  ;  TypeSerializer  typeSer  =  createTypeSerializer  (  config  ,  valueType  )  ;    [BUGGY]  MapSerializer  anySer  =  MapSerializer  .  construct  (  null  ,  type  ,  staticTyping  ,  typeSer  ,  null  ,  null  ,  null  )  ;    PropertyName  name  =  new  PropertyName  (  anyGetter  .  getName  (  )  )  ;  BeanProperty  .  Std  anyProp  =  new  BeanProperty  .  Std  (  name  ,  valueType  ,  null  ,  beanDesc  .  getClassAnnotations  (  )  ,  anyGetter  ,  PropertyMetadata  .  STD_OPTIONAL  )  ;  	JacksonDatabind_10_BeanSerializerFactory_1_1	395	1	src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java
1141	context  =  new  TypeBindings(this,  (Class<?>)  null);  	[BUGGY]  return  _unknownType  (  )  ;  [FE]  AssertionFailedError:  expected:<interface  javalangCharSequence>  but  was:<class  javalangObject>  assertEquals  (  CharSequence  .  class  ,  t  .  getRawClass  (  )  )  ;  [METHOD]  _fromVariable  [TYPE]  JavaType  [PARAMETER]  TypeVariable<?>  type  TypeBindings  context  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  HierarchicType  _cachedArrayListType  _cachedHashMapType  [TYPE]  Type[]  bounds  [TYPE]  String  name  [TYPE]  long  serialVersionUID  [TYPE]  TypeBindings  context  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_STRING  [TYPE]  JavaType  actualType  [TYPE]  boolean  false  true  [TYPE]  TypeVariable  type  [TYPE]  LRUMap  _typeCache  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  TypeFactory  instance  [CONTEXT]  protected  JavaType  _fromVariable  (  TypeVariable<?>  type  ,  TypeBindings  context  )  {  final  String  name  =  type  .  getName  (  )  ;  if  (  context  =  =  null  )  {  [BUGGY]  return  _unknownType  (  )  ;  }  else  {      	JacksonDatabind_11_TypeFactory_2_1	895	1	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1142	JavaType  actualType  =  context.findType(name,  false);  	[BUGGY]  JavaType  actualType  =  context  .  findType  (  name  )  ;  [FE]  AssertionFailedError:  expected:<interface  javalangCharSequence>  but  was:<class  javalangObject>  assertEquals  (  CharSequence  .  class  ,  t  .  getRawClass  (  )  )  ;  [METHOD]  _fromVariable  [TYPE]  JavaType  [PARAMETER]  TypeVariable<?>  type  TypeBindings  context  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  HierarchicType  _cachedArrayListType  _cachedHashMapType  [TYPE]  Type[]  bounds  [TYPE]  String  name  [TYPE]  long  serialVersionUID  [TYPE]  TypeBindings  context  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_STRING  [TYPE]  JavaType  actualType  [TYPE]  boolean  false  true  [TYPE]  TypeVariable  type  [TYPE]  LRUMap  _typeCache  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  TypeFactory  instance  [CONTEXT]  protected  JavaType  _fromVariable  (  TypeVariable<?>  type  ,  TypeBindings  context  )  {  final  String  name  =  type  .  getName  (  )  ;  if  (  context  =  =  null  )  {  return  _unknownType  (  )  ;  }  else  {      [BUGGY]  JavaType  actualType  =  context  .  findType  (  name  )  ;  if  (  actualType  !  =  null  )  {  return  actualType  ;  }  }  	JacksonDatabind_11_TypeFactory_2_2	902	1	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1143	return  (_valueDeserializer  ==  null)  &&  (_keyDeserializer  ==  null)  &&  (_valueTypeDeserializer  ==  null)  	[BUGGY]  return  (  _valueTypeDeserializer  =  =  null  )  [FE]  AssertionFailedError:  expected:<1>  but  was:<100>  assertEquals  (  1  ,  bean  .  map2  .  get  (   "a "  )  .  intValue  (  )  )  ;  [METHOD]  isCachable  [TYPE]  boolean  [PARAMETER]  [CLASS]  MapDeserializer  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  JsonDeserializer  _delegateDeserializer  _valueDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  KeyDeserializer  _keyDeserializer  [TYPE]  JavaType  _mapType  [TYPE]  boolean  _hasDefaultCreator  _standardStringKey  false  true  [TYPE]  MapReferringAccumulator  _parent  [TYPE]  Class  _valueType  [TYPE]  List  _accumulator  [TYPE]  Object  key  [TYPE]  TypeDeserializer  _valueTypeDeserializer  [TYPE]  Map  _result  next  [TYPE]  HashSet  _ignorableProperties  [CONTEXT]  public  boolean  isCachable  (  )  {    [BUGGY]  return  (  _valueTypeDeserializer  =  =  null  )  &&  (  _ignorableProperties  =  =  null  )  ;  }  	JacksonDatabind_12_MapDeserializer_1_1	303	1	src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java
1144	if  (id  ==  null)  {  return  null;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  (  was  javalangNullPointerException  )    (  through  reference  chain:  comfasterxmljacksondatabindstructIdentifiable[ "id "]  )  assertEquals  (  3  ,  value  .  value  )  ;  [METHOD]  findObjectId  [TYPE]  ReadableObjectId  [PARAMETER]  Object  id  ObjectIdGenerator<?>  gen  ObjectIdResolver  resolverType  [CLASS]  DefaultDeserializationContext  [TYPE]  ObjectIdGenerator  gen  [TYPE]  ReadableObjectId  entry  [TYPE]  boolean  false  true  [TYPE]  IdKey  key  [TYPE]  List  _objectIdResolvers  [TYPE]  Object  id  [TYPE]  ObjectIdResolver  res  resolver  resolverType  [TYPE]  long  serialVersionUID  [TYPE]  LinkedHashMap  _objectIds  [CONTEXT]  public  ReadableObjectId  findObjectId  (  Object  id  ,  ObjectIdGenerator<?>  gen  ,  ObjectIdResolver  resolverType  )  {    [BUGGY]  final  ObjectIdGenerator  .  IdKey  key  =  gen  .  key  (  id  )  ;  if  (  _objectIds  =  =  null  )  {  _objectIds  =  new  LinkedHashMap<ObjectIdGenerator  .  IdKey  ,  ReadableObjectId>  (  )  ;  }  else  {  	JacksonDatabind_13_DefaultDeserializationContext_1_1	87	0	src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java
1145	if  (id  ==  null)  {  return  null;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  (  was  javalangNullPointerException  )    (  through  reference  chain:  comfasterxmljacksondatabindstructIdentifiable[ "id "]  )  assertEquals  (  3  ,  value  .  value  )  ;  [METHOD]  deserializeSetAndReturn  [TYPE]  Object  [PARAMETER]  JsonParser  jp  DeserializationContext  ctxt  Object  instance  [CLASS]  ObjectIdValueProperty  [TYPE]  ReadableObjectId  roid  [TYPE]  boolean  false  true  [TYPE]  SettableBeanProperty  idProp  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  id  instance  [TYPE]  long  serialVersionUID  [TYPE]  JsonParser  jp  [CONTEXT]  public  Object  deserializeSetAndReturn  (  JsonParser  jp  ,  DeserializationContext  ctxt  ,  Object  instance  )  throws  IOException  {  Object  id  =  _valueDeserializer  .  deserialize  (  jp  ,  ctxt  )  ;        [BUGGY]  ReadableObjectId  roid  =  ctxt  .  findObjectId  (  id  ,  _objectIdReader  .  generator  ,  _objectIdReader  .  resolver  )  ;  roid  .  bindItem  (  instance  )  ;  SettableBeanProperty  idProp  =  _objectIdReader  .  idProperty  ;  if  (  idProp  !  =  null  )  {  return  idProp  .  setAndReturn  (  instance  ,  id  )  ;  }  return  instance  ;  }  	JacksonDatabind_13_ObjectIdValueProperty_1_1	92	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java
1146	JsonDeserializer<Object>  deser  =  _findTreeDeserializer(ctxt);  	[BUGGY]  JsonDeserializer<Object>  deser  =  _findRootDeserializer  (  ctxt  ,  JSON_NODE_TYPE  )  ;  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "i "  (  class  comfasterxmljacksondatabindconvertTestUpdateValue$DataB  )  ,  not  marked  as  ignorable  (  2  known  properties:   "da "  ,   "k "]  )  assertEquals  (  13  ,  dbUpdViaNode  .  k  )  ;  [METHOD]  _bindAsTree  [TYPE]  JsonNode  [PARAMETER]  JsonParser  jp  [CLASS]  ObjectReader  [TYPE]  RootNameLookup  _rootNames  [TYPE]  DefaultDeserializationContext  _context  [TYPE]  FormatSchema  _schema  [TYPE]  JsonFactory  _parserFactory  [TYPE]  DeserializationConfig  _config  [TYPE]  DataFormatReaders  _dataFormatReaders  [TYPE]  JsonNode  result  [TYPE]  JsonDeserializer  _rootDeserializer  deser  [TYPE]  InjectableValues  _injectableValues  [TYPE]  long  serialVersionUID  [TYPE]  JavaType  JSON_NODE_TYPE  _valueType  [TYPE]  boolean  _unwrapRoot  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  _valueToUpdate  [TYPE]  JsonToken  t  [TYPE]  ConcurrentHashMap  _rootDeserializers  [TYPE]  JsonParser  jp  [CONTEXT]  protected  JsonNode  _bindAsTree  (  JsonParser  jp  )  throws  IOException  {  JsonNode  result  ;  JsonToken  t  =  _initForReading  (  jp  )  ;  if  (  t  =  =  JsonToken  .  VALUE_NULL  ||  t  =  =  JsonToken  .  END_ARRAY  ||  t  =  =  JsonToken  .  END_OBJECT  )  {  result  =  NullNode  .  instance  ;  }  else  {  DeserializationContext  ctxt  =  createDeserializationContext  (  jp  ,  _config  )  ;  [BUGGY]  JsonDeserializer<Object>  deser  =  _findRootDeserializer  (  ctxt  ,  JSON_NODE_TYPE  )  ;  if  (  _unwrapRoot  )  {  result  =  (  JsonNode  )  _unwrapAndDeserialize  (  jp  ,  ctxt  ,  JSON_NODE_TYPE  ,  deser  )  ;  }  else  {  result  =  (  JsonNode  )  deser  .  deserialize  (  jp  ,  ctxt  )  ;  }  }  jp  .  clearCurrentToken  (  )  ;  return  result  ;  }  	JacksonDatabind_14_ObjectReader_2_1	1476	1	src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
1147	protected  JsonDeserializer<Object>  _findTreeDeserializer(DeserializationContext  ctxt)  throws  JsonMappingException  {  JsonDeserializer<Object>  deser  =  _rootDeserializers.get(JSON_NODE_TYPE);  if  (deser  ==  null)  {  deser  =  ctxt.findRootValueDeserializer(JSON_NODE_TYPE);  if  (deser  ==  null)  {    throw  new  JsonMappingException( "Can  not  find  a  deserializer  for  type   "+JSON_NODE_TYPE);  }  _rootDeserializers.put(JSON_NODE_TYPE,  deser);  }  return  deser;  }  	[BUGGY]  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "i "  (  class  comfasterxmljacksondatabindconvertTestUpdateValue$DataB  )  ,  not  marked  as  ignorable  (  2  known  properties:   "da "  ,   "k "]  )  assertEquals  (  13  ,  dbUpdViaNode  .  k  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_14_ObjectReader_2_2	1577	0	src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
1148	public  final  boolean  isJavaLangObject()  {  return  _class  ==  Object.class;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_15_JavaType_1_1	302	0	src/main/java/com/fasterxml/jackson/databind/JavaType.java
1149	if  (ser  ==  null  &&  !delegateType.isJavaLangObject())  {  	[BUGGY]  if  (  ser  =  =  null  )  {  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  createSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  origType  [CLASS]  BeanSerializerFactory  [TYPE]  JavaType  delegateType  origType  type  [TYPE]  boolean  false  staticTyping  true  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  BeanSerializerFactory  instance  [TYPE]  Converter  conv  [TYPE]  JsonSerializer  ser  [TYPE]  SerializerProvider  prov  [TYPE]  long  serialVersionUID  [CONTEXT]  boolean  staticTyping  ;  JavaType  type  =  modifyTypeByAnnotation  (  config  ,  beanDesc  .  getClassInfo  (  )  ,  origType  )  ;  if  (  type  =  =  origType  )  {  //  no  changes  ,  won't  force  static  typing  staticTyping  =  false  ;  }  else  {  //  changes  ;  assume  static  typing  ;  plus  ,  need  to  re-introspect  if  class  differs  staticTyping  =  true  ;  if  (  !type  .  hasRawClass  (  origType  .  getRawClass  (  )  )  )  {  beanDesc  =  config  .  introspect  (  type  )  ;  }  }  Converter<Object  ,  Object>  conv  =  beanDesc  .  findSerializationConverter  (  )  ;  if  (  conv  =  =  null  )  {  //  no  ,  simple  return  (  JsonSerializer<Object>  )  _createSerializer2  (  prov  ,  type  ,  beanDesc  ,  staticTyping  )  ;  }  JavaType  delegateType  =  conv  .  getOutputType  (  prov  .  getTypeFactory  (  )  )  ;    if  (  !delegateType  .  hasRawClass  (  type  .  getRawClass  (  )  )  )  {  beanDesc  =  config  .  introspect  (  delegateType  )  ;  ser  =  findSerializerFromAnnotation  (  prov  ,  beanDesc  .  getClassInfo  (  )  )  ;  }  [BUGGY]  if  (  ser  =  =  null  )  {  ser  =  _createSerializer2  (  prov  ,  delegateType  ,  beanDesc  ,  true  )  ;  }  return  new  StdDelegatingSerializer  (  conv  ,  delegateType  ,  ser  )  ;  }  	JacksonDatabind_15_BeanSerializerFactory_1_1	163	1	src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java
1150	JsonSerializer<?>  ser  =  delegateType.isJavaLangObject()  ?  null  :  provider.findValueSerializer(delegateType,  prop);  	[BUGGY]  JsonSerializer<?>  ser  =  provider  .  findValueSerializer  (  delegateType  ,  prop  )  ;  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  findConvertingSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  provider  BeanPropertyWriter  prop  [CLASS]  BeanSerializerBase  [TYPE]  PropertyName  NAME_FOR_OBJECT_REF  [TYPE]  Shape  _serializationShape  [TYPE]  AnnotatedMember  _typeId  m  [TYPE]  AnnotationIntrospector  intr  [TYPE]  JsonSerializer  ser  [TYPE]  BeanPropertyWriter[]  NO_PROPS  _filteredProps  _props  [TYPE]  AnyGetterWriter  _anyGetterWriter  [TYPE]  JavaType  delegateType  [TYPE]  ObjectIdWriter  _objectIdWriter  [TYPE]  boolean  false  true  [TYPE]  Converter  conv  [TYPE]  Object  _propertyFilterId  convDef  [TYPE]  SerializerProvider  provider  [TYPE]  BeanPropertyWriter  prop  [CONTEXT]  protected  JsonSerializer<Object>  findConvertingSerializer  (  SerializerProvider  provider  ,  BeanPropertyWriter  prop  )  throws  JsonMappingException  {  final  AnnotationIntrospector  intr  =  provider  .  getAnnotationIntrospector  (  )  ;  if  (  intr  !  =  null  )  {  AnnotatedMember  m  =  prop  .  getMember  (  )  ;  if  (  m  !  =  null  )  {  Object  convDef  =  intr  .  findSerializationConverter  (  m  )  ;  if  (  convDef  !  =  null  )  {  Converter<Object  ,  Object>  conv  =  provider  .  converterInstance  (  prop  .  getMember  (  )  ,  convDef  )  ;  JavaType  delegateType  =  conv  .  getOutputType  (  provider  .  getTypeFactory  (  )  )  ;  [BUGGY]  JsonSerializer<?>  ser  =  provider  .  findValueSerializer  (  delegateType  ,  prop  )  ;  return  new  StdDelegatingSerializer  (  conv  ,  delegateType  ,  ser  )  ;  }  }  }  return  null  ;  }  	JacksonDatabind_15_BeanSerializerBase_1_1	370	1	src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java
1151	if  (!delegateType.isJavaLangObject())  {  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  provider  BeanProperty  property  [CLASS]  StdDelegatingSerializer  [TYPE]  Converter  _converter  [TYPE]  JavaType  _delegateType  delegateType  [TYPE]  JsonSerializer  _delegateSerializer  delSer  [TYPE]  boolean  false  true  [TYPE]  SerializerProvider  provider  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonSerializer<?>  createContextual  (  SerializerProvider  provider  ,  BeanProperty  property  )  throws  JsonMappingException  {  JsonSerializer<?>  delSer  =  _delegateSerializer  ;  JavaType  delegateType  =  _delegateType  ;  if  (  delSer  =  =  null  )  {  if  (  delegateType  =  =  null  )  {  delegateType  =  _converter  .  getOutputType  (  provider  .  getTypeFactory  (  )  )  ;  }    [BUGGY]  delSer  =  provider  .  findValueSerializer  (  delegateType  )  ;  }  if  (  delSer  instanceof  ContextualSerializer  )  {  delSer  =  provider  .  handleSecondaryContextualization  (  delSer  ,  property  )  ;  }  return  (  delSer  =  =  _delegateSerializer  )  ?  this  :  withDelegate  (  _converter  ,  delegateType  ,  delSer  )  ;  }  	JacksonDatabind_15_StdDelegatingSerializer_8_1	121	0	src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java
1152	if  (delSer  ==  _delegateSerializer  &&  delegateType  ==  _delegateType)  {  return  this;  }  return  withDelegate(_converter,  delegateType,  delSer);  	[BUGGY]  return  (  delSer  =  =  _delegateSerializer  )  ?  this  :  withDelegate  (  _converter  ,  delegateType  ,  delSer  )  ;  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  provider  BeanProperty  property  [CLASS]  StdDelegatingSerializer  [TYPE]  Converter  _converter  [TYPE]  JavaType  _delegateType  delegateType  [TYPE]  JsonSerializer  _delegateSerializer  delSer  [TYPE]  boolean  false  true  [TYPE]  SerializerProvider  provider  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonSerializer<?>  createContextual  (  SerializerProvider  provider  ,  BeanProperty  property  )  throws  JsonMappingException  {  JsonSerializer<?>  delSer  =  _delegateSerializer  ;  JavaType  delegateType  =  _delegateType  ;  if  (  delSer  =  =  null  )  {  if  (  delegateType  =  =  null  )  {  delegateType  =  _converter  .  getOutputType  (  provider  .  getTypeFactory  (  )  )  ;  }    delSer  =  provider  .  findValueSerializer  (  delegateType  )  ;  }  if  (  delSer  instanceof  ContextualSerializer  )  {  delSer  =  provider  .  handleSecondaryContextualization  (  delSer  ,  property  )  ;  }  [BUGGY]  return  (  delSer  =  =  _delegateSerializer  )  ?  this  :  withDelegate  (  _converter  ,  delegateType  ,  delSer  )  ;  }  	JacksonDatabind_15_StdDelegatingSerializer_8_2	126	2	src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java
1153	JsonSerializer<Object>  ser  =  _delegateSerializer;  if  (ser  ==  null)  {  ser  =  _findSerializer(delegateValue,  provider);  }  ser.serialize(delegateValue,  gen,  provider);  	[BUGGY]  _delegateSerializer  .  serialize  (  delegateValue  ,  gen  ,  provider  )  ;  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  serialize  [TYPE]  void  [PARAMETER]  Object  value  JsonGenerator  gen  SerializerProvider  provider  [CLASS]  StdDelegatingSerializer  [TYPE]  JavaType  _delegateType  [TYPE]  boolean  false  true  [TYPE]  Converter  _converter  [TYPE]  JsonGenerator  gen  [TYPE]  Object  delegateValue  value  [TYPE]  JsonSerializer  _delegateSerializer  [TYPE]  SerializerProvider  provider  [CONTEXT]  public  void  serialize  (  Object  value  ,  JsonGenerator  gen  ,  SerializerProvider  provider  )  throws  IOException  {  Object  delegateValue  =  convertValue  (  value  )  ;  if  (  delegateValue  =  =  null  )  {  provider  .  defaultSerializeNull  (  gen  )  ;  return  ;  }  [BUGGY]  _delegateSerializer  .  serialize  (  delegateValue  ,  gen  ,  provider  )  ;  }  	JacksonDatabind_15_StdDelegatingSerializer_8_3	161	1	src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java
1154	JsonSerializer<Object>  ser  =  _delegateSerializer;  if  (ser  ==  null)  {  ser  =  _findSerializer(value,  provider);  }  ser.serializeWithType(delegateValue,  gen,  provider,  typeSer);  	[BUGGY]  _delegateSerializer  .  serializeWithType  (  delegateValue  ,  gen  ,  provider  ,  typeSer  )  ;  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  serializeWithType  [TYPE]  void  [PARAMETER]  Object  value  JsonGenerator  gen  SerializerProvider  provider  TypeSerializer  typeSer  [CLASS]  StdDelegatingSerializer  [TYPE]  JavaType  _delegateType  [TYPE]  boolean  false  true  [TYPE]  TypeSerializer  typeSer  [TYPE]  Converter  _converter  [TYPE]  JsonGenerator  gen  [TYPE]  Object  delegateValue  value  [TYPE]  JsonSerializer  _delegateSerializer  [TYPE]  SerializerProvider  provider  [CONTEXT]  public  void  serializeWithType  (  Object  value  ,  JsonGenerator  gen  ,  SerializerProvider  provider  ,  TypeSerializer  typeSer  )  throws  IOException  {    Object  delegateValue  =  convertValue  (  value  )  ;  [BUGGY]  _delegateSerializer  .  serializeWithType  (  delegateValue  ,  gen  ,  provider  ,  typeSer  )  ;  }  	JacksonDatabind_15_StdDelegatingSerializer_8_4	172	1	src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java
1155	if  (_delegateSerializer  ==  null)  {    return  (value  ==  null);  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  isEmpty  [TYPE]  boolean  [PARAMETER]  Object  value  [CLASS]  StdDelegatingSerializer  [TYPE]  Converter  _converter  [TYPE]  JavaType  _delegateType  [TYPE]  Object  delegateValue  value  [TYPE]  JsonSerializer  _delegateSerializer  [TYPE]  boolean  false  true  [CONTEXT]  public  boolean  isEmpty  (  Object  value  )  {  Object  delegateValue  =  convertValue  (  value  )  ;  [BUGGY]  return  _delegateSerializer  .  isEmpty  (  delegateValue  )  ;  }  	JacksonDatabind_15_StdDelegatingSerializer_8_5	180	0	src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java
1156	if  (_delegateSerializer  ==  null)  {    return  (value  ==  null);  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  isEmpty  [TYPE]  boolean  [PARAMETER]  SerializerProvider  prov  Object  value  [CLASS]  StdDelegatingSerializer  [TYPE]  Converter  _converter  [TYPE]  JavaType  _delegateType  [TYPE]  Object  delegateValue  value  [TYPE]  JsonSerializer  _delegateSerializer  [TYPE]  boolean  false  true  [TYPE]  SerializerProvider  prov  [CONTEXT]  public  boolean  isEmpty  (  SerializerProvider  prov  ,  Object  value  )  {  Object  delegateValue  =  convertValue  (  value  )  ;  [BUGGY]  return  _delegateSerializer  .  isEmpty  (  prov  ,  delegateValue  )  ;  }  	JacksonDatabind_15_StdDelegatingSerializer_8_6	187	0	src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java
1157	if  (_delegateSerializer  !=  null)  {  _delegateSerializer.acceptJsonFormatVisitor(visitor,  typeHint);  }  	[BUGGY]  _delegateSerializer  .  acceptJsonFormatVisitor  (  visitor  ,  typeHint  )  ;  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  acceptJsonFormatVisitor  [TYPE]  void  [PARAMETER]  JsonFormatVisitorWrapper  visitor  JavaType  typeHint  [CLASS]  StdDelegatingSerializer  [TYPE]  Converter  _converter  [TYPE]  JavaType  _delegateType  typeHint  [TYPE]  JsonSerializer  _delegateSerializer  [TYPE]  boolean  false  true  [TYPE]  JsonFormatVisitorWrapper  visitor  [CONTEXT]  public  void  acceptJsonFormatVisitor  (  JsonFormatVisitorWrapper  visitor  ,  JavaType  typeHint  )  throws  JsonMappingException  {      [BUGGY]  _delegateSerializer  .  acceptJsonFormatVisitor  (  visitor  ,  typeHint  )  ;  }  	JacksonDatabind_15_StdDelegatingSerializer_8_7	224	1	src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java
1158	protected  JsonSerializer<Object>  _findSerializer(Object  value,  SerializerProvider  serializers)  throws  JsonMappingException  {  return  serializers.findValueSerializer(value.getClass());  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_15_StdDelegatingSerializer_8_8	256	0	src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java
1159	if  (existingSerializer  ==  null  &&  !delegateType.hasRawClass(Object.class))  {  	[BUGGY]  if  (  existingSerializer  =  =  null  )  {  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindconvertTestConvertingSerializer$DummyBean  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertEquals  (   "{\ "a\ ":2  ,  \ "b\ ":4} "  ,  json  )  ;  [METHOD]  findConvertingContentSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  provider  BeanProperty  prop  JsonSerializer<?>  existingSerializer  [CLASS]  StdSerializer  [TYPE]  JavaType  delegateType  [TYPE]  boolean  false  true  [TYPE]  AnnotationIntrospector  intr  [TYPE]  AnnotatedMember  m  [TYPE]  Converter  conv  [TYPE]  Class  _handledType  [TYPE]  Object  convDef  [TYPE]  JsonSerializer  existingSerializer  [TYPE]  SerializerProvider  provider  [TYPE]  long  serialVersionUID  [TYPE]  BeanProperty  prop  [CONTEXT]  protected  JsonSerializer<?>  findConvertingContentSerializer  (  SerializerProvider  provider  ,  BeanProperty  prop  ,  JsonSerializer<?>  existingSerializer  )  throws  JsonMappingException  {      final  AnnotationIntrospector  intr  =  provider  .  getAnnotationIntrospector  (  )  ;  if  (  intr  !  =  null  &&  prop  !  =  null  )  {  AnnotatedMember  m  =  prop  .  getMember  (  )  ;  if  (  m  !  =  null  )  {  Object  convDef  =  intr  .  findSerializationContentConverter  (  m  )  ;  if  (  convDef  !  =  null  )  {  Converter<Object  ,  Object>  conv  =  provider  .  converterInstance  (  prop  .  getMember  (  )  ,  convDef  )  ;  JavaType  delegateType  =  conv  .  getOutputType  (  provider  .  getTypeFactory  (  )  )  ;  [BUGGY]  if  (  existingSerializer  =  =  null  )  {  existingSerializer  =  provider  .  findValueSerializer  (  delegateType  )  ;  }  return  new  StdDelegatingSerializer  (  conv  ,  delegateType  ,  existingSerializer  )  ;  }  }  }  return  existingSerializer  ;  }  	JacksonDatabind_15_StdSerializer_1_1	262	1	src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java
1160	return  (previous  ==  null)  ||  !previous.equals(ann);  	[BUGGY]  return  (  previous  !  =  null  )  &&  previous  .  equals  (  ann  )  ;  [FE]  ComparisonFailure:  expected:<{ "[bar] ": "result "}>  but  was:<{ "[stuff] ": "result "}>  assertEquals  (   "{\ "bar\ ":\ "result\ "} "  ,  result  )  ;  [METHOD]  _add  [TYPE]  boolean  [PARAMETER]  Annotation  ann  [CLASS]  AnnotationMap  [TYPE]  HashMap  _annotations  [TYPE]  Annotation  ann  previous  [TYPE]  boolean  false  true  [CONTEXT]  protected  final  boolean  _add  (  Annotation  ann  )  {  if  (  _annotations  =  =  null  )  {  _annotations  =  new  HashMap<Class<?  extends  Annotation>  ,  Annotation>  (  )  ;  }  Annotation  previous  =  _annotations  .  put  (  ann  .  annotationType  (  )  ,  ann  )  ;  [BUGGY]  return  (  previous  !  =  null  )  &&  previous  .  equals  (  ann  )  ;  }  	JacksonDatabind_16_AnnotationMap_1_1	112	1	src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java
1161	&&  !TreeNode.class.isAssignableFrom(t.getRawClass()));  	[BUGGY]  ||  TreeNode  .  class  .  isAssignableFrom  (  t  .  getRawClass  (  )  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Unexpected  token  (  VALUE_NUMBER_INT  )  ,  expected  VALUE_STRING:  need  JSON  String  that  contains  type  id  (  for  subtype  of  comfasterxmljacksondatabindJsonNode  )  assertEquals  (  2  ,  obj  .  path  (   "a "  )  .  asInt  (  )  )  ;  [METHOD]  useForType  [TYPE]  boolean  [PARAMETER]  JavaType  t  [CLASS]  DefaultTypeResolverBuilder  [TYPE]  JavaType  t  [TYPE]  boolean  false  true  [TYPE]  DefaultTyping  _appliesFor  [TYPE]  long  serialVersionUID  [CONTEXT]  public  boolean  useForType  (  JavaType  t  )  {  switch  (  _appliesFor  )  {  case  NON_CONCRETE_AND_ARRAYS:  while  (  t  .  isArrayType  (  )  )  {  t  =  t  .  getContentType  (  )  ;  }  case  OBJECT_AND_NON_CONCRETE:  return  (  t  .  getRawClass  (  )  =  =  Object  .  class  )  ||  (  !t  .  isConcrete  (  )    [BUGGY]  ||  TreeNode  .  class  .  isAssignableFrom  (  t  .  getRawClass  (  )  )  )  ;  case  NON_FINAL:  while  (  t  .  isArrayType  (  )  )  {  t  =  t  .  getContentType  (  )  ;  }  return  !t  .  isFinal  (  )  &&  !TreeNode  .  class  .  isAssignableFrom  (  t  .  getRawClass  (  )  )  ;  default:    return  (  t  .  getRawClass  (  )  =  =  Object  .  class  )  ;  }  }  	JacksonDatabind_17_ObjectMapper_1_1	180	1	src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
1162	protected  final  static  int  STATE_CLOSED  =  0;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_1	28	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1163	protected  final  static  int  STATE_NEED_RESYNC  =  1;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_2	32	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1164	protected  final  static  int  STATE_MAY_HAVE_VALUE  =  2;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_3	37	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1165	protected  final  static  int  STATE_HAS_VALUE  =  3;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_4	42	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1166	protected  final  JsonParser  _parser;  	[BUGGY]  protected  JsonParser  _parser  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_5	69	1	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1167	protected  final  JsonStreamContext  _seqContext;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_6	75	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1168	protected  int  _state;  	[BUGGY]  protected  boolean  _hasNextChecked  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_7	98	1	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1169	if  (p  ==  null)  {    _seqContext  =  null;  _state  =  STATE_CLOSED;  }  else  {  JsonStreamContext  sctxt  =  p.getParsingContext();  if  (managedParser  &&  p.isExpectedStartArrayToken())  {  }  else  {  	[BUGGY]  if  (  managedParser  &&  (  p  !  =  null  )  &&  p  .  isExpectedStartArrayToken  (  )  )  {  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_8	138	1	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1170	JsonToken  t  =  p.getCurrentToken();  if  ((t  ==  JsonToken.START_OBJECT)  ||  (t  ==  JsonToken.START_ARRAY))  {  sctxt  =  sctxt.getParent();  }  }  _seqContext  =  sctxt;  _state  =  STATE_MAY_HAVE_VALUE;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_9	144	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1171	if  (_state  !=  STATE_CLOSED)  {  _state  =  STATE_CLOSED;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [METHOD]  close  [TYPE]  void  [PARAMETER]  [CLASS]  MappingIterator  [TYPE]  MappingIterator  EMPTY_ITERATOR  [TYPE]  JavaType  _type  [TYPE]  boolean  _closeParser  _hasNextChecked  false  true  [TYPE]  T  _updatedValue  [TYPE]  DeserializationContext  _context  [TYPE]  JsonDeserializer  _deserializer  [TYPE]  JsonParser  _parser  [CONTEXT]  public  void  close  (  )  throws  IOException  {  [BUGGY]  if  (  _parser  !  =  null  )  {  _parser  .  close  (  )  ;  }  }  	JacksonDatabind_18_MappingIterator_18_10	189	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1172	}  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_11	192	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1173	switch  (_state)  {  case  STATE_CLOSED:  case  STATE_NEED_RESYNC:  _resync();  case  STATE_MAY_HAVE_VALUE:  	[BUGGY]  if  (  _parser  =  =  null  )  {  }  if  (  !_hasNextChecked  )  {  _hasNextChecked  =  true  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [METHOD]  hasNextValue  [TYPE]  boolean  [PARAMETER]  [CLASS]  MappingIterator  [TYPE]  MappingIterator  EMPTY_ITERATOR  [TYPE]  JavaType  _type  [TYPE]  boolean  _closeParser  _hasNextChecked  false  true  [TYPE]  T  _updatedValue  [TYPE]  DeserializationContext  _context  [TYPE]  JsonToken  t  [TYPE]  JsonDeserializer  _deserializer  [TYPE]  JsonParser  _parser  jp  [CONTEXT]  public  boolean  hasNextValue  (  )  throws  IOException  {  [BUGGY]  if  (  _parser  =  =  null  )  {  return  false  ;  }  if  (  !_hasNextChecked  )  {  JsonToken  t  =  _parser  .  getCurrentToken  (  )  ;  _hasNextChecked  =  true  ;  if  (  t  =  =  null  )  {  //  un-initialized  or  cleared  ;  find  next  t  =  _parser  .  nextToken  (  )  ;  if  (  t  =  =  null  ||  t  =  =  JsonToken  .  END_ARRAY  )  {  JsonParser  jp  =  _parser  ;  _parser  =  null  ;  if  (  _closeParser  )  {  jp  .  close  (  )  ;  }  return  false  ;  }  }  }  return  true  ;  }  	JacksonDatabind_18_MappingIterator_18_12	210	4	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1174	_state  =  STATE_CLOSED;  if  (_closeParser  &&  (_parser  !=  null))  {  _parser.close();  	[BUGGY]  JsonParser  jp  =  _parser  ;  _parser  =  null  ;  if  (  _closeParser  )  {  jp  .  close  (  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [METHOD]  hasNextValue  [TYPE]  boolean  [PARAMETER]  [CLASS]  MappingIterator  [TYPE]  MappingIterator  EMPTY_ITERATOR  [TYPE]  JavaType  _type  [TYPE]  boolean  _closeParser  _hasNextChecked  false  true  [TYPE]  T  _updatedValue  [TYPE]  DeserializationContext  _context  [TYPE]  JsonToken  t  [TYPE]  JsonDeserializer  _deserializer  [TYPE]  JsonParser  _parser  jp  [CONTEXT]  public  boolean  hasNextValue  (  )  throws  IOException  {  if  (  _parser  =  =  null  )  {  return  false  ;  }  if  (  !_hasNextChecked  )  {  JsonToken  t  =  _parser  .  getCurrentToken  (  )  ;  _hasNextChecked  =  true  ;  if  (  t  =  =  null  )  {  //  un-initialized  or  cleared  ;  find  next  t  =  _parser  .  nextToken  (  )  ;  if  (  t  =  =  null  ||  t  =  =  JsonToken  .  END_ARRAY  )  {  [BUGGY]  JsonParser  jp  =  _parser  ;  _parser  =  null  ;  if  (  _closeParser  )  {  jp  .  close  (  )  ;  }  return  false  ;  }  }  }  return  true  ;  }  	JacksonDatabind_18_MappingIterator_18_13	221	4	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1175	_state  =  STATE_HAS_VALUE;  return  true;  case  STATE_HAS_VALUE:  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [METHOD]  hasNextValue  [TYPE]  boolean  [PARAMETER]  [CLASS]  MappingIterator  [TYPE]  MappingIterator  EMPTY_ITERATOR  [TYPE]  JavaType  _type  [TYPE]  boolean  _closeParser  _hasNextChecked  false  true  [TYPE]  T  _updatedValue  [TYPE]  DeserializationContext  _context  [TYPE]  JsonToken  t  [TYPE]  JsonDeserializer  _deserializer  [TYPE]  JsonParser  _parser  jp  [CONTEXT]  public  boolean  hasNextValue  (  )  throws  IOException  {  if  (  _parser  =  =  null  )  {  return  false  ;  }  if  (  !_hasNextChecked  )  {  JsonToken  t  =  _parser  .  getCurrentToken  (  )  ;  _hasNextChecked  =  true  ;  if  (  t  =  =  null  )  {  //  un-initialized  or  cleared  ;  find  next  t  =  _parser  .  nextToken  (  )  ;  if  (  t  =  =  null  ||  t  =  =  JsonToken  .  END_ARRAY  )  {  JsonParser  jp  =  _parser  ;  _parser  =  null  ;  if  (  _closeParser  )  {  jp  .  close  (  )  ;  }  return  false  ;  }  }  [BUGGY]  }  return  true  ;  }  	JacksonDatabind_18_MappingIterator_18_14	229	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1176	switch  (_state)  {  case  STATE_CLOSED:  return  _throwNoSuchElement();  case  STATE_NEED_RESYNC:    case  STATE_MAY_HAVE_VALUE:  	[BUGGY]  if  (  !_hasNextChecked  )  {  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [METHOD]  nextValue  [TYPE]  T  [PARAMETER]  [CLASS]  MappingIterator  [TYPE]  MappingIterator  EMPTY_ITERATOR  [TYPE]  JavaType  _type  [TYPE]  boolean  _closeParser  _hasNextChecked  false  true  [TYPE]  T  _updatedValue  value  [TYPE]  DeserializationContext  _context  [TYPE]  JsonDeserializer  _deserializer  [TYPE]  JsonParser  _parser  [CONTEXT]  public  T  nextValue  (  )  throws  IOException  {  [BUGGY]  if  (  !_hasNextChecked  )  {  if  (  !hasNextValue  (  )  )  {  return  _throwNoSuchElement  (  )  ;  }  }  if  (  _parser  =  =  null  )  {  return  _throwNoSuchElement  (  )  ;  }  _hasNextChecked  =  false  ;  try  {  T  value  ;  if  (  _updatedValue  =  =  null  )  {  value  =  _deserializer  .  deserialize  (  _parser  ,  _context  )  ;  }  else{  _deserializer  .  deserialize  (  _parser  ,  _context  ,  _updatedValue  )  ;  value  =  _updatedValue  ;  }  return  value  ;  }  finally  {      _parser  .  clearCurrentToken  (  )  ;  }  }  	JacksonDatabind_18_MappingIterator_18_15	236	1	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1177	break;  case  STATE_HAS_VALUE:  break;  int  nextState  =  STATE_NEED_RESYNC;  	[BUGGY]  if  (  _parser  =  =  null  )  {  return  _throwNoSuchElement  (  )  ;  }  _hasNextChecked  =  false  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [METHOD]  nextValue  [TYPE]  T  [PARAMETER]  [CLASS]  MappingIterator  [TYPE]  MappingIterator  EMPTY_ITERATOR  [TYPE]  JavaType  _type  [TYPE]  boolean  _closeParser  _hasNextChecked  false  true  [TYPE]  T  _updatedValue  value  [TYPE]  DeserializationContext  _context  [TYPE]  JsonDeserializer  _deserializer  [TYPE]  JsonParser  _parser  [CONTEXT]  public  T  nextValue  (  )  throws  IOException  {  if  (  !_hasNextChecked  )  {  if  (  !hasNextValue  (  )  )  {  return  _throwNoSuchElement  (  )  ;  }  [BUGGY]  }  if  (  _parser  =  =  null  )  {  return  _throwNoSuchElement  (  )  ;  }  _hasNextChecked  =  false  ;  try  {  T  value  ;  if  (  _updatedValue  =  =  null  )  {  value  =  _deserializer  .  deserialize  (  _parser  ,  _context  )  ;  }  else{  _deserializer  .  deserialize  (  _parser  ,  _context  ,  _updatedValue  )  ;  value  =  _updatedValue  ;  }  return  value  ;  }  finally  {      _parser  .  clearCurrentToken  (  )  ;  }  }  	JacksonDatabind_18_MappingIterator_18_16	240	4	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1178	nextState  =  STATE_MAY_HAVE_VALUE;  _state  =  nextState;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [METHOD]  nextValue  [TYPE]  T  [PARAMETER]  [CLASS]  MappingIterator  [TYPE]  MappingIterator  EMPTY_ITERATOR  [TYPE]  JavaType  _type  [TYPE]  boolean  _closeParser  _hasNextChecked  false  true  [TYPE]  T  _updatedValue  value  [TYPE]  DeserializationContext  _context  [TYPE]  JsonDeserializer  _deserializer  [TYPE]  JsonParser  _parser  [CONTEXT]  public  T  nextValue  (  )  throws  IOException  {  if  (  !_hasNextChecked  )  {  if  (  !hasNextValue  (  )  )  {  return  _throwNoSuchElement  (  )  ;  }  }  if  (  _parser  =  =  null  )  {  return  _throwNoSuchElement  (  )  ;  }  _hasNextChecked  =  false  ;  try  {  T  value  ;  if  (  _updatedValue  =  =  null  )  {  value  =  _deserializer  .  deserialize  (  _parser  ,  _context  )  ;  }  else{  _deserializer  .  deserialize  (  _parser  ,  _context  ,  _updatedValue  )  ;  value  =  _updatedValue  ;  }  [BUGGY]  return  value  ;  }  finally  {      _parser  .  clearCurrentToken  (  )  ;  }  }  	JacksonDatabind_18_MappingIterator_18_17	254	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1179	protected  void  _resync()  throws  IOException  {  final  JsonParser  p  =  _parser;  if  (p.getParsingContext()  ==  _seqContext)  {  return;  }  while  (true)  {  JsonToken  t  =  p.nextToken();  if  ((t  ==  JsonToken.END_ARRAY)  ||  (t  ==  JsonToken.END_OBJECT))  {  if  (p.getParsingContext()  ==  _seqContext)  {  p.clearCurrentToken();  return;  }  }  else  if  ((t  ==  JsonToken.START_ARRAY)  ||  (t  ==  JsonToken.START_OBJECT))  {  p.skipChildren();  }  else  if  (t  ==  null)  {  return;  }  }  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  instantiate  value  of  type  [simple  type  ,  class  comfasterxmljacksondatabindseqReadRecoveryTest$Bean]  from  Integral  number  (  1  )  ;  no  single-int-arg  constructor/factory  method  assertFalse  (  it  .  hasNextValue  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_18_MappingIterator_18_18	352	0	src/main/java/com/fasterxml/jackson/databind/MappingIterator.java
1180	if  (rawClass  ==  Properties.class)  {  return  MapType.construct(rawClass,  CORE_TYPE_STRING,  CORE_TYPE_STRING);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<129>  but  was:<null>  assertEquals  (   "129 "  ,  props  .  getProperty  (   "A "  )  )  ;  [METHOD]  _mapType  [TYPE]  JavaType  [PARAMETER]  Class<?>  rawClass  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_STRING  [TYPE]  TypeParser  _parser  [TYPE]  boolean  false  true  [TYPE]  HierarchicType  _cachedArrayListType  _cachedHashMapType  [TYPE]  LRUMap  _typeCache  [TYPE]  JavaType[]  NO_TYPES  typeParams  [TYPE]  Class  rawClass  [TYPE]  TypeFactory  instance  [TYPE]  long  serialVersionUID  [CONTEXT]  private  JavaType  _mapType  (  Class<?>  rawClass  )  {  [BUGGY]  JavaType[]  typeParams  =  findTypeParameters  (  rawClass  ,  Map  .  class  )  ;  if  (  typeParams  =  =  null  )  {  return  MapType  .  construct  (  rawClass  ,  _unknownType  (  )  ,  _unknownType  (  )  )  ;  }  if  (  typeParams  .  length  !  =  2  )  {  throw  new  IllegalArgumentException  (   "Strange  Map  type   "+rawClass  .  getName  (  )  + ":  can  not  determine  type  parameters "  )  ;  }  return  MapType  .  construct  (  rawClass  ,  typeParams[0]  ,  typeParams[1]  )  ;  }  	JacksonDatabind_19_TypeFactory_1_1	1021	0	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1181		[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Conflicting  setter  definitions  for  property   "all ":  comfasterxmljacksondatabindnodeObjectNode#setAll  (  1  params  )  vs  comfasterxmljacksondatabindnodeObjectNode#setAll  (  1  params  )  assertEquals  (   "bing "  ,  result  .  json  .  path  (   "baz "  )  .  asText  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_20_ObjectNode_2_1	4	0	src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java
1182	@JsonIgnore    	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Conflicting  setter  definitions  for  property   "all ":  comfasterxmljacksondatabindnodeObjectNode#setAll  (  1  params  )  vs  comfasterxmljacksondatabindnodeObjectNode#setAll  (  1  params  )  assertEquals  (   "bing "  ,  result  .  json  .  path  (   "baz "  )  .  asText  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_20_ObjectNode_2_2	324	0	src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java
1183		[BUGGY]  [FE]  ComparisonFailure:  expected:<[ "[b "  ,   "a] "]>  but  was:<[ "[B "  ,   "A] "]>  assertSame  (  EnumWithPropertyAnno  .  A  ,  result[1]  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_21_JacksonAnnotationIntrospector_3_1	4	0	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1184	@Override  public  String  findEnumValue(Enum<?>  value)  {  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[ "[b "  ,   "a] "]>  but  was:<[ "[B "  ,   "A] "]>  assertSame  (  EnumWithPropertyAnno  .  A  ,  result[1]  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_21_JacksonAnnotationIntrospector_3_2	64	0	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1185	try  {  Field  f  =  value.getClass().getField(value.name());  if  (f  !=  null)  {  JsonProperty  prop  =  f.getAnnotation(JsonProperty.class);  String  n  =  prop.value();  if  (n  !=  null  &&  !n.isEmpty())  {  return  n;  }  }  }  catch  (Exception  e)  {  }  return  value.name();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[ "[b "  ,   "a] "]>  but  was:<[ "[B "  ,   "A] "]>  assertSame  (  EnumWithPropertyAnno  .  A  ,  result[1]  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_21_JacksonAnnotationIntrospector_3_3	67	0	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1186	return  buildMapSerializer(prov,  (MapType)  mlt,  beanDesc,  staticTyping,  	[BUGGY]  return  buildMapSerializer  (  config  ,  (  MapType  )  mlt  ,  beanDesc  ,  staticTyping  ,  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildContainerSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  type  BeanDescription  beanDesc  boolean  staticTyping  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapLikeType  mlType  mlt  [TYPE]  JavaType  elementType  type  [TYPE]  CollectionLikeType  clType  clt  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  SerializerProvider  prov  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  if  (  !type  .  isContainerType  (  )  ||  type  .  getContentType  (  )  .  getRawClass  (  )  !  =  Object  .  class  )  {  staticTyping  =  true  ;  }  }  JavaType  elementType  =  type  .  getContentType  (  )  ;  TypeSerializer  elementTypeSerializer  =  createTypeSerializer  (  config  ,  elementType  )  ;    if  (  elementTypeSerializer  !  =  null  )  {  staticTyping  =  false  ;  }  JsonSerializer<Object>  elementValueSerializer  =  _findContentSerializer  (  prov  ,  beanDesc  .  getClassInfo  (  )  )  ;  if  (  type  .  isMapLikeType  (  )  )  {  //  implements  java  .  util  .  Map  MapLikeType  mlt  =  (  MapLikeType  )  type  ;      JsonSerializer<Object>  keySerializer  =  _findKeySerializer  (  prov  ,  beanDesc  .  getClassInfo  (  )  )  ;  if  (  mlt  .  isTrueMapType  (  )  )  {  [BUGGY]  return  buildMapSerializer  (  config  ,  (  MapType  )  mlt  ,  beanDesc  ,  staticTyping  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  JsonSerializer<?>  ser  =  null  ;  for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  	JacksonDatabind_22_BasicSerializerFactory_16_1	580	1	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1187	MapLikeType  mlType  =  (MapLikeType)  type;  if  (ser  !=  null)  {  break;  }  }  if  (ser  ==  null)  {    ser  =  findSerializerByAnnotations(prov,  type,  beanDesc);  }  	[BUGGY]  MapLikeType  mlType  =  (  MapLikeType  )  type  ;  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildContainerSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  type  BeanDescription  beanDesc  boolean  staticTyping  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapLikeType  mlType  mlt  [TYPE]  JavaType  elementType  type  [TYPE]  CollectionLikeType  clType  clt  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  SerializerProvider  prov  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  JavaType  elementType  =  type  .  getContentType  (  )  ;  TypeSerializer  elementTypeSerializer  =  createTypeSerializer  (  config  ,  elementType  )  ;    if  (  elementTypeSerializer  !  =  null  )  {  staticTyping  =  false  ;  }  JsonSerializer<Object>  elementValueSerializer  =  _findContentSerializer  (  prov  ,  beanDesc  .  getClassInfo  (  )  )  ;  if  (  type  .  isMapLikeType  (  )  )  {  //  implements  java  .  util  .  Map  MapLikeType  mlt  =  (  MapLikeType  )  type  ;      JsonSerializer<Object>  keySerializer  =  _findKeySerializer  (  prov  ,  beanDesc  .  getClassInfo  (  )  )  ;  if  (  mlt  .  isTrueMapType  (  )  )  {  return  buildMapSerializer  (  config  ,  (  MapType  )  mlt  ,  beanDesc  ,  staticTyping  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  JsonSerializer<?>  ser  =  null  ;  [BUGGY]  for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  MapLikeType  mlType  =  (  MapLikeType  )  type  ;  ser  =  serializers  .  findMapLikeSerializer  (  config  ,  mlType  ,  beanDesc  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  if  (  ser  !  =  null  )  {  if  (  _factoryConfig  .  hasSerializerModifiers  (  )  )  {  	JacksonDatabind_22_BasicSerializerFactory_16_2	585	1	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1188	return  ser;  	[BUGGY]  }  return  ser  ;  return  null  ;  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildContainerSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  type  BeanDescription  beanDesc  boolean  staticTyping  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapLikeType  mlType  mlt  [TYPE]  JavaType  elementType  type  [TYPE]  CollectionLikeType  clType  clt  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  SerializerProvider  prov  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  JsonSerializer<Object>  elementValueSerializer  =  _findContentSerializer  (  prov  ,  beanDesc  .  getClassInfo  (  )  )  ;  if  (  type  .  isMapLikeType  (  )  )  {  //  implements  java  .  util  .  Map  MapLikeType  mlt  =  (  MapLikeType  )  type  ;      JsonSerializer<Object>  keySerializer  =  _findKeySerializer  (  prov  ,  beanDesc  .  getClassInfo  (  )  )  ;  if  (  mlt  .  isTrueMapType  (  )  )  {  return  buildMapSerializer  (  config  ,  (  MapType  )  mlt  ,  beanDesc  ,  staticTyping  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  JsonSerializer<?>  ser  =  null  ;  for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  MapLikeType  mlType  =  (  MapLikeType  )  type  ;  ser  =  serializers  .  findMapLikeSerializer  (  config  ,  mlType  ,  beanDesc  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  if  (  ser  !  =  null  )  {  if  (  _factoryConfig  .  hasSerializerModifiers  (  )  )  {  for  (  BeanSerializerModifier  mod  :  _factoryConfig  .  serializerModifiers  (  )  )  {  ser  =  mod  .  modifyMapLikeSerializer  (  config  ,  mlType  ,  beanDesc  ,  ser  )  ;  }  [BUGGY]  }  return  ser  ;  }  }  return  null  ;  }  	JacksonDatabind_22_BasicSerializerFactory_16_3	594	3	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1189	return  buildCollectionSerializer(prov,    (CollectionType)  clt,  beanDesc,  staticTyping,  	[BUGGY]  return  buildCollectionSerializer  (  config  ,    (  CollectionType  )  clt  ,  beanDesc  ,  staticTyping  ,  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildContainerSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  type  BeanDescription  beanDesc  boolean  staticTyping  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapLikeType  mlType  mlt  [TYPE]  JavaType  elementType  type  [TYPE]  CollectionLikeType  clType  clt  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  SerializerProvider  prov  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  JsonSerializer<Object>  keySerializer  =  _findKeySerializer  (  prov  ,  beanDesc  .  getClassInfo  (  )  )  ;  if  (  mlt  .  isTrueMapType  (  )  )  {  return  buildMapSerializer  (  config  ,  (  MapType  )  mlt  ,  beanDesc  ,  staticTyping  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  JsonSerializer<?>  ser  =  null  ;  for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  MapLikeType  mlType  =  (  MapLikeType  )  type  ;  ser  =  serializers  .  findMapLikeSerializer  (  config  ,  mlType  ,  beanDesc  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  if  (  ser  !  =  null  )  {  if  (  _factoryConfig  .  hasSerializerModifiers  (  )  )  {  for  (  BeanSerializerModifier  mod  :  _factoryConfig  .  serializerModifiers  (  )  )  {  ser  =  mod  .  modifyMapLikeSerializer  (  config  ,  mlType  ,  beanDesc  ,  ser  )  ;  }  }  return  ser  ;  }  }  return  null  ;  }  if  (  type  .  isCollectionLikeType  (  )  )  {  CollectionLikeType  clt  =  (  CollectionLikeType  )  type  ;  if  (  clt  .  isTrueCollectionType  (  )  )  {  [BUGGY]  return  buildCollectionSerializer  (  config  ,  (  CollectionType  )  clt  ,  beanDesc  ,  staticTyping  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  JsonSerializer<?>  ser  =  null  ;  CollectionLikeType  clType  =  (  CollectionLikeType  )  type  ;  	JacksonDatabind_22_BasicSerializerFactory_16_4	603	1	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1190	if  (ser  !=  null)  {  break;  }  }  if  (ser  ==  null)  {    ser  =  findSerializerByAnnotations(prov,  type,  beanDesc);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildContainerSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  type  BeanDescription  beanDesc  boolean  staticTyping  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapLikeType  mlType  mlt  [TYPE]  JavaType  elementType  type  [TYPE]  CollectionLikeType  clType  clt  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  SerializerProvider  prov  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  ser  =  serializers  .  findMapLikeSerializer  (  config  ,  mlType  ,  beanDesc  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  if  (  ser  !  =  null  )  {  if  (  _factoryConfig  .  hasSerializerModifiers  (  )  )  {  for  (  BeanSerializerModifier  mod  :  _factoryConfig  .  serializerModifiers  (  )  )  {  ser  =  mod  .  modifyMapLikeSerializer  (  config  ,  mlType  ,  beanDesc  ,  ser  )  ;  }  }  return  ser  ;  }  }  return  null  ;  }  if  (  type  .  isCollectionLikeType  (  )  )  {  CollectionLikeType  clt  =  (  CollectionLikeType  )  type  ;  if  (  clt  .  isTrueCollectionType  (  )  )  {  return  buildCollectionSerializer  (  config  ,  (  CollectionType  )  clt  ,  beanDesc  ,  staticTyping  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  JsonSerializer<?>  ser  =  null  ;  CollectionLikeType  clType  =  (  CollectionLikeType  )  type  ;  for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  ser  =  serializers  .  findCollectionLikeSerializer  (  config  ,  clType  ,  beanDesc  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  [BUGGY]  if  (  ser  !  =  null  )  {  if  (  _factoryConfig  .  hasSerializerModifiers  (  )  )  {  for  (  BeanSerializerModifier  mod  :  _factoryConfig  .  serializerModifiers  (  )  )  {  ser  =  mod  .  modifyCollectionLikeSerializer  (  config  ,  clType  ,  beanDesc  ,  ser  )  ;  }  }  	JacksonDatabind_22_BasicSerializerFactory_16_5	612	0	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1191	return  ser;  return  buildArraySerializer(prov,  (ArrayType)  type,  beanDesc,  staticTyping,  	[BUGGY]  }  return  ser  ;  return  null  ;  return  buildArraySerializer  (  config  ,  (  ArrayType  )  type  ,  beanDesc  ,  staticTyping  ,  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildContainerSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  type  BeanDescription  beanDesc  boolean  staticTyping  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapLikeType  mlType  mlt  [TYPE]  JavaType  elementType  type  [TYPE]  CollectionLikeType  clType  clt  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  SerializerProvider  prov  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  for  (  BeanSerializerModifier  mod  :  _factoryConfig  .  serializerModifiers  (  )  )  {  ser  =  mod  .  modifyMapLikeSerializer  (  config  ,  mlType  ,  beanDesc  ,  ser  )  ;  }  }  return  ser  ;  }  }  return  null  ;  }  if  (  type  .  isCollectionLikeType  (  )  )  {  CollectionLikeType  clt  =  (  CollectionLikeType  )  type  ;  if  (  clt  .  isTrueCollectionType  (  )  )  {  return  buildCollectionSerializer  (  config  ,  (  CollectionType  )  clt  ,  beanDesc  ,  staticTyping  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  JsonSerializer<?>  ser  =  null  ;  CollectionLikeType  clType  =  (  CollectionLikeType  )  type  ;  for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  ser  =  serializers  .  findCollectionLikeSerializer  (  config  ,  clType  ,  beanDesc  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  if  (  ser  !  =  null  )  {  if  (  _factoryConfig  .  hasSerializerModifiers  (  )  )  {  for  (  BeanSerializerModifier  mod  :  _factoryConfig  .  serializerModifiers  (  )  )  {  ser  =  mod  .  modifyCollectionLikeSerializer  (  config  ,  clType  ,  beanDesc  ,  ser  )  ;  [BUGGY]  }  }  return  ser  ;  }  }  return  null  ;  	JacksonDatabind_22_BasicSerializerFactory_16_6	616	4	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1192	protected  JsonSerializer<?>  buildCollectionSerializer(SerializerProvider  prov,  	[BUGGY]  protected  JsonSerializer<?>  buildCollectionSerializer  (  SerializationConfig  config  ,  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_22_BasicSerializerFactory_16_7	636	1	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1193	SerializationConfig  config  =  prov.getConfig();  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildCollectionSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializationConfig  config  CollectionType  type  BeanDescription  beanDesc  boolean  staticTyping  TypeSerializer  elementTypeSerializer  Object>  elementValueSerializer  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  ser  [TYPE]  JavaType  enumType  [TYPE]  boolean  false  staticTyping  true  [TYPE]  CollectionType  type  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  Value  format  [TYPE]  Class  elementRaw  raw  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  protected  JsonSerializer<?>  buildCollectionSerializer  (  SerializationConfig  config  ,  CollectionType  type  ,  BeanDescription  beanDesc  ,  boolean  staticTyping  ,  TypeSerializer  elementTypeSerializer  ,  JsonSerializer<Object>  elementValueSerializer  )  throws  JsonMappingException  {  [BUGGY]  JsonSerializer<?>  ser  =  null  ;      for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  	JacksonDatabind_22_BasicSerializerFactory_16_8	641	0	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1194	ser  =  findSerializerByAnnotations(prov,  type,  beanDesc);    if  (ser  ==  null)  {  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildCollectionSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializationConfig  config  CollectionType  type  BeanDescription  beanDesc  boolean  staticTyping  TypeSerializer  elementTypeSerializer  Object>  elementValueSerializer  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  ser  [TYPE]  JavaType  enumType  [TYPE]  boolean  false  staticTyping  true  [TYPE]  CollectionType  type  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  Value  format  [TYPE]  Class  elementRaw  raw  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  protected  JsonSerializer<?>  buildCollectionSerializer  (  SerializationConfig  config  ,  CollectionType  type  ,  BeanDescription  beanDesc  ,  boolean  staticTyping  ,  TypeSerializer  elementTypeSerializer  ,  JsonSerializer<Object>  elementValueSerializer  )  throws  JsonMappingException  {  JsonSerializer<?>  ser  =  null  ;      for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  ser  =  serializers  .  findCollectionSerializer  (  config  ,  type  ,  beanDesc  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  if  (  ser  !  =  null  )  {  break  ;  }  }  if  (  ser  =  =  null  )  {  [BUGGY]    JsonFormat  .  Value  format  =  beanDesc  .  findExpectedFormat  (  null  )  ;  if  (  format  !  =  null  &&  format  .  getShape  (  )  =  =  JsonFormat  .  Shape  .  OBJECT  )  {  return  null  ;  }  	JacksonDatabind_22_BasicSerializerFactory_16_9	655	0	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1195	}  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildCollectionSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializationConfig  config  CollectionType  type  BeanDescription  beanDesc  boolean  staticTyping  TypeSerializer  elementTypeSerializer  Object>  elementValueSerializer  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  JsonSerializer  elementValueSerializer  ser  [TYPE]  JavaType  enumType  [TYPE]  boolean  false  staticTyping  true  [TYPE]  CollectionType  type  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  Value  format  [TYPE]  Class  elementRaw  raw  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  if  (  !enumType  .  isEnumType  (  )  )  {  enumType  =  null  ;  }  ser  =  buildEnumSetSerializer  (  enumType  )  ;  }  else  {  Class<?>  elementRaw  =  type  .  getContentType  (  )  .  getRawClass  (  )  ;  if  (  isIndexedList  (  raw  )  )  {  if  (  elementRaw  =  =  String  .  class  )  {  if  (  elementValueSerializer  =  =  null  ||  ClassUtil  .  isJacksonStdImpl  (  elementValueSerializer  )  )  {  ser  =  IndexedStringListSerializer  .  instance  ;  }  }  else  {  ser  =  buildIndexedListSerializer  (  type  .  getContentType  (  )  ,  staticTyping  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  }  else  if  (  elementRaw  =  =  String  .  class  )  {  if  (  elementValueSerializer  =  =  null  ||  ClassUtil  .  isJacksonStdImpl  (  elementValueSerializer  )  )  {  ser  =  StringCollectionSerializer  .  instance  ;  }  }  if  (  ser  =  =  null  )  {  ser  =  buildCollectionSerializer  (  type  .  getContentType  (  )  ,  staticTyping  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  [BUGGY]  }  }  }  if  (  _factoryConfig  .  hasSerializerModifiers  (  )  )  {  for  (  BeanSerializerModifier  mod  :  _factoryConfig  .  serializerModifiers  (  )  )  {  	JacksonDatabind_22_BasicSerializerFactory_16_10	691	0	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1196	protected  JsonSerializer<?>  buildMapSerializer(SerializerProvider  prov,  	[BUGGY]  protected  JsonSerializer<?>  buildMapSerializer  (  SerializationConfig  config  ,  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_22_BasicSerializerFactory_16_11	737	1	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1197	final  SerializationConfig  config  =  prov.getConfig();  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildMapSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializationConfig  config  MapType  type  BeanDescription  beanDesc  boolean  staticTyping  Object>  keySerializer  TypeSerializer  elementTypeSerializer  Object>  elementValueSerializer  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  AnnotationIntrospector  ai  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapType  type  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  Object  filterId  suppressableValue  [TYPE]  MapSerializer  mapSer  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  protected  JsonSerializer<?>  buildMapSerializer  (  SerializationConfig  config  ,  MapType  type  ,  BeanDescription  beanDesc  ,  boolean  staticTyping  ,  JsonSerializer<Object>  keySerializer  ,  TypeSerializer  elementTypeSerializer  ,  JsonSerializer<Object>  elementValueSerializer  )  throws  JsonMappingException  {  [BUGGY]  JsonSerializer<?>  ser  =  null  ;      	JacksonDatabind_22_BasicSerializerFactory_16_12	743	0	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1198	ser  =  findSerializerByAnnotations(prov,  type,  beanDesc);    if  (ser  ==  null)  {  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildMapSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializationConfig  config  MapType  type  BeanDescription  beanDesc  boolean  staticTyping  Object>  keySerializer  TypeSerializer  elementTypeSerializer  Object>  elementValueSerializer  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  AnnotationIntrospector  ai  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapType  type  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  Object  filterId  suppressableValue  [TYPE]  MapSerializer  mapSer  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  protected  JsonSerializer<?>  buildMapSerializer  (  SerializationConfig  config  ,  MapType  type  ,  BeanDescription  beanDesc  ,  boolean  staticTyping  ,  JsonSerializer<Object>  keySerializer  ,  TypeSerializer  elementTypeSerializer  ,  JsonSerializer<Object>  elementValueSerializer  )  throws  JsonMappingException  {  JsonSerializer<?>  ser  =  null  ;      for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  ser  =  serializers  .  findMapSerializer  (  config  ,  type  ,  beanDesc  ,  keySerializer  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  if  (  ser  !  =  null  )  {  break  ;  }  }  if  (  ser  =  =  null  )  {  [BUGGY]    if  (  EnumMap  .  class  .  isAssignableFrom  (  type  .  getRawClass  (  )  )  &&  (  (  keySerializer  =  =  null  )  ||  ClassUtil  .  isJacksonStdImpl  (  keySerializer  )  )  )  {  JavaType  keyType  =  type  .  getKeyType  (  )  ;  	JacksonDatabind_22_BasicSerializerFactory_16_13	756	0	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1199	}  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildMapSerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializationConfig  config  MapType  type  BeanDescription  beanDesc  boolean  staticTyping  Object>  keySerializer  TypeSerializer  elementTypeSerializer  Object>  elementValueSerializer  [CLASS]  BasicSerializerFactory  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  AnnotationIntrospector  ai  [TYPE]  JsonSerializer  elementValueSerializer  keySerializer  ser  [TYPE]  MapType  type  [TYPE]  boolean  false  staticTyping  true  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  Object  filterId  suppressableValue  [TYPE]  MapSerializer  mapSer  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  &&  (  (  keySerializer  =  =  null  )  ||  ClassUtil  .  isJacksonStdImpl  (  keySerializer  )  )  )  {  JavaType  keyType  =  type  .  getKeyType  (  )  ;  EnumValues  enums  =  null  ;  if  (  keyType  .  isEnumType  (  )  )  {  //  non-enum  if  we  got  it  as  type  erased  class  (  from  instance  )  @SuppressWarnings  (   "unchecked "  )  Class<Enum<?>>  enumClass  =  (  Class<Enum<?>>  )  keyType  .  getRawClass  (  )  ;  enums  =  EnumValues  .  construct  (  config  ,  enumClass  )  ;  }  ser  =  new  EnumMapSerializer  (  type  .  getContentType  (  )  ,  staticTyping  ,  enums  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  }  else  {  Object  filterId  =  findFilterId  (  config  ,  beanDesc  )  ;  AnnotationIntrospector  ai  =  config  .  getAnnotationIntrospector  (  )  ;  MapSerializer  mapSer  =  MapSerializer  .  construct  (  ai  .  findPropertiesToIgnore  (  beanDesc  .  getClassInfo  (  )  ,  true  )  ,  type  ,  staticTyping  ,  elementTypeSerializer  ,  keySerializer  ,  elementValueSerializer  ,  filterId  )  ;  Object  suppressableValue  =  findSuppressableContentValue  (  config  ,  type  .  getContentType  (  )  ,  beanDesc  )  ;  if  (  suppressableValue  !  =  null  )  {  mapSer  =  mapSer  .  withContentInclusion  (  suppressableValue  )  ;  }  ser  =  mapSer  ;  }  [BUGGY]  if  (  _factoryConfig  .  hasSerializerModifiers  (  )  )  {  for  (  BeanSerializerModifier  mod  :  _factoryConfig  .  serializerModifiers  (  )  )  {  ser  =  mod  .  modifyMapSerializer  (  config  ,  type  ,  beanDesc  ,  ser  )  ;  }  }  	JacksonDatabind_22_BasicSerializerFactory_16_14	784	0	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1200	protected  JsonSerializer<?>  buildArraySerializer(SerializerProvider  prov,  	[BUGGY]  protected  JsonSerializer<?>  buildArraySerializer  (  SerializationConfig  config  ,  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_22_BasicSerializerFactory_16_15	831	1	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1201	SerializationConfig  config  =  prov.getConfig();  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  buildArraySerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializationConfig  config  ArrayType  type  BeanDescription  beanDesc  boolean  staticTyping  TypeSerializer  elementTypeSerializer  Object>  elementValueSerializer  [CLASS]  BasicSerializerFactory  [TYPE]  ArrayType  type  [TYPE]  SerializerFactoryConfig  _factoryConfig  [TYPE]  boolean  false  staticTyping  true  [TYPE]  HashMap  _concrete  _concreteLazy  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  TypeSerializer  elementTypeSerializer  [TYPE]  Class  raw  [TYPE]  JsonSerializer  elementValueSerializer  ser  [TYPE]  Serializers  serializers  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  protected  JsonSerializer<?>  buildArraySerializer  (  SerializationConfig  config  ,  ArrayType  type  ,  BeanDescription  beanDesc  ,  boolean  staticTyping  ,  TypeSerializer  elementTypeSerializer  ,  JsonSerializer<Object>  elementValueSerializer  )  throws  JsonMappingException  {      [BUGGY]  JsonSerializer<?>  ser  =  null  ;  for  (  Serializers  serializers  :  customSerializers  (  )  )  {  //  (  1  )  Custom  ser  =  serializers  .  findArraySerializer  (  config  ,  type  ,  beanDesc  ,  elementTypeSerializer  ,  elementValueSerializer  )  ;  if  (  ser  !  =  null  )  {  	JacksonDatabind_22_BasicSerializerFactory_16_16	841	0	src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java
1202	JsonSerializer<?>  ser  =  null;  	[BUGGY]  JsonSerializer<?>  ser  =  findSerializerByAnnotations  (  prov  ,  type  ,  beanDesc  )  ;  if  (  ser  !  =  null  )  {  return  ser  ;  }  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  _createSerializer2  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  type  BeanDescription  beanDesc  boolean  staticTyping  [CLASS]  BeanSerializerFactory  [TYPE]  JavaType  type  [TYPE]  boolean  false  staticTyping  true  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  BeanSerializerFactory  instance  [TYPE]  JsonSerializer  ser  [TYPE]  SerializerProvider  prov  [TYPE]  Serializers  serializers  [TYPE]  long  serialVersionUID  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  protected  JsonSerializer<?>  _createSerializer2  (  SerializerProvider  prov  ,  JavaType  type  ,  BeanDescription  beanDesc  ,  boolean  staticTyping  )  throws  JsonMappingException  {  [BUGGY]  JsonSerializer<?>  ser  =  findSerializerByAnnotations  (  prov  ,  type  ,  beanDesc  )  ;  if  (  ser  !  =  null  )  {  return  ser  ;  }  final  SerializationConfig  config  =  prov  .  getConfig  (  )  ;  	JacksonDatabind_22_BeanSerializerFactory_2_1	174	4	src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java
1203	if  (ser  ==  null)  {  ser  =  findSerializerByAnnotations(prov,  type,  beanDesc);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[42]>  but  was:<[ "value "]>  assertEquals  (   "42 "  ,  mapper  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  _createSerializer2  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  JavaType  type  BeanDescription  beanDesc  boolean  staticTyping  [CLASS]  BeanSerializerFactory  [TYPE]  JavaType  type  [TYPE]  boolean  false  staticTyping  true  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  BeanSerializerFactory  instance  [TYPE]  JsonSerializer  ser  [TYPE]  SerializerProvider  prov  [TYPE]  Serializers  serializers  [TYPE]  long  serialVersionUID  [TYPE]  BeanSerializerModifier  mod  [CONTEXT]  if  (  property  =  =  null  )  {  JavaType  t  =  origType  .  getContentType  (  )  ;  if  (  t  !  =  null  &&  !t  .  hasRawClass  (  Object  .  class  )  )  {  staticTyping  =  true  ;  }  }  }  ser  =  buildContainerSerializer  (  prov  ,  type  ,  beanDesc  ,  staticTyping  )  ;  if  (  ser  !  =  null  )  {  return  ser  ;  }  }  else  {  for  (  Serializers  serializers  :  customSerializers  (  )  )  {  ser  =  serializers  .  findSerializer  (  config  ,  type  ,  beanDesc  )  ;  if  (  ser  !  =  null  )  {  break  ;  }  }    [BUGGY]  }  if  (  ser  =  =  null  )  {    	JacksonDatabind_22_BeanSerializerFactory_2_2	212	0	src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java
1204	protected  final  static  Integer  EMPTY_INTEGER  =  Integer.valueOf(0);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_1	54	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1205	private  final  static  Short  EMPTY  =  (short)  0;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_2	120	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1206	@Override  public  boolean  isEmpty(SerializerProvider  prov,  Short  value)  {  return  EMPTY.equals(value);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_3	124	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1207	@Override  public  boolean  isEmpty(SerializerProvider  prov,  Object  value)  {  return  EMPTY_INTEGER.equals(value);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_4	159	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1208	@Override  public  boolean  isEmpty(SerializerProvider  prov,  Number  value)  {  return  value.intValue()  ==  0;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_5	175	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1209	private  final  static  Long  EMPTY  =  0L;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_6	185	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1210	@Override  public  boolean  isEmpty(SerializerProvider  prov,  Object  value)  {  return  EMPTY.equals(value);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_7	190	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1211	private  final  static  Float  EMPTY  =  0f;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_8	200	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1212	@Override  public  boolean  isEmpty(SerializerProvider  prov,  Object  value)  {  return  EMPTY.equals(value);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_9	205	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1213	private  final  static  Double  EMPTY  =  0d;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_10	222	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1214	@Override  public  boolean  isEmpty(SerializerProvider  prov,  Object  value)  {  return  EMPTY.equals(value);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "value ":0]}>  assertEquals  (   "{} "  ,  inclMapper  .  writeValueAsString  (  zero  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_23_NumberSerializers_11_11	227	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1215	_timeZone,  _defaultBase64);  	[BUGGY]  TimeZone  tz  =  (  df  =  =  null  )  ?  _timeZone  :  df  .  getTimeZone  (  )  ;  tz  ,  _defaultBase64  )  ;  [FE]  AssertionFailedError:  expected:<sunutilcalendarZoneInfo[id  =   "America/Los_Angeles "  ,  offset  =  -28800000  ,  dstSavings  =  3600000  ,  useDaylight  =  true  ,  transitions  =  185  ,  lastRule  =  javautilSimpleTimeZone[id  =  America/Los_Angeles  ,  offset  =  -28800000  ,  dstSavings  =  3600000  ,  useDaylight  =  true  ,  startYear  =  0  ,  startMode  =  3  ,  startMonth  =  2  ,  startDay  =  8  ,  startDayOfWeek  =  1  ,  startTime  =  7200000  ,  startTimeMode  =  0  ,  endMode  =  3  ,  endMonth  =  10  ,  endDay  =  1  ,  endDayOfWeek  =  1  ,  endTime  =  7200000  ,  endTimeMode  =  0]]>  but  was:<sunutilcalendarZoneInfo[id  =   "GMT "  ,  offset  =  0  ,  dstSavings  =  0  ,  useDaylight  =  false  ,  transitions  =  0  ,  lastRule  =  null]>  assertEquals  (  tz1  ,  mapper  .  reader  (  )  .  getConfig  (  )  .  getTimeZone  (  )  )  ;  [METHOD]  withDateFormat  [TYPE]  BaseSettings  [PARAMETER]  DateFormat  df  [CLASS]  BaseSettings  [TYPE]  HandlerInstantiator  _handlerInstantiator  [TYPE]  Locale  _locale  [TYPE]  TypeResolverBuilder  _typeResolverBuilder  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  long  serialVersionUID  [TYPE]  ClassIntrospector  _classIntrospector  [TYPE]  TimeZone  _timeZone  tz  [TYPE]  boolean  false  true  [TYPE]  VisibilityChecker  _visibilityChecker  [TYPE]  DateFormat  _dateFormat  df  [TYPE]  Base64Variant  _defaultBase64  [TYPE]  PropertyNamingStrategy  _propertyNamingStrategy  [TYPE]  TypeFactory  _typeFactory  [CONTEXT]  public  BaseSettings  withDateFormat  (  DateFormat  df  )  {  if  (  _dateFormat  =  =  df  )  {  return  this  ;  }  [BUGGY]  TimeZone  tz  =  (  df  =  =  null  )  ?  _timeZone  :  df  .  getTimeZone  (  )  ;  return  new  BaseSettings  (  _classIntrospector  ,  _annotationIntrospector  ,  _visibilityChecker  ,  _propertyNamingStrategy  ,  _typeFactory  ,  _typeResolverBuilder  ,  df  ,  _handlerInstantiator  ,  _locale  ,  tz  ,  _defaultBase64  )  ;  }  	JacksonDatabind_24_BaseSettings_1_1	234	2	src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java
1216	type  =  (T)  ctxt.getTypeFactory().constructSpecializedType(type,  subclass);  	[BUGGY]  type  =  (  T  )  type  .  narrowBy  (  subclass  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  Class  [B  (  of  type  array  )  as  a  Bean  assertEquals  (  byte[]  .  class  ,  result  .  someBytes  .  getClass  (  )  )  ;  [METHOD]  modifyTypeByAnnotation  [TYPE]  <T  [PARAMETER]  DeserializationContext  ctxt  Annotated  a  T  type  [CLASS]  BasicDeserializerFactory  [TYPE]  PropertyName  UNWRAPPED_CREATOR_PARAM_NAME  [TYPE]  DeserializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _collectionFallbacks  _mapFallbacks  [TYPE]  AnnotationIntrospector  intr  [TYPE]  JsonDeserializer  cd  [TYPE]  KeyDeserializer  kd  [TYPE]  Annotated  a  [TYPE]  JavaType  contentType  keyType  [TYPE]  boolean  false  true  [TYPE]  T  type  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  CLASS_CHAR_BUFFER  CLASS_ITERABLE  CLASS_MAP_ENTRY  CLASS_OBJECT  CLASS_STRING  cc  keyClass  subclass  [TYPE]  Object  cdDef  kdDef  [TYPE]  IllegalArgumentException  iae  [CONTEXT]  protected  <T  extends  JavaType>  T  modifyTypeByAnnotation  (  DeserializationContext  ctxt  ,  Annotated  a  ,  T  type  )  throws  JsonMappingException  {  AnnotationIntrospector  intr  =  ctxt  .  getAnnotationIntrospector  (  )  ;  Class<?>  subclass  =  intr  .  findDeserializationType  (  a  ,  type  )  ;  if  (  subclass  !  =  null  )  {  try  {  [BUGGY]  type  =  (  T  )  type  .  narrowBy  (  subclass  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (   "Failed  to  narrow  type   "+type+ "  with  concrete-type  annotation  (  value   "+subclass  .  getName  (  )  + "  )  ,  method  ' "+a  .  getName  (  )  + "':   "+iae  .  getMessage  (  )  ,  null  ,  iae  )  ;  }  }  	JacksonDatabind_25_BasicDeserializerFactory_1_1	1757	1	src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
1217	type  =  ctxt.getTypeFactory().constructSpecializedType(type,  subclass);  	[BUGGY]  type  =  type  .  narrowBy  (  subclass  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  Class  [B  (  of  type  array  )  as  a  Bean  assertEquals  (  byte[]  .  class  ,  result  .  someBytes  .  getClass  (  )  )  ;  [METHOD]  modifyTypeByAnnotation  [TYPE]  JavaType  [PARAMETER]  DeserializationContext  ctxt  Annotated  a  JavaType  type  [CLASS]  DeserializerCache  [TYPE]  HashMap  _incompleteDeserializers  [TYPE]  AnnotationIntrospector  intr  [TYPE]  JsonDeserializer  cd  [TYPE]  long  serialVersionUID  [TYPE]  KeyDeserializer  kd  [TYPE]  Annotated  a  [TYPE]  JavaType  contentType  keyType  type  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  cc  cdClass  keyClass  subclass  [TYPE]  Object  cdDef  kdDef  [TYPE]  ConcurrentHashMap  _cachedDeserializers  [TYPE]  IllegalArgumentException  iae  [CONTEXT]  private  JavaType  modifyTypeByAnnotation  (  DeserializationContext  ctxt  ,  Annotated  a  ,  JavaType  type  )  throws  JsonMappingException  {  AnnotationIntrospector  intr  =  ctxt  .  getAnnotationIntrospector  (  )  ;  Class<?>  subclass  =  intr  .  findDeserializationType  (  a  ,  type  )  ;  if  (  subclass  !  =  null  )  {  try  {  [BUGGY]  type  =  type  .  narrowBy  (  subclass  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (   "Failed  to  narrow  type   "+type+ "  with  concrete-type  annotation  (  value   "+subclass  .  getName  (  )  + "  )  ,  method  ' "+a  .  getName  (  )  + "':   "+iae  .  getMessage  (  )  ,  null  ,  iae  )  ;  }  }  	JacksonDatabind_25_DeserializerCache_1_1	477	1	src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
1218	type  =  ctxt.getTypeFactory().constructSpecializedType(_baseType,  type.getRawClass());  	[BUGGY]  type  =  _baseType  .  narrowBy  (  type  .  getRawClass  (  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  Class  [B  (  of  type  array  )  as  a  Bean  assertEquals  (  byte[]  .  class  ,  result  .  someBytes  .  getClass  (  )  )  ;  [METHOD]  _findDeserializer  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  String  typeId  [CLASS]  TypeDeserializerBase  [TYPE]  JavaType  _baseType  _defaultImpl  type  [TYPE]  boolean  _typeIdVisible  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  String  _typePropertyName  typeId  [TYPE]  JsonDeserializer  _defaultImplDeserializer  deser  [TYPE]  Map  _deserializers  [TYPE]  long  serialVersionUID  [TYPE]  TypeIdResolver  _idResolver  [TYPE]  BeanProperty  _property  [CONTEXT]    JavaType  type  =  _idResolver  .  typeFromId  (  ctxt  ,  typeId  )  ;  if  (  type  =  =  null  )  {  deser  =  _findDefaultImplDeserializer  (  ctxt  )  ;  if  (  deser  =  =  null  )  {  deser  =  _handleUnknownTypeId  (  ctxt  ,  typeId  ,  _idResolver  ,  _baseType  )  ;  }  }  else  {          if  (  (  _baseType  !  =  null  )  &&  _baseType  .  getClass  (  )  =  =  type  .  getClass  (  )  )  {      [BUGGY]  type  =  _baseType  .  narrowBy  (  type  .  getRawClass  (  )  )  ;  }  deser  =  ctxt  .  findContextualValueDeserializer  (  type  ,  _property  )  ;  }  _deserializers  .  put  (  typeId  ,  deser  )  ;  }  	JacksonDatabind_25_TypeDeserializerBase_1_1	177	1	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
1219	return  config.getTypeFactory().constructSpecializedType(type,  dst);  	[BUGGY]  return  type  .  narrowBy  (  dst  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  Class  [B  (  of  type  array  )  as  a  Bean  assertEquals  (  byte[]  .  class  ,  result  .  someBytes  .  getClass  (  )  )  ;  [METHOD]  findTypeMapping  [TYPE]  JavaType  [PARAMETER]  DeserializationConfig  config  JavaType  type  [CLASS]  SimpleAbstractTypeResolver  [TYPE]  DeserializationConfig  config  [TYPE]  JavaType  type  [TYPE]  Class  dst  src  [TYPE]  boolean  false  true  [TYPE]  HashMap  _mappings  [TYPE]  long  serialVersionUID  [CONTEXT]  public  JavaType  findTypeMapping  (  DeserializationConfig  config  ,  JavaType  type  )  {  Class<?>  src  =  type  .  getRawClass  (  )  ;  Class<?>  dst  =  _mappings  .  get  (  new  ClassKey  (  src  )  )  ;  if  (  dst  =  =  null  )  {  return  null  ;  }  [BUGGY]  return  type  .  narrowBy  (  dst  )  ;  }  	JacksonDatabind_25_SimpleAbstractTypeResolver_1_1	80	1	src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java
1220	implements  BeanProperty,  java.io.Serializable    private  static  final  long  serialVersionUID  =  4603296144163950020L;  	[BUGGY]  implements  BeanProperty  [FE]  NotSerializableException:  comfasterxmljacksondatabindserBeanPropertyWriter  assertNotNull  (  result2  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_26_BeanPropertyWriter_1_1	39	1	src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java
1221	if  (ext.handlePropertyValue(p,  ctxt,  propName,  null))  {  	[BUGGY]  if  (  ext  .  handlePropertyValue  (  p  ,  ctxt  ,  propName  ,  buffer  )  )  {  [FE]  IllegalStateException:  No  fallback  setter/field  defined:  can  not  use  creator  property  for  comfasterxmljacksondatabinddeserCreatorProperty  assertEquals  (  Payload928  .  class  ,  envelope2  .  _payload  .  getClass  (  )  )  ;  [METHOD]  deserializeUsingPropertyBasedWithExternalTypeId  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializer  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  SettableBeanProperty  creatorProp  prop  [TYPE]  String  propName  [TYPE]  PropertyBasedCreator  creator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  e  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  tokens  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  Object  bean  [TYPE]  ExternalTypeHandler  ext  [TYPE]  JsonParser  p  [CONTEXT]  protected  Object  deserializeUsingPropertyBasedWithExternalTypeId  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  final  ExternalTypeHandler  ext  =  _externalTypeIdHandler  .  start  (  )  ;  final  PropertyBasedCreator  creator  =  _propertyBasedCreator  ;  PropertyValueBuffer  buffer  =  creator  .  startBuilding  (  p  ,  ctxt  ,  _objectIdReader  )  ;  TokenBuffer  tokens  =  new  TokenBuffer  (  p  )  ;  tokens  .  writeStartObject  (  )  ;  JsonToken  t  =  p  .  getCurrentToken  (  )  ;  for  (  ;  t  =  =  JsonToken  .  FIELD_NAME  ;  t  =  p  .  nextToken  (  )  )  {  String  propName  =  p  .  getCurrentName  (  )  ;  p  .  nextToken  (  )  ;  //  to  point  to  value  SettableBeanProperty  creatorProp  =  creator  .  findCreatorProperty  (  propName  )  ;  if  (  creatorProp  !  =  null  )  {    [BUGGY]  if  (  ext  .  handlePropertyValue  (  p  ,  ctxt  ,  propName  ,  buffer  )  )  {  ;  }  else  {  if  (  buffer  .  assignParameter  (  creatorProp  ,  _deserializeWithErrorWrapping  (  p  ,  ctxt  ,  creatorProp  )  )  )  {  t  =  p  .  nextToken  (  )  ;  //  to  move  to  following  FIELD_NAME/END_OBJECT  	JacksonDatabind_27_BeanDeserializer_1_1	794	1	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1222	if  (p.isExpectedStartObjectToken()  ||  p.hasToken(JsonToken.FIELD_NAME))  {  	[BUGGY]  if  (  p  .  getCurrentToken  (  )  =  =  JsonToken  .  START_OBJECT  )  {  p  .  nextToken  (  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindnodeObjectNode  out  of  END_OBJECT  token  [METHOD]  deserialize  [TYPE]  ObjectNode  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  ObjectDeserializer  [TYPE]  DeserializationContext  ctxt  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  ObjectDeserializer  _instance  [TYPE]  JsonParser  p  [CONTEXT]  public  ObjectNode  deserialize  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  [BUGGY]  if  (  p  .  getCurrentToken  (  )  =  =  JsonToken  .  START_OBJECT  )  {  p  .  nextToken  (  )  ;  return  deserializeObject  (  p  ,  ctxt  ,  ctxt  .  getNodeFactory  (  )  )  ;  }    if  (  p  .  getCurrentToken  (  )  =  =  JsonToken  .  FIELD_NAME  )  {  return  deserializeObject  (  p  ,  ctxt  ,  ctxt  .  getNodeFactory  (  )  )  ;  }  throw  ctxt  .  mappingException  (  ObjectNode  .  class  )  ;  }  	JacksonDatabind_28_JsonNodeDeserializer_2_1	97	2	src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java
1223	if  (p.hasToken(JsonToken.END_OBJECT))  {  return  ctxt.getNodeFactory().objectNode();  	[BUGGY]  if  (  p  .  getCurrentToken  (  )  =  =  JsonToken  .  FIELD_NAME  )  {  return  deserializeObject  (  p  ,  ctxt  ,  ctxt  .  getNodeFactory  (  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindnodeObjectNode  out  of  END_OBJECT  token  [METHOD]  deserialize  [TYPE]  ObjectNode  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  ObjectDeserializer  [TYPE]  DeserializationContext  ctxt  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  ObjectDeserializer  _instance  [TYPE]  JsonParser  p  [CONTEXT]  public  ObjectNode  deserialize  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  p  .  getCurrentToken  (  )  =  =  JsonToken  .  START_OBJECT  )  {  p  .  nextToken  (  )  ;  return  deserializeObject  (  p  ,  ctxt  ,  ctxt  .  getNodeFactory  (  )  )  ;  }    [BUGGY]  if  (  p  .  getCurrentToken  (  )  =  =  JsonToken  .  FIELD_NAME  )  {  return  deserializeObject  (  p  ,  ctxt  ,  ctxt  .  getNodeFactory  (  )  )  ;  }  throw  ctxt  .  mappingException  (  ObjectNode  .  class  )  ;  }  	JacksonDatabind_28_JsonNodeDeserializer_2_2	103	2	src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java
1224	if  (t  ==  JsonToken.VALUE_NULL)  {  return  null;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindjsontypeTestExternalId$ValueBean  out  of  VALUE_STRING  token  assertNotNull  (  b  )  ;  [METHOD]  _deserialize  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  int  index  String  typeId  [CLASS]  ExternalTypeHandler  [TYPE]  SettableBeanProperty  _property  [TYPE]  HashMap  _nameToPropertyIndex  [TYPE]  TokenBuffer[]  _tokens  [TYPE]  ArrayList  _properties  [TYPE]  String[]  _typeIds  [TYPE]  String  _typePropertyName  typeId  [TYPE]  int  index  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  merged  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  ExtTypedProperty[]  _properties  [TYPE]  TypeDeserializer  _typeDeserializer  [TYPE]  JsonParser  mp  p  p2  [CONTEXT]  protected  final  Object  _deserialize  (  JsonParser  p  ,  DeserializationContext  ctxt  ,  int  index  ,  String  typeId  )  throws  IOException  {  JsonParser  p2  =  _tokens[index]  .  asParser  (  p  )  ;  JsonToken  t  =  p2  .  nextToken  (  )  ;  [BUGGY]  TokenBuffer  merged  =  new  TokenBuffer  (  p  )  ;  merged  .  writeStartArray  (  )  ;  merged  .  writeString  (  typeId  )  ;  merged  .  copyCurrentStructure  (  p2  )  ;  merged  .  writeEndArray  (  )  ;    JsonParser  mp  =  merged  .  asParser  (  p  )  ;  mp  .  nextToken  (  )  ;  return  _properties[index]  .  getProperty  (  )  .  deserialize  (  mp  ,  ctxt  )  ;  }  	JacksonDatabind_29_ExternalTypeHandler_2_1	228	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
1225	if  (t  ==  JsonToken.VALUE_NULL)  {  _properties[index].getProperty().set(bean,  null);  return;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindjsontypeTestExternalId$ValueBean  out  of  VALUE_STRING  token  assertNotNull  (  b  )  ;  [METHOD]  _deserializeAndSet  [TYPE]  void  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  Object  bean  int  index  String  typeId  [CLASS]  ExternalTypeHandler  [TYPE]  SettableBeanProperty  _property  [TYPE]  HashMap  _nameToPropertyIndex  [TYPE]  TokenBuffer[]  _tokens  [TYPE]  ArrayList  _properties  [TYPE]  String[]  _typeIds  [TYPE]  String  _typePropertyName  typeId  [TYPE]  int  index  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  merged  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  [TYPE]  JsonToken  t  [TYPE]  ExtTypedProperty[]  _properties  [TYPE]  TypeDeserializer  _typeDeserializer  [TYPE]  JsonParser  mp  p  p2  [CONTEXT]  protected  final  void  _deserializeAndSet  (  JsonParser  p  ,  DeserializationContext  ctxt  ,  Object  bean  ,  int  index  ,  String  typeId  )  throws  IOException  {    JsonParser  p2  =  _tokens[index]  .  asParser  (  p  )  ;  JsonToken  t  =  p2  .  nextToken  (  )  ;  [BUGGY]  TokenBuffer  merged  =  new  TokenBuffer  (  p  )  ;  merged  .  writeStartArray  (  )  ;  merged  .  writeString  (  typeId  )  ;  merged  .  copyCurrentStructure  (  p2  )  ;  merged  .  writeEndArray  (  )  ;  JsonParser  mp  =  merged  .  asParser  (  p  )  ;  mp  .  nextToken  (  )  ;  _properties[index]  .  getProperty  (  )  .  deserializeAndSet  (  mp  ,  ctxt  ,  bean  )  ;  }  	JacksonDatabind_29_ExternalTypeHandler_2_2	251	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
1226	if  (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS))  {  buf  =  buf.forceUseOfBigDecimal(true);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  BigDecimal  =  -100000000000000000001  ;  got  back  BigDecimal  =  -10E+10  assertTrue  (  String  .  format  (   "Expected  %s  =  %s  ;  got  back  %s  =  %s "  ,  [METHOD]  valueToTree  [TYPE]  <T  [PARAMETER]  Object  fromValue  [CLASS]  ObjectMapper  [TYPE]  DefaultDeserializationContext  _deserializationContext  [TYPE]  Set  _registeredModuleTypes  [TYPE]  DefaultSerializerProvider  _serializerProvider  [TYPE]  AnnotationIntrospector  DEFAULT_ANNOTATION_INTROSPECTOR  [TYPE]  JsonFactory  _jsonFactory  [TYPE]  DeserializationConfig  _deserializationConfig  [TYPE]  JsonNode  result  [TYPE]  SimpleMixInResolver  _mixIns  [TYPE]  long  serialVersionUID  [TYPE]  PrettyPrinter  _defaultPrettyPrinter  [TYPE]  VisibilityChecker  STD_VISIBILITY_CHECKER  [TYPE]  DefaultTyping  JAVA_LANG_OBJECT  NON_CONCRETE_AND_ARRAYS  NON_FINAL  OBJECT_AND_NON_CONCRETE  _appliesFor  [TYPE]  ConcurrentHashMap  _rootDeserializers  [TYPE]  JsonParser  jp  [TYPE]  SerializerFactory  _serializerFactory  [TYPE]  SubtypeResolver  _subtypeResolver  [TYPE]  SerializationConfig  _serializationConfig  [TYPE]  IOException  e  [TYPE]  InjectableValues  _injectableValues  [TYPE]  JavaType  JSON_NODE_TYPE  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  buf  [TYPE]  Object  fromValue  [TYPE]  BaseSettings  DEFAULT_BASE  [TYPE]  TypeFactory  _typeFactory  [CONTEXT]  public  <T  extends  JsonNode>  T  valueToTree  (  Object  fromValue  )  throws  IllegalArgumentException  {  if  (  fromValue  =  =  null  )  return  null  ;  TokenBuffer  buf  =  new  TokenBuffer  (  this  ,  false  )  ;  [BUGGY]  JsonNode  result  ;  try  {  writeValue  (  buf  ,  fromValue  )  ;  JsonParser  jp  =  buf  .  asParser  (  )  ;  result  =  readTree  (  jp  )  ;  jp  .  close  (  )  ;  }  catch  (  IOException  e  )  {  //  should  not  occur  ,  no  real  i/o  .  .  .  throw  new  IllegalArgumentException  (  e  .  getMessage  (  )  ,  e  )  ;  }  return  (  T  )  result  ;  }  	JacksonDatabind_30_ObjectMapper_2_1	2510	0	src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
1227	if  (isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS))  {  buf  =  buf.forceUseOfBigDecimal(true);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  BigDecimal  =  -100000000000000000001  ;  got  back  BigDecimal  =  -10E+10  assertTrue  (  String  .  format  (   "Expected  %s  =  %s  ;  got  back  %s  =  %s "  ,  [METHOD]  _convert  [TYPE]  Object  [PARAMETER]  Object  fromValue  JavaType  toValueType  [CLASS]  ObjectMapper  [TYPE]  DefaultDeserializationContext  _deserializationContext  [TYPE]  Set  _registeredModuleTypes  [TYPE]  DefaultSerializerProvider  _serializerProvider  [TYPE]  AnnotationIntrospector  DEFAULT_ANNOTATION_INTROSPECTOR  [TYPE]  JsonFactory  _jsonFactory  [TYPE]  DeserializationConfig  _deserializationConfig  deserConfig  [TYPE]  SimpleMixInResolver  _mixIns  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  PrettyPrinter  _defaultPrettyPrinter  [TYPE]  VisibilityChecker  STD_VISIBILITY_CHECKER  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  DefaultTyping  JAVA_LANG_OBJECT  NON_CONCRETE_AND_ARRAYS  NON_FINAL  OBJECT_AND_NON_CONCRETE  _appliesFor  [TYPE]  ConcurrentHashMap  _rootDeserializers  [TYPE]  JsonParser  jp  [TYPE]  SerializerFactory  _serializerFactory  [TYPE]  SubtypeResolver  _subtypeResolver  [TYPE]  SerializationConfig  _serializationConfig  config  [TYPE]  IOException  e  [TYPE]  InjectableValues  _injectableValues  [TYPE]  JavaType  JSON_NODE_TYPE  toValueType  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  buf  [TYPE]  Object  fromValue  result  [TYPE]  Class  targetType  [TYPE]  BaseSettings  DEFAULT_BASE  [TYPE]  TypeFactory  _typeFactory  [CONTEXT]  protected  Object  _convert  (  Object  fromValue  ,  JavaType  toValueType  )  throws  IllegalArgumentException  {      Class<?>  targetType  =  toValueType  .  getRawClass  (  )  ;  if  (  targetType  !  =  Object  .  class  &&  !toValueType  .  hasGenericTypes  (  )  &&  targetType  .  isAssignableFrom  (  fromValue  .  getClass  (  )  )  )  {  return  fromValue  ;  }  TokenBuffer  buf  =  new  TokenBuffer  (  this  ,  false  )  ;  [BUGGY]  try  {    SerializationConfig  config  =  getSerializationConfig  (  )  .  without  (  SerializationFeature  .  WRAP_ROOT_VALUE  )  ;  _serializerProvider  (  config  )  .  serializeValue  (  buf  ,  fromValue  )  ;  	JacksonDatabind_30_ObjectMapper_2_2	3426	0	src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
1228	protected  boolean  _forceBigDecimal;  	[BUGGY]  [FE]  AssertionFailedError:  Expected  BigDecimal  =  -100000000000000000001  ;  got  back  BigDecimal  =  -10E+10  assertTrue  (  String  .  format  (   "Expected  %s  =  %s  ;  got  back  %s  =  %s "  ,  [CLASS]  [CONTEXT]  	JacksonDatabind_30_TokenBuffer_6_1	80	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1229	_forceBigDecimal  =  (ctxt  ==  null)  ?  false  :  ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);  	[BUGGY]  [FE]  AssertionFailedError:  Expected  BigDecimal  =  -100000000000000000001  ;  got  back  BigDecimal  =  -10E+10  assertTrue  (  String  .  format  (   "Expected  %s  =  %s  ;  got  back  %s  =  %s "  ,  [CLASS]  [CONTEXT]  	JacksonDatabind_30_TokenBuffer_6_2	188	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1230	public  TokenBuffer  forceUseOfBigDecimal(boolean  b)  {  _forceBigDecimal  =  b;  return  this;  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  BigDecimal  =  -100000000000000000001  ;  got  back  BigDecimal  =  -10E+10  assertTrue  (  String  .  format  (   "Expected  %s  =  %s  ;  got  back  %s  =  %s "  ,  [CLASS]  [CONTEXT]  	JacksonDatabind_30_TokenBuffer_6_3	193	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1231	if  (_forceBigDecimal)  {  	[BUGGY]  [FE]  AssertionFailedError:  Expected  BigDecimal  =  -100000000000000000001  ;  got  back  BigDecimal  =  -10E+10  assertTrue  (  String  .  format  (   "Expected  %s  =  %s  ;  got  back  %s  =  %s "  ,  [METHOD]  copyCurrentEvent  [TYPE]  void  [PARAMETER]  JsonParser  p  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [TYPE]  JsonParser  p  [CONTEXT]  writeEndArray  (  )  ;  break  ;  case  FIELD_NAME:  writeFieldName  (  p  .  getCurrentName  (  )  )  ;  break  ;  case  VALUE_STRING:  if  (  p  .  hasTextCharacters  (  )  )  {  writeString  (  p  .  getTextCharacters  (  )  ,  p  .  getTextOffset  (  )  ,  p  .  getTextLength  (  )  )  ;  }  else  {  writeString  (  p  .  getText  (  )  )  ;  }  break  ;  case  VALUE_NUMBER_INT:  switch  (  p  .  getNumberType  (  )  )  {  case  INT:  writeNumber  (  p  .  getIntValue  (  )  )  ;  break  ;  case  BIG_INTEGER:  writeNumber  (  p  .  getBigIntegerValue  (  )  )  ;  break  ;  default:  writeNumber  (  p  .  getLongValue  (  )  )  ;  }  break  ;  case  VALUE_NUMBER_FLOAT:  [BUGGY]      switch  (  p  .  getNumberType  (  )  )  {  	JacksonDatabind_30_TokenBuffer_6_4	959	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1232	writeNumber(p.getDecimalValue());  }  else  {  	[BUGGY]  [FE]  AssertionFailedError:  Expected  BigDecimal  =  -100000000000000000001  ;  got  back  BigDecimal  =  -10E+10  assertTrue  (  String  .  format  (   "Expected  %s  =  %s  ;  got  back  %s  =  %s "  ,  [METHOD]  copyCurrentEvent  [TYPE]  void  [PARAMETER]  JsonParser  p  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [TYPE]  JsonParser  p  [CONTEXT]  case  VALUE_STRING:  if  (  p  .  hasTextCharacters  (  )  )  {  writeString  (  p  .  getTextCharacters  (  )  ,  p  .  getTextOffset  (  )  ,  p  .  getTextLength  (  )  )  ;  }  else  {  writeString  (  p  .  getText  (  )  )  ;  }  break  ;  case  VALUE_NUMBER_INT:  switch  (  p  .  getNumberType  (  )  )  {  case  INT:  writeNumber  (  p  .  getIntValue  (  )  )  ;  break  ;  case  BIG_INTEGER:  writeNumber  (  p  .  getBigIntegerValue  (  )  )  ;  break  ;  default:  writeNumber  (  p  .  getLongValue  (  )  )  ;  }  break  ;  case  VALUE_NUMBER_FLOAT:      [BUGGY]  switch  (  p  .  getNumberType  (  )  )  {  case  BIG_DECIMAL:  writeNumber  (  p  .  getDecimalValue  (  )  )  ;  break  ;  case  FLOAT:  writeNumber  (  p  .  getFloatValue  (  )  )  ;  	JacksonDatabind_30_TokenBuffer_6_5	964	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1233	}  	[BUGGY]  [FE]  AssertionFailedError:  Expected  BigDecimal  =  -100000000000000000001  ;  got  back  BigDecimal  =  -10E+10  assertTrue  (  String  .  format  (   "Expected  %s  =  %s  ;  got  back  %s  =  %s "  ,  [METHOD]  copyCurrentEvent  [TYPE]  void  [PARAMETER]  JsonParser  p  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [TYPE]  JsonParser  p  [CONTEXT]  case  INT:  writeNumber  (  p  .  getIntValue  (  )  )  ;  break  ;  case  BIG_INTEGER:  writeNumber  (  p  .  getBigIntegerValue  (  )  )  ;  break  ;  default:  writeNumber  (  p  .  getLongValue  (  )  )  ;  }  break  ;  case  VALUE_NUMBER_FLOAT:      switch  (  p  .  getNumberType  (  )  )  {  case  BIG_DECIMAL:  writeNumber  (  p  .  getDecimalValue  (  )  )  ;  break  ;  case  FLOAT:  writeNumber  (  p  .  getFloatValue  (  )  )  ;  break  ;  default:  writeNumber  (  p  .  getDoubleValue  (  )  )  ;  [BUGGY]  }  break  ;  case  VALUE_TRUE:  writeBoolean  (  true  )  ;  break  ;  case  VALUE_FALSE:  	JacksonDatabind_30_TokenBuffer_6_6	973	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1234	_appendValue(JsonToken.VALUE_STRING,  text);  	[BUGGY]  _append  (  JsonToken  .  VALUE_STRING  ,  text  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeString  [TYPE]  void  [PARAMETER]  String  text  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  String  text  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeString  (  String  text  )  throws  IOException  {  if  (  text  =  =  null  )  {  writeNull  (  )  ;  }  else  {  [BUGGY]  _append  (  JsonToken  .  VALUE_STRING  ,  text  )  ;  }  }  	JacksonDatabind_31_TokenBuffer_20_1	672	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1235	_appendValue(JsonToken.VALUE_STRING,  text);  	[BUGGY]  _append  (  JsonToken  .  VALUE_STRING  ,  text  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeString  [TYPE]  void  [PARAMETER]  SerializableString  text  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  SerializableString  text  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeString  (  SerializableString  text  )  throws  IOException  {  if  (  text  =  =  null  )  {  writeNull  (  )  ;  }  else  {  [BUGGY]  _append  (  JsonToken  .  VALUE_STRING  ,  text  )  ;  }  }  	JacksonDatabind_31_TokenBuffer_20_2	686	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1236	_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT,  new  RawValue(text));  	[BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  new  RawValue  (  text  )  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeRawValue  [TYPE]  void  [PARAMETER]  String  text  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  String  text  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeRawValue  (  String  text  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  new  RawValue  (  text  )  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_3	731	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1237	_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT,  new  RawValue(text));  	[BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  new  RawValue  (  text  )  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeRawValue  [TYPE]  void  [PARAMETER]  String  text  int  offset  int  len  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  String  text  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  len  offset  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeRawValue  (  String  text  ,  int  offset  ,  int  len  )  throws  IOException  {  if  (  offset  >  0  ||  len  !  =  text  .  length  (  )  )  {  text  =  text  .  substring  (  offset  ,  offset+len  )  ;  }  [BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  new  RawValue  (  text  )  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_4	739	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1238	_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT,  new  String(text,  offset,  len));  	[BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  new  String  (  text  ,  offset  ,  len  )  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeRawValue  [TYPE]  void  [PARAMETER]  char[]  text  int  offset  int  len  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  len  offset  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  char[]  text  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeRawValue  (  char[]  text  ,  int  offset  ,  int  len  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  new  String  (  text  ,  offset  ,  len  )  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_5	744	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1239	_appendValue(JsonToken.VALUE_NUMBER_INT,  Short.valueOf(i));  	[BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_INT  ,  Short  .  valueOf  (  i  )  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  short  i  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  short  i  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNumber  (  short  i  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_INT  ,  Short  .  valueOf  (  i  )  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_6	755	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1240	_appendValue(JsonToken.VALUE_NUMBER_INT,  Integer.valueOf(i));  	[BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_INT  ,  Integer  .  valueOf  (  i  )  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  int  i  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  i  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNumber  (  int  i  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_INT  ,  Integer  .  valueOf  (  i  )  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_7	760	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1241	_appendValue(JsonToken.VALUE_NUMBER_INT,  Long.valueOf(l));  	[BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_INT  ,  Long  .  valueOf  (  l  )  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  long  l  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  l  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNumber  (  long  l  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_INT  ,  Long  .  valueOf  (  l  )  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_8	765	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1242	_appendValue(JsonToken.VALUE_NUMBER_FLOAT,  Double.valueOf(d));  	[BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_FLOAT  ,  Double  .  valueOf  (  d  )  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  double  d  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  double  d  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNumber  (  double  d  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_FLOAT  ,  Double  .  valueOf  (  d  )  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_9	770	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1243	_appendValue(JsonToken.VALUE_NUMBER_FLOAT,  Float.valueOf(f));  	[BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_FLOAT  ,  Float  .  valueOf  (  f  )  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  float  f  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  float  f  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNumber  (  float  f  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_FLOAT  ,  Float  .  valueOf  (  f  )  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_10	775	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1244	_appendValue(JsonToken.VALUE_NUMBER_FLOAT,  dec);  	[BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_FLOAT  ,  dec  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  BigDecimal  dec  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  BigDecimal  dec  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNumber  (  BigDecimal  dec  )  throws  IOException  {  if  (  dec  =  =  null  )  {  writeNull  (  )  ;  }  else  {  [BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_FLOAT  ,  dec  )  ;  }  }  	JacksonDatabind_31_TokenBuffer_20_11	783	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1245	_appendValue(JsonToken.VALUE_NUMBER_INT,  v);  	[BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_INT  ,  v  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  BigInteger  v  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  BigInteger  v  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNumber  (  BigInteger  v  )  throws  IOException  {  if  (  v  =  =  null  )  {  writeNull  (  )  ;  }  else  {  [BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_INT  ,  v  )  ;  }  }  	JacksonDatabind_31_TokenBuffer_20_12	792	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1246	_appendValue(JsonToken.VALUE_NUMBER_FLOAT,  encodedValue);  	[BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_FLOAT  ,  encodedValue  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNumber  [TYPE]  void  [PARAMETER]  String  encodedValue  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  String  encodedValue  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNumber  (  String  encodedValue  )  throws  IOException  {    [BUGGY]  _append  (  JsonToken  .  VALUE_NUMBER_FLOAT  ,  encodedValue  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_13	801	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1247	_appendValue(state  ?  JsonToken.VALUE_TRUE  :  JsonToken.VALUE_FALSE);  	[BUGGY]  _append  (  state  ?  JsonToken  .  VALUE_TRUE  :  JsonToken  .  VALUE_FALSE  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeBoolean  [TYPE]  void  [PARAMETER]  boolean  state  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  state  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeBoolean  (  boolean  state  )  throws  IOException  {  [BUGGY]  _append  (  state  ?  JsonToken  .  VALUE_TRUE  :  JsonToken  .  VALUE_FALSE  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_14	806	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1248	_appendValue(JsonToken.VALUE_NULL);  	[BUGGY]  _append  (  JsonToken  .  VALUE_NULL  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeNull  [TYPE]  void  [PARAMETER]  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeNull  (  )  throws  IOException  {  [BUGGY]  _append  (  JsonToken  .  VALUE_NULL  )  ;  }  	JacksonDatabind_31_TokenBuffer_20_15	811	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1249	_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT,  value);  	[BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  value  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeObject  [TYPE]  void  [PARAMETER]  Object  value  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  value  [TYPE]  Class  raw  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeObject  (  Object  value  )  throws  IOException  {  if  (  value  =  =  null  )  {  writeNull  (  )  ;  return  ;  }  Class<?>  raw  =  value  .  getClass  (  )  ;  if  (  raw  =  =  byte[]  .  class  ||  (  value  instanceof  RawValue  )  )  {  [BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  value  )  ;  return  ;  }  if  (  _objectCodec  =  =  null  )  {      _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  value  )  ;  }  else  {  _objectCodec  .  writeValue  (  this  ,  value  )  ;  }  }  	JacksonDatabind_31_TokenBuffer_20_16	829	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1250	_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT,  value);  	[BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  value  )  ;  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeObject  [TYPE]  void  [PARAMETER]  Object  value  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  Object  _objectId  _typeId  value  [TYPE]  Class  raw  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeObject  (  Object  value  )  throws  IOException  {  if  (  value  =  =  null  )  {  writeNull  (  )  ;  return  ;  }  Class<?>  raw  =  value  .  getClass  (  )  ;  if  (  raw  =  =  byte[]  .  class  ||  (  value  instanceof  RawValue  )  )  {  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  value  )  ;  return  ;  }  if  (  _objectCodec  =  =  null  )  {      [BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  value  )  ;  }  else  {  _objectCodec  .  writeValue  (  this  ,  value  )  ;  }  }  	JacksonDatabind_31_TokenBuffer_20_17	837	1	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1251	_appendValue(JsonToken.VALUE_EMBEDDED_OBJECT,  node);  	[BUGGY]  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [METHOD]  writeTree  [TYPE]  void  [PARAMETER]  TreeNode  node  [CLASS]  TokenBuffer  [TYPE]  JsonLocation  _location  [TYPE]  JsonWriteContext  _writeContext  [TYPE]  ObjectCodec  _codec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteBuilder  [TYPE]  TreeMap  _nativeIds  [TYPE]  int  DEFAULT_GENERATOR_FEATURES  TOKENS_PER_SEGMENT  _appendAt  _generatorFeatures  _segmentPtr  [TYPE]  Segment  _first  _last  _next  _segment  [TYPE]  long  _tokenTypes  [TYPE]  JsonReadContext  _parsingContext  [TYPE]  boolean  _closed  _forceBigDecimal  _hasNativeId  _hasNativeIds  _hasNativeObjectIds  _hasNativeTypeIds  _mayHaveNativeIds  false  true  [TYPE]  TreeNode  node  [TYPE]  Object  _objectId  _typeId  [TYPE]  JsonToken[]  TOKEN_TYPES_BY_INDEX  [TYPE]  Object[]  _tokens  [CONTEXT]  public  void  writeTree  (  TreeNode  node  )  throws  IOException  {  if  (  node  =  =  null  )  {  writeNull  (  )  ;  return  ;  }  if  (  _objectCodec  =  =  null  )  {  [BUGGY]  _append  (  JsonToken  .  VALUE_EMBEDDED_OBJECT  ,  node  )  ;  }  else  {  _objectCodec  .  writeTree  (  this  ,  node  )  ;  }  }  	JacksonDatabind_31_TokenBuffer_20_18	853	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1252	protected  final  void  _appendValue(JsonToken  type)  {  _writeContext.writeValue();  Segment  next  =  _hasNativeId  ?  _last.append(_appendAt,  type,  _objectId,  _typeId)  :  _last.append(_appendAt,  type);  if  (next  ==  null)  {  ++_appendAt;  }  else  {  _last  =  next;  _appendAt  =  1;    }  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_31_TokenBuffer_20_19	1091	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1253	protected  final  void  _appendValue(JsonToken  type,  Object  value)  {  _writeContext.writeValue();  Segment  next  =  _hasNativeId  ?  _last.append(_appendAt,  type,  value,  _objectId,  _typeId)  :  _last.append(_appendAt,  type,  value);  if  (next  ==  null)  {  ++_appendAt;  }  else  {  _last  =  next;  _appendAt  =  1;  }  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  name  'b'  (  JsonParser  )  ,  TokenBuffer  had  'a'  assertEquals  (  ctxt1  .  getCurrentIndex  (  )  ,  ctxt2  .  getCurrentIndex  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_31_TokenBuffer_20_20	1098	0	src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java
1254	case  JsonTokenId.ID_END_OBJECT:  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  javalangObject  out  of  END_OBJECT  token  assertTrue  (  pojo  .  value  instanceof  Map  )  ;  [METHOD]  deserialize  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  UntypedObjectDeserializer  [TYPE]  UntypedObjectDeserializer  instance  [TYPE]  JavaType  _listType  _mapType  [TYPE]  boolean  false  true  [TYPE]  Vanilla  std  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonDeserializer  _listDeserializer  _mapDeserializer  _numberDeserializer  _stringDeserializer  [TYPE]  long  serialVersionUID  [TYPE]  Object[]  NO_OBJECTS  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserialize  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  switch  (  p  .  getCurrentTokenId  (  )  )  {  case  JsonTokenId  .  ID_START_OBJECT:  case  JsonTokenId  .  ID_FIELD_NAME:    [BUGGY]  if  (  _mapDeserializer  !  =  null  )  {  return  _mapDeserializer  .  deserialize  (  p  ,  ctxt  )  ;  }  return  mapObject  (  p  ,  ctxt  )  ;  case  JsonTokenId  .  ID_START_ARRAY:  if  (  ctxt  .  isEnabled  (  DeserializationFeature  .  USE_JAVA_ARRAY_FOR_JSON_ARRAY  )  )  {  	JacksonDatabind_32_UntypedObjectDeserializer_2_1	221	0	src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
1255	case  JsonTokenId.ID_END_OBJECT:  return  new  LinkedHashMap<String,Object>(2);  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  javalangObject  out  of  END_OBJECT  token  assertTrue  (  pojo  .  value  instanceof  Map  )  ;  [METHOD]  deserialize  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  Vanilla  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  boolean  false  true  [TYPE]  Vanilla  std  [TYPE]  long  serialVersionUID  [TYPE]  JsonParser  p  [CONTEXT]  case  JsonTokenId  .  ID_EMBEDDED_OBJECT:  return  p  .  getEmbeddedObject  (  )  ;  case  JsonTokenId  .  ID_STRING:  return  p  .  getText  (  )  ;  case  JsonTokenId  .  ID_NUMBER_INT:  if  (  ctxt  .  hasSomeOfFeatures  (  F_MASK_INT_COERCIONS  )  )  {  return  _coerceIntegral  (  p  ,  ctxt  )  ;  }  return  p  .  getNumberValue  (  )  ;  //  should  be  optimal  ,  whatever  it  is  case  JsonTokenId  .  ID_NUMBER_FLOAT:  if  (  ctxt  .  isEnabled  (  DeserializationFeature  .  USE_BIG_DECIMAL_FOR_FLOATS  )  )  {  return  p  .  getDecimalValue  (  )  ;  }  return  Double  .  valueOf  (  p  .  getDoubleValue  (  )  )  ;  case  JsonTokenId  .  ID_TRUE:  return  Boolean  .  TRUE  ;  case  JsonTokenId  .  ID_FALSE:  return  Boolean  .  FALSE  ;  case  JsonTokenId  .  ID_NULL:  //  should  not  get  this  but  .  .  .  return  null  ;  [BUGGY]    default:  throw  ctxt  .  mappingException  (  Object  .  class  )  ;  	JacksonDatabind_32_UntypedObjectDeserializer_2_2	535	0	src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java
1256	||  _hasAnnotation(a,  JsonRawValue.class)  ||  _hasAnnotation(a,  JsonUnwrapped.class)  ||  _hasAnnotation(a,  JsonBackReference.class)  ||  _hasAnnotation(a,  JsonManagedReference.class))  {  	[BUGGY]  ||  _hasAnnotation  (  a  ,  JsonRawValue  .  class  )  )  {  [FE]  jacksondatabindJsonMappingException:  No  serializer  found  for  class  comfasterxmljacksondatabindstructTestUnwrapped$Outer  and  no  properties  discovered  to  create  BeanSerializer  (  to  avoid  exception  ,  disable  SerializationFeatureFAIL_ON_EMPTY_BEANS  )    )  assertFalse  (  actual  .  contains  (   "inner "  )  )  ;  [METHOD]  findNameForSerialization  [TYPE]  PropertyName  [PARAMETER]  Annotated  a  [CLASS]  JacksonAnnotationIntrospector  [TYPE]  Annotated  a  [TYPE]  String  name  [TYPE]  JsonProperty  pann  [TYPE]  boolean  false  true  [TYPE]  JsonGetter  jg  [TYPE]  long  serialVersionUID  [CONTEXT]  public  PropertyName  findNameForSerialization  (  Annotated  a  )  {  String  name  =  null  ;  JsonGetter  jg  =  _findAnnotation  (  a  ,  JsonGetter  .  class  )  ;  if  (  jg  !  =  null  )  {  name  =  jg  .  value  (  )  ;  }  else  {  JsonProperty  pann  =  _findAnnotation  (  a  ,  JsonProperty  .  class  )  ;  if  (  pann  !  =  null  )  {  name  =  pann  .  value  (  )  ;      }  else  if  (  _hasAnnotation  (  a  ,  JsonSerialize  .  class  )  ||  _hasAnnotation  (  a  ,  JsonView  .  class  )  [BUGGY]  ||  _hasAnnotation  (  a  ,  JsonRawValue  .  class  )  )  {  name  =   " "  ;  }  else  {  return  null  ;  }  }  return  PropertyName  .  construct  (  name  )  ;  }  	JacksonDatabind_33_JacksonAnnotationIntrospector_1_1	748	1	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1257	visitFloatFormat(visitor,  typeHint,  JsonParser.NumberType.BIG_DECIMAL);  	[BUGGY]  visitFloatFormat  (  visitor  ,  typeHint  ,  JsonParser  .  NumberType  .  BIG_INTEGER  )  ;  [FE]  ComparisonFailure:  expected:<dec  (  [numberType  =  BIG_[DECIMAL]]  )  ][optProp  bigInt  (  [>  but  was:<dec  (  [numberType  =  BIG_[INTEGER]]  )  ][optProp  bigInt  (  [>  [METHOD]  acceptJsonFormatVisitor  [TYPE]  void  [PARAMETER]  JsonFormatVisitorWrapper  visitor  JavaType  typeHint  [CLASS]  NumberSerializer  [TYPE]  NumberSerializer  instance  [TYPE]  JavaType  typeHint  [TYPE]  Class  h  [TYPE]  boolean  _isInt  false  true  [TYPE]  JsonFormatVisitorWrapper  visitor  [CONTEXT]  public  void  acceptJsonFormatVisitor  (  JsonFormatVisitorWrapper  visitor  ,  JavaType  typeHint  )  throws  JsonMappingException  {  if  (  _isInt  )  {  visitIntFormat  (  visitor  ,  typeHint  ,  JsonParser  .  NumberType  .  BIG_INTEGER  )  ;  }  else  {  Class<?>  h  =  handledType  (  )  ;  if  (  h  =  =  BigDecimal  .  class  )  {  [BUGGY]  visitFloatFormat  (  visitor  ,  typeHint  ,  JsonParser  .  NumberType  .  BIG_INTEGER  )  ;  }  else  {    }  }  }  	JacksonDatabind_34_NumberSerializer_1_1	81	1	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java
1258	JsonToken  t  =  p.getCurrentToken();  if  (t  ==  JsonToken.START_OBJECT)  {  	[BUGGY]  if  (  p  .  getCurrentToken  (  )  !  =  JsonToken  .  START_OBJECT  )  {  throw  ctxt  .  wrongTokenException  (  p  ,  JsonToken  .  START_OBJECT  ,   "need  JSON  Object  to  contain  As  .  WRAPPER_OBJECT  type  information  for  class   "+baseTypeName  (  )  )  ;  }  [FE]  jacksondatabindJsonMappingException:  Unexpected  token  (  FIELD_NAME  )  ,  expected  START_OBJECT:  need  JSON  Object  to  contain  AsWRAPPER_OBJECT  type  information  for  class  comfasterxmljacksondatabindjsontypeWrapperObjectWithObjectIdTest$Computer  assertEquals  (  3  ,  result  .  computers  .  size  (  )  )  ;  [METHOD]  _deserialize  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  AsWrapperTypeDeserializer  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  tb  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  typeId  value  [TYPE]  String  typeId  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  JsonParser  p  [CONTEXT]  private  final  Object  _deserialize  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  p  .  canReadTypeId  (  )  )  {  Object  typeId  =  p  .  getTypeId  (  )  ;  if  (  typeId  !  =  null  )  {  return  _deserializeWithNativeTypeId  (  p  ,  ctxt  ,  typeId  )  ;  }  }  [BUGGY]  if  (  p  .  getCurrentToken  (  )  !  =  JsonToken  .  START_OBJECT  )  {  throw  ctxt  .  wrongTokenException  (  p  ,  JsonToken  .  START_OBJECT  ,   "need  JSON  Object  to  contain  As  .  WRAPPER_OBJECT  type  information  for  class   "+baseTypeName  (  )  )  ;  }  if  (  p  .  nextToken  (  )  !  =  JsonToken  .  FIELD_NAME  )  {  	JacksonDatabind_35_AsWrapperTypeDeserializer_2_1	89	4	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java
1259	}  else  if  (t  !=  JsonToken.FIELD_NAME)  {  throw  ctxt.wrongTokenException(p,  JsonToken.START_OBJECT,   "need  JSON  Object  to  contain  As.WRAPPER_OBJECT  type  information  for  class   "+baseTypeName());  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Unexpected  token  (  FIELD_NAME  )  ,  expected  START_OBJECT:  need  JSON  Object  to  contain  AsWRAPPER_OBJECT  type  information  for  class  comfasterxmljacksondatabindjsontypeWrapperObjectWithObjectIdTest$Computer  assertEquals  (  3  ,  result  .  computers  .  size  (  )  )  ;  [METHOD]  _deserialize  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  AsWrapperTypeDeserializer  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  tb  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  typeId  value  [TYPE]  String  typeId  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  JsonParser  p  [CONTEXT]  private  final  Object  _deserialize  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  p  .  canReadTypeId  (  )  )  {  Object  typeId  =  p  .  getTypeId  (  )  ;  if  (  typeId  !  =  null  )  {  return  _deserializeWithNativeTypeId  (  p  ,  ctxt  ,  typeId  )  ;  }  }  if  (  p  .  getCurrentToken  (  )  !  =  JsonToken  .  START_OBJECT  )  {  throw  ctxt  .  wrongTokenException  (  p  ,  JsonToken  .  START_OBJECT  ,   "need  JSON  Object  to  contain  As  .  WRAPPER_OBJECT  type  information  for  class   "+baseTypeName  (  )  )  ;  }  if  (  p  .  nextToken  (  )  !  =  JsonToken  .  FIELD_NAME  )  {  throw  ctxt  .  wrongTokenException  (  p  ,  JsonToken  .  FIELD_NAME  ,   "need  JSON  String  that  contains  type  id  (  for  subtype  of   "+baseTypeName  (  )  + "  )   "  )  ;  }  [BUGGY]  final  String  typeId  =  p  .  getText  (  )  ;  JsonDeserializer<Object>  deser  =  _findDeserializer  (  ctxt  ,  typeId  )  ;  p  .  nextToken  (  )  ;    if  (  _typeIdVisible  &&  p  .  getCurrentToken  (  )  =  =  JsonToken  .  START_OBJECT  )  {  	JacksonDatabind_35_AsWrapperTypeDeserializer_2_2	98	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java
1260	@Override    public  void  setLenient(boolean  enabled)  {  Boolean  newValue  =  enabled;  if  (_lenient  !=  newValue)  {  _lenient  =  newValue;  _clearFormats();  }  }  	[BUGGY]  [FE]  NullPointerException  assertNotNull  (  dt  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_36_StdDateFormat_2_1	250	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1261	if  (lenient  !=  null)  {  df.setLenient(lenient.booleanValue());  }  	[BUGGY]  [FE]  NullPointerException  assertNotNull  (  dt  )  ;  [METHOD]  _cloneFormat  [TYPE]  DateFormat  [PARAMETER]  DateFormat  df  String  format  TimeZone  tz  Locale  loc  Boolean  lenient  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  loc  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  tz  [TYPE]  boolean  false  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_ISO8601_Z  DATE_FORMAT_PLAIN  DATE_FORMAT_RFC1123  _formatISO8601  _formatISO8601_z  _formatPlain  _formatRFC1123  df  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_ISO8601_Z  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  format  [TYPE]  String[]  ALL_FORMATS  [TYPE]  Boolean  _lenient  lenient  [CONTEXT]  private  final  static  DateFormat  _cloneFormat  (  DateFormat  df  ,  String  format  ,  TimeZone  tz  ,  Locale  loc  ,  Boolean  lenient  )  {  if  (  !loc  .  equals  (  DEFAULT_LOCALE  )  )  {  df  =  new  SimpleDateFormat  (  format  ,  loc  )  ;  df  .  setTimeZone  (  (  tz  =  =  null  )  ?  DEFAULT_TIMEZONE  :  tz  )  ;  }  else  {  df  =  (  DateFormat  )  df  .  clone  (  )  ;  if  (  tz  !  =  null  )  {  df  .  setTimeZone  (  tz  )  ;  }  }  [BUGGY]  return  df  ;  }  	JacksonDatabind_36_StdDateFormat_2_2	557	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1262	return  new  SimpleType(subclass,  _bindings,  this,  _superInterfaces,  	[BUGGY]  return  new  SimpleType  (  subclass  ,  _bindings  ,  _superClass  ,  _superInterfaces  ,  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "name "  (  class  comfasterxmljacksondatabindobjectidObjecid1083Test$JsonMapSchema  )  ,  not  marked  as  ignorable  (  0  known  properties:  ]  )  [METHOD]  _narrow  [TYPE]  JavaType  [PARAMETER]  Class<?>  subclass  [CLASS]  SimpleType  [TYPE]  long  serialVersionUID  [TYPE]  Class  subclass  [TYPE]  boolean  false  true  [CONTEXT]  protected  JavaType  _narrow  (  Class<?>  subclass  )  {  if  (  _class  =  =  subclass  )  {  return  this  ;  }      if  (  !_class  .  isAssignableFrom  (  subclass  )  )  {  throw  new  IllegalArgumentException  (   "Class   "+subclass  .  getName  (  )  + "  not  sub-type  of   "  +_class  .  getName  (  )  )  ;  }    [BUGGY]  return  new  SimpleType  (  subclass  ,  _bindings  ,  _superClass  ,  _superInterfaces  ,  _valueHandler  ,  _typeHandler  ,  _asStatic  )  ;  }  	JacksonDatabind_37_SimpleType_1_1	135	1	src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
1263		[BUGGY]  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindinteropDeprecatedTypeHandling1102Test$Point>  but  was:<class  javautilLinkedHashMap>  assertEquals  (  5  ,  p  .  getY  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_38_CollectionType_2_1	3	0	src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java
1264	TypeVariable<?>[]  vars  =  rawType.getTypeParameters();  TypeBindings  bindings;  if  ((vars  ==  null)  ||  (vars.length  !=  1))  {  bindings  =  TypeBindings.emptyBindings();  }  else  {  bindings  =  TypeBindings.create(rawType,  elemT);  }  return  new  CollectionType(rawType,  bindings,  	[BUGGY]  return  new  CollectionType  (  rawType  ,  null  ,  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindinteropDeprecatedTypeHandling1102Test$Point>  but  was:<class  javautilLinkedHashMap>  assertEquals  (  5  ,  p  .  getY  (  )  )  ;  [METHOD]  construct  [TYPE]  CollectionType  [PARAMETER]  Class<?>  rawType  JavaType  elemT  [CLASS]  CollectionType  [TYPE]  Class  rawType  [TYPE]  JavaType  elemT  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [CONTEXT]  public  static  CollectionType  construct  (  Class<?>  rawType  ,  JavaType  elemT  )  {    [BUGGY]  return  new  CollectionType  (  rawType  ,  null  ,  _bogusSuperClass  (  rawType  )  ,  null  ,  elemT  ,  null  ,  null  ,  false  )  ;  }  	JacksonDatabind_38_CollectionType_2_2	50	1	src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java
1265		[BUGGY]  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindinteropDeprecatedTypeHandling1102Test$Point>  but  was:<class  javautilLinkedHashMap>  assertEquals  (  5  ,  p  .  getY  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_38_MapType_2_1	3	0	src/main/java/com/fasterxml/jackson/databind/type/MapType.java
1266	TypeVariable<?>[]  vars  =  rawType.getTypeParameters();  TypeBindings  bindings;  if  ((vars  ==  null)  ||  (vars.length  !=  2))  {  bindings  =  TypeBindings.emptyBindings();  }  else  {  bindings  =  TypeBindings.create(rawType,  keyT,  valueT);  }  return  new  MapType(rawType,  bindings,  _bogusSuperClass(rawType),  null,  	[BUGGY]  return  new  MapType  (  rawType  ,  null  ,  _bogusSuperClass  (  rawType  )  ,  null  ,  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindinteropDeprecatedTypeHandling1102Test$Point>  but  was:<class  javautilLinkedHashMap>  assertEquals  (  5  ,  p  .  getY  (  )  )  ;  [METHOD]  construct  [TYPE]  MapType  [PARAMETER]  Class<?>  rawType  JavaType  keyT  JavaType  valueT  [CLASS]  MapType  [TYPE]  Class  rawType  [TYPE]  JavaType  keyT  valueT  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [CONTEXT]  public  static  MapType  construct  (  Class<?>  rawType  ,  JavaType  keyT  ,  JavaType  valueT  )  {    [BUGGY]  return  new  MapType  (  rawType  ,  null  ,  _bogusSuperClass  (  rawType  )  ,  null  ,  keyT  ,  valueT  ,  null  ,  null  ,  false  )  ;  }  	JacksonDatabind_38_MapType_2_2	47	1	src/main/java/com/fasterxml/jackson/databind/type/MapType.java
1267	TypeBindings  b  =  TypeBindings.emptyBindings();  return  new  SimpleType(cls,  b,  _buildSuperClass(cls.getSuperclass(),  b),  null,  null,  null,  false);  	[BUGGY]  return  new  SimpleType  (  cls  ,  TypeBindings  .  emptyBindings  (  )  ,  _bogusSuperClass  (  cls  )  ,  null  ,  null  ,  null  ,  false  )  ;  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindinteropDeprecatedTypeHandling1102Test$Point>  but  was:<class  javautilLinkedHashMap>  assertEquals  (  5  ,  p  .  getY  (  )  )  ;  [METHOD]  construct  [TYPE]  SimpleType  [PARAMETER]  Class<?>  cls  [CLASS]  SimpleType  [TYPE]  long  serialVersionUID  [TYPE]  Class  cls  [TYPE]  boolean  false  true  [CONTEXT]  public  static  SimpleType  construct  (  Class<?>  cls  )  {    if  (  Map  .  class  .  isAssignableFrom  (  cls  )  )  {  throw  new  IllegalArgumentException  (   "Can  not  construct  SimpleType  for  a  Map  (  class:   "+cls  .  getName  (  )  + "  )   "  )  ;  }  if  (  Collection  .  class  .  isAssignableFrom  (  cls  )  )  {  throw  new  IllegalArgumentException  (   "Can  not  construct  SimpleType  for  a  Collection  (  class:   "+cls  .  getName  (  )  + "  )   "  )  ;  }  if  (  cls  .  isArray  (  )  )  {  throw  new  IllegalArgumentException  (   "Can  not  construct  SimpleType  for  an  array  (  class:   "+cls  .  getName  (  )  + "  )   "  )  ;  }  [BUGGY]  return  new  SimpleType  (  cls  ,  TypeBindings  .  emptyBindings  (  )  ,  _bogusSuperClass  (  cls  )  ,  null  ,  null  ,  null  ,  false  )  ;  }  	JacksonDatabind_38_SimpleType_2_1	116	2	src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
1268	private  static  JavaType  _buildSuperClass(Class<?>  superClass,  TypeBindings  b)  {  if  (superClass  ==  null)  {  return  null;  }  if  (superClass  ==  Object.class)  {  return  TypeFactory.unknownType();  }  JavaType  superSuper  =  _buildSuperClass(superClass.getSuperclass(),  b);  return  new  SimpleType(superClass,  b,  superSuper,  null,  null,  null,  false);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindinteropDeprecatedTypeHandling1102Test$Point>  but  was:<class  javautilLinkedHashMap>  assertEquals  (  5  ,  p  .  getY  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_38_SimpleType_2_2	251	0	src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
1269	if  (p.hasToken(JsonToken.FIELD_NAME))  {  while  (true)  {  JsonToken  t  =  p.nextToken();  if  ((t  ==  null)  ||  (t  ==  JsonToken.END_OBJECT))  {  break;  }  p.skipChildren();  }  }  else  {  }  	[BUGGY]  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "location "  (  class  comfasterxmljacksondatabindjsontypeTestPolymorphicWithDefaultImpl$CallRecord  )  ,  not  marked  as  ignorable  (  4  known  properties:   "version "  ,   "item "  ,   "item2 "  ,   "application "]  )  assertEquals  (   "123 "  ,  r3  .  application  )  ;  [METHOD]  deserialize  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  NullifyingDeserializer  [TYPE]  DeserializationContext  ctxt  [TYPE]  boolean  false  true  [TYPE]  NullifyingDeserializer  instance  [TYPE]  long  serialVersionUID  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserialize  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {    [BUGGY]  p  .  skipChildren  (  )  ;  return  null  ;  }  	JacksonDatabind_39_NullifyingDeserializer_1_1	35	0	src/main/java/com/fasterxml/jackson/databind/deser/std/NullifyingDeserializer.java
1270	@Override  public  T  getEmptyValue(DeserializationContext  ctxt)  throws  JsonMappingException  {  if  (_primitive  &&  ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES))  {  throw  ctxt.mappingException(   "Can  not  map  Empty  String  as  null  into  type  %s  (set  DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES  to  \'false\'  to  allow) ",  handledType().toString());  }  return  _nullValue;  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  not  have  passed  assertEquals  (  emptyValue  ,  intR  .  readValue  (  EMPTY  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_40_NumberDeserializers_1_1	148	0	src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java
1271	TypeBindings  bindings  =  (contextClass  ==  null)  ?  TypeBindings.emptyBindings()  :  constructType(contextClass).getBindings();  return  _fromAny(null,  type,  bindings);  	[BUGGY]  return  constructType  (  type  ,  constructType  (  contextClass  )  )  ;  [FE]  IllegalArgumentException:  Unrecognized  Type:  [null]  assertEquals  (  Point  .  class  ,  t3  .  getRawClass  (  )  )  ;  [METHOD]  constructType  [TYPE]  JavaType  [PARAMETER]  Type  type  Class<?>  contextClass  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  Type  type  [TYPE]  TypeParser  _parser  [TYPE]  boolean  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  contextClass  [TYPE]  TypeFactory  instance  [TYPE]  long  serialVersionUID  [TYPE]  TypeBindings  EMPTY_BINDINGS  [CONTEXT]  public  JavaType  constructType  (  Type  type  ,  Class<?>  contextClass  )  {  [BUGGY]  return  constructType  (  type  ,  constructType  (  contextClass  )  )  ;  }  	JacksonDatabind_41_TypeFactory_2_1	602	1	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1272	TypeBindings  bindings  =  (contextType  ==  null)  ?  TypeBindings.emptyBindings()  :  contextType.getBindings();  return  _fromAny(null,  type,  bindings);  	[BUGGY]  return  _fromAny  (  null  ,  type  ,  contextType  .  getBindings  (  )  )  ;  [FE]  IllegalArgumentException:  Unrecognized  Type:  [null]  assertEquals  (  Point  .  class  ,  t3  .  getRawClass  (  )  )  ;  [METHOD]  constructType  [TYPE]  JavaType  [PARAMETER]  Type  type  JavaType  contextType  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  long  serialVersionUID  [TYPE]  TypeBindings  EMPTY_BINDINGS  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  Type  type  [TYPE]  JavaType  contextType  [TYPE]  boolean  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  [TYPE]  TypeFactory  instance  [CONTEXT]  public  JavaType  constructType  (  Type  type  ,  JavaType  contextType  )  {  [BUGGY]  return  _fromAny  (  null  ,  type  ,  contextType  .  getBindings  (  )  )  ;  }  	JacksonDatabind_41_TypeFactory_2_2	610	1	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1273	if  (_kind  ==  STD_LOCALE)  {  return  Locale.ROOT;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected  same:<>  was  not:<null>  assertSame  (  Locale  .  ROOT  ,  loc  )  ;  [METHOD]  _deserializeFromEmptyString  [TYPE]  Object  [PARAMETER]  [CLASS]  Std  [TYPE]  long  serialVersionUID  [TYPE]  int  STD_CHARSET  STD_CLASS  STD_CURRENCY  STD_FILE  STD_INET_ADDRESS  STD_INET_SOCKET_ADDRESS  STD_JAVA_TYPE  STD_LOCALE  STD_PATTERN  STD_TIME_ZONE  STD_URI  STD_URL  _kind  [TYPE]  boolean  false  true  [CONTEXT]  protected  Object  _deserializeFromEmptyString  (  )  throws  IOException  {  if  (  _kind  =  =  STD_URI  )  {  return  URI  .  create  (   " "  )  ;  }  [BUGGY]  return  super  .  _deserializeFromEmptyString  (  )  ;  }  	JacksonDatabind_42_FromStringDeserializer_1_1	284	0	src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java
1274		[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  javalangString  out  of  VALUE_NULL  token  assertEquals  (  3  ,  value  .  value  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_43_ObjectIdValueProperty_3_1	7	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java
1275		[BUGGY]  Object  id  =  _valueDeserializer  .  deserialize  (  p  ,  ctxt  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  javalangString  out  of  VALUE_NULL  token  assertEquals  (  3  ,  value  .  value  )  ;  [METHOD]  deserializeSetAndReturn  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  Object  instance  [CLASS]  ObjectIdValueProperty  [TYPE]  ReadableObjectId  roid  [TYPE]  boolean  false  true  [TYPE]  SettableBeanProperty  idProp  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  id  instance  [TYPE]  long  serialVersionUID  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeSetAndReturn  (  JsonParser  p  ,  DeserializationContext  ctxt  ,  Object  instance  )  throws  IOException  {  [BUGGY]  Object  id  =  _valueDeserializer  .  deserialize  (  p  ,  ctxt  )  ;        if  (  id  =  =  null  )  {  return  null  ;  }  ReadableObjectId  roid  =  ctxt  .  findObjectId  (  id  ,  _objectIdReader  .  generator  ,  _objectIdReader  .  resolver  )  ;  roid  .  bindItem  (  instance  )  ;  SettableBeanProperty  idProp  =  _objectIdReader  .  idProperty  ;  if  (  idProp  !  =  null  )  {  return  idProp  .  setAndReturn  (  instance  ,  id  )  ;  }  return  instance  ;  }  	JacksonDatabind_43_ObjectIdValueProperty_3_2	78	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java
1276	if  (p.hasToken(JsonToken.VALUE_NULL))  {  Object  id  =  _valueDeserializer.deserialize(p,  ctxt);  	[BUGGY]  if  (  id  =  =  null  )  {  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  javalangString  out  of  VALUE_NULL  token  assertEquals  (  3  ,  value  .  value  )  ;  [METHOD]  deserializeSetAndReturn  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  Object  instance  [CLASS]  ObjectIdValueProperty  [TYPE]  ReadableObjectId  roid  [TYPE]  boolean  false  true  [TYPE]  SettableBeanProperty  idProp  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  id  instance  [TYPE]  long  serialVersionUID  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeSetAndReturn  (  JsonParser  p  ,  DeserializationContext  ctxt  ,  Object  instance  )  throws  IOException  {  Object  id  =  _valueDeserializer  .  deserialize  (  p  ,  ctxt  )  ;        [BUGGY]  if  (  id  =  =  null  )  {  return  null  ;  }  ReadableObjectId  roid  =  ctxt  .  findObjectId  (  id  ,  _objectIdReader  .  generator  ,  _objectIdReader  .  resolver  )  ;  roid  .  bindItem  (  instance  )  ;  SettableBeanProperty  idProp  =  _objectIdReader  .  idProperty  ;  if  (  idProp  !  =  null  )  {  return  idProp  .  setAndReturn  (  instance  ,  id  )  ;  }  return  instance  ;  }  	JacksonDatabind_43_ObjectIdValueProperty_3_3	85	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java
1277	if  (!_class.isAssignableFrom(subclass))  {  	[BUGGY]  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "b "  (  class  comfasterxmljacksondatabindjsontypeTestSubtypes$Default1125  )  ,  not  marked  as  ignorable  (  2  known  properties:   "a "  ,   "def "]  )  assertEquals  (  9  ,  impl  .  def  )  ;  [METHOD]  _narrow  [TYPE]  JavaType  [PARAMETER]  Class<?>  subclass  [CLASS]  SimpleType  [TYPE]  long  serialVersionUID  [TYPE]  Class  subclass  [TYPE]  boolean  false  true  [CONTEXT]  protected  JavaType  _narrow  (  Class<?>  subclass  )  {  if  (  _class  =  =  subclass  )  {  return  this  ;  }      [BUGGY]  throw  new  IllegalArgumentException  (   "Class   "+subclass  .  getName  (  )  + "  not  sub-type  of   "  +_class  .  getName  (  )  )  ;  return  new  SimpleType  (  subclass  ,  _bindings  ,  this  ,  _superInterfaces  ,  _valueHandler  ,  _typeHandler  ,  _asStatic  )  ;    }  	JacksonDatabind_44_SimpleType_2_1	132	0	src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
1278	}  Class<?>  next  =  subclass.getSuperclass();  if  (next  ==  _class)  {    return  new  SimpleType(subclass,  _bindings,  this,  _superInterfaces,  _valueHandler,  _typeHandler,  _asStatic);  }  if  ((next  !=  null)  &&  _class.isAssignableFrom(next))  {  JavaType  superb  =  _narrow(next);  return  new  SimpleType(subclass,  _bindings,  superb,  null,  _valueHandler,  _typeHandler,  _asStatic);  }  Class<?>[]  nextI  =  subclass.getInterfaces();  for  (Class<?>  iface  :  nextI)  {  if  (iface  ==  _class)  {    return  new  SimpleType(subclass,  _bindings,  null,  new  JavaType[]  {  this  },  _valueHandler,  _typeHandler,  _asStatic);  }  if  (_class.isAssignableFrom(iface))  {    JavaType  superb  =  _narrow(iface);  return  new  SimpleType(subclass,  _bindings,  null,  new  JavaType[]  {  superb  },  _valueHandler,  _typeHandler,  _asStatic);  }  }  throw  new  IllegalArgumentException( "Internal  error:  Can  not  resolve  sub-type  for  Class   "+subclass.getName()+ "  to   "  +_class.getName());  	[BUGGY]  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "b "  (  class  comfasterxmljacksondatabindjsontypeTestSubtypes$Default1125  )  ,  not  marked  as  ignorable  (  2  known  properties:   "a "  ,   "def "]  )  assertEquals  (  9  ,  impl  .  def  )  ;  [METHOD]  _narrow  [TYPE]  JavaType  [PARAMETER]  Class<?>  subclass  [CLASS]  SimpleType  [TYPE]  long  serialVersionUID  [TYPE]  Class  subclass  [TYPE]  boolean  false  true  [CONTEXT]  protected  JavaType  _narrow  (  Class<?>  subclass  )  {  if  (  _class  =  =  subclass  )  {  return  this  ;  }      throw  new  IllegalArgumentException  (   "Class   "+subclass  .  getName  (  )  + "  not  sub-type  of   "  +_class  .  getName  (  )  )  ;  return  new  SimpleType  (  subclass  ,  _bindings  ,  this  ,  _superInterfaces  ,  _valueHandler  ,  _typeHandler  ,  _asStatic  )  ;  [BUGGY]    }  	JacksonDatabind_44_SimpleType_2_2	138	0	src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java
1279	if  ((shape  ==  JsonFormat.Shape.STRING)  ||  format.hasPattern()  ||  format.hasLocale()  ||  format.hasTimeZone())  {  	[BUGGY]  if  (  format  .  getShape  (  )  =  =  JsonFormat  .  Shape  .  STRING  )  {  [FE]  ComparisonFailure:  expected:<{ "date ":[ "1970-01-01 "]}>  but  was:<{ "date ":[0]}>  assertEquals  (  aposToQuotes  (   "{'date':'1970-01-01T01:00:00  .  000+0100'} "  )  ,  json  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  serializers  BeanProperty  property  [CLASS]  DateTimeSerializerBase  [TYPE]  Locale  loc  [TYPE]  TimeZone  tz  [TYPE]  Shape  shape  [TYPE]  boolean  false  true  [TYPE]  DateFormat  _customFormat  [TYPE]  Value  format  [TYPE]  String  pattern  [TYPE]  Boolean  _useTimestamp  [TYPE]  SerializerProvider  serializers  [TYPE]  SimpleDateFormat  df  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonSerializer<?>  createContextual  (  SerializerProvider  serializers  ,  BeanProperty  property  )  throws  JsonMappingException  {  if  (  property  !  =  null  )  {  JsonFormat  .  Value  format  =  serializers  .  getAnnotationIntrospector  (  )  .  findFormat  (  (  Annotated  )  property  .  getMember  (  )  )  ;  if  (  format  !  =  null  )  {  JsonFormat  .  Shape  shape  =  format  .  getShape  (  )  ;  if  (  shape  .  isNumeric  (  )  )  {  return  withFormat  (  Boolean  .  TRUE  ,  null  )  ;  }  [BUGGY]  if  (  format  .  getShape  (  )  =  =  JsonFormat  .  Shape  .  STRING  )  {  TimeZone  tz  =  format  .  getTimeZone  (  )  ;  final  String  pattern  =  format  .  hasPattern  (  )  ?  format  .  getPattern  (  )  :  StdDateFormat  .  DATE_FORMAT_STR_ISO8601  ;  final  Locale  loc  =  format  .  hasLocale  (  )  	JacksonDatabind_45_DateTimeSerializerBase_1_1	63	1	src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java
1280	sb.append(">;");	[BUGGY]  [FE]  ComparisonFailure:  expected:<e<Ljava/lang/String  ;  [>]  ;  >  but  was:<e<Ljava/lang/String  ;  []  ;  >  assertEquals  (   "Ljava/util/concurrent/atomic/AtomicReference<Ljava/lang/String  ;  >  ;   "  ,  t  .  getGenericSignature  (  )  )  ;  [METHOD]  getGenericSignature  [TYPE]  StringBuilder  [PARAMETER]  StringBuilder  sb  [CLASS]  ReferenceType  [TYPE]  JavaType  _referencedType  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  long  serialVersionUID  [CONTEXT]  public  StringBuilder  getGenericSignature  (  StringBuilder  sb  )  {  _classSignature  (  _class  ,  sb  ,  false  )  ;  sb  .  append  (  '<'  )  ;  sb  =  _referencedType  .  getGenericSignature  (  sb  )  ;  [BUGGY]  sb  .  append  (  '  ;  '  )  ;  return  sb  ;  }  	JacksonDatabind_46_ReferenceType_1_1	156	0	src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
1281	Class<?>  currRaw  =  type.getRawClass();  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [types  not  related]  )  :  got  one  with  message   "Failed  to  widen  type  [simple  type  ,  class  javalangLong]  with  annotation  (  value  javalangString  )  ,  from  [METHOD]  refineSerializationType  [TYPE]  JavaType  [PARAMETER]  MapperConfig<?>  config  Annotated  a  JavaType  baseType  [CLASS]  AnnotationIntrospector  [TYPE]  Annotated  a  [TYPE]  Type  BACK_REFERENCE  MANAGED_REFERENCE  _type  [TYPE]  JavaType  baseType  contentType  keyType  type  [TYPE]  boolean  false  true  [TYPE]  MapperConfig  config  [TYPE]  Class  contentClass  currRaw  keyClass  serClass  [TYPE]  String  _name  [TYPE]  TypeFactory  tf  [TYPE]  IllegalArgumentException  iae  [CONTEXT]  public  JavaType  refineSerializationType  (  final  MapperConfig<?>  config  ,  final  Annotated  a  ,  final  JavaType  baseType  )  throws  JsonMappingException  {  JavaType  type  =  baseType  ;  final  TypeFactory  tf  =  config  .  getTypeFactory  (  )  ;          Class<?>  serClass  =  findSerializationType  (  a  )  ;  if  (  serClass  !  =  null  )  {  if  (  type  .  hasRawClass  (  serClass  )  )  {    type  =  type  .  withStaticTyping  (  )  ;  }  else  {  [BUGGY]  try  {    type  =  tf  .  constructGeneralizedType  (  type  ,  serClass  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (  null  ,  	JacksonDatabind_47_AnnotationIntrospector_2_1	816	0	src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java
1282	if  (serClass.isAssignableFrom(currRaw))  {    }  else  if  (currRaw.isAssignableFrom(serClass))  {    type  =  tf.constructSpecializedType(type,  serClass);  }  else  {  throw  new  JsonMappingException(null,  String.format( "Can  not  refine  serialization  type  %s  into  %s;  types  not  related ",  type,  serClass.getName()));  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [types  not  related]  )  :  got  one  with  message   "Failed  to  widen  type  [simple  type  ,  class  javalangLong]  with  annotation  (  value  javalangString  )  ,  from  [METHOD]  refineSerializationType  [TYPE]  JavaType  [PARAMETER]  MapperConfig<?>  config  Annotated  a  JavaType  baseType  [CLASS]  AnnotationIntrospector  [TYPE]  Annotated  a  [TYPE]  Type  BACK_REFERENCE  MANAGED_REFERENCE  _type  [TYPE]  JavaType  baseType  contentType  keyType  type  [TYPE]  boolean  false  true  [TYPE]  MapperConfig  config  [TYPE]  Class  contentClass  currRaw  keyClass  serClass  [TYPE]  String  _name  [TYPE]  TypeFactory  tf  [TYPE]  IllegalArgumentException  iae  [CONTEXT]  public  JavaType  refineSerializationType  (  final  MapperConfig<?>  config  ,  final  Annotated  a  ,  final  JavaType  baseType  )  throws  JsonMappingException  {  JavaType  type  =  baseType  ;  final  TypeFactory  tf  =  config  .  getTypeFactory  (  )  ;          Class<?>  serClass  =  findSerializationType  (  a  )  ;  if  (  serClass  !  =  null  )  {  if  (  type  .  hasRawClass  (  serClass  )  )  {    type  =  type  .  withStaticTyping  (  )  ;  }  else  {  try  {    [BUGGY]  type  =  tf  .  constructGeneralizedType  (  type  ,  serClass  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (  null  ,  String  .  format  (   "Failed  to  widen  type  %s  with  annotation  (  value  %s  )  ,  from  '%s':  %s "  ,  type  ,  serClass  .  getName  (  )  ,  a  .  getName  (  )  ,  iae  .  getMessage  (  )  )  ,  iae  )  ;  	JacksonDatabind_47_AnnotationIntrospector_2_2	819	0	src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java
1283	if  (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS))  {  vchecker  =  vchecker.withGetterVisibility(Visibility.NONE);  }  if  (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS))  {  vchecker  =  vchecker.withIsGetterVisibility(Visibility.NONE);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  find  1  property  ,  not  2  ;  properties  =  [[Property  'name'  ;  ctors:  null  ,  field  (  s  )  :  null  ,  getter  (  s  )  :  null  ,  setter  (  s  )  :  [method  comfasterxmljacksondatabindserTestFeatures$TCls#setName  (  1  params  )  ][visible  =  true  ,  ignore  =  false  ,  explicitName  =  false]]  ,  [Property  'groupname'  ;  ctors:  null  ,  field  (  s  )  :  [field  comfasterxmljacksondatabindserTestFeatures$TCls#groupname][visible  =  true  ,  ignore  =  false  ,  explicitName  =  true]  ,  getter  (  s  )  :  null  ,  setter  (  s  )  :  null]]  [METHOD]  getDefaultVisibilityChecker  [TYPE]  VisibilityChecker  [PARAMETER]  [CLASS]  DeserializationConfig  [TYPE]  LinkedNode  _problemHandlers  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  _deserFeatures  _formatReadFeatures  _formatReadFeaturesToChange  _parserFeatures  _parserFeaturesToChange  [TYPE]  VisibilityChecker  vchecker  [TYPE]  JsonNodeFactory  _nodeFactory  [CONTEXT]  public  VisibilityChecker<?>  getDefaultVisibilityChecker  (  )  {  VisibilityChecker<?>  vchecker  =  super  .  getDefaultVisibilityChecker  (  )  ;  if  (  !isEnabled  (  MapperFeature  .  AUTO_DETECT_SETTERS  )  )  {  vchecker  =  vchecker  .  withSetterVisibility  (  Visibility  .  NONE  )  ;  }  if  (  !isEnabled  (  MapperFeature  .  AUTO_DETECT_CREATORS  )  )  {  vchecker  =  vchecker  .  withCreatorVisibility  (  Visibility  .  NONE  )  ;  }  [BUGGY]  if  (  !isEnabled  (  MapperFeature  .  AUTO_DETECT_FIELDS  )  )  {  vchecker  =  vchecker  .  withFieldVisibility  (  Visibility  .  NONE  )  ;  }  return  vchecker  ;  }  	JacksonDatabind_48_DeserializationConfig_1_1	780	0	src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java
1284	if  (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS))  {  vchecker  =  vchecker.withSetterVisibility(Visibility.NONE);  }  if  (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS))  {  vchecker  =  vchecker.withCreatorVisibility(Visibility.NONE);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  find  1  property  ,  not  2  ;  properties  =  [[Property  'name'  ;  ctors:  null  ,  field  (  s  )  :  null  ,  getter  (  s  )  :  null  ,  setter  (  s  )  :  [method  comfasterxmljacksondatabindserTestFeatures$TCls#setName  (  1  params  )  ][visible  =  true  ,  ignore  =  false  ,  explicitName  =  false]]  ,  [Property  'groupname'  ;  ctors:  null  ,  field  (  s  )  :  [field  comfasterxmljacksondatabindserTestFeatures$TCls#groupname][visible  =  true  ,  ignore  =  false  ,  explicitName  =  true]  ,  getter  (  s  )  :  null  ,  setter  (  s  )  :  null]]  [METHOD]  getDefaultVisibilityChecker  [TYPE]  VisibilityChecker  [PARAMETER]  [CLASS]  SerializationConfig  [TYPE]  PrettyPrinter  DEFAULT_PRETTY_PRINTER  _defaultPrettyPrinter  [TYPE]  boolean  false  true  [TYPE]  VisibilityChecker  vchecker  [TYPE]  Value  DEFAULT_INCLUSION  _serializationInclusion  [TYPE]  long  serialVersionUID  [TYPE]  FilterProvider  _filterProvider  [TYPE]  int  _formatWriteFeatures  _formatWriteFeaturesToChange  _generatorFeatures  _generatorFeaturesToChange  _serFeatures  [CONTEXT]  public  VisibilityChecker<?>  getDefaultVisibilityChecker  (  )  {  VisibilityChecker<?>  vchecker  =  super  .  getDefaultVisibilityChecker  (  )  ;  [BUGGY]  if  (  !isEnabled  (  MapperFeature  .  AUTO_DETECT_GETTERS  )  )  {  vchecker  =  vchecker  .  withGetterVisibility  (  Visibility  .  NONE  )  ;  }  if  (  !isEnabled  (  MapperFeature  .  AUTO_DETECT_IS_GETTERS  )  )  {  vchecker  =  vchecker  .  withIsGetterVisibility  (  Visibility  .  NONE  )  ;  }  if  (  !isEnabled  (  MapperFeature  .  AUTO_DETECT_FIELDS  )  )  {  vchecker  =  vchecker  .  withFieldVisibility  (  Visibility  .  NONE  )  ;  }  return  vchecker  ;  }  	JacksonDatabind_48_SerializationConfig_1_1	865	0	src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java
1285	if  (id  ==  null)  {  }  	[BUGGY]  [FE]  jacksondatabinddeserUnresolvedForwardReference:  Unresolved  forward  references  for:  Object  id  [1]  (  for  comfasterxmljacksondatabindobjectidAlwaysAsReferenceFirstTest$Bar  )  at  [Source:  { "bar1 ":1  ,   "bar2 ":{ "@id ":2  ,   "value ":3}}  ;  line:  1  ,  column:  10]  assertNotNull  (  result  )  ;  [METHOD]  generateId  [TYPE]  Object  [PARAMETER]  Object  forPojo  [CLASS]  WritableObjectId  [TYPE]  ObjectIdGenerator  generator  [TYPE]  Object  forPojo  id  [TYPE]  boolean  false  idWritten  true  [CONTEXT]  public  Object  generateId  (  Object  forPojo  )  {    [BUGGY]  id  =  generator  .  generateId  (  forPojo  )  ;  return  id  ;  }  	JacksonDatabind_49_WritableObjectId_1_1	50	0	src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java
1286		[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindobjectidObjectWithCreator1261Test$Child  out  of  START_ARRAY  token  [CLASS]  [CONTEXT]  	JacksonDatabind_50_BeanDeserializer_7_1	9	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1287	List<BeanReferring>  referrings  =  null;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindobjectidObjectWithCreator1261Test$Child  out  of  START_ARRAY  token  [METHOD]  _deserializeUsingPropertyBased  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializer  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  SettableBeanProperty  creatorProp  prop  [TYPE]  TokenBuffer  unknown  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  Object  bean  [TYPE]  String  propName  [TYPE]  PropertyBasedCreator  creator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  _nullFromCreator  e  [TYPE]  JsonParser  p  [CONTEXT]  protected  Object  _deserializeUsingPropertyBased  (  final  JsonParser  p  ,  final  DeserializationContext  ctxt  )  throws  IOException  {  final  PropertyBasedCreator  creator  =  _propertyBasedCreator  ;  PropertyValueBuffer  buffer  =  creator  .  startBuilding  (  p  ,  ctxt  ,  _objectIdReader  )  ;  TokenBuffer  unknown  =  null  ;  JsonToken  t  =  p  .  getCurrentToken  (  )  ;  [BUGGY]  for  (  ;  t  =  =  JsonToken  .  FIELD_NAME  ;  t  =  p  .  nextToken  (  )  )  {  String  propName  =  p  .  getCurrentName  (  )  ;  p  .  nextToken  (  )  ;  //  to  point  to  value  SettableBeanProperty  creatorProp  =  creator  .  findCreatorProperty  (  propName  )  ;  if  (  creatorProp  !  =  null  )  {  	JacksonDatabind_50_BeanDeserializer_7_2	387	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1288	try  {  }  catch  (UnresolvedForwardReference  reference)  {  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindobjectidObjectWithCreator1261Test$Child  out  of  START_ARRAY  token  [METHOD]  _deserializeUsingPropertyBased  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializer  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  SettableBeanProperty  creatorProp  prop  [TYPE]  TokenBuffer  unknown  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  Object  bean  [TYPE]  String  propName  [TYPE]  PropertyBasedCreator  creator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  _nullFromCreator  e  [TYPE]  JsonParser  p  [CONTEXT]  return  ctxt  .  handleInstantiationProblem  (  handledType  (  )  ,  null  ,  _creatorReturnedNullException  (  )  )  ;  }  p  .  setCurrentValue  (  bean  )  ;    if  (  bean  .  getClass  (  )  !  =  _beanType  .  getRawClass  (  )  )  {  return  handlePolymorphic  (  p  ,  ctxt  ,  bean  ,  unknown  )  ;  }  if  (  unknown  !  =  null  )  {  //  nope  ,  just  extra  unknown  stuff  .  .  .  bean  =  handleUnknownProperties  (  ctxt  ,  bean  ,  unknown  )  ;  }  return  deserialize  (  p  ,  ctxt  ,  bean  )  ;  }  continue  ;  }  if  (  buffer  .  readIdProperty  (  propName  )  )  {  continue  ;  }  SettableBeanProperty  prop  =  _beanProperties  .  find  (  propName  )  ;  if  (  prop  !  =  null  )  {  [BUGGY]  buffer  .  bufferProperty  (  prop  ,  _deserializeWithErrorWrapping  (  p  ,  ctxt  ,  prop  )  )  ;    continue  ;  }  	JacksonDatabind_50_BeanDeserializer_7_3	429	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1289	BeanReferring  referring  =  handleUnresolvedReference(p,  prop,  buffer,  reference);  if  (referrings  ==  null)  {  referrings  =  new  ArrayList<BeanReferring>();  }  referrings.add(referring);  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindobjectidObjectWithCreator1261Test$Child  out  of  START_ARRAY  token  [METHOD]  _deserializeUsingPropertyBased  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializer  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  SettableBeanProperty  creatorProp  prop  [TYPE]  TokenBuffer  unknown  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  Object  bean  [TYPE]  String  propName  [TYPE]  PropertyBasedCreator  creator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  _nullFromCreator  e  [TYPE]  JsonParser  p  [CONTEXT]  p  .  setCurrentValue  (  bean  )  ;    if  (  bean  .  getClass  (  )  !  =  _beanType  .  getRawClass  (  )  )  {  return  handlePolymorphic  (  p  ,  ctxt  ,  bean  ,  unknown  )  ;  }  if  (  unknown  !  =  null  )  {  //  nope  ,  just  extra  unknown  stuff  .  .  .  bean  =  handleUnknownProperties  (  ctxt  ,  bean  ,  unknown  )  ;  }  return  deserialize  (  p  ,  ctxt  ,  bean  )  ;  }  continue  ;  }  if  (  buffer  .  readIdProperty  (  propName  )  )  {  continue  ;  }  SettableBeanProperty  prop  =  _beanProperties  .  find  (  propName  )  ;  if  (  prop  !  =  null  )  {  buffer  .  bufferProperty  (  prop  ,  _deserializeWithErrorWrapping  (  p  ,  ctxt  ,  prop  )  )  ;    [BUGGY]  continue  ;  }  if  (  _ignorableProps  !  =  null  &&  _ignorableProps  .  contains  (  propName  )  )  {  handleIgnoredProperty  (  p  ,  ctxt  ,  handledType  (  )  ,  propName  )  ;  continue  ;  	JacksonDatabind_50_BeanDeserializer_7_4	433	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1290	if  (referrings  !=  null)  {  for  (BeanReferring  referring  :  referrings)  {  referring.setBean(bean);  }  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindobjectidObjectWithCreator1261Test$Child  out  of  START_ARRAY  token  [METHOD]  _deserializeUsingPropertyBased  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializer  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  SettableBeanProperty  creatorProp  prop  [TYPE]  TokenBuffer  unknown  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  Object  bean  [TYPE]  String  propName  [TYPE]  PropertyBasedCreator  creator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  _nullFromCreator  e  [TYPE]  JsonParser  p  [CONTEXT]  if  (  _anySetter  !  =  null  )  {  try  {  buffer  .  bufferAnyProperty  (  _anySetter  ,  propName  ,  _anySetter  .  deserialize  (  p  ,  ctxt  )  )  ;  }  catch  (  Exception  e  )  {  wrapAndThrow  (  e  ,  _beanType  .  getRawClass  (  )  ,  propName  ,  ctxt  )  ;  }  continue  ;  }  if  (  unknown  =  =  null  )  {  unknown  =  new  TokenBuffer  (  p  ,  ctxt  )  ;  }  unknown  .  writeFieldName  (  propName  )  ;  unknown  .  copyCurrentStructure  (  p  )  ;  }  Object  bean  ;  try  {  bean  =  creator  .  build  (  ctxt  ,  buffer  )  ;  }  catch  (  Exception  e  )  {  wrapInstantiationProblem  (  e  ,  ctxt  )  ;  bean  =  null  ;  //  never  gets  here  }  [BUGGY]  if  (  unknown  !  =  null  )  {  if  (  bean  .  getClass  (  )  !  =  _beanType  .  getRawClass  (  )  )  {  return  handlePolymorphic  (  null  ,  ctxt  ,  bean  ,  unknown  )  ;  }  	JacksonDatabind_50_BeanDeserializer_7_5	465	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1291	private  BeanReferring  handleUnresolvedReference(JsonParser  p,  SettableBeanProperty  prop,  PropertyValueBuffer  buffer,  UnresolvedForwardReference  reference)  throws  JsonMappingException  {  BeanReferring  referring  =  new  BeanReferring(reference,  prop.getType().getRawClass(),  buffer,  prop);  reference.getRoid().appendReferring(referring);  return  referring;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindobjectidObjectWithCreator1261Test$Child  out  of  START_ARRAY  token  [CLASS]  [CONTEXT]  	JacksonDatabind_50_BeanDeserializer_7_6	479	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1292	static  class  BeanReferring  extends  Referring  {  private  final  SettableBeanProperty  _prop;  private  Object  _bean;  public  void  setBean(Object  bean)  {  _bean  =  bean;  }  BeanReferring(UnresolvedForwardReference  ref,  Class<?>  valueType,  PropertyValueBuffer  buffer,  SettableBeanProperty  prop)  {  super(ref,  valueType);  _prop  =  prop;  }  @Override  public  void  handleResolvedForwardReference(Object  id,  Object  value)  throws  IOException  {  _prop.set(_bean,  value);  }  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  deserialize  instance  of  comfasterxmljacksondatabindobjectidObjectWithCreator1261Test$Child  out  of  START_ARRAY  token  [CLASS]  [CONTEXT]  	JacksonDatabind_50_BeanDeserializer_7_7	933	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1293	if  (!type.hasGenericTypes())  {  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Problem  deserializing  property  'options'  (  expected  type:  [simple  type  ,  class  javalangObject]  ;  actual  type:  javautilLinkedHashMap  )  ,  problem:  Can  not  set  comfasterxmljacksondatabindjsontypeTestCustomTypeIdResolver$Poly1Base  field  comfasterxmljacksondatabindjsontypeTestCustomTypeIdResolver$Base1270options  to  javautilLinkedHashMap  assertNotNull  (  itemRead  .  b  )  ;  [METHOD]  _findDeserializer  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  String  typeId  [CLASS]  TypeDeserializerBase  [TYPE]  JavaType  _baseType  _defaultImpl  actual  type  [TYPE]  boolean  _typeIdVisible  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  String  _typePropertyName  typeId  [TYPE]  JsonDeserializer  _defaultImplDeserializer  deser  [TYPE]  Map  _deserializers  [TYPE]  long  serialVersionUID  [TYPE]  TypeIdResolver  _idResolver  [TYPE]  BeanProperty  _property  [CONTEXT]  return  null  ;  }  deser  =  ctxt  .  findContextualValueDeserializer  (  actual  ,  _property  )  ;  }  }  else  {          if  (  (  _baseType  !  =  null  )  &&  _baseType  .  getClass  (  )  =  =  type  .  getClass  (  )  )  {          [BUGGY]  type  =  ctxt  .  getTypeFactory  (  )  .  constructSpecializedType  (  _baseType  ,  type  .  getRawClass  (  )  )  ;  }  deser  =  ctxt  .  findContextualValueDeserializer  (  type  ,  _property  )  ;  }  _deserializers  .  put  (  typeId  ,  deser  )  ;  }  	JacksonDatabind_51_TypeDeserializerBase_1_1	184	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
1294	_externalTypeIdHandler  =  extTypes.build(_beanProperties);  	[BUGGY]  _externalTypeIdHandler  =  extTypes  .  build  (  )  ;  [FE]  ComparisonFailure:  expected:<foo>  but  was:<null>  assertEquals  (   "foo "  ,  msg  .  type  )  ;  [METHOD]  resolve  [TYPE]  void  [PARAMETER]  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  unwrapped  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  SettableBeanProperty  origProp  prop  u  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  Builder  extTypes  [TYPE]  SettableBeanProperty[]  creatorProps  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  cd  deser  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  int  i  len  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  delegateType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  TypeDeserializer  typeDeser  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [CONTEXT]  }  _delegateDeserializer  =  _findDelegateDeserializer  (  ctxt  ,  delegateType  ,  _valueInstantiator  .  getDelegateCreator  (  )  )  ;  }  if  (  _valueInstantiator  .  canCreateUsingArrayDelegate  (  )  )  {  JavaType  delegateType  =  _valueInstantiator  .  getArrayDelegateType  (  ctxt  .  getConfig  (  )  )  ;  if  (  delegateType  =  =  null  )  {  throw  new  IllegalArgumentException  (   "Invalid  array-delegate-creator  definition  for   "+_beanType  + ":  value  instantiator  (   "+_valueInstantiator  .  getClass  (  )  .  getName  (  )  + "  )  returned  true  for  'canCreateUsingArrayDelegate  (  )  '  ,  but  null  for  'getArrayDelegateType  (  )  ' "  )  ;  }  _arrayDelegateDeserializer  =  _findDelegateDeserializer  (  ctxt  ,  delegateType  ,  _valueInstantiator  .  getArrayDelegateCreator  (  )  )  ;  }  if  (  creatorProps  !  =  null  )  {  _propertyBasedCreator  =  PropertyBasedCreator  .  construct  (  ctxt  ,  _valueInstantiator  ,  creatorProps  )  ;  }  if  (  extTypes  !  =  null  )  {    [BUGGY]  _externalTypeIdHandler  =  extTypes  .  build  (  )  ;  _nonStandardCreation  =  true  ;  }  _unwrappedPropertyHandler  =  unwrapped  ;  	JacksonDatabind_52_BeanDeserializerBase_1_1	612	1	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1295	public  ExternalTypeHandler  build(BeanPropertyMap  otherProps)  {  final  int  len  =  _properties.size();  ExtTypedProperty[]  extProps  =  new  ExtTypedProperty[len];  for  (int  i  =  0;  i  <  len;  ++i)  {  ExtTypedProperty  extProp  =  _properties.get(i);  String  typePropId  =  extProp.getTypePropertyName();  SettableBeanProperty  typeProp  =  otherProps.find(typePropId);  if  (typeProp  !=  null)  {  extProp.linkTypeProperty(typeProp);  }  extProps[i]  =  extProp;  }  return  new  ExternalTypeHandler(extProps,  _nameToPropertyIndex,  null,  null);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<foo>  but  was:<null>  assertEquals  (   "foo "  ,  msg  .  type  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_52_ExternalTypeHandler_1_1	310	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
1296	public  Object  asKey(Class<?>  rawBase)  {  return  new  AsKey(rawBase,  _types,  _hashCode);  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindjsontypeTypeRefinementForMap1215Test$HasUniqueId  ,  problem:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  be  instantiated  with  additional  type  information  assertEquals  (   "value "  ,  value  .  property  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_53_TypeBindings_2_1	302	0	src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java
1297	final  static  class  AsKey  {  private  final  Class<?>  _raw;  private  final  JavaType[]  _params;  private  final  int  _hash;    public  AsKey(Class<?>  raw,  JavaType[]  params,  int  hash)  {  _raw  =  raw  ;  _params  =  params;  _hash  =  hash;  }  @Override  public  int  hashCode()  {  return  _hash;  }    @Override  public  boolean  equals(Object  o)  {  if  (o  ==  this)  return  true;  if  (o  ==  null)  return  false;  if  (o.getClass()  !=  getClass())  return  false;  AsKey  other  =  (AsKey)  o;    if  ((_hash  ==  other._hash)  &&  (_raw  ==  other._raw))  {  final  JavaType[]  otherParams  =  other._params;  final  int  len  =  _params.length;    if  (len  ==  otherParams.length)  {  for  (int  i  =  0;  i  <  len;  ++i)  {  if  (!_params[i].equals(otherParams[i]))  {  return  false;  }  }  return  true;  }  }  return  false;  }  @Override  public  String  toString()  {  return  _raw.getName()+ "<> ";  }  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindjsontypeTypeRefinementForMap1215Test$HasUniqueId  ,  problem:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  be  instantiated  with  additional  type  information  assertEquals  (   "value "  ,  value  .  property  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_53_TypeBindings_2_2	428	0	src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java
1298	protected  final  LRUMap<Object,JavaType>  _typeCache  =  new  LRUMap<Object,JavaType>(16,  100);  	[BUGGY]  protected  final  LRUMap<Class<?>  ,  JavaType>  _typeCache  =  new  LRUMap<Class<?>  ,  JavaType>  (  16  ,  100  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindjsontypeTypeRefinementForMap1215Test$HasUniqueId  ,  problem:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  be  instantiated  with  additional  type  information  assertEquals  (   "value "  ,  value  .  property  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_53_TypeFactory_6_1	117	1	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1299	newType  =  baseType.refine(subclass,  tb,  null,  new  JavaType[]  {  baseType  });  newType  =  baseType.refine(subclass,  tb,  baseType,  NO_TYPES);  	[BUGGY]  newType  =  baseType  .  refine  (  subclass  ,  TypeBindings  .  emptyBindings  (  )  ,  null  ,  new  JavaType[]  {  baseType  }  )  ;  newType  =  baseType  .  refine  (  subclass  ,  TypeBindings  .  emptyBindings  (  )  ,  baseType  ,  NO_TYPES  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindjsontypeTypeRefinementForMap1215Test$HasUniqueId  ,  problem:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  be  instantiated  with  additional  type  information  assertEquals  (   "value "  ,  value  .  property  )  ;  [METHOD]  constructSpecializedType  [TYPE]  JavaType  [PARAMETER]  JavaType  baseType  Class<?>  subclass  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  long  serialVersionUID  [TYPE]  int  typeParamCount  [TYPE]  TypeBindings  EMPTY_BINDINGS  tb  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  JavaType  baseType  newType  [TYPE]  boolean  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  rawBase  subclass  [TYPE]  TypeFactory  instance  [CONTEXT]  if  (  rawBase  =  =  EnumSet  .  class  )  {  return  baseType  ;  }  }  }  int  typeParamCount  =  subclass  .  getTypeParameters  (  )  .  length  ;  if  (  typeParamCount  =  =  0  )  {  newType  =  _fromClass  (  null  ,  subclass  ,  TypeBindings  .  emptyBindings  (  )  )  ;  break  ;  }              [BUGGY]  if  (  baseType  .  isInterface  (  )  )  {  newType  =  baseType  .  refine  (  subclass  ,  TypeBindings  .  emptyBindings  (  )  ,  null  ,  new  JavaType[]  {  baseType  }  )  ;  }  else  {  newType  =  baseType  .  refine  (  subclass  ,  TypeBindings  .  emptyBindings  (  )  ,  baseType  ,  NO_TYPES  )  ;  }  	JacksonDatabind_53_TypeFactory_6_2	385	2	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1300	newType  =  _fromClass(null,  subclass,  tb);  	[BUGGY]  TypeBindings  tb  =  null  ;  if  (  baseType  .  containedTypeCount  (  )  =  =  typeParamCount  )  {  if  (  typeParamCount  =  =  1  )  {  tb  =  TypeBindings  .  create  (  subclass  ,  baseType  .  containedType  (  0  )  )  ;  }  else  if  (  typeParamCount  =  =  2  )  {  tb  =  TypeBindings  .  create  (  subclass  ,  baseType  .  containedType  (  0  )  ,  baseType  .  containedType  (  1  )  )  ;  }  }  newType  =  _fromClass  (  null  ,  subclass  ,  (  tb  =  =  null  )  ?  TypeBindings  .  emptyBindings  (  )  :  tb  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindjsontypeTypeRefinementForMap1215Test$HasUniqueId  ,  problem:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  be  instantiated  with  additional  type  information  assertEquals  (   "value "  ,  value  .  property  )  ;  [METHOD]  constructSpecializedType  [TYPE]  JavaType  [PARAMETER]  JavaType  baseType  Class<?>  subclass  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  long  serialVersionUID  [TYPE]  int  typeParamCount  [TYPE]  TypeBindings  EMPTY_BINDINGS  tb  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  JavaType  baseType  newType  [TYPE]  boolean  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  rawBase  subclass  [TYPE]  TypeFactory  instance  [CONTEXT]  int  typeParamCount  =  subclass  .  getTypeParameters  (  )  .  length  ;  if  (  typeParamCount  =  =  0  )  {  newType  =  _fromClass  (  null  ,  subclass  ,  TypeBindings  .  emptyBindings  (  )  )  ;  break  ;  }              if  (  baseType  .  isInterface  (  )  )  {  newType  =  baseType  .  refine  (  subclass  ,  TypeBindings  .  emptyBindings  (  )  ,  null  ,  new  JavaType[]  {  baseType  }  )  ;  }  else  {  newType  =  baseType  .  refine  (  subclass  ,  TypeBindings  .  emptyBindings  (  )  ,  baseType  ,  NO_TYPES  )  ;  }  if  (  newType  =  =  null  )  {  [BUGGY]  TypeBindings  tb  =  null  ;  if  (  baseType  .  containedTypeCount  (  )  =  =  typeParamCount  )  {  if  (  typeParamCount  =  =  1  )  {  tb  =  TypeBindings  .  create  (  subclass  ,  baseType  .  containedType  (  0  )  )  ;  }  else  if  (  typeParamCount  =  =  2  )  {  tb  =  TypeBindings  .  create  (  subclass  ,  baseType  .  containedType  (  0  )  ,  	JacksonDatabind_53_TypeFactory_6_3	392	11	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1301	private  TypeBindings  _bindingsForSubtype(JavaType  baseType,  int  typeParamCount,  Class<?>  subclass)  {  int  baseCount  =  baseType.containedTypeCount();  if  (baseCount  ==  typeParamCount)  {  if  (typeParamCount  ==  1)  {  return  TypeBindings.create(subclass,  baseType.containedType(0));  }  if  (typeParamCount  ==  2)  {  return  TypeBindings.create(subclass,  baseType.containedType(0),  baseType.containedType(1));  }  List<JavaType>  types  =  new  ArrayList<JavaType>(baseCount);  for  (int  i  =  0;  i  <  baseCount;  ++i)  {  types.add(baseType.containedType(i));  }  return  TypeBindings.create(subclass,  types);  }  return  TypeBindings.emptyBindings();  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindjsontypeTypeRefinementForMap1215Test$HasUniqueId  ,  problem:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  be  instantiated  with  additional  type  information  assertEquals  (   "value "  ,  value  .  property  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_53_TypeFactory_6_4	456	0	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1302	final  Object  key;  if  ((bindings  ==  null)  ||  bindings.isEmpty())  {  key  =  rawType;  result  =  _typeCache.get(key);    }  else  {  key  =  bindings.asKey(rawType);  }  result  =  _typeCache.get(key);    	[BUGGY]  boolean  cachable  =  (  bindings  =  =  null  )  ||  bindings  .  isEmpty  (  )  ;  if  (  cachable  )  {  result  =  _typeCache  .  get  (  rawType  )  ;  }  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindjsontypeTypeRefinementForMap1215Test$HasUniqueId  ,  problem:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  be  instantiated  with  additional  type  information  assertEquals  (   "value "  ,  value  .  property  )  ;  [METHOD]  _fromClass  [TYPE]  JavaType  [PARAMETER]  ClassStack  context  Class<?>  rawType  TypeBindings  bindings  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  ClassStack  context  prev  [TYPE]  long  serialVersionUID  [TYPE]  TypeBindings  EMPTY_BINDINGS  bindings  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  JavaType  result  superClass  [TYPE]  boolean  cachable  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  superInterfaces  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  rawType  [TYPE]  ResolvedRecursiveType  selfRef  [TYPE]  TypeFactory  instance  [CONTEXT]  protected  JavaType  _fromClass  (  ClassStack  context  ,  Class<?>  rawType  ,  TypeBindings  bindings  )  {  JavaType  result  =  _findWellKnownSimple  (  rawType  )  ;  if  (  result  !  =  null  )  {  return  result  ;  }  [BUGGY]  boolean  cachable  =  (  bindings  =  =  null  )  ||  bindings  .  isEmpty  (  )  ;  if  (  cachable  )  {  result  =  _typeCache  .  get  (  rawType  )  ;  if  (  result  !  =  null  )  {  return  result  ;  }  	JacksonDatabind_53_TypeFactory_6_5	1160	4	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1303	_typeCache.putIfAbsent(key,  result);    	[BUGGY]  if  (  cachable  )  {  _typeCache  .  putIfAbsent  (  rawType  ,  result  )  ;  }  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindjsontypeTypeRefinementForMap1215Test$HasUniqueId  ,  problem:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  be  instantiated  with  additional  type  information  assertEquals  (   "value "  ,  value  .  property  )  ;  [METHOD]  _fromClass  [TYPE]  JavaType  [PARAMETER]  ClassStack  context  Class<?>  rawType  TypeBindings  bindings  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  ClassStack  context  prev  [TYPE]  long  serialVersionUID  [TYPE]  TypeBindings  EMPTY_BINDINGS  bindings  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  JavaType  result  superClass  [TYPE]  boolean  cachable  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  superInterfaces  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  rawType  [TYPE]  ResolvedRecursiveType  selfRef  [TYPE]  TypeFactory  instance  [CONTEXT]  }  if  (  rawType  =  =  Properties  .  class  )  {  result  =  MapType  .  construct  (  rawType  ,  bindings  ,  superClass  ,  superInterfaces  ,  CORE_TYPE_STRING  ,  CORE_TYPE_STRING  )  ;  }    else  if  (  superClass  !  =  null  )  {  result  =  superClass  .  refine  (  rawType  ,  bindings  ,  superClass  ,  superInterfaces  )  ;  }  if  (  result  =  =  null  )  {  result  =  _fromWellKnownClass  (  context  ,  rawType  ,  bindings  ,  superClass  ,  superInterfaces  )  ;  if  (  result  =  =  null  )  {  result  =  _fromWellKnownInterface  (  context  ,  rawType  ,  bindings  ,  superClass  ,  superInterfaces  )  ;  if  (  result  =  =  null  )  {  result  =  _newSimpleType  (  rawType  ,  bindings  ,  superClass  ,  superInterfaces  )  ;  }  }  }  }  context  .  resolveSelfReferences  (  result  )  ;  [BUGGY]  if  (  cachable  )  {  _typeCache  .  putIfAbsent  (  rawType  ,  result  )  ;  }  return  result  ;  }  	JacksonDatabind_53_TypeFactory_6_6	1225	3	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1304	if  (actualType.isReferenceType())  {  	[BUGGY]  if  (  declaredType  .  isReferenceType  (  )  )  {  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "a ":null]}>  assertEquals  (   "{} "  ,  json  )  ;  [METHOD]  buildWriter  [TYPE]  BeanPropertyWriter  [PARAMETER]  SerializerProvider  prov  BeanPropertyDefinition  propDef  JavaType  declaredType  JsonSerializer<?>  ser  TypeSerializer  typeSer  TypeSerializer  contentTypeSer  AnnotatedMember  am  boolean  defaultUseStaticTyping  [CLASS]  PropertyBuilder  [TYPE]  SerializationConfig  _config  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  AnnotatedMember  am  [TYPE]  Include  inclusion  [TYPE]  JsonSerializer  ser  [TYPE]  NameTransformer  unwrapper  [TYPE]  JavaType  actualType  ct  declaredType  serializationType  [TYPE]  boolean  defaultUseStaticTyping  false  suppressNulls  true  [TYPE]  Value  _defaultInclusion  inclV  [TYPE]  BeanPropertyDefinition  propDef  [TYPE]  TypeSerializer  contentTypeSer  typeSer  [TYPE]  Object  NO_DEFAULT_MARKER  _defaultBean  serDef  valueToSuppress  [TYPE]  SerializerProvider  prov  [TYPE]  BeanPropertyWriter  bpw  [CONTEXT]  switch  (  inclusion  )  {  case  NON_DEFAULT:      if  (  _defaultInclusion  .  getValueInclusion  (  )  =  =  JsonInclude  .  Include  .  NON_DEFAULT  )  {  valueToSuppress  =  getPropertyDefaultValue  (  propDef  .  getName  (  )  ,  am  ,  actualType  )  ;  }  else  {  valueToSuppress  =  getDefaultValue  (  actualType  )  ;  }  if  (  valueToSuppress  =  =  null  )  {  suppressNulls  =  true  ;  }  else  {  if  (  valueToSuppress  .  getClass  (  )  .  isArray  (  )  )  {  valueToSuppress  =  ArrayBuilders  .  getArrayComparator  (  valueToSuppress  )  ;  }  }  break  ;  case  NON_ABSENT:  //  new  with  2  .  6  ,  to  support  Guava/JDK8  Optionals  suppressNulls  =  true  ;  [BUGGY]  if  (  declaredType  .  isReferenceType  (  )  )  {  valueToSuppress  =  BeanPropertyWriter  .  MARKER_FOR_EMPTY  ;  }  break  ;  case  NON_EMPTY:  	JacksonDatabind_54_PropertyBuilder_2_1	134	1	src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
1305	if  (actualType.isContainerType()  	[BUGGY]  if  (  declaredType  .  isContainerType  (  )  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "a ":null]}>  assertEquals  (   "{} "  ,  json  )  ;  [METHOD]  buildWriter  [TYPE]  BeanPropertyWriter  [PARAMETER]  SerializerProvider  prov  BeanPropertyDefinition  propDef  JavaType  declaredType  JsonSerializer<?>  ser  TypeSerializer  typeSer  TypeSerializer  contentTypeSer  AnnotatedMember  am  boolean  defaultUseStaticTyping  [CLASS]  PropertyBuilder  [TYPE]  SerializationConfig  _config  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  AnnotatedMember  am  [TYPE]  Include  inclusion  [TYPE]  JsonSerializer  ser  [TYPE]  NameTransformer  unwrapper  [TYPE]  JavaType  actualType  ct  declaredType  serializationType  [TYPE]  boolean  defaultUseStaticTyping  false  suppressNulls  true  [TYPE]  Value  _defaultInclusion  inclV  [TYPE]  BeanPropertyDefinition  propDef  [TYPE]  TypeSerializer  contentTypeSer  typeSer  [TYPE]  Object  NO_DEFAULT_MARKER  _defaultBean  serDef  valueToSuppress  [TYPE]  SerializerProvider  prov  [TYPE]  BeanPropertyWriter  bpw  [CONTEXT]  valueToSuppress  =  ArrayBuilders  .  getArrayComparator  (  valueToSuppress  )  ;  }  }  break  ;  case  NON_ABSENT:  //  new  with  2  .  6  ,  to  support  Guava/JDK8  Optionals  suppressNulls  =  true  ;  if  (  declaredType  .  isReferenceType  (  )  )  {  valueToSuppress  =  BeanPropertyWriter  .  MARKER_FOR_EMPTY  ;  }  break  ;  case  NON_EMPTY:  suppressNulls  =  true  ;  valueToSuppress  =  BeanPropertyWriter  .  MARKER_FOR_EMPTY  ;  break  ;  case  NON_NULL:  suppressNulls  =  true  ;  case  ALWAYS:  //  default  default:  [BUGGY]  if  (  declaredType  .  isContainerType  (  )  &&  !_config  .  isEnabled  (  SerializationFeature  .  WRITE_EMPTY_JSON_ARRAYS  )  )  {  valueToSuppress  =  BeanPropertyWriter  .  MARKER_FOR_EMPTY  ;  }  break  ;  }  	JacksonDatabind_54_PropertyBuilder_2_2	150	1	src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
1306		[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "[aleph] ": "b "}>  but  was:<{ "[A] ": "b "}>  assertEquals  (   "{\ "aleph\ ":\ "b\ "} "  ,  MAPPER  .  writeValueAsString  (  input  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_55_StdKeySerializers_3_1	10	0	src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java
1307	return  EnumKeySerializer.construct(rawKeyType,  EnumValues.constructFromName(config,  (Class<Enum<?>>)  rawKeyType));  	[BUGGY]  return  new  Default  (  Default  .  TYPE_ENUM  ,  rawKeyType  )  ;  [FE]  ComparisonFailure:  expected:<{ "[aleph] ": "b "}>  but  was:<{ "[A] ": "b "}>  assertEquals  (   "{\ "aleph\ ":\ "b\ "} "  ,  MAPPER  .  writeValueAsString  (  input  )  )  ;  [METHOD]  getFallbackKeySerializer  [TYPE]  JsonSerializer  [PARAMETER]  SerializationConfig  config  Class<?>  rawKeyType  [CLASS]  StdKeySerializers  [TYPE]  Class  rawKeyType  [TYPE]  JsonSerializer  DEFAULT_KEY_SERIALIZER  DEFAULT_STRING_SERIALIZER  [TYPE]  boolean  false  true  [TYPE]  int  TYPE_CALENDAR  TYPE_CLASS  TYPE_DATE  TYPE_ENUM  TYPE_TO_STRING  _typeId  [TYPE]  SerializationConfig  config  [TYPE]  PropertySerializerMap  _dynamicSerializers  [CONTEXT]  public  static  JsonSerializer<Object>  getFallbackKeySerializer  (  SerializationConfig  config  ,  Class<?>  rawKeyType  )  {  if  (  rawKeyType  !  =  null  )  {        if  (  rawKeyType  =  =  Enum  .  class  )  {  return  new  Dynamic  (  )  ;  }  if  (  rawKeyType  .  isEnum  (  )  )  {  [BUGGY]  return  new  Default  (  Default  .  TYPE_ENUM  ,  rawKeyType  )  ;  }  }  return  DEFAULT_KEY_SERIALIZER  ;  }  	JacksonDatabind_55_StdKeySerializers_3_2	82	1	src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java
1308	public  static  class  EnumKeySerializer  extends  StdSerializer<Object>  {  protected  final  EnumValues  _values;  protected  EnumKeySerializer(Class<?>  enumType,  EnumValues  values)  {  super(enumType,  false);  _values  =  values;  }  public  static  EnumKeySerializer  construct(Class<?>  enumType,  EnumValues  enumValues)  {  return  new  EnumKeySerializer(enumType,  enumValues);  }  @Override  public  void  serialize(Object  value,  JsonGenerator  g,  SerializerProvider  serializers)  throws  IOException  {  if  (serializers.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING))  {  g.writeFieldName(value.toString());  return;  }  Enum<?>  en  =  (Enum<?>)  value;  g.writeFieldName(_values.serializedValueFor(en));  }  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "[aleph] ": "b "}>  but  was:<{ "[A] ": "b "}>  assertEquals  (   "{\ "aleph\ ":\ "b\ "} "  ,  MAPPER  .  writeValueAsString  (  input  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_55_StdKeySerializers_3_3	215	0	src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java
1309		[BUGGY]  [FE]  AssertionFailedError:  expected:<en_US>  but  was:<en-us>  assertSame  (  Locale  .  ROOT  ,  loc  )  ;  [METHOD]  _deserialize  [TYPE]  Object  [PARAMETER]  String  value  DeserializationContext  ctxt  [CLASS]  Std  [TYPE]  DeserializationContext  ctxt  [TYPE]  String  first  second  value  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  STD_CHARSET  STD_CLASS  STD_CURRENCY  STD_FILE  STD_INET_ADDRESS  STD_INET_SOCKET_ADDRESS  STD_JAVA_TYPE  STD_LOCALE  STD_PATTERN  STD_TIME_ZONE  STD_URI  STD_URL  _kind  i  ix  j  port  [TYPE]  Exception  e  [CONTEXT]  protected  Object  _deserialize  (  String  value  ,  DeserializationContext  ctxt  )  throws  IOException  {  switch  (  _kind  )  {  case  STD_FILE:  return  new  File  (  value  )  ;  case  STD_URL:  return  new  URL  (  value  )  ;  case  STD_URI:  return  URI  .  create  (  value  )  ;  case  STD_CLASS:  try  {  return  ctxt  .  findClass  (  value  )  ;  }  catch  (  Exception  e  )  {  throw  ctxt  .  instantiationException  (  _valueClass  ,  ClassUtil  .  getRootCause  (  e  )  )  ;  }  case  STD_JAVA_TYPE:  return  ctxt  .  getTypeFactory  (  )  .  constructFromCanonical  (  value  )  ;  case  STD_CURRENCY:  return  Currency  .  getInstance  (  value  )  ;  case  STD_PATTERN:  return  Pattern  .  compile  (  value  )  ;  case  STD_LOCALE:  {  [BUGGY]  int  ix  =  value  .  indexOf  (  '_'  )  ;  if  (  ix  <  0  )  {  //  single  argument  return  new  Locale  (  value  )  ;  }  String  first  =  value  .  substring  (  0  ,  ix  )  ;  value  =  value  .  substring  (  ix+1  )  ;  	JacksonDatabind_56_FromStringDeserializer_3_1	231	0	src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java
1310		[BUGGY]  [FE]  AssertionFailedError:  expected:<en_US>  but  was:<en-us>  assertSame  (  Locale  .  ROOT  ,  loc  )  ;  [METHOD]  _deserialize  [TYPE]  Object  [PARAMETER]  String  value  DeserializationContext  ctxt  [CLASS]  Std  [TYPE]  DeserializationContext  ctxt  [TYPE]  String  first  second  value  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  STD_CHARSET  STD_CLASS  STD_CURRENCY  STD_FILE  STD_INET_ADDRESS  STD_INET_SOCKET_ADDRESS  STD_JAVA_TYPE  STD_LOCALE  STD_PATTERN  STD_TIME_ZONE  STD_URI  STD_URL  _kind  i  ix  j  port  [TYPE]  Exception  e  [CONTEXT]  return  new  URL  (  value  )  ;  case  STD_URI:  return  URI  .  create  (  value  )  ;  case  STD_CLASS:  try  {  return  ctxt  .  findClass  (  value  )  ;  }  catch  (  Exception  e  )  {  throw  ctxt  .  instantiationException  (  _valueClass  ,  ClassUtil  .  getRootCause  (  e  )  )  ;  }  case  STD_JAVA_TYPE:  return  ctxt  .  getTypeFactory  (  )  .  constructFromCanonical  (  value  )  ;  case  STD_CURRENCY:  return  Currency  .  getInstance  (  value  )  ;  case  STD_PATTERN:  return  Pattern  .  compile  (  value  )  ;  case  STD_LOCALE:  {  int  ix  =  value  .  indexOf  (  '_'  )  ;  if  (  ix  <  0  )  {  //  single  argument  return  new  Locale  (  value  )  ;  }  String  first  =  value  .  substring  (  0  ,  ix  )  ;  value  =  value  .  substring  (  ix+1  )  ;  [BUGGY]  ix  =  value  .  indexOf  (  '_'  )  ;  if  (  ix  <  0  )  {  //  two  pieces  return  new  Locale  (  first  ,  value  )  ;  }  String  second  =  value  .  substring  (  0  ,  ix  )  ;  return  new  Locale  (  first  ,  second  ,  value  .  substring  (  ix+1  )  )  ;  	JacksonDatabind_56_FromStringDeserializer_3_2	237	0	src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java
1311	protected  int  _firstHyphenOrUnderscore(String  str)  {  for  (int  i  =  0,  end  =  str.length();  i  <  end;  ++i)  {  char  c  =  str.charAt(i);\n',   "+                                if  (c  ==  '_'  ||  c  ==  '-')  {\n ",  '+                                        return  i;  }  }  return  -1;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<en_US>  but  was:<en-us>  assertSame  (  Locale  .  ROOT  ,  loc  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_56_FromStringDeserializer_3_3	292	0	src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java
1312	return  _bindAndReadValues(_considerFilter(_parserFactory.createParser(src,  offset,  length),  	[BUGGY]  return  _bindAndReadValues  (  _considerFilter  (  _parserFactory  .  createParser  (  src  )  ,  [FE]  CharConversionException:  Invalid  UTF-32  character  0x2261223a  (  above  10ffff  )  at  char  #1  ,  byte  #7  )  assertFalse  (  it  .  hasNext  (  )  )  ;  [METHOD]  readValues  [TYPE]  <T>  [PARAMETER]  byte[]  src  int  offset  int  length  [CLASS]  ObjectReader  [TYPE]  DefaultDeserializationContext  _context  [TYPE]  FormatSchema  _schema  [TYPE]  JsonFactory  _parserFactory  [TYPE]  DeserializationConfig  _config  [TYPE]  DataFormatReaders  _dataFormatReaders  [TYPE]  JsonDeserializer  _rootDeserializer  [TYPE]  InjectableValues  _injectableValues  [TYPE]  long  serialVersionUID  [TYPE]  int  length  offset  [TYPE]  byte[]  src  [TYPE]  JavaType  JSON_NODE_TYPE  _valueType  [TYPE]  boolean  _unwrapRoot  false  true  [TYPE]  Object  _valueToUpdate  [TYPE]  ConcurrentHashMap  _rootDeserializers  [TYPE]  TokenFilter  _filter  [CONTEXT]  public  <T>  MappingIterator<T>  readValues  (  byte[]  src  ,  int  offset  ,  int  length  )  throws  IOException  ,  JsonProcessingException  {  if  (  _dataFormatReaders  !  =  null  )  {  return  _detectBindAndReadValues  (  _dataFormatReaders  .  findFormat  (  src  ,  offset  ,  length  )  ,  false  )  ;  }  [BUGGY]  return  _bindAndReadValues  (  _considerFilter  (  _parserFactory  .  createParser  (  src  )  ,  true  )  )  ;  }  	JacksonDatabind_57_ObjectReader_1_1	1441	1	src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
1313	if  ((mutator  instanceof  AnnotatedField)  &&   "cause ".equals(mutator.getName()))  {  ;  }  else  {  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  access  private  javalangThrowable  javalangThrowablecause  (  from  class  javalangThrowable  ;  failed  to  set  access:  Can  not  force  permission:  (   "javalangreflectReflectPermission "   "suppressAccessChecks "  )  assertNotNull  (  e  )  ;  [METHOD]  constructSettableProperty  [TYPE]  SettableBeanProperty  [PARAMETER]  DeserializationContext  ctxt  BeanDescription  beanDesc  BeanPropertyDefinition  propDef  JavaType  propType0  [CLASS]  BeanDeserializerFactory  [TYPE]  Std  property  [TYPE]  Class[]  INIT_CAUSE_PARAMS  NO_VIEWS  [TYPE]  SettableBeanProperty  prop  [TYPE]  ReferenceProperty  ref  [TYPE]  BeanDescription  beanDesc  [TYPE]  AnnotatedMember  mutator  [TYPE]  JsonDeserializer  propDeser  [TYPE]  ObjectIdInfo  objectIdInfo  [TYPE]  long  serialVersionUID  [TYPE]  JavaType  propType0  type  [TYPE]  boolean  false  true  [TYPE]  BeanDeserializerFactory  instance  [TYPE]  BeanPropertyDefinition  propDef  [TYPE]  DeserializationContext  ctxt  [TYPE]  TypeDeserializer  typeDeser  [CONTEXT]  protected  SettableBeanProperty  constructSettableProperty  (  DeserializationContext  ctxt  ,  BeanDescription  beanDesc  ,  BeanPropertyDefinition  propDef  ,  JavaType  propType0  )  throws  JsonMappingException  {  AnnotatedMember  mutator  =  propDef  .  getNonConstructorMutator  (  )  ;  if  (  ctxt  .  canOverrideAccessModifiers  (  )  )  {    [BUGGY]  mutator  .  fixAccess  (  ctxt  .  isEnabled  (  MapperFeature  .  OVERRIDE_PUBLIC_ACCESS_MODIFIERS  )  )  ;  }  BeanProperty  .  Std  property  =  new  BeanProperty  .  Std  (  propDef  .  getFullName  (  )  ,  propType0  ,  propDef  .  getWrapperName  (  )  ,  beanDesc  .  getClassAnnotations  (  )  ,  mutator  ,  propDef  .  getMetadata  (  )  )  ;  	JacksonDatabind_58_BeanDeserializerFactory_1_1	715	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1314	public  JavaType  withHandlersFrom(JavaType  src)  {  JavaType  type  =  this;  Object  h  =  src.getTypeHandler();  if  (h  !=  _typeHandler)  {  type  =  type.withTypeHandler(h);  }  h  =  src.getValueHandler();  if  (h  !=  _valueHandler)  {  type  =  type.withValueHandler(h);  }  return  type;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  find  a  (  Map  )  Key  deserializer  for  type  [simple  type  ,  class  comfasterxmljacksondatabindjsontypeTypeRefinementForMapTest$CompoundKey]  assertEquals  (  TEST_INSTANCE_SERIALIZED  ,  testInstanceSerialized  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_59_JavaType_1_1	140	0	src/main/java/com/fasterxml/jackson/databind/JavaType.java
1315	@Override  public  JavaType  withHandlersFrom(JavaType  src)  {  JavaType  type  =  super.withHandlersFrom(src);  JavaType  srcCt  =  src.getContentType();  if  (srcCt  !=  null)  {  JavaType  ct  =  _elementType.withHandlersFrom(srcCt);  if  (ct  !=  _elementType)  {  type  =  type.withContentType(ct);  }  }  return  type;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  find  a  (  Map  )  Key  deserializer  for  type  [simple  type  ,  class  comfasterxmljacksondatabindjsontypeTypeRefinementForMapTest$CompoundKey]  assertEquals  (  TEST_INSTANCE_SERIALIZED  ,  testInstanceSerialized  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_59_CollectionLikeType_1_1	136	0	src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java
1316	@Override  public  JavaType  withHandlersFrom(JavaType  src)  {  JavaType  type  =  super.withHandlersFrom(src);  JavaType  srcKeyType  =  src.getKeyType();  if  (type  instanceof  MapLikeType)  {  if  (srcKeyType  !=  null)  {  JavaType  ct  =  _keyType.withHandlersFrom(srcKeyType);  if  (ct  !=  _keyType)  {  type  =  ((MapLikeType)  type).withKeyType(ct);  }  }  }  JavaType  srcCt  =  src.getContentType();  if  (srcCt  !=  null)  {  JavaType  ct  =  _valueType.withHandlersFrom(srcCt);  if  (ct  !=  _valueType)  {  type  =  type.withContentType(ct);  }  }  return  type;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  find  a  (  Map  )  Key  deserializer  for  type  [simple  type  ,  class  comfasterxmljacksondatabindjsontypeTypeRefinementForMapTest$CompoundKey]  assertEquals  (  TEST_INSTANCE_SERIALIZED  ,  testInstanceSerialized  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_59_MapLikeType_1_1	148	0	src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java
1317	newType  =  newType.withHandlersFrom(baseType);  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  find  a  (  Map  )  Key  deserializer  for  type  [simple  type  ,  class  comfasterxmljacksondatabindjsontypeTypeRefinementForMapTest$CompoundKey]  assertEquals  (  TEST_INSTANCE_SERIALIZED  ,  testInstanceSerialized  )  ;  [METHOD]  constructSpecializedType  [TYPE]  JavaType  [PARAMETER]  JavaType  baseType  Class<?>  subclass  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  long  serialVersionUID  [TYPE]  int  typeParamCount  [TYPE]  TypeBindings  EMPTY_BINDINGS  tb  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  JavaType  baseType  newType  [TYPE]  boolean  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  rawBase  subclass  [TYPE]  TypeFactory  instance  [CONTEXT]            TypeBindings  tb  =  _bindingsForSubtype  (  baseType  ,  typeParamCount  ,  subclass  )  ;  if  (  baseType  .  isInterface  (  )  )  {  newType  =  baseType  .  refine  (  subclass  ,  tb  ,  null  ,  new  JavaType[]  {  baseType  }  )  ;  }  else  {  newType  =  baseType  .  refine  (  subclass  ,  tb  ,  baseType  ,  NO_TYPES  )  ;  }  if  (  newType  =  =  null  )  {  newType  =  _fromClass  (  null  ,  subclass  ,  tb  )  ;  }  }  while  (  false  )  ;    [BUGGY]  return  newType  ;      	JacksonDatabind_59_TypeFactory_1_1	428	0	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1318		[BUGGY]  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindjsontypeTestDefaultWithCreators$Bean1385>  but  was:<class  [B>  Assert  .  assertArrayEquals  (  BYTES  ,  b  .  raw  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_60_JsonValueSerializer_4_1	9	0	src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
1319		[BUGGY]  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindjsontypeTestDefaultWithCreators$Bean1385>  but  was:<class  [B>  Assert  .  assertArrayEquals  (  BYTES  ,  b  .  raw  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_60_JsonValueSerializer_4_2	17	0	src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
1320	TypeSerializerRerouter  rr  =  new  TypeSerializerRerouter(typeSer0,  bean);  ser.serializeWithType(value,  gen,  provider,  rr);  	[BUGGY]  ser  .  serializeWithType  (  value  ,  gen  ,  provider  ,  typeSer0  )  ;  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindjsontypeTestDefaultWithCreators$Bean1385>  but  was:<class  [B>  Assert  .  assertArrayEquals  (  BYTES  ,  b  .  raw  )  ;  [METHOD]  serializeWithType  [TYPE]  void  [PARAMETER]  Object  bean  JsonGenerator  gen  SerializerProvider  provider  TypeSerializer  typeSer0  [CLASS]  JsonValueSerializer  [TYPE]  boolean  _forceTypeInformation  false  true  [TYPE]  AnnotatedMethod  _accessorMethod  [TYPE]  TypeSerializer  typeSer0  [TYPE]  JsonGenerator  gen  [TYPE]  Throwable  t  [TYPE]  Object  bean  value  [TYPE]  JsonSerializer  _valueSerializer  ser  [TYPE]  IOException  ioe  [TYPE]  SerializerProvider  provider  [TYPE]  Exception  e  [TYPE]  BeanProperty  _property  [CONTEXT]  try  {  value  =  _accessorMethod  .  getValue  (  bean  )  ;  if  (  value  =  =  null  )  {  provider  .  defaultSerializeNull  (  gen  )  ;  return  ;  }  JsonSerializer<Object>  ser  =  _valueSerializer  ;  if  (  ser  =  =  null  )  {  //  no  serializer  yet?  Need  to  fetch  ser  =  provider  .  findValueSerializer  (  value  .  getClass  (  )  ,  _property  )  ;  }  else  {    if  (  _forceTypeInformation  )  {  typeSer0  .  writeTypePrefixForScalar  (  bean  ,  gen  )  ;  ser  .  serialize  (  value  ,  gen  ,  provider  )  ;  typeSer0  .  writeTypeSuffixForScalar  (  bean  ,  gen  )  ;  return  ;  }  }    [BUGGY]  ser  .  serializeWithType  (  value  ,  gen  ,  provider  ,  typeSer0  )  ;  }  catch  (  IOException  ioe  )  {  throw  ioe  ;  }  catch  (  Exception  e  )  {  Throwable  t  =  e  ;  	JacksonDatabind_60_JsonValueSerializer_4_3	226	1	src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
1321	static  class  TypeSerializerRerouter  extends  TypeSerializer  {  protected  final  TypeSerializer  _typeSerializer;  protected  final  Object  _forObject;  public  TypeSerializerRerouter(TypeSerializer  ts,  Object  ob)  {  _typeSerializer  =  ts;  _forObject  =  ob;  }  @Override  public  TypeSerializer  forProperty(BeanProperty  prop)  {    throw  new  UnsupportedOperationException();  }  @Override  public  As  getTypeInclusion()  {  return  _typeSerializer.getTypeInclusion();  }  @Override  public  String  getPropertyName()  {  return  _typeSerializer.getPropertyName();  }  @Override  public  TypeIdResolver  getTypeIdResolver()  {  return  _typeSerializer.getTypeIdResolver();  }  @Override  public  void  writeTypePrefixForScalar(Object  value,  JsonGenerator  gen)  throws  IOException  {  _typeSerializer.writeTypePrefixForScalar(_forObject,  gen);  }  @Override  public  void  writeTypePrefixForObject(Object  value,  JsonGenerator  gen)  throws  IOException  {  _typeSerializer.writeTypePrefixForObject(_forObject,  gen);  }  @Override  public  void  writeTypePrefixForArray(Object  value,  JsonGenerator  gen)  throws  IOException  {  _typeSerializer.writeTypePrefixForArray(_forObject,  gen);  }  @Override  public  void  writeTypeSuffixForScalar(Object  value,  JsonGenerator  gen)  throws  IOException  {  _typeSerializer.writeTypeSuffixForScalar(_forObject,  gen);  }  @Override  public  void  writeTypeSuffixForObject(Object  value,  JsonGenerator  gen)  throws  IOException  {  _typeSerializer.writeTypeSuffixForObject(_forObject,  gen);  }  @Override  public  void  writeTypeSuffixForArray(Object  value,  JsonGenerator  gen)  throws  IOException  {  _typeSerializer.writeTypeSuffixForArray(_forObject,  gen);  }  public  void  writeTypePrefixForScalar(Object  value,  JsonGenerator  gen,  Class<?>  type)  throws  IOException  {  _typeSerializer.writeTypePrefixForScalar(_forObject,  gen,  type);  }  public  void  writeTypePrefixForObject(Object  value,  JsonGenerator  gen,  Class<?>  type)  throws  IOException  {  _typeSerializer.writeTypePrefixForObject(_forObject,  gen,  type);  }  public  void  writeTypePrefixForArray(Object  value,  JsonGenerator  gen,  Class<?>  type)  throws  IOException  {  _typeSerializer.writeTypePrefixForArray(_forObject,  gen,  type);  }  @Override  public  void  writeCustomTypePrefixForScalar(Object  value,  JsonGenerator  gen,  String  typeId)  throws  IOException  {  _typeSerializer.writeCustomTypePrefixForScalar(_forObject,  gen,  typeId);  }  @Override  public  void  writeCustomTypePrefixForObject(Object  value,  JsonGenerator  gen,  String  typeId)  throws  IOException  {  _typeSerializer.writeCustomTypePrefixForObject(_forObject,  gen,  typeId);  }  @Override  public  void  writeCustomTypePrefixForArray(Object  value,  JsonGenerator  gen,  String  typeId)  throws  IOException  {  _typeSerializer.writeCustomTypePrefixForArray(_forObject,  gen,  typeId);  }  @Override  public  void  writeCustomTypeSuffixForScalar(Object  value,  JsonGenerator  gen,  String  typeId)  throws  IOException  {  _typeSerializer.writeCustomTypeSuffixForScalar(_forObject,  gen,  typeId);  }  @Override  public  void  writeCustomTypeSuffixForObject(Object  value,  JsonGenerator  gen,  String  typeId)  throws  IOException  {  _typeSerializer.writeCustomTypeSuffixForObject(_forObject,  gen,  typeId);  }  @Override  public  void  writeCustomTypeSuffixForArray(Object  value,  JsonGenerator  gen,  String  typeId)  throws  IOException  {  _typeSerializer.writeCustomTypeSuffixForArray(_forObject,  gen,  typeId);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<class  comfasterxmljacksondatabindjsontypeTestDefaultWithCreators$Bean1385>  but  was:<class  [B>  Assert  .  assertArrayEquals  (  BYTES  ,  b  .  raw  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_60_JsonValueSerializer_4_4	363	0	src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java
1322	if  (t.isPrimitive())  {  return  false;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Class  javalangLong  not  subtype  of  [simple  type  ,  class  long]  (  through  reference  chain:  javautilHashMap[ "longAsField "]->comfasterxmljacksondatabindjsontypeData[ "key "]  )  assertEquals  (  2  ,  result  .  size  (  )  )  ;  [METHOD]  useForType  [TYPE]  boolean  [PARAMETER]  JavaType  t  [CLASS]  DefaultTypeResolverBuilder  [TYPE]  JavaType  t  [TYPE]  boolean  false  true  [TYPE]  DefaultTyping  _appliesFor  [TYPE]  long  serialVersionUID  [CONTEXT]  public  boolean  useForType  (  JavaType  t  )  {    [BUGGY]  switch  (  _appliesFor  )  {  case  NON_CONCRETE_AND_ARRAYS:  while  (  t  .  isArrayType  (  )  )  {  t  =  t  .  getContentType  (  )  ;  }  	JacksonDatabind_61_ObjectMapper_1_1	232	0	src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java
1323	if  (baseType.isPrimitive())  {  return  null;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Class  javalangLong  not  subtype  of  [simple  type  ,  class  long]  (  through  reference  chain:  javautilHashMap[ "longAsField "]->comfasterxmljacksondatabindjsontypeData[ "key "]  )  assertEquals  (  2  ,  result  .  size  (  )  )  ;  [METHOD]  buildTypeSerializer  [TYPE]  TypeSerializer  [PARAMETER]  SerializationConfig  config  JavaType  baseType  NamedType>  subtypes  [CLASS]  StdTypeResolverBuilder  [TYPE]  As  _includeAs  [TYPE]  JavaType  baseType  [TYPE]  boolean  _typeIdVisible  false  true  [TYPE]  SerializationConfig  config  [TYPE]  Collection  subtypes  [TYPE]  Class  _defaultImpl  [TYPE]  Id  _idType  [TYPE]  String  _typeProperty  [TYPE]  TypeIdResolver  _customIdResolver  idRes  [CONTEXT]  public  TypeSerializer  buildTypeSerializer  (  SerializationConfig  config  ,  JavaType  baseType  ,  Collection<NamedType>  subtypes  )  {  if  (  _idType  =  =  JsonTypeInfo  .  Id  .  NONE  )  {  return  null  ;  }    [BUGGY]  TypeIdResolver  idRes  =  idResolver  (  config  ,  baseType  ,  subtypes  ,  true  ,  false  )  ;  switch  (  _includeAs  )  {  case  WRAPPER_ARRAY:  return  new  AsArrayTypeSerializer  (  idRes  ,  null  )  ;  case  PROPERTY:  return  new  AsPropertyTypeSerializer  (  idRes  ,  null  ,  _typeProperty  )  ;  case  WRAPPER_OBJECT:  return  new  AsWrapperTypeSerializer  (  idRes  ,  null  )  ;  case  EXTERNAL_PROPERTY:  return  new  AsExternalTypeSerializer  (  idRes  ,  null  ,  _typeProperty  )  ;  case  EXISTING_PROPERTY:  return  new  AsExistingPropertyTypeSerializer  (  idRes  ,  null  ,  _typeProperty  )  ;  }  throw  new  IllegalStateException  (   "Do  not  know  how  to  construct  standard  type  serializer  for  inclusion  type:   "+_includeAs  )  ;  }  	JacksonDatabind_61_StdTypeResolverBuilder_2_1	74	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java
1324	if  (baseType.isPrimitive())  {  return  null;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Class  javalangLong  not  subtype  of  [simple  type  ,  class  long]  (  through  reference  chain:  javautilHashMap[ "longAsField "]->comfasterxmljacksondatabindjsontypeData[ "key "]  )  assertEquals  (  2  ,  result  .  size  (  )  )  ;  [METHOD]  buildTypeDeserializer  [TYPE]  TypeDeserializer  [PARAMETER]  DeserializationConfig  config  JavaType  baseType  NamedType>  subtypes  [CLASS]  StdTypeResolverBuilder  [TYPE]  As  _includeAs  [TYPE]  JavaType  baseType  defaultImpl  [TYPE]  boolean  _typeIdVisible  false  true  [TYPE]  Collection  subtypes  [TYPE]  Class  _defaultImpl  [TYPE]  DeserializationConfig  config  [TYPE]  Id  _idType  [TYPE]  String  _typeProperty  [TYPE]  TypeIdResolver  _customIdResolver  idRes  [CONTEXT]  public  TypeDeserializer  buildTypeDeserializer  (  DeserializationConfig  config  ,  JavaType  baseType  ,  Collection<NamedType>  subtypes  )  {  if  (  _idType  =  =  JsonTypeInfo  .  Id  .  NONE  )  {  return  null  ;  }    [BUGGY]  TypeIdResolver  idRes  =  idResolver  (  config  ,  baseType  ,  subtypes  ,  false  ,  true  )  ;  JavaType  defaultImpl  ;  if  (  _defaultImpl  =  =  null  )  {  	JacksonDatabind_61_StdTypeResolverBuilder_2_2	104	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java
1325	}  else  if  (_valueInstantiator.canCreateUsingArrayDelegate())  {  JavaType  delegateType  =  _valueInstantiator.getArrayDelegateType(ctxt.getConfig());  if  (delegateType  ==  null)  {  throw  new  IllegalArgumentException( "Invalid  array-delegate-creator  definition  for   "+_collectionType  + ":  value  instantiator  ( "+_valueInstantiator.getClass().getName()  + ")  returned  true  for  \'canCreateUsingArrayDelegate()\',  but  null  for  \'getArrayDelegateType()\' ");  }  delegateDeser  =  findDeserializer(ctxt,  delegateType,  property);  	[BUGGY]  [FE]  IllegalStateException:  No  default  constructor  for  [collection  type  ;  class  javautilCollections$UnmodifiableSet  ,  contains  [simple  type  ,  class  javalangObject]]  assertTrue  (  foo  .  isEmpty  (  )  )  ;  [METHOD]  createContextual  [TYPE]  CollectionDeserializer  [PARAMETER]  DeserializationContext  ctxt  BeanProperty  property  [CLASS]  CollectionDeserializer  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  JsonDeserializer  _delegateDeserializer  _valueDeserializer  delegateDeser  valueDeser  [TYPE]  long  serialVersionUID  [TYPE]  BeanProperty  property  [TYPE]  JavaType  _collectionType  delegateType  vt  [TYPE]  CollectionReferringAccumulator  _parent  [TYPE]  boolean  false  true  [TYPE]  Collection  _result  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  _elementType  [TYPE]  List  _accumulator  next  [TYPE]  TypeDeserializer  _valueTypeDeserializer  valueTypeDeser  [TYPE]  Boolean  _unwrapSingle  unwrapSingle  [CONTEXT]  public  CollectionDeserializer  createContextual  (  DeserializationContext  ctxt  ,  BeanProperty  property  )  throws  JsonMappingException  {  JsonDeserializer<Object>  delegateDeser  =  null  ;  if  (  _valueInstantiator  !  =  null  )  {  if  (  _valueInstantiator  .  canCreateUsingDelegate  (  )  )  {  JavaType  delegateType  =  _valueInstantiator  .  getDelegateType  (  ctxt  .  getConfig  (  )  )  ;  if  (  delegateType  =  =  null  )  {  throw  new  IllegalArgumentException  (   "Invalid  delegate-creator  definition  for   "+_collectionType  + ":  value  instantiator  (   "+_valueInstantiator  .  getClass  (  )  .  getName  (  )  + "  )  returned  true  for  'canCreateUsingDelegate  (  )  '  ,  but  null  for  'getDelegateType  (  )  ' "  )  ;  }  delegateDeser  =  findDeserializer  (  ctxt  ,  delegateType  ,  property  )  ;  [BUGGY]  }  }    Boolean  unwrapSingle  =  findFormatFeature  (  ctxt  ,  property  ,  Collection  .  class  ,  	JacksonDatabind_62_CollectionDeserializer_1_1	184	0	src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java
1326		[BUGGY]  [FE]  ComparisonFailure:  expected:<databinddeserexc[ExceptionPathTest$]Outer[ "inner "]>  but  was:<databinddeserexc[]Outer[ "inner "]>  assertEquals  (  getClass  (  )  .  getName  (  )  + "$Outer[\ "inner\ "] "  ,  [CLASS]  [CONTEXT]  	JacksonDatabind_63_JsonMappingException_3_1	10	0	src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
1327	while  (cls.isArray())  {  cls  =  cls.getComponentType();  ++arrays;  }  sb.append(cls.getName());  while  (--arrays  >=  0)  {  sb.append( "[] ");  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<databinddeserexc[ExceptionPathTest$]Outer[ "inner "]>  but  was:<databinddeserexc[]Outer[ "inner "]>  assertEquals  (  getClass  (  )  .  getName  (  )  + "$Outer[\ "inner\ "] "  ,  [METHOD]  getDescription  [TYPE]  String  [PARAMETER]  [CLASS]  Reference  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Object  _from  [TYPE]  Class  cls  [TYPE]  String  _desc  _fieldName  pkgName  [TYPE]  long  serialVersionUID  [TYPE]  int  _index  [CONTEXT]  public  String  getDescription  (  )  {  if  (  _desc  =  =  null  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  if  (  _from  =  =  null  )  {  //  can  this  ever  occur?  sb  .  append  (   "UNKNOWN "  )  ;  }  else  {  Class<?>  cls  =  (  _from  instanceof  Class<?>  )  ?  (  Class<?>  )  _from  :  _from  .  getClass  (  )  ;      [BUGGY]  String  pkgName  =  ClassUtil  .  getPackageName  (  cls  )  ;  if  (  pkgName  !  =  null  )  {  sb  .  append  (  pkgName  )  ;  sb  .  append  (  '  .  '  )  ;  }  sb  .  append  (  cls  .  getSimpleName  (  )  )  ;  	JacksonDatabind_63_JsonMappingException_3_2	131	0	src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
1328		[BUGGY]  sb  .  append  (  cls  .  getSimpleName  (  )  )  ;  [FE]  ComparisonFailure:  expected:<databinddeserexc[ExceptionPathTest$]Outer[ "inner "]>  but  was:<databinddeserexc[]Outer[ "inner "]>  assertEquals  (  getClass  (  )  .  getName  (  )  + "$Outer[\ "inner\ "] "  ,  [METHOD]  getDescription  [TYPE]  String  [PARAMETER]  [CLASS]  Reference  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  Object  _from  [TYPE]  Class  cls  [TYPE]  String  _desc  _fieldName  pkgName  [TYPE]  long  serialVersionUID  [TYPE]  int  _index  [CONTEXT]  public  String  getDescription  (  )  {  if  (  _desc  =  =  null  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  if  (  _from  =  =  null  )  {  //  can  this  ever  occur?  sb  .  append  (   "UNKNOWN "  )  ;  }  else  {  Class<?>  cls  =  (  _from  instanceof  Class<?>  )  ?  (  Class<?>  )  _from  :  _from  .  getClass  (  )  ;      String  pkgName  =  ClassUtil  .  getPackageName  (  cls  )  ;  if  (  pkgName  !  =  null  )  {  sb  .  append  (  pkgName  )  ;  sb  .  append  (  '  .  '  )  ;  }  [BUGGY]  sb  .  append  (  cls  .  getSimpleName  (  )  )  ;  }  sb  .  append  (  '['  )  ;  if  (  _fieldName  !  =  null  )  {  sb  .  append  (  ' "'  )  ;  sb  .  append  (  _fieldName  )  ;  	JacksonDatabind_63_JsonMappingException_3_3	136	1	src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
1329	Object  defaultBean;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "str ":null]}>  assertEquals  (  aposToQuotes  (   "{} "  )  ,  [METHOD]  buildWriter  [TYPE]  BeanPropertyWriter  [PARAMETER]  SerializerProvider  prov  BeanPropertyDefinition  propDef  JavaType  declaredType  JsonSerializer<?>  ser  TypeSerializer  typeSer  TypeSerializer  contentTypeSer  AnnotatedMember  am  boolean  defaultUseStaticTyping  [CLASS]  PropertyBuilder  [TYPE]  SerializationConfig  _config  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  AnnotatedMember  am  [TYPE]  Include  inclusion  [TYPE]  JsonSerializer  ser  [TYPE]  NameTransformer  unwrapper  [TYPE]  JavaType  actualType  ct  declaredType  serializationType  [TYPE]  boolean  _useRealPropertyDefaults  defaultUseStaticTyping  false  suppressNulls  true  [TYPE]  JsonMappingException  e  [TYPE]  Value  _defaultInclusion  inclV  [TYPE]  BeanPropertyDefinition  propDef  [TYPE]  TypeSerializer  contentTypeSer  typeSer  [TYPE]  Object  NO_DEFAULT_MARKER  _defaultBean  serDef  valueToSuppress  [TYPE]  SerializerProvider  prov  [TYPE]  BeanPropertyWriter  bpw  [CONTEXT]  JavaType  actualType  =  (  serializationType  =  =  null  )  ?  declaredType  :  serializationType  ;      JsonInclude  .  Value  inclV  =  _config  .  getDefaultPropertyInclusion  (  actualType  .  getRawClass  (  )  ,  _defaultInclusion  )  ;    inclV  =  inclV  .  withOverrides  (  propDef  .  findInclusion  (  )  )  ;  JsonInclude  .  Include  inclusion  =  inclV  .  getValueInclusion  (  )  ;  if  (  inclusion  =  =  JsonInclude  .  Include  .  USE_DEFAULTS  )  {  //  should  not  occur  but  .  .  .  inclusion  =  JsonInclude  .  Include  .  ALWAYS  ;  }  switch  (  inclusion  )  {  case  NON_DEFAULT:      [BUGGY]      if  (  _useRealPropertyDefaults  )  {  	JacksonDatabind_64_PropertyBuilder_3_1	152	0	src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
1330	if  (_useRealPropertyDefaults  &&  (defaultBean  =  getDefaultBean())  !=  null)  {  	[BUGGY]  if  (  _useRealPropertyDefaults  )  {  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "str ":null]}>  assertEquals  (  aposToQuotes  (   "{} "  )  ,  [METHOD]  buildWriter  [TYPE]  BeanPropertyWriter  [PARAMETER]  SerializerProvider  prov  BeanPropertyDefinition  propDef  JavaType  declaredType  JsonSerializer<?>  ser  TypeSerializer  typeSer  TypeSerializer  contentTypeSer  AnnotatedMember  am  boolean  defaultUseStaticTyping  [CLASS]  PropertyBuilder  [TYPE]  SerializationConfig  _config  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  AnnotatedMember  am  [TYPE]  Include  inclusion  [TYPE]  JsonSerializer  ser  [TYPE]  NameTransformer  unwrapper  [TYPE]  JavaType  actualType  ct  declaredType  serializationType  [TYPE]  boolean  _useRealPropertyDefaults  defaultUseStaticTyping  false  suppressNulls  true  [TYPE]  JsonMappingException  e  [TYPE]  Value  _defaultInclusion  inclV  [TYPE]  BeanPropertyDefinition  propDef  [TYPE]  TypeSerializer  contentTypeSer  typeSer  [TYPE]  Object  NO_DEFAULT_MARKER  _defaultBean  serDef  valueToSuppress  [TYPE]  SerializerProvider  prov  [TYPE]  BeanPropertyWriter  bpw  [CONTEXT]  JsonInclude  .  Value  inclV  =  _config  .  getDefaultPropertyInclusion  (  actualType  .  getRawClass  (  )  ,  _defaultInclusion  )  ;    inclV  =  inclV  .  withOverrides  (  propDef  .  findInclusion  (  )  )  ;  JsonInclude  .  Include  inclusion  =  inclV  .  getValueInclusion  (  )  ;  if  (  inclusion  =  =  JsonInclude  .  Include  .  USE_DEFAULTS  )  {  //  should  not  occur  but  .  .  .  inclusion  =  JsonInclude  .  Include  .  ALWAYS  ;  }  switch  (  inclusion  )  {  case  NON_DEFAULT:          [BUGGY]  if  (  _useRealPropertyDefaults  )  {  if  (  prov  .  isEnabled  (  MapperFeature  .  CAN_OVERRIDE_ACCESS_MODIFIERS  )  )  {  am  .  fixAccess  (  _config  .  isEnabled  (  MapperFeature  .  OVERRIDE_PUBLIC_ACCESS_MODIFIERS  )  )  ;  }  valueToSuppress  =  getPropertyDefaultValue  (  propDef  .  getName  (  )  ,  am  ,  actualType  )  ;  	JacksonDatabind_64_PropertyBuilder_3_2	157	1	src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
1331	try  {  valueToSuppress  =  am.getValue(defaultBean);  }  catch  (Exception  e)  {  _throwWrapped(e,  propDef.getName(),  defaultBean);  }  	[BUGGY]  valueToSuppress  =  getPropertyDefaultValue  (  propDef  .  getName  (  )  ,  am  ,  actualType  )  ;  [FE]  ComparisonFailure:  expected:<{[]}>  but  was:<{[ "str ":null]}>  assertEquals  (  aposToQuotes  (   "{} "  )  ,  [METHOD]  buildWriter  [TYPE]  BeanPropertyWriter  [PARAMETER]  SerializerProvider  prov  BeanPropertyDefinition  propDef  JavaType  declaredType  JsonSerializer<?>  ser  TypeSerializer  typeSer  TypeSerializer  contentTypeSer  AnnotatedMember  am  boolean  defaultUseStaticTyping  [CLASS]  PropertyBuilder  [TYPE]  SerializationConfig  _config  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  AnnotatedMember  am  [TYPE]  Include  inclusion  [TYPE]  JsonSerializer  ser  [TYPE]  NameTransformer  unwrapper  [TYPE]  JavaType  actualType  ct  declaredType  serializationType  [TYPE]  boolean  _useRealPropertyDefaults  defaultUseStaticTyping  false  suppressNulls  true  [TYPE]  JsonMappingException  e  [TYPE]  Value  _defaultInclusion  inclV  [TYPE]  BeanPropertyDefinition  propDef  [TYPE]  TypeSerializer  contentTypeSer  typeSer  [TYPE]  Object  NO_DEFAULT_MARKER  _defaultBean  serDef  valueToSuppress  [TYPE]  SerializerProvider  prov  [TYPE]  BeanPropertyWriter  bpw  [CONTEXT]  inclV  =  inclV  .  withOverrides  (  propDef  .  findInclusion  (  )  )  ;  JsonInclude  .  Include  inclusion  =  inclV  .  getValueInclusion  (  )  ;  if  (  inclusion  =  =  JsonInclude  .  Include  .  USE_DEFAULTS  )  {  //  should  not  occur  but  .  .  .  inclusion  =  JsonInclude  .  Include  .  ALWAYS  ;  }  switch  (  inclusion  )  {  case  NON_DEFAULT:          if  (  _useRealPropertyDefaults  )  {  if  (  prov  .  isEnabled  (  MapperFeature  .  CAN_OVERRIDE_ACCESS_MODIFIERS  )  )  {  am  .  fixAccess  (  _config  .  isEnabled  (  MapperFeature  .  OVERRIDE_PUBLIC_ACCESS_MODIFIERS  )  )  ;  }  [BUGGY]  valueToSuppress  =  getPropertyDefaultValue  (  propDef  .  getName  (  )  ,  am  ,  actualType  )  ;  }  else  {  valueToSuppress  =  getDefaultValue  (  actualType  )  ;  suppressNulls  =  true  ;  }  if  (  valueToSuppress  =  =  null  )  {  	JacksonDatabind_64_PropertyBuilder_3_3	162	1	src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
1332	return  ctxt.handleWeirdKey(_keyClass,  key,   "not  a  valid  representation,  problem:  (%s)  %s ",  re.getClass().getName(),  re.getMessage());  	[BUGGY]  return  ctxt  .  handleWeirdKey  (  _keyClass  ,  key  ,   "not  a  valid  representation  ,  problem:  %s "  ,  re  .  getMessage  (  )  )  ;  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  deserialize  Map  key  of  type  comfasterxmljacksondatabinddeserKeyDeser1429Test$FullName  from  String   "firstlast ":  not  a  valid  representation  ,  problem:  wrong  number  of  arguments  assertEquals  (  entry  .  getValue  (  )  .  doubleValue  (  )  ,  42  ,  0  )  ;  [METHOD]  deserializeKey  [TYPE]  Object  [PARAMETER]  String  key  DeserializationContext  ctxt  [CLASS]  StdKeyDeserializer  [TYPE]  AnnotatedMethod  _factory  [TYPE]  FromStringDeserializer  _deser  [TYPE]  Constructor  _ctor  [TYPE]  Method  _factoryMethod  [TYPE]  String  key  [TYPE]  JsonDeserializer  _delegate  [TYPE]  long  serialVersionUID  [TYPE]  int  TYPE_BOOLEAN  TYPE_BYTE  TYPE_CALENDAR  TYPE_CHAR  TYPE_CLASS  TYPE_CURRENCY  TYPE_DATE  TYPE_DOUBLE  TYPE_FLOAT  TYPE_INT  TYPE_LOCALE  TYPE_LONG  TYPE_SHORT  TYPE_URI  TYPE_URL  TYPE_UUID  _kind  [TYPE]  Exception  re  [TYPE]  StringKD  sObject  sString  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  _keyClass  [TYPE]  Object  result  [TYPE]  EnumResolver  _byNameResolver  _byToStringResolver  [CONTEXT]  public  Object  deserializeKey  (  String  key  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  key  =  =  null  )  {  //  is  this  even  legal  call?  return  null  ;  }  try  {  Object  result  =  _parse  (  key  ,  ctxt  )  ;  if  (  result  !  =  null  )  {  return  result  ;  }  }  catch  (  Exception  re  )  {  [BUGGY]  return  ctxt  .  handleWeirdKey  (  _keyClass  ,  key  ,   "not  a  valid  representation  ,  problem:  %s "  ,  re  .  getMessage  (  )  )  ;  }  if  (  _keyClass  .  isEnum  (  )  &&  ctxt  .  getConfig  (  )  .  isEnabled  (  DeserializationFeature  .  READ_UNKNOWN_ENUM_VALUES_AS_NULL  )  )  {  return  null  ;  }  return  ctxt  .  handleWeirdKey  (  _keyClass  ,  key  ,   "not  a  valid  representation "  )  ;  }  	JacksonDatabind_65_StdKeyDeserializer_1_1	128	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java
1333	if  (isFactoryMethod(am)  &&  am.getParameterCount()  ==  1)  {  	[BUGGY]  if  (  isFactoryMethod  (  am  )  )  {  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  deserialize  Map  key  of  type  comfasterxmljacksondatabinddeserKeyDeser1429Test$FullName  from  String   "firstlast ":  not  a  valid  representation  ,  problem:  wrong  number  of  arguments  assertEquals  (  entry  .  getValue  (  )  .  doubleValue  (  )  ,  42  ,  0  )  ;  [METHOD]  findFactoryMethod  [TYPE]  Method  [PARAMETER]  expArgTypes  [CLASS]  BasicBeanDescription  [TYPE]  Class[]  expArgTypes  [TYPE]  boolean  false  true  [TYPE]  AnnotatedMethod  am  [TYPE]  AnnotatedClass  _classInfo  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  MapperConfig  _config  [TYPE]  List  _properties  [TYPE]  Class  actualArgType  expArgType  [TYPE]  ObjectIdInfo  _objectIdInfo  [TYPE]  POJOPropertiesCollector  _propCollector  [CONTEXT]  public  Method  findFactoryMethod  (  Class<?>  .  .  .  expArgTypes  )  {  for  (  AnnotatedMethod  am  :  _classInfo  .  getStaticMethods  (  )  )  {  [BUGGY]  if  (  isFactoryMethod  (  am  )  )  {  Class<?>  actualArgType  =  am  .  getRawParameterType  (  0  )  ;  for  (  Class<?>  expArgType  :  expArgTypes  )  {  if  (  actualArgType  .  isAssignableFrom  (  expArgType  )  )  {  return  am  .  getAnnotated  (  )  ;  }  }  }  }  return  null  ;  }  	JacksonDatabind_65_BasicBeanDescription_2_1	525	1	src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
1334	if  (am.getParameterCount()  ==  1)  {  }  	[BUGGY]  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  deserialize  Map  key  of  type  comfasterxmljacksondatabinddeserKeyDeser1429Test$FullName  from  String   "firstlast ":  not  a  valid  representation  ,  problem:  wrong  number  of  arguments  assertEquals  (  entry  .  getValue  (  )  .  doubleValue  (  )  ,  42  ,  0  )  ;  [METHOD]  isFactoryMethod  [TYPE]  boolean  [PARAMETER]  AnnotatedMethod  am  [CLASS]  BasicBeanDescription  [TYPE]  boolean  false  true  [TYPE]  AnnotatedMethod  am  [TYPE]  AnnotatedClass  _classInfo  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  MapperConfig  _config  [TYPE]  List  _properties  [TYPE]  Class  cls  rt  [TYPE]  String  name  [TYPE]  ObjectIdInfo  _objectIdInfo  [TYPE]  POJOPropertiesCollector  _propCollector  [CONTEXT]  protected  boolean  isFactoryMethod  (  AnnotatedMethod  am  )  {    Class<?>  rt  =  am  .  getRawReturnType  (  )  ;  if  (  !getBeanClass  (  )  .  isAssignableFrom  (  rt  )  )  {  return  false  ;  }      if  (  _annotationIntrospector  .  hasCreatorAnnotation  (  am  )  )  {  return  true  ;  }  final  String  name  =  am  .  getName  (  )  ;  if  (   "valueOf "  .  equals  (  name  )  )  {  [BUGGY]  return  true  ;  }  if  (   "fromString "  .  equals  (  name  )  )  {  if  (  am  .  getParameterCount  (  )  =  =  1  )  {  Class<?>  cls  =  am  .  getRawParameterType  (  0  )  ;  	JacksonDatabind_65_BasicBeanDescription_2_2	558	0	src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
1335		[BUGGY]  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  deserialize  Map  key  of  type  comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$SuperTypeEnum  from  String   "FOO ":  not  a  valid  representation:  No  enum  constant  comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializerSuperTypeEnum}  assertEquals  (   "Deserialized  someMap  .  FOO  should  equal  bar "  ,   "bar "  ,  [CLASS]  [CONTEXT]  	JacksonDatabind_66_StdKeyDeserializer_3_1	11	0	src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java
1336		[BUGGY]  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  deserialize  Map  key  of  type  comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$SuperTypeEnum  from  String   "FOO ":  not  a  valid  representation:  No  enum  constant  comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializerSuperTypeEnum}  assertEquals  (   "Deserialized  someMap  .  FOO  should  equal  bar "  ,   "bar "  ,  [CLASS]  [CONTEXT]  	JacksonDatabind_66_StdKeyDeserializer_3_2	18	0	src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java
1337	TokenBuffer  tb  =  new  TokenBuffer(ctxt.getParser(),  ctxt);  tb.writeString(key);  JsonParser  p  =  tb.asParser();  p.nextToken();  Object  result  =  _delegate.deserialize(p,  ctxt);  	[BUGGY]  Object  result  =  _delegate  .  deserialize  (  ctxt  .  getParser  (  )  ,  ctxt  )  ;  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  deserialize  Map  key  of  type  comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$SuperTypeEnum  from  String   "FOO ":  not  a  valid  representation:  No  enum  constant  comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializerSuperTypeEnum}  assertEquals  (   "Deserialized  someMap  .  FOO  should  equal  bar "  ,   "bar "  ,  [METHOD]  deserializeKey  [TYPE]  Object  [PARAMETER]  String  key  DeserializationContext  ctxt  [CLASS]  DelegatingKD  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  _keyClass  [TYPE]  Object  result  [TYPE]  String  key  [TYPE]  JsonDeserializer  _delegate  [TYPE]  long  serialVersionUID  [TYPE]  Exception  re  [CONTEXT]  public  final  Object  deserializeKey  (  String  key  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  key  =  =  null  )  {  //  is  this  even  legal  call?  return  null  ;  }  [BUGGY]  try  {  Object  result  =  _delegate  .  deserialize  (  ctxt  .  getParser  (  )  ,  ctxt  )  ;  if  (  result  !  =  null  )  {  return  result  ;  }  return  ctxt  .  handleWeirdKey  (  _keyClass  ,  key  ,   "not  a  valid  representation "  )  ;  }  catch  (  Exception  re  )  {  return  ctxt  .  handleWeirdKey  (  _keyClass  ,  key  ,   "not  a  valid  representation:  %s "  ,  re  .  getMessage  (  )  )  ;  }  }  	JacksonDatabind_66_StdKeyDeserializer_3_3	314	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java
1338	deser  =  _createEnumKeyDeserializer(ctxt,  type);  }  else  {  deser  =  StdKeyDeserializers.findStringBasedKeyDeserializer(config,  type);  	[BUGGY]  return  _createEnumKeyDeserializer  (  ctxt  ,  type  )  ;  deser  =  StdKeyDeserializers  .  findStringBasedKeyDeserializer  (  config  ,  type  )  ;  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  deserialize  Map  key  of  type  comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$KeyEnum  from  String   "REPlaceMENTS ":  not  a  valid  representation  ,  problem:  (  comfasterxmljacksondatabindexcInvalidFormatException  )  Can  not  deserialize  Map  key  of  type  comfasterxmljacksondatabindmoduleTestCustomEnumKeyDeserializer$KeyEnum  from  String   "REPlaceMENTS ":  not  one  of  values  excepted  for  Enum  class:  [rootDirectory  ,  replacements  ,  licenseString]  assertSame  (  KeyEnum  .  replacements  ,  map  .  keySet  (  )  .  iterator  (  )  .  next  (  )  )  ;  [METHOD]  createKeyDeserializer  [TYPE]  KeyDeserializer  [PARAMETER]  DeserializationContext  ctxt  JavaType  type  [CLASS]  BasicDeserializerFactory  [TYPE]  PropertyName  UNWRAPPED_CREATOR_PARAM_NAME  [TYPE]  BeanDeserializerModifier  mod  [TYPE]  JavaType  type  [TYPE]  boolean  false  true  [TYPE]  DeserializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _collectionFallbacks  _mapFallbacks  [TYPE]  BeanDescription  beanDesc  [TYPE]  DeserializationContext  ctxt  [TYPE]  KeyDeserializers  d  [TYPE]  Class  CLASS_CHAR_BUFFER  CLASS_ITERABLE  CLASS_MAP_ENTRY  CLASS_OBJECT  CLASS_STRING  [TYPE]  DeserializationConfig  config  [TYPE]  KeyDeserializer  deser  [CONTEXT]  public  KeyDeserializer  createKeyDeserializer  (  DeserializationContext  ctxt  ,  JavaType  type  )  throws  JsonMappingException  {  final  DeserializationConfig  config  =  ctxt  .  getConfig  (  )  ;  KeyDeserializer  deser  =  null  ;  if  (  _factoryConfig  .  hasKeyDeserializers  (  )  )  {  BeanDescription  beanDesc  =  config  .  introspectClassAnnotations  (  type  .  getRawClass  (  )  )  ;  for  (  KeyDeserializers  d:  _factoryConfig  .  keyDeserializers  (  )  )  {  deser  =  d  .  findKeyDeserializer  (  type  ,  config  ,  beanDesc  )  ;  if  (  deser  !  =  null  )  {  break  ;  }  }  }  if  (  deser  =  =  null  )  {  if  (  type  .  isEnumType  (  )  )  {  [BUGGY]  return  _createEnumKeyDeserializer  (  ctxt  ,  type  )  ;  }  deser  =  StdKeyDeserializers  .  findStringBasedKeyDeserializer  (  config  ,  type  )  ;  }  if  (  deser  !  =  null  )  {  	JacksonDatabind_67_BasicDeserializerFactory_1_1	1403	2	src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
1339	final  JsonDeserializer<Object>  delegateDeser  =  _delegateDeserializer();  if  (delegateDeser  !=  null)  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromObjectUsingNonDefault  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  protected  Object  deserializeFromObjectUsingNonDefault  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  [BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  return  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  }  if  (  _propertyBasedCreator  !  =  null  )  {  return  _deserializeUsingPropertyBased  (  p  ,  ctxt  )  ;  }  if  (  _beanType  .  isAbstract  (  )  )  {  return  ctxt  .  handleMissingInstantiator  (  handledType  (  )  ,  p  ,   "abstract  type  (  need  to  add/enable  type  information?  )   "  )  ;  }  return  ctxt  .  handleMissingInstantiator  (  _beanType  .  getRawClass  (  )  ,  p  ,   "no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )   "  )  ;  }  	JacksonDatabind_68_BeanDeserializerBase_11_1	1192	2	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1340	final  JsonDeserializer<Object>  delegateDeser  =  _delegateDeserializer();  if  (delegateDeser  !=  null)  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromNumber  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeFromNumber  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  _objectIdReader  !  =  null  )  {  return  deserializeFromObjectId  (  p  ,  ctxt  )  ;  }  [BUGGY]  switch  (  p  .  getNumberType  (  )  )  {  case  INT:  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromInt  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  	JacksonDatabind_68_BeanDeserializerBase_11_2	1220	2	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1341	if  (delegateDeser  !=  null)  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromNumber  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeFromNumber  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  _objectIdReader  !  =  null  )  {  return  deserializeFromObjectId  (  p  ,  ctxt  )  ;  }  switch  (  p  .  getNumberType  (  )  )  {  case  INT:  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromInt  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  }  return  _valueInstantiator  .  createFromInt  (  ctxt  ,  p  .  getIntValue  (  )  )  ;  case  LONG:  [BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromInt  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  	JacksonDatabind_68_BeanDeserializerBase_11_3	1234	2	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1342	if  (delegateDeser  !=  null)  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromNumber  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromInt  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  }  return  _valueInstantiator  .  createFromInt  (  ctxt  ,  p  .  getIntValue  (  )  )  ;  case  LONG:  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromInt  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  }  return  _valueInstantiator  .  createFromLong  (  ctxt  ,  p  .  getLongValue  (  )  )  ;  }  [BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  	JacksonDatabind_68_BeanDeserializerBase_11_4	1247	2	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1343	JsonDeserializer<Object>  delegateDeser  =  _delegateDeserializer();  if  (delegateDeser  !=  null)  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromString  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeFromString  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  _objectIdReader  !  =  null  )  {  return  deserializeFromObjectId  (  p  ,  ctxt  )  ;  }    [BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromString  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  }  return  _valueInstantiator  .  createFromString  (  ctxt  ,  p  .  getText  (  )  )  ;  }  	JacksonDatabind_68_BeanDeserializerBase_11_5	1269	2	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1344	JsonDeserializer<Object>  delegateDeser  =  _delegateDeserializer();  if  (delegateDeser  !=  null)  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromDouble  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  NumberType  t  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeFromDouble  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  NumberType  t  =  p  .  getNumberType  (  )  ;  if  (  (  t  =  =  NumberType  .  DOUBLE  )  ||  (  t  =  =  NumberType  .  FLOAT  )  )  {  [BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromDouble  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  }  return  _valueInstantiator  .  createFromDouble  (  ctxt  ,  p  .  getDoubleValue  (  )  )  ;  }  if  (  _delegateDeserializer  !  =  null  )  {  return  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  }  return  ctxt  .  handleMissingInstantiator  (  handledType  (  )  ,  p  ,   "no  suitable  creator  method  found  to  deserialize  from  Number  value  (  %s  )   "  ,  p  .  getNumberValue  (  )  )  ;  }  	JacksonDatabind_68_BeanDeserializerBase_11_6	1291	2	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1345	JsonDeserializer<Object>  delegateDeser  =  _delegateDeserializer();  if  (delegateDeser  !=  null)  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromDouble  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  NumberType  t  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeFromDouble  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  NumberType  t  =  p  .  getNumberType  (  )  ;  if  (  (  t  =  =  NumberType  .  DOUBLE  )  ||  (  t  =  =  NumberType  .  FLOAT  )  )  {  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromDouble  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  }  return  _valueInstantiator  .  createFromDouble  (  ctxt  ,  p  .  getDoubleValue  (  )  )  ;  }  [BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  return  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  }  return  ctxt  .  handleMissingInstantiator  (  handledType  (  )  ,  p  ,   "no  suitable  creator  method  found  to  deserialize  from  Number  value  (  %s  )   "  ,  p  .  getNumberValue  (  )  )  ;  }  	JacksonDatabind_68_BeanDeserializerBase_11_7	1304	2	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1346	JsonDeserializer<Object>  delegateDeser  =  _delegateDeserializer();  if  (delegateDeser  !=  null)  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromBoolean  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  value  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeFromBoolean  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  [BUGGY]  if  (  _delegateDeserializer  !  =  null  )  {  if  (  !_valueInstantiator  .  canCreateFromBoolean  (  )  )  {  Object  bean  =  _valueInstantiator  .  createUsingDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  }  boolean  value  =  (  p  .  getCurrentToken  (  )  =  =  JsonToken  .  VALUE_TRUE  )  ;  return  _valueInstantiator  .  createFromBoolean  (  ctxt  ,  value  )  ;  }  	JacksonDatabind_68_BeanDeserializerBase_11_8	1318	2	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1347	JsonDeserializer<Object>  delegateDeser  =  _arrayDelegateDeserializer;  if  ((delegateDeser  !=  null)  ||  ((delegateDeser  =  _delegateDeserializer)  !=  null))  {  delegateDeser.deserialize(p,  ctxt));  	[BUGGY]  if  (  _arrayDelegateDeserializer  !  =  null  )  {  try  {  Object  bean  =  _valueInstantiator  .  createUsingArrayDelegate  (  ctxt  ,  _arrayDelegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  catch  (  Exception  e  )  {  return  wrapInstantiationProblem  (  e  ,  ctxt  )  ;  }  }  if  (  _delegateDeserializer  !  =  null  )  {  try  {  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromArray  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  e  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  value  [TYPE]  JsonToken  t  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeFromArray  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  [BUGGY]  if  (  _arrayDelegateDeserializer  !  =  null  )  {  try  {  Object  bean  =  _valueInstantiator  .  createUsingArrayDelegate  (  ctxt  ,  _arrayDelegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  	JacksonDatabind_68_BeanDeserializerBase_11_9	1335	14	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1348		[BUGGY]  }  catch  (  Exception  e  )  {  wrapInstantiationProblem  (  e  ,  ctxt  )  ;  return  null  ;  }  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )  [METHOD]  deserializeFromArray  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializerBase  [TYPE]  PropertyName  TEMP_PROPERTY_NAME  [TYPE]  UnwrappedPropertyHandler  _unwrappedPropertyHandler  [TYPE]  Shape  _serializationShape  [TYPE]  Set  _ignorableProps  [TYPE]  ValueInjector[]  _injectables  [TYPE]  HashMap  _subDeserializers  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  ObjectIdReader  _objectIdReader  [TYPE]  JsonDeserializer  _arrayDelegateDeserializer  _delegateDeserializer  [TYPE]  PropertyBasedCreator  _propertyBasedCreator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  e  [TYPE]  SettableAnyProperty  _anySetter  [TYPE]  JavaType  _beanType  [TYPE]  Annotations  _classAnnotations  [TYPE]  boolean  _ignoreAllUnknown  _needViewProcesing  _nonStandardCreation  _vanillaProcessing  false  true  [TYPE]  BeanPropertyMap  _beanProperties  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  bean  value  [TYPE]  JsonToken  t  [TYPE]  Map  _backRefs  [TYPE]  ExternalTypeHandler  _externalTypeIdHandler  [TYPE]  JsonParser  p  [CONTEXT]  public  Object  deserializeFromArray  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  _arrayDelegateDeserializer  !  =  null  )  {  try  {  Object  bean  =  _valueInstantiator  .  createUsingArrayDelegate  (  ctxt  ,  _arrayDelegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  }  catch  (  Exception  e  )  {  return  wrapInstantiationProblem  (  e  ,  ctxt  )  ;  }  }  if  (  _delegateDeserializer  !  =  null  )  {  try  {  Object  bean  =  _valueInstantiator  .  createUsingArrayDelegate  (  ctxt  ,  _delegateDeserializer  .  deserialize  (  p  ,  ctxt  )  )  ;  if  (  _injectables  !  =  null  )  {  injectValues  (  ctxt  ,  bean  )  ;  }  return  bean  ;  [BUGGY]  }  catch  (  Exception  e  )  {  wrapInstantiationProblem  (  e  ,  ctxt  )  ;  return  null  ;  }  }  if  (  ctxt  .  isEnabled  (  DeserializationFeature  .  UNWRAP_SINGLE_VALUE_ARRAYS  )  )  {  	JacksonDatabind_68_BeanDeserializerBase_11_10	1355	4	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1349	private  final  JsonDeserializer<Object>  _delegateDeserializer()  {  JsonDeserializer<Object>  deser  =  _delegateDeserializer;  if  (deser  ==  null)  {  deser  =  _arrayDelegateDeserializer;  }  return  deser;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindstructSingleValueAsArrayTest$Messages:  no  suitable  constructor  found  ,  can  not  deserialize  from  Object  value  (  missing  default  constructor  or  creator  ,  or  perhaps  need  to  add/enable  type  information?  )    [CLASS]  [CONTEXT]  	JacksonDatabind_68_BeanDeserializerBase_11_11	1399	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java
1350	if  (verifyNonDup(creator,  C_ARRAY_DELEGATE,  explicit))  {  }  if  (verifyNonDup(creator,  C_DELEGATE,  explicit))  {  }  	[BUGGY]  verifyNonDup  (  creator  ,  C_ARRAY_DELEGATE  ,  explicit  )  ;  verifyNonDup  (  creator  ,  C_DELEGATE  ,  explicit  )  ;  [FE]  jacksondatabindJsonMappingException:  Could  not  find  creator  property  with  name  'intField'  (  in  class  comfasterxmljacksondatabindcreatorsCreator1476Test$SimplePojo  )  assertEquals  (   "foo "  ,  pojo  .  getStringField  (  )  )  ;  [METHOD]  addDelegatingCreator  [TYPE]  void  [PARAMETER]  AnnotatedWithParams  creator  boolean  explicit  SettableBeanProperty[]  injectables  [CLASS]  CreatorCollector  [TYPE]  AnnotatedWithParams  creator  [TYPE]  boolean  _canFixAccess  _forceAccess  _hasNonDefaultCreator  explicit  false  true  [TYPE]  AnnotatedParameter  _incompleteParameter  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotatedWithParams[]  _creators  [TYPE]  SettableBeanProperty[]  _arrayDelegateArgs  _delegateArgs  _propertyBasedArgs  injectables  [TYPE]  String[]  TYPE_DESCS  [TYPE]  int  C_ARRAY_DELEGATE  C_BOOLEAN  C_DEFAULT  C_DELEGATE  C_DOUBLE  C_INT  C_LONG  C_PROPS  C_STRING  TYPE_COLLECTION  TYPE_HASH_MAP  TYPE_MAP  _explicitCreators  _type  [TYPE]  long  serialVersionUID  [CONTEXT]  public  void  addDelegatingCreator  (  AnnotatedWithParams  creator  ,  boolean  explicit  ,  SettableBeanProperty[]  injectables  )  {  if  (  creator  .  getParameterType  (  0  )  .  isCollectionLikeType  (  )  )  {  [BUGGY]  verifyNonDup  (  creator  ,  C_ARRAY_DELEGATE  ,  explicit  )  ;  _arrayDelegateArgs  =  injectables  ;  }  else  {  verifyNonDup  (  creator  ,  C_DELEGATE  ,  explicit  )  ;  _delegateArgs  =  injectables  ;  }  }  	JacksonDatabind_69_CreatorCollector_7_1	165	2	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1351	if  (verifyNonDup(creator,  C_PROPS,  explicit))  {  	[BUGGY]  verifyNonDup  (  creator  ,  C_PROPS  ,  explicit  )  ;  [FE]  jacksondatabindJsonMappingException:  Could  not  find  creator  property  with  name  'intField'  (  in  class  comfasterxmljacksondatabindcreatorsCreator1476Test$SimplePojo  )  assertEquals  (   "foo "  ,  pojo  .  getStringField  (  )  )  ;  [METHOD]  addPropertyCreator  [TYPE]  void  [PARAMETER]  AnnotatedWithParams  creator  boolean  explicit  SettableBeanProperty[]  properties  [CLASS]  CreatorCollector  [TYPE]  Integer  old  [TYPE]  AnnotatedWithParams  creator  [TYPE]  boolean  _canFixAccess  _forceAccess  _hasNonDefaultCreator  explicit  false  true  [TYPE]  HashMap  names  [TYPE]  AnnotatedParameter  _incompleteParameter  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotatedWithParams[]  _creators  [TYPE]  SettableBeanProperty[]  _arrayDelegateArgs  _delegateArgs  _propertyBasedArgs  properties  [TYPE]  String[]  TYPE_DESCS  [TYPE]  String  name  [TYPE]  int  C_ARRAY_DELEGATE  C_BOOLEAN  C_DEFAULT  C_DELEGATE  C_DOUBLE  C_INT  C_LONG  C_PROPS  C_STRING  TYPE_COLLECTION  TYPE_HASH_MAP  TYPE_MAP  _explicitCreators  _type  i  len  [TYPE]  long  serialVersionUID  [CONTEXT]  public  void  addPropertyCreator  (  AnnotatedWithParams  creator  ,  boolean  explicit  ,  SettableBeanProperty[]  properties  )  {  [BUGGY]  verifyNonDup  (  creator  ,  C_PROPS  ,  explicit  )  ;  if  (  properties  .  length  >  1  )  {  HashMap<String  ,  Integer>  names  =  new  HashMap<String  ,  Integer>  (  )  ;  for  (  int  i  =  0  ,  len  =  properties  .  length  ;  i  <  len  ;  ++i  )  {  String  name  =  properties[i]  .  getName  (  )  ;    if  (  name  .  length  (  )  =  =  0  &&  properties[i]  .  getInjectableValueId  (  )  !  =  null  )  {  continue  ;  }  Integer  old  =  names  .  put  (  name  ,  Integer  .  valueOf  (  i  )  )  ;  if  (  old  !  =  null  )  {  throw  new  IllegalArgumentException  (   "Duplicate  creator  property  \ " "+name+ "\ "  (  index   "+old+ "  vs   "+i+ "  )   "  )  ;  }  }  }  _propertyBasedArgs  =  properties  ;  }  	JacksonDatabind_69_CreatorCollector_7_2	176	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1352	}  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Could  not  find  creator  property  with  name  'intField'  (  in  class  comfasterxmljacksondatabindcreatorsCreator1476Test$SimplePojo  )  assertEquals  (   "foo "  ,  pojo  .  getStringField  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_69_CreatorCollector_7_3	195	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1353	protected  boolean  verifyNonDup(AnnotatedWithParams  newOne,  int  typeIndex,  boolean  explicit)  	[BUGGY]  protected  void  verifyNonDup  (  AnnotatedWithParams  newOne  ,  int  typeIndex  ,  boolean  explicit  )  [FE]  jacksondatabindJsonMappingException:  Could  not  find  creator  property  with  name  'intField'  (  in  class  comfasterxmljacksondatabindcreatorsCreator1476Test$SimplePojo  )  assertEquals  (   "foo "  ,  pojo  .  getStringField  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_69_CreatorCollector_7_4	299	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1354	return  false;  	[BUGGY]  return  ;  [FE]  jacksondatabindJsonMappingException:  Could  not  find  creator  property  with  name  'intField'  (  in  class  comfasterxmljacksondatabindcreatorsCreator1476Test$SimplePojo  )  assertEquals  (   "foo "  ,  pojo  .  getStringField  (  )  )  ;  [METHOD]  verifyNonDup  [TYPE]  void  [PARAMETER]  AnnotatedWithParams  newOne  int  typeIndex  boolean  explicit  [CLASS]  CreatorCollector  [TYPE]  AnnotatedWithParams  newOne  oldOne  [TYPE]  boolean  _canFixAccess  _forceAccess  _hasNonDefaultCreator  explicit  false  true  verify  [TYPE]  AnnotatedParameter  _incompleteParameter  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotatedWithParams[]  _creators  [TYPE]  SettableBeanProperty[]  _arrayDelegateArgs  _delegateArgs  _propertyBasedArgs  [TYPE]  Class  newType  oldType  [TYPE]  String[]  TYPE_DESCS  [TYPE]  int  C_ARRAY_DELEGATE  C_BOOLEAN  C_DEFAULT  C_DELEGATE  C_DOUBLE  C_INT  C_LONG  C_PROPS  C_STRING  TYPE_COLLECTION  TYPE_HASH_MAP  TYPE_MAP  _explicitCreators  _type  mask  typeIndex  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  void  verifyNonDup  (  AnnotatedWithParams  newOne  ,  int  typeIndex  ,  boolean  explicit  )  {  final  int  mask  =  (  1  <<  typeIndex  )  ;  _hasNonDefaultCreator  =  true  ;  AnnotatedWithParams  oldOne  =  _creators[typeIndex]  ;  if  (  oldOne  !  =  null  )  {  boolean  verify  ;  if  (  (  _explicitCreators  &  mask  )  !  =  0  )  {  //  already  had  explicitly  annotated  ,  leave  as-is  if  (  !explicit  )  {  [BUGGY]  return  ;  }  verify  =  true  ;  }  else  {  	JacksonDatabind_69_CreatorCollector_7_5	310	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1355	return  false;  	[BUGGY]  return  ;  [FE]  jacksondatabindJsonMappingException:  Could  not  find  creator  property  with  name  'intField'  (  in  class  comfasterxmljacksondatabindcreatorsCreator1476Test$SimplePojo  )  assertEquals  (   "foo "  ,  pojo  .  getStringField  (  )  )  ;  [METHOD]  verifyNonDup  [TYPE]  void  [PARAMETER]  AnnotatedWithParams  newOne  int  typeIndex  boolean  explicit  [CLASS]  CreatorCollector  [TYPE]  AnnotatedWithParams  newOne  oldOne  [TYPE]  boolean  _canFixAccess  _forceAccess  _hasNonDefaultCreator  explicit  false  true  verify  [TYPE]  AnnotatedParameter  _incompleteParameter  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotatedWithParams[]  _creators  [TYPE]  SettableBeanProperty[]  _arrayDelegateArgs  _delegateArgs  _propertyBasedArgs  [TYPE]  Class  newType  oldType  [TYPE]  String[]  TYPE_DESCS  [TYPE]  int  C_ARRAY_DELEGATE  C_BOOLEAN  C_DEFAULT  C_DELEGATE  C_DOUBLE  C_INT  C_LONG  C_PROPS  C_STRING  TYPE_COLLECTION  TYPE_HASH_MAP  TYPE_MAP  _explicitCreators  _type  mask  typeIndex  [TYPE]  long  serialVersionUID  [CONTEXT]  if  (  (  _explicitCreators  &  mask  )  !  =  0  )  {  //  already  had  explicitly  annotated  ,  leave  as-is  if  (  !explicit  )  {  return  ;  }  verify  =  true  ;  }  else  {  verify  =  !explicit  ;  }  if  (  verify  &&  (  oldOne  .  getClass  (  )  =  =  newOne  .  getClass  (  )  )  )  {  Class<?>  oldType  =  oldOne  .  getRawParameterType  (  0  )  ;  Class<?>  newType  =  newOne  .  getRawParameterType  (  0  )  ;  if  (  oldType  =  =  newType  )  {  throw  new  IllegalArgumentException  (   "Conflicting   "+TYPE_DESCS[typeIndex]  + "  creators:  already  had  explicitly  marked   "+oldOne+ "  ,  encountered   "+newOne  )  ;  }  if  (  newType  .  isAssignableFrom  (  oldType  )  )  {  [BUGGY]  return  ;  }  }  }  if  (  explicit  )  {  	JacksonDatabind_69_CreatorCollector_7_6	332	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1356	return  true;  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Could  not  find  creator  property  with  name  'intField'  (  in  class  comfasterxmljacksondatabindcreatorsCreator1476Test$SimplePojo  )  assertEquals  (   "foo "  ,  pojo  .  getStringField  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_69_CreatorCollector_7_7	341	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java
1357	found  =  key.equals(_hashArea[i-1]);  	[BUGGY]  found  =  key  .  equals  (  prop  .  getName  (  )  )  ;  [FE]  NoSuchElementException:  No  entry  'businessAddress'  found  ,  can't  remove  assertNotNull  (  p  )  ;  [METHOD]  remove  [TYPE]  void  [PARAMETER]  SettableBeanProperty  propToRm  [CLASS]  BeanPropertyMap  [TYPE]  boolean  _caseInsensitive  false  found  true  [TYPE]  SettableBeanProperty  prop  propToRm  [TYPE]  ArrayList  props  [TYPE]  SettableBeanProperty[]  _propsInOrder  [TYPE]  String  key  [TYPE]  long  serialVersionUID  [TYPE]  int  _hashMask  _size  _spillCount  end  i  [TYPE]  Object[]  _hashArea  [CONTEXT]  public  void  remove  (  SettableBeanProperty  propToRm  )  {  ArrayList<SettableBeanProperty>  props  =  new  ArrayList<SettableBeanProperty>  (  _size  )  ;  String  key  =  getPropertyName  (  propToRm  )  ;  boolean  found  =  false  ;  for  (  int  i  =  1  ,  end  =  _hashArea  .  length  ;  i  <  end  ;  i  +  =  2  )  {  SettableBeanProperty  prop  =  (  SettableBeanProperty  )  _hashArea[i]  ;  if  (  prop  =  =  null  )  {  continue  ;  }  if  (  !found  )  {    [BUGGY]  found  =  key  .  equals  (  prop  .  getName  (  )  )  ;  if  (  found  )  {  _propsInOrder[_findFromOrdered  (  prop  )  ]  =  null  ;  continue  ;  }  }  props  .  add  (  prop  )  ;  }  if  (  !found  )  {  throw  new  NoSuchElementException  (   "No  entry  ' "+propToRm  .  getName  (  )  + "'  found  ,  can't  remove "  )  ;  }  init  (  props  )  ;  }  	JacksonDatabind_70_BeanPropertyMap_1_1	440	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java
1358	if  (raw  ==  String.class  ||  raw  ==  Object.class  ||  raw  ==  CharSequence.class)  {  	[BUGGY]  if  (  raw  =  =  String  .  class  ||  raw  =  =  Object  .  class  )  {  [FE]  jacksondatabindJsonMappingException:  Can  not  find  a  (  Map  )  Key  deserializer  for  type  [simple  type  ,  class  javalangCharSequence]  assertEquals  (   "b "  ,  result  .  get  (   "a "  )  )  ;  [METHOD]  forType  [TYPE]  StdKeyDeserializer  [PARAMETER]  Class<?>  raw  [CLASS]  StdKeyDeserializer  [TYPE]  StringKD  sObject  sString  [TYPE]  boolean  false  true  [TYPE]  AnnotatedMethod  _factory  [TYPE]  FromStringDeserializer  _deser  deser  [TYPE]  Constructor  _ctor  [TYPE]  Class  _keyClass  raw  [TYPE]  EnumResolver  _byNameResolver  _byToStringResolver  [TYPE]  Method  _factoryMethod  [TYPE]  JsonDeserializer  _delegate  [TYPE]  long  serialVersionUID  [TYPE]  int  TYPE_BOOLEAN  TYPE_BYTE  TYPE_CALENDAR  TYPE_CHAR  TYPE_CLASS  TYPE_CURRENCY  TYPE_DATE  TYPE_DOUBLE  TYPE_FLOAT  TYPE_INT  TYPE_LOCALE  TYPE_LONG  TYPE_SHORT  TYPE_URI  TYPE_URL  TYPE_UUID  _kind  kind  [CONTEXT]  public  static  StdKeyDeserializer  forType  (  Class<?>  raw  )  {  int  kind  ;    [BUGGY]  if  (  raw  =  =  String  .  class  ||  raw  =  =  Object  .  class  )  {  return  StringKD  .  forType  (  raw  )  ;  }  else  if  (  raw  =  =  UUID  .  class  )  {  kind  =  TYPE_UUID  ;  }  else  if  (  raw  =  =  Integer  .  class  )  {  kind  =  TYPE_INT  ;  	JacksonDatabind_71_StdKeyDeserializer_1_1	75	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java
1359	@Override  public  int  getCreatorIndex()  {  return  _delegate.getCreatorIndex();  }  	[BUGGY]  [FE]  IllegalStateException:  Internal  error:  no  creator  index  for  property  'a'  (  of  type  comfasterxmljacksondatabinddeserimplInnerClassProperty  )    [CLASS]  [CONTEXT]  	JacksonDatabind_72_InnerClassProperty_2_1	93	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java
1360	}  	[BUGGY]  }  [FE]  IllegalStateException:  Internal  error:  no  creator  index  for  property  'a'  (  of  type  comfasterxmljacksondatabinddeserimplInnerClassProperty  )    [CLASS]  [CONTEXT]  	JacksonDatabind_72_InnerClassProperty_2_2	167	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java
1361		[BUGGY]  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "x "  (  class  comfasterxmljacksondatabinddeserReadOrWriteOnlyTest$ReadXWriteY  )  ,  not  marked  as  ignorable  (  one  known  property:   "y "]  )  assertEquals  (  6  ,  result  .  y  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_73_POJOPropertiesCollector_2_1	7	0	src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
1362	Access  acc  =  prop.removeNonVisible(inferMutators);  if  (!_forSerialization  &&  (acc  ==  Access.READ_ONLY))  {  _collectIgnorals(prop.getName());  }  	[BUGGY]  prop  .  removeNonVisible  (  inferMutators  )  ;  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "x "  (  class  comfasterxmljacksondatabinddeserReadOrWriteOnlyTest$ReadXWriteY  )  ,  not  marked  as  ignorable  (  one  known  property:   "y "]  )  assertEquals  (  6  ,  result  .  y  )  ;  [METHOD]  _removeUnwantedAccessor  [TYPE]  void  [PARAMETER]  POJOPropertyBuilder>  props  [CLASS]  POJOPropertiesCollector  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  MapperConfig  _config  [TYPE]  String  _mutatorPrefix  [TYPE]  LinkedList  _anyGetters  _anySetterField  _anySetters  _creatorProperties  _jsonValueGetters  [TYPE]  LinkedHashMap  _injectables  _properties  [TYPE]  JavaType  _type  [TYPE]  boolean  _collected  _forSerialization  _stdBeanNaming  false  inferMutators  true  [TYPE]  AnnotatedClass  _classDef  [TYPE]  VisibilityChecker  _visibilityChecker  [TYPE]  Iterator  it  [TYPE]  POJOPropertyBuilder  prop  [TYPE]  Map  props  [TYPE]  HashSet  _ignoredPropertyNames  [CONTEXT]  protected  void  _removeUnwantedAccessor  (  Map<String  ,  POJOPropertyBuilder>  props  )  {  final  boolean  inferMutators  =  _config  .  isEnabled  (  MapperFeature  .  INFER_PROPERTY_MUTATORS  )  ;  Iterator<POJOPropertyBuilder>  it  =  props  .  values  (  )  .  iterator  (  )  ;  while  (  it  .  hasNext  (  )  )  {  POJOPropertyBuilder  prop  =  it  .  next  (  )  ;  [BUGGY]  prop  .  removeNonVisible  (  inferMutators  )  ;  }  }  	JacksonDatabind_73_POJOPropertiesCollector_2_2	731	1	src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java
1363	public  JsonProperty.Access  removeNonVisible(boolean  inferMutators)  	[BUGGY]  public  void  removeNonVisible  (  boolean  inferMutators  )  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "x "  (  class  comfasterxmljacksondatabinddeserReadOrWriteOnlyTest$ReadXWriteY  )  ,  not  marked  as  ignorable  (  one  known  property:   "y "]  )  assertEquals  (  6  ,  result  .  y  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_73_POJOPropertyBuilder_2_1	644	1	src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
1364	return  acc;  	[BUGGY]  [FE]  jacksondatabindexcUnrecognizedPropertyException:  Unrecognized  field   "x "  (  class  comfasterxmljacksondatabinddeserReadOrWriteOnlyTest$ReadXWriteY  )  ,  not  marked  as  ignorable  (  one  known  property:   "y "]  )  assertEquals  (  6  ,  result  .  y  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_73_POJOPropertyBuilder_2_2	683	0	src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java
1365	}  else  if  (p.getCurrentToken()  ==  JsonToken.VALUE_STRING)  {  if  (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT))  {  String  str  =  p.getText().trim();  if  (str.isEmpty())  {  return  null;  }  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Unexpected  token  (  VALUE_STRING  )  ,  expected  FIELD_NAME:  missing  property  'type'  that  is  to  contain  type  id  (  for  class  comfasterxmljacksondatabindjsontypeTestPolymorphicWithDefaultImpl$AsProperty  )  assertNull  (  wrapper  .  value  )  ;  [METHOD]  _deserializeTypedUsingDefaultImpl  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  TokenBuffer  tb  [CLASS]  AsPropertyTypeDeserializer  [TYPE]  As  _inclusion  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  tb  [TYPE]  DeserializationContext  ctxt  [TYPE]  Object  result  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  JsonParser  p  [CONTEXT]  protected  Object  _deserializeTypedUsingDefaultImpl  (  JsonParser  p  ,  DeserializationContext  ctxt  ,  TokenBuffer  tb  )  throws  IOException  {  JsonDeserializer<Object>  deser  =  _findDefaultImplDeserializer  (  ctxt  )  ;  if  (  deser  !  =  null  )  {  if  (  tb  !  =  null  )  {  tb  .  writeEndObject  (  )  ;  p  =  tb  .  asParser  (  p  )  ;  p  .  nextToken  (  )  ;  }  return  deser  .  deserialize  (  p  ,  ctxt  )  ;  }  Object  result  =  TypeDeserializer  .  deserializeIfNatural  (  p  ,  ctxt  ,  _baseType  )  ;  if  (  result  !  =  null  )  {  return  result  ;  }  if  (  p  .  getCurrentToken  (  )  =  =  JsonToken  .  START_ARRAY  )  {  return  super  .  deserializeTypedFromAny  (  p  ,  ctxt  )  ;  [BUGGY]  }  ctxt  .  reportWrongTokenException  (  p  ,  JsonToken  .  FIELD_NAME  ,   "missing  property  ' "+_typePropertyName+ "'  that  is  to  contain  type  id  (  for  class   "+baseTypeName  (  )  + "  )   "  )  ;  return  null  ;  }  	JacksonDatabind_74_AsPropertyTypeDeserializer_1_1	156	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java
1366	Boolean  serializeAsIndex  =  _isShapeWrittenUsingIndex(enumClass,  format,  true,  null);  	[BUGGY]  Boolean  serializeAsIndex  =  _isShapeWrittenUsingIndex  (  enumClass  ,  format  ,  true  )  ;  [FE]  ComparisonFailure:  expected:<{ "color ":[2]}>  but  was:<{ "color ":[ "GREEN "]}>  assertEquals  (  String  .  format  (  aposToQuotes  (   "{'color':%s} "  )  ,  Color  .  GREEN  .  ordinal  (  )  )  ,  [METHOD]  construct  [TYPE]  EnumSerializer  [PARAMETER]  Class<?>  enumClass  SerializationConfig  config  BeanDescription  beanDesc  Value  format  [CLASS]  EnumSerializer  [TYPE]  boolean  false  true  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  beanDesc  [TYPE]  Value  format  [TYPE]  Class  enumClass  [TYPE]  Boolean  _serializeAsIndex  serializeAsIndex  [TYPE]  EnumValues  _values  v  [TYPE]  long  serialVersionUID  [CONTEXT]  public  static  EnumSerializer  construct  (  Class<?>  enumClass  ,  SerializationConfig  config  ,  BeanDescription  beanDesc  ,  JsonFormat  .  Value  format  )  {      EnumValues  v  =  EnumValues  .  constructFromName  (  config  ,  (  Class<Enum<?>>  )  enumClass  )  ;  [BUGGY]  Boolean  serializeAsIndex  =  _isShapeWrittenUsingIndex  (  enumClass  ,  format  ,  true  )  ;  return  new  EnumSerializer  (  v  ,  serializeAsIndex  )  ;  }  	JacksonDatabind_75_EnumSerializer_5_1	86	1	src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java
1367	format,  false,  _serializeAsIndex);  	[BUGGY]  format  ,  false  )  ;  [FE]  ComparisonFailure:  expected:<{ "color ":[2]}>  but  was:<{ "color ":[ "GREEN "]}>  assertEquals  (  String  .  format  (  aposToQuotes  (   "{'color':%s} "  )  ,  Color  .  GREEN  .  ordinal  (  )  )  ,  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  serializers  BeanProperty  property  [CLASS]  EnumSerializer  [TYPE]  boolean  false  true  [TYPE]  Value  format  [TYPE]  Boolean  _serializeAsIndex  serializeAsIndex  [TYPE]  SerializerProvider  serializers  [TYPE]  EnumValues  _values  [TYPE]  long  serialVersionUID  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonSerializer<?>  createContextual  (  SerializerProvider  serializers  ,  BeanProperty  property  )  throws  JsonMappingException  {  if  (  property  !  =  null  )  {  JsonFormat  .  Value  format  =  findFormatOverrides  (  serializers  ,  property  ,  handledType  (  )  )  ;  if  (  format  !  =  null  )  {  Boolean  serializeAsIndex  =  _isShapeWrittenUsingIndex  (  property  .  getType  (  )  .  getRawClass  (  )  ,  [BUGGY]  format  ,  false  )  ;  if  (  serializeAsIndex  !  =  _serializeAsIndex  )  {  return  new  EnumSerializer  (  _values  ,  serializeAsIndex  )  ;  }  }  }  return  this  ;  }  	JacksonDatabind_75_EnumSerializer_5_2	104	1	src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java
1368	JsonFormat.Value  format,  boolean  fromClass,  Boolean  defaultValue)  	[BUGGY]  JsonFormat  .  Value  format  ,  boolean  fromClass  )  [FE]  ComparisonFailure:  expected:<{ "color ":[2]}>  but  was:<{ "color ":[ "GREEN "]}>  assertEquals  (  String  .  format  (  aposToQuotes  (   "{'color':%s} "  )  ,  Color  .  GREEN  .  ordinal  (  )  )  ,  [METHOD]  _isShapeWrittenUsingIndex  [TYPE]  Boolean  [PARAMETER]  Class<?>  enumClass  Value  format  boolean  fromClass  [CLASS]  EnumSerializer  [TYPE]  boolean  false  fromClass  true  [TYPE]  Shape  shape  [TYPE]  Value  format  [TYPE]  Class  enumClass  [TYPE]  Boolean  _serializeAsIndex  [TYPE]  EnumValues  _values  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  static  Boolean  _isShapeWrittenUsingIndex  (  Class<?>  enumClass  ,  [BUGGY]  JsonFormat  .  Value  format  ,  boolean  fromClass  )  {  JsonFormat  .  Shape  shape  =  (  format  =  =  null  )  ?  null  :  format  .  getShape  (  )  ;  if  (  shape  =  =  null  )  {  return  null  ;  }  if  (  shape  =  =  Shape  .  ANY  ||  shape  =  =  Shape  .  SCALAR  )  {  return  null  ;  }  if  (  shape  =  =  Shape  .  STRING  ||  shape  =  =  Shape  .  NATURAL  )  {  return  Boolean  .  FALSE  ;  }  if  (  shape  .  isNumeric  (  )  ||  (  shape  =  =  Shape  .  ARRAY  )  )  {  return  Boolean  .  TRUE  ;  }  throw  new  IllegalArgumentException  (  String  .  format  (   "Unsupported  serialization  shape  (  %s  )  for  Enum  %s  ,  not  supported  as  %s  annotation "  ,  shape  ,  enumClass  .  getName  (  )  ,  (  fromClass?   "class "  :   "property "  )  )  )  ;  }  	JacksonDatabind_75_EnumSerializer_5_3	217	1	src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java
1369	return  defaultValue;  	[BUGGY]  return  null  ;  [FE]  ComparisonFailure:  expected:<{ "color ":[2]}>  but  was:<{ "color ":[ "GREEN "]}>  assertEquals  (  String  .  format  (  aposToQuotes  (   "{'color':%s} "  )  ,  Color  .  GREEN  .  ordinal  (  )  )  ,  [METHOD]  _isShapeWrittenUsingIndex  [TYPE]  Boolean  [PARAMETER]  Class<?>  enumClass  Value  format  boolean  fromClass  [CLASS]  EnumSerializer  [TYPE]  boolean  false  fromClass  true  [TYPE]  Shape  shape  [TYPE]  Value  format  [TYPE]  Class  enumClass  [TYPE]  Boolean  _serializeAsIndex  [TYPE]  EnumValues  _values  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  static  Boolean  _isShapeWrittenUsingIndex  (  Class<?>  enumClass  ,  JsonFormat  .  Value  format  ,  boolean  fromClass  )  {  JsonFormat  .  Shape  shape  =  (  format  =  =  null  )  ?  null  :  format  .  getShape  (  )  ;  if  (  shape  =  =  null  )  {  [BUGGY]  return  null  ;  }  if  (  shape  =  =  Shape  .  ANY  ||  shape  =  =  Shape  .  SCALAR  )  {  return  null  ;  }  if  (  shape  =  =  Shape  .  STRING  ||  shape  =  =  Shape  .  NATURAL  )  {  return  Boolean  .  FALSE  ;  }  if  (  shape  .  isNumeric  (  )  ||  (  shape  =  =  Shape  .  ARRAY  )  )  {  return  Boolean  .  TRUE  ;  }  throw  new  IllegalArgumentException  (  String  .  format  (   "Unsupported  serialization  shape  (  %s  )  for  Enum  %s  ,  not  supported  as  %s  annotation "  ,  shape  ,  enumClass  .  getName  (  )  ,  (  fromClass?   "class "  :   "property "  )  )  )  ;  }  	JacksonDatabind_75_EnumSerializer_5_4	221	1	src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java
1370	return  defaultValue;  	[BUGGY]  return  null  ;  [FE]  ComparisonFailure:  expected:<{ "color ":[2]}>  but  was:<{ "color ":[ "GREEN "]}>  assertEquals  (  String  .  format  (  aposToQuotes  (   "{'color':%s} "  )  ,  Color  .  GREEN  .  ordinal  (  )  )  ,  [METHOD]  _isShapeWrittenUsingIndex  [TYPE]  Boolean  [PARAMETER]  Class<?>  enumClass  Value  format  boolean  fromClass  [CLASS]  EnumSerializer  [TYPE]  boolean  false  fromClass  true  [TYPE]  Shape  shape  [TYPE]  Value  format  [TYPE]  Class  enumClass  [TYPE]  Boolean  _serializeAsIndex  [TYPE]  EnumValues  _values  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  static  Boolean  _isShapeWrittenUsingIndex  (  Class<?>  enumClass  ,  JsonFormat  .  Value  format  ,  boolean  fromClass  )  {  JsonFormat  .  Shape  shape  =  (  format  =  =  null  )  ?  null  :  format  .  getShape  (  )  ;  if  (  shape  =  =  null  )  {  return  null  ;  }  if  (  shape  =  =  Shape  .  ANY  ||  shape  =  =  Shape  .  SCALAR  )  {  [BUGGY]  return  null  ;  }  if  (  shape  =  =  Shape  .  STRING  ||  shape  =  =  Shape  .  NATURAL  )  {  return  Boolean  .  FALSE  ;  }  if  (  shape  .  isNumeric  (  )  ||  (  shape  =  =  Shape  .  ARRAY  )  )  {  return  Boolean  .  TRUE  ;  }  throw  new  IllegalArgumentException  (  String  .  format  (   "Unsupported  serialization  shape  (  %s  )  for  Enum  %s  ,  not  supported  as  %s  annotation "  ,  shape  ,  enumClass  .  getName  (  )  ,  (  fromClass?   "class "  :   "property "  )  )  )  ;  }  	JacksonDatabind_75_EnumSerializer_5_5	225	1	src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java
1371	buffer.assignParameter(creatorProp,  creatorProp.deserialize(p,  ctxt));  	[BUGGY]  if  (  buffer  .  assignParameter  (  creatorProp  ,  creatorProp  .  deserialize  (  p  ,  ctxt  )  )  )  {  t  =  p  .  nextToken  (  )  ;  Object  bean  ;  try  {  bean  =  creator  .  build  (  ctxt  ,  buffer  )  ;  }  catch  (  Exception  e  )  {  wrapAndThrow  (  e  ,  _beanType  .  getRawClass  (  )  ,  propName  ,  ctxt  )  ;  continue  ;  }  while  (  t  =  =  JsonToken  .  FIELD_NAME  )  {  p  .  nextToken  (  )  ;  tokens  .  copyCurrentStructure  (  p  )  ;  t  =  p  .  nextToken  (  )  ;  }  tokens  .  writeEndObject  (  )  ;  if  (  bean  .  getClass  (  )  !  =  _beanType  .  getRawClass  (  )  )  {  ctxt  .  reportMappingException  (   "Can  not  create  polymorphic  instances  with  unwrapped  values "  )  ;  return  null  ;  }  return  _unwrappedPropertyHandler  .  processUnwrapped  (  p  ,  ctxt  ,  bean  ,  tokens  )  ;  }  [FE]  ComparisonFailure:  expected:<John>  but  was:<null>  assertEquals  (  true  ,  person  .  isAlive  (  )  )  ;  [METHOD]  deserializeUsingPropertyBasedWithUnwrapped  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BuilderBasedDeserializer  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  AnnotatedMethod  _buildMethod  [TYPE]  SettableBeanProperty  creatorProp  prop  [TYPE]  String  propName  [TYPE]  PropertyBasedCreator  creator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  e  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  tokens  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  Object  bean  [TYPE]  JsonParser  p  [CONTEXT]  protected  Object  deserializeUsingPropertyBasedWithUnwrapped  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  ,  JsonProcessingException  {  final  PropertyBasedCreator  creator  =  _propertyBasedCreator  ;  PropertyValueBuffer  buffer  =  creator  .  startBuilding  (  p  ,  ctxt  ,  _objectIdReader  )  ;  TokenBuffer  tokens  =  new  TokenBuffer  (  p  ,  ctxt  )  ;  tokens  .  writeStartObject  (  )  ;  JsonToken  t  =  p  .  getCurrentToken  (  )  ;  for  (  ;  t  =  =  JsonToken  .  FIELD_NAME  ;  t  =  p  .  nextToken  (  )  )  {  String  propName  =  p  .  getCurrentName  (  )  ;  p  .  nextToken  (  )  ;  //  to  point  to  value  SettableBeanProperty  creatorProp  =  creator  .  findCreatorProperty  (  propName  )  ;  if  (  creatorProp  !  =  null  )  {  [BUGGY]  if  (  buffer  .  assignParameter  (  creatorProp  ,  creatorProp  .  deserialize  (  p  ,  ctxt  )  )  )  {  t  =  p  .  nextToken  (  )  ;  Object  bean  ;  try  {  bean  =  creator  .  build  (  ctxt  ,  buffer  )  ;  }  catch  (  Exception  e  )  {  	JacksonDatabind_76_BuilderBasedDeserializer_1_1	583	21	src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java
1372	checkIllegalTypes(ctxt,  type,  beanDesc);  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "N/A  [METHOD]  createBeanDeserializer  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  JavaType  type  BeanDescription  beanDesc  [CLASS]  BeanDeserializerFactory  [TYPE]  JavaType  concreteType  type  [TYPE]  Class[]  INIT_CAUSE_PARAMS  NO_VIEWS  [TYPE]  boolean  false  true  [TYPE]  BeanDeserializerFactory  instance  [TYPE]  BeanDescription  beanDesc  [TYPE]  DeserializationContext  ctxt  [TYPE]  DeserializationConfig  config  [TYPE]  JsonDeserializer  custom  deser  [TYPE]  long  serialVersionUID  [CONTEXT]  if  (  type  .  isAbstract  (  )  &&  !type  .  isPrimitive  (  )  )  {  JavaType  concreteType  =  materializeAbstractType  (  ctxt  ,  type  ,  beanDesc  )  ;  if  (  concreteType  !  =  null  )  {    beanDesc  =  config  .  introspect  (  concreteType  )  ;  return  buildBeanDeserializer  (  ctxt  ,  concreteType  ,  beanDesc  )  ;  }  }  @SuppressWarnings  (   "unchecked "  )  JsonDeserializer<Object>  deser  =  (  JsonDeserializer<Object>  )  findStdDeserializer  (  ctxt  ,  type  ,  beanDesc  )  ;  if  (  deser  !  =  null  )  {  return  deser  ;  }  if  (  !isPotentialBeanType  (  type  .  getRawClass  (  )  )  )  {  return  null  ;  }  [BUGGY]  return  buildBeanDeserializer  (  ctxt  ,  type  ,  beanDesc  )  ;  }  @Override  public  JsonDeserializer<Object>  createBuilderBasedDeserializer  (  	JacksonDatabind_77_BeanDeserializerFactory_2_1	143	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1373	protected  void  checkIllegalTypes(DeserializationContext  ctxt,  JavaType  type,  BeanDescription  beanDesc)  throws  JsonMappingException  {  Class<?>  raw  =  type.getRawClass();  String  name  =  raw.getSimpleName();  if  ( "TemplatesImpl ".equals(name))  {    if  (raw.getName().startsWith( "com.sun.org.apache.xalan "))  {  throw  JsonMappingException.from(ctxt,  String.format( "Illegal  type  (%s)  to  deserialize:  prevented  for  security  reasons ",  name));  }  }  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "N/A  [CLASS]  [CONTEXT]  	JacksonDatabind_77_BeanDeserializerFactory_2_2	842	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1374	protected  final  static  Set<String>  DEFAULT_NO_DESER_CLASS_NAMES;  static  {  Set<String>  s  =  new  HashSet<>();  s.add( "org.apache.commons.collections.functors.InvokerTransformer ");  s.add( "org.apache.commons.collections.functors.InstantiateTransformer ");  s.add( "org.apache.commons.collections4.functors.InvokerTransformer ");  s.add( "org.apache.commons.collections4.functors.InstantiateTransformer ");  s.add( "org.codehaus.groovy.runtime.ConvertedClosure ");  s.add( "org.codehaus.groovy.runtime.MethodClosure ");  s.add( "org.springframework.beans.factory.ObjectFactory ");  s.add( "com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl ");  DEFAULT_NO_DESER_CLASS_NAMES  =  Collections.unmodifiableSet(s);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "N/A  [CLASS]  [CONTEXT]  	JacksonDatabind_78_BeanDeserializerFactory_4_1	48	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1375	protected  Set<String>  _cfgIllegalClassNames  =  DEFAULT_NO_DESER_CLASS_NAMES;  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "N/A  [CLASS]  [CONTEXT]  	JacksonDatabind_78_BeanDeserializerFactory_4_2	56	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1376	checkIllegalTypes(ctxt,  type,  beanDesc);  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "N/A  [METHOD]  createBeanDeserializer  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  JavaType  type  BeanDescription  beanDesc  [CLASS]  BeanDeserializerFactory  [TYPE]  JavaType  concreteType  type  [TYPE]  Class[]  INIT_CAUSE_PARAMS  NO_VIEWS  [TYPE]  boolean  false  true  [TYPE]  BeanDeserializerFactory  instance  [TYPE]  BeanDescription  beanDesc  [TYPE]  DeserializationContext  ctxt  [TYPE]  DeserializationConfig  config  [TYPE]  JsonDeserializer  custom  deser  [TYPE]  long  serialVersionUID  [CONTEXT]    if  (  type  .  isAbstract  (  )  &&  !type  .  isPrimitive  (  )  &&  !type  .  isEnumType  (  )  )  {  JavaType  concreteType  =  materializeAbstractType  (  ctxt  ,  type  ,  beanDesc  )  ;  if  (  concreteType  !  =  null  )  {    beanDesc  =  config  .  introspect  (  concreteType  )  ;  return  buildBeanDeserializer  (  ctxt  ,  concreteType  ,  beanDesc  )  ;  }  }  @SuppressWarnings  (   "unchecked "  )  JsonDeserializer<Object>  deser  =  (  JsonDeserializer<Object>  )  findStdDeserializer  (  ctxt  ,  type  ,  beanDesc  )  ;  if  (  deser  !  =  null  )  {  return  deser  ;  }  if  (  !isPotentialBeanType  (  type  .  getRawClass  (  )  )  )  {  return  null  ;  }  [BUGGY]  return  buildBeanDeserializer  (  ctxt  ,  type  ,  beanDesc  )  ;  }  @Override  public  JsonDeserializer<Object>  createBuilderBasedDeserializer  (  	JacksonDatabind_78_BeanDeserializerFactory_4_3	156	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1377	protected  void  checkIllegalTypes(DeserializationContext  ctxt,  JavaType  type,  BeanDescription  beanDesc)  throws  JsonMappingException  {  String  full  =  type.getRawClass().getName();  if  (_cfgIllegalClassNames.contains(full))  {  ctxt.reportBadTypeDefinition(beanDesc,   "Illegal  type  (%s)  to  deserialize:  prevented  for  security  reasons ",  full);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "N/A  [CLASS]  [CONTEXT]  	JacksonDatabind_78_BeanDeserializerFactory_4_4	878	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1378	if  (ref  ==  null)  {  return  objectIdInfo;  if  (objectIdInfo  ==  null)  {  objectIdInfo  =  ObjectIdInfo.empty();  }  return  objectIdInfo.withAlwaysAsId(ref.alwaysAsId());  	[BUGGY]  if  (  ref  !  =  null  )  {  objectIdInfo  =  objectIdInfo  .  withAlwaysAsId  (  ref  .  alwaysAsId  (  )  )  ;  return  objectIdInfo  ;  [FE]  ComparisonFailure:  expected:<{ "alwaysClass ":[1]  ,   "alwaysProp ":2}>  but  was:<{ "alwaysClass ":[{ "id ":1  ,   "value ":13}]  ,   "alwaysProp ":2}>  assertEquals  (  aposToQuotes  (   "{'alwaysClass':1  ,  'alwaysProp':2} "  )  ,  json  )  ;  [METHOD]  findObjectReferenceInfo  [TYPE]  ObjectIdInfo  [PARAMETER]  Annotated  ann  ObjectIdInfo  objectIdInfo  [CLASS]  JacksonAnnotationIntrospector  [TYPE]  Annotated  ann  [TYPE]  Class[]  ANNOTATIONS_TO_INFER_DESER  ANNOTATIONS_TO_INFER_SER  [TYPE]  boolean  _cfgConstructorPropertiesImpliesCreator  false  true  [TYPE]  LRUMap  _annotationsInside  [TYPE]  JsonIdentityReference  ref  [TYPE]  Class  _bogus  [TYPE]  ObjectIdInfo  objectIdInfo  [TYPE]  long  serialVersionUID  [TYPE]  Java7Support  _jdk7Helper  [CONTEXT]  public  ObjectIdInfo  findObjectReferenceInfo  (  Annotated  ann  ,  ObjectIdInfo  objectIdInfo  )  {  JsonIdentityReference  ref  =  _findAnnotation  (  ann  ,  JsonIdentityReference  .  class  )  ;  [BUGGY]  if  (  ref  !  =  null  )  {  objectIdInfo  =  objectIdInfo  .  withAlwaysAsId  (  ref  .  alwaysAsId  (  )  )  ;  }  return  objectIdInfo  ;  }  	JacksonDatabind_79_JacksonAnnotationIntrospector_1_1	579	3	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1379	private  final  static  ObjectIdInfo  EMPTY  =  new  ObjectIdInfo(PropertyName.NO_NAME,  Object.class,  null,  false,  null);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "alwaysClass ":[1]  ,   "alwaysProp ":2}>  but  was:<{ "alwaysClass ":[{ "id ":1  ,   "value ":13}]  ,   "alwaysProp ":2}>  assertEquals  (  aposToQuotes  (   "{'alwaysClass':1  ,  'alwaysProp':2} "  )  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_79_ObjectIdInfo_2_1	25	0	src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java
1380	public  static  ObjectIdInfo  empty()  {  return  EMPTY;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "alwaysClass ":[1]  ,   "alwaysProp ":2}>  but  was:<{ "alwaysClass ":[{ "id ":1  ,   "value ":13}]  ,   "alwaysProp ":2}>  assertEquals  (  aposToQuotes  (   "{'alwaysClass':1  ,  'alwaysProp':2} "  )  ,  json  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_79_ObjectIdInfo_2_2	63	0	src/main/java/com/fasterxml/jackson/databind/introspect/ObjectIdInfo.java
1381	objectIdInfo  =  intr.findObjectReferenceInfo(accessor,  null);  if  (objectIdInfo  !=  null)  {  }  	[BUGGY]  objectIdInfo  =  intr  .  findObjectReferenceInfo  (  accessor  ,  new  ObjectIdInfo  (  NAME_FOR_OBJECT_REF  ,  null  ,  null  ,  null  )  )  ;  [FE]  ComparisonFailure:  expected:<{ "alwaysClass ":[1]  ,   "alwaysProp ":2}>  but  was:<{ "alwaysClass ":[{ "id ":1  ,   "value ":13}]  ,   "alwaysProp ":2}>  assertEquals  (  aposToQuotes  (   "{'alwaysClass':1  ,  'alwaysProp':2} "  )  ,  json  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  provider  BeanProperty  property  [CLASS]  BeanSerializerBase  [TYPE]  PropertyName  NAME_FOR_OBJECT_REF  [TYPE]  ObjectIdGenerator  gen  [TYPE]  Shape  _serializationShape  shape  [TYPE]  BeanSerializerBase  contextual  [TYPE]  SerializationConfig  config  [TYPE]  BeanDescription  desc  [TYPE]  AnnotatedMember  _typeId  accessor  [TYPE]  AnnotationIntrospector  intr  [TYPE]  JsonSerializer  ser  [TYPE]  String[]  ignorals  [TYPE]  String  propName  [TYPE]  ObjectIdInfo  objectIdInfo  [TYPE]  BeanPropertyWriter[]  NO_PROPS  _filteredProps  _props  [TYPE]  AnyGetterWriter  _anyGetterWriter  [TYPE]  int  i  len  [TYPE]  BeanProperty  property  [TYPE]  JavaType  idType  type  [TYPE]  ObjectIdWriter  _objectIdWriter  oiw  [TYPE]  boolean  false  true  [TYPE]  Value  format  [TYPE]  Object  _propertyFilterId  filterId  newFilterId  [TYPE]  Class  implClass  [TYPE]  SerializerProvider  provider  [TYPE]  BeanPropertyWriter  fp  idProp  prop  [CONTEXT]  case  NUMBER:  case  NUMBER_INT:    BeanDescription  desc  =  config  .  introspectClassAnnotations  (  _handledType  )  ;  JsonSerializer<?>  ser  =  EnumSerializer  .  construct  (  _handledType  ,  provider  .  getConfig  (  )  ,  desc  ,  format  )  ;  return  provider  .  handlePrimaryContextualization  (  ser  ,  property  )  ;  }  }  }  }  }  ObjectIdWriter  oiw  =  _objectIdWriter  ;  String[]  ignorals  =  null  ;  Object  newFilterId  =  null  ;    if  (  accessor  !  =  null  )  {  ignorals  =  intr  .  findPropertiesToIgnore  (  accessor  ,  true  )  ;  ObjectIdInfo  objectIdInfo  =  intr  .  findObjectIdInfo  (  accessor  )  ;  if  (  objectIdInfo  =  =  null  )  {  if  (  oiw  !  =  null  )  {  [BUGGY]  objectIdInfo  =  intr  .  findObjectReferenceInfo  (  accessor  ,  new  ObjectIdInfo  (  NAME_FOR_OBJECT_REF  ,  null  ,  null  ,  null  )  )  ;  oiw  =  _objectIdWriter  .  withAlwaysAsId  (  objectIdInfo  .  getAlwaysAsId  (  )  )  ;  }  }  else  {  	JacksonDatabind_79_BeanSerializerBase_1_1	432	2	src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java
1382	if  (property  !=  null)  {  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  2  ,  subtypes  .  size  (  )  )  ;  [METHOD]  collectAndResolveSubtypesByClass  [TYPE]  Collection  [PARAMETER]  MapperConfig<?>  config  AnnotatedMember  property  JavaType  baseType  [CLASS]  StdSubtypeResolver  [TYPE]  LinkedHashSet  _registeredSubtypes  [TYPE]  JavaType  baseType  [TYPE]  boolean  false  true  [TYPE]  HashMap  collected  [TYPE]  AnnotatedClass  ac  curr  [TYPE]  NamedType  nt  rootType  subtype  [TYPE]  AnnotatedMember  property  [TYPE]  AnnotationIntrospector  ai  [TYPE]  MapperConfig  config  [TYPE]  Collection  st  [TYPE]  Class  rawBase  [TYPE]  long  serialVersionUID  [CONTEXT]  public  Collection<NamedType>  collectAndResolveSubtypesByClass  (  MapperConfig<?>  config  ,  AnnotatedMember  property  ,  JavaType  baseType  )  {  final  AnnotationIntrospector  ai  =  config  .  getAnnotationIntrospector  (  )  ;  Class<?>  rawBase  =  (  baseType  =  =  null  )  ?  property  .  getRawType  (  )  :  baseType  .  getRawClass  (  )  ;  HashMap<NamedType  ,  NamedType>  collected  =  new  HashMap<NamedType  ,  NamedType>  (  )  ;  if  (  _registeredSubtypes  !  =  null  )  {  for  (  NamedType  subtype  :  _registeredSubtypes  )  {  if  (  rawBase  .  isAssignableFrom  (  subtype  .  getType  (  )  )  )  {  //  yes  AnnotatedClass  curr  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  subtype  .  getType  (  )  )  ;  _collectAndResolve  (  curr  ,  subtype  ,  config  ,  ai  ,  collected  )  ;  }  }  }  [BUGGY]  Collection<NamedType>  st  =  ai  .  findSubtypes  (  property  )  ;  if  (  st  !  =  null  )  {  for  (  NamedType  nt  :  st  )  {  AnnotatedClass  ac  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  nt  .  getType  (  )  )  ;  _collectAndResolve  (  ac  ,  nt  ,  config  ,  ai  ,  collected  )  ;  	JacksonDatabind_80_StdSubtypeResolver_4_1	79	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java
1383	}  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  2  ,  subtypes  .  size  (  )  )  ;  [METHOD]  collectAndResolveSubtypesByClass  [TYPE]  Collection  [PARAMETER]  MapperConfig<?>  config  AnnotatedMember  property  JavaType  baseType  [CLASS]  StdSubtypeResolver  [TYPE]  LinkedHashSet  _registeredSubtypes  [TYPE]  JavaType  baseType  [TYPE]  boolean  false  true  [TYPE]  HashMap  collected  [TYPE]  AnnotatedClass  ac  curr  [TYPE]  NamedType  nt  rootType  subtype  [TYPE]  AnnotatedMember  property  [TYPE]  AnnotationIntrospector  ai  [TYPE]  MapperConfig  config  [TYPE]  Collection  st  [TYPE]  Class  rawBase  [TYPE]  long  serialVersionUID  [CONTEXT]  final  AnnotationIntrospector  ai  =  config  .  getAnnotationIntrospector  (  )  ;  Class<?>  rawBase  =  (  baseType  =  =  null  )  ?  property  .  getRawType  (  )  :  baseType  .  getRawClass  (  )  ;  HashMap<NamedType  ,  NamedType>  collected  =  new  HashMap<NamedType  ,  NamedType>  (  )  ;  if  (  _registeredSubtypes  !  =  null  )  {  for  (  NamedType  subtype  :  _registeredSubtypes  )  {  if  (  rawBase  .  isAssignableFrom  (  subtype  .  getType  (  )  )  )  {  //  yes  AnnotatedClass  curr  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  subtype  .  getType  (  )  )  ;  _collectAndResolve  (  curr  ,  subtype  ,  config  ,  ai  ,  collected  )  ;  }  }  }  Collection<NamedType>  st  =  ai  .  findSubtypes  (  property  )  ;  if  (  st  !  =  null  )  {  for  (  NamedType  nt  :  st  )  {  AnnotatedClass  ac  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  nt  .  getType  (  )  )  ;  _collectAndResolve  (  ac  ,  nt  ,  config  ,  ai  ,  collected  )  ;  }  [BUGGY]  }  NamedType  rootType  =  new  NamedType  (  rawBase  ,  null  )  ;  AnnotatedClass  ac  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  rawBase  )  ;    	JacksonDatabind_80_StdSubtypeResolver_4_2	86	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java
1384	if  (property  !=  null)  {  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  2  ,  subtypes  .  size  (  )  )  ;  [METHOD]  collectAndResolveSubtypesByTypeId  [TYPE]  Collection  [PARAMETER]  MapperConfig<?>  config  AnnotatedMember  property  JavaType  baseType  [CLASS]  StdSubtypeResolver  [TYPE]  LinkedHashSet  _registeredSubtypes  [TYPE]  Set  typesHandled  [TYPE]  NamedType  nt  rootType  subtype  [TYPE]  AnnotatedMember  property  [TYPE]  AnnotationIntrospector  ai  [TYPE]  MapperConfig  config  [TYPE]  long  serialVersionUID  [TYPE]  JavaType  baseType  [TYPE]  boolean  false  true  [TYPE]  AnnotatedClass  ac  curr  [TYPE]  Collection  st  [TYPE]  Class  rawBase  [TYPE]  Map  byName  [CONTEXT]  public  Collection<NamedType>  collectAndResolveSubtypesByTypeId  (  MapperConfig<?>  config  ,  AnnotatedMember  property  ,  JavaType  baseType  )  {  final  AnnotationIntrospector  ai  =  config  .  getAnnotationIntrospector  (  )  ;  Class<?>  rawBase  =  baseType  .  getRawClass  (  )  ;    Set<Class<?>>  typesHandled  =  new  HashSet<Class<?>>  (  )  ;  Map<String  ,  NamedType>  byName  =  new  LinkedHashMap<String  ,  NamedType>  (  )  ;    NamedType  rootType  =  new  NamedType  (  rawBase  ,  null  )  ;  AnnotatedClass  ac  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  rawBase  )  ;  _collectAndResolveByTypeId  (  ac  ,  rootType  ,  config  ,  typesHandled  ,  byName  )  ;    [BUGGY]  Collection<NamedType>  st  =  ai  .  findSubtypes  (  property  )  ;  if  (  st  !  =  null  )  {  for  (  NamedType  nt  :  st  )  {  ac  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  nt  .  getType  (  )  )  ;  _collectAndResolveByTypeId  (  ac  ,  nt  ,  config  ,  typesHandled  ,  byName  )  ;  }  	JacksonDatabind_80_StdSubtypeResolver_4_3	145	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java
1385	}  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  2  ,  subtypes  .  size  (  )  )  ;  [METHOD]  collectAndResolveSubtypesByTypeId  [TYPE]  Collection  [PARAMETER]  MapperConfig<?>  config  AnnotatedMember  property  JavaType  baseType  [CLASS]  StdSubtypeResolver  [TYPE]  LinkedHashSet  _registeredSubtypes  [TYPE]  Set  typesHandled  [TYPE]  NamedType  nt  rootType  subtype  [TYPE]  AnnotatedMember  property  [TYPE]  AnnotationIntrospector  ai  [TYPE]  MapperConfig  config  [TYPE]  long  serialVersionUID  [TYPE]  JavaType  baseType  [TYPE]  boolean  false  true  [TYPE]  AnnotatedClass  ac  curr  [TYPE]  Collection  st  [TYPE]  Class  rawBase  [TYPE]  Map  byName  [CONTEXT]  public  Collection<NamedType>  collectAndResolveSubtypesByTypeId  (  MapperConfig<?>  config  ,  AnnotatedMember  property  ,  JavaType  baseType  )  {  final  AnnotationIntrospector  ai  =  config  .  getAnnotationIntrospector  (  )  ;  Class<?>  rawBase  =  baseType  .  getRawClass  (  )  ;    Set<Class<?>>  typesHandled  =  new  HashSet<Class<?>>  (  )  ;  Map<String  ,  NamedType>  byName  =  new  LinkedHashMap<String  ,  NamedType>  (  )  ;    NamedType  rootType  =  new  NamedType  (  rawBase  ,  null  )  ;  AnnotatedClass  ac  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  rawBase  )  ;  _collectAndResolveByTypeId  (  ac  ,  rootType  ,  config  ,  typesHandled  ,  byName  )  ;    Collection<NamedType>  st  =  ai  .  findSubtypes  (  property  )  ;  if  (  st  !  =  null  )  {  for  (  NamedType  nt  :  st  )  {  ac  =  AnnotatedClassResolver  .  resolveWithoutSuperTypes  (  config  ,  nt  .  getType  (  )  )  ;  _collectAndResolveByTypeId  (  ac  ,  nt  ,  config  ,  typesHandled  ,  byName  )  ;  }  [BUGGY]  }  if  (  _registeredSubtypes  !  =  null  )  {  for  (  NamedType  subtype  :  _registeredSubtypes  )  {  if  (  rawBase  .  isAssignableFrom  (  subtype  .  getType  (  )  )  )  {  //  yes  	JacksonDatabind_80_StdSubtypeResolver_4_4	151	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java
1386	}  else  if  (_primitiveAndWrapper(currRaw,  serClass))  {  type  =  type.withStaticTyping();  	[BUGGY]  [FE]  jacksondatabindexcInvalidDefinitionException:  Invalid  definition  for  property   "i "  (  of  type  comfasterxmljacksondatabindintrospectTypeCoercion1592Test$Bean1592  )  :  Can  not  refine  serialization  type  [simple  type  ,  class  int]  into  javalangInteger  ;  types  not  related  assertNotNull  (  result  )  ;  [METHOD]  refineSerializationType  [TYPE]  JavaType  [PARAMETER]  MapperConfig<?>  config  Annotated  a  JavaType  baseType  [CLASS]  JacksonAnnotationIntrospector  [TYPE]  JsonSerialize  jsonSer  [TYPE]  Annotated  a  [TYPE]  JavaType  baseType  contentType  keyType  type  [TYPE]  Class[]  ANNOTATIONS_TO_INFER_DESER  ANNOTATIONS_TO_INFER_SER  [TYPE]  boolean  _cfgConstructorPropertiesImpliesCreator  false  true  [TYPE]  LRUMap  _annotationsInside  [TYPE]  MapperConfig  config  [TYPE]  Class  contentClass  currRaw  keyClass  serClass  [TYPE]  TypeFactory  tf  [TYPE]  long  serialVersionUID  [TYPE]  IllegalArgumentException  iae  [TYPE]  Java7Support  _java7Helper  [CONTEXT]  public  JavaType  refineSerializationType  (  final  MapperConfig<?>  config  ,  final  Annotated  a  ,  final  JavaType  baseType  )  throws  JsonMappingException  {  JavaType  type  =  baseType  ;  final  TypeFactory  tf  =  config  .  getTypeFactory  (  )  ;  final  JsonSerialize  jsonSer  =  _findAnnotation  (  a  ,  JsonSerialize  .  class  )  ;    final  Class<?>  serClass  =  (  jsonSer  =  =  null  )  ?  null  :  _classIfExplicit  (  jsonSer  .  as  (  )  )  ;  if  (  serClass  !  =  null  )  {  if  (  type  .  hasRawClass  (  serClass  )  )  {    type  =  type  .  withStaticTyping  (  )  ;  }  else  {  Class<?>  currRaw  =  type  .  getRawClass  (  )  ;  try  {    if  (  serClass  .  isAssignableFrom  (  currRaw  )  )  {  //  common  case  type  =  tf  .  constructGeneralizedType  (  type  ,  serClass  )  ;  }  else  if  (  currRaw  .  isAssignableFrom  (  serClass  )  )  {  //  specialization  ,  ok  as  well  type  =  tf  .  constructSpecializedType  (  type  ,  serClass  )  ;  [BUGGY]  }  else  {  throw  new  JsonMappingException  (  null  ,  String  .  format  (   "Can  not  refine  serialization  type  %s  into  %s  ;  types  not  related "  ,  type  ,  serClass  .  getName  (  )  )  )  ;  }  	JacksonDatabind_81_JacksonAnnotationIntrospector_7_1	764	0	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1387	}  else  if  (_primitiveAndWrapper(currRaw,  keyClass))  {  keyType  =  keyType.withStaticTyping();  	[BUGGY]  [FE]  jacksondatabindexcInvalidDefinitionException:  Invalid  definition  for  property   "i "  (  of  type  comfasterxmljacksondatabindintrospectTypeCoercion1592Test$Bean1592  )  :  Can  not  refine  serialization  type  [simple  type  ,  class  int]  into  javalangInteger  ;  types  not  related  assertNotNull  (  result  )  ;  [METHOD]  refineSerializationType  [TYPE]  JavaType  [PARAMETER]  MapperConfig<?>  config  Annotated  a  JavaType  baseType  [CLASS]  JacksonAnnotationIntrospector  [TYPE]  JsonSerialize  jsonSer  [TYPE]  Annotated  a  [TYPE]  JavaType  baseType  contentType  keyType  type  [TYPE]  Class[]  ANNOTATIONS_TO_INFER_DESER  ANNOTATIONS_TO_INFER_SER  [TYPE]  boolean  _cfgConstructorPropertiesImpliesCreator  false  true  [TYPE]  LRUMap  _annotationsInside  [TYPE]  MapperConfig  config  [TYPE]  Class  contentClass  currRaw  keyClass  serClass  [TYPE]  TypeFactory  tf  [TYPE]  long  serialVersionUID  [TYPE]  IllegalArgumentException  iae  [TYPE]  Java7Support  _java7Helper  [CONTEXT]  String  .  format  (   "Failed  to  widen  type  %s  with  annotation  (  value  %s  )  ,  from  '%s':  %s "  ,  type  ,  serClass  .  getName  (  )  ,  a  .  getName  (  )  ,  iae  .  getMessage  (  )  )  ,  iae  )  ;  }  }  }    if  (  type  .  isMapLikeType  (  )  )  {  JavaType  keyType  =  type  .  getKeyType  (  )  ;  final  Class<?>  keyClass  =  (  jsonSer  =  =  null  )  ?  null  :  _classIfExplicit  (  jsonSer  .  keyAs  (  )  )  ;  if  (  keyClass  !  =  null  )  {  if  (  keyType  .  hasRawClass  (  keyClass  )  )  {  keyType  =  keyType  .  withStaticTyping  (  )  ;  }  else  {  Class<?>  currRaw  =  keyType  .  getRawClass  (  )  ;  try  {    if  (  keyClass  .  isAssignableFrom  (  currRaw  )  )  {  //  common  case  keyType  =  tf  .  constructGeneralizedType  (  keyType  ,  keyClass  )  ;  }  else  if  (  currRaw  .  isAssignableFrom  (  keyClass  )  )  {  //  specialization  ,  ok  as  well  keyType  =  tf  .  constructSpecializedType  (  keyType  ,  keyClass  )  ;  [BUGGY]  }  else  {  throw  new  JsonMappingException  (  null  ,  String  .  format  (   "Can  not  refine  serialization  key  type  %s  into  %s  ;  types  not  related "  ,  keyType  ,  keyClass  .  getName  (  )  )  )  ;  }  	JacksonDatabind_81_JacksonAnnotationIntrospector_7_2	797	0	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1388	}  else  if  (_primitiveAndWrapper(currRaw,  contentClass))  {  contentType  =  contentType.withStaticTyping();  	[BUGGY]  [FE]  jacksondatabindexcInvalidDefinitionException:  Invalid  definition  for  property   "i "  (  of  type  comfasterxmljacksondatabindintrospectTypeCoercion1592Test$Bean1592  )  :  Can  not  refine  serialization  type  [simple  type  ,  class  int]  into  javalangInteger  ;  types  not  related  assertNotNull  (  result  )  ;  [METHOD]  refineSerializationType  [TYPE]  JavaType  [PARAMETER]  MapperConfig<?>  config  Annotated  a  JavaType  baseType  [CLASS]  JacksonAnnotationIntrospector  [TYPE]  JsonSerialize  jsonSer  [TYPE]  Annotated  a  [TYPE]  JavaType  baseType  contentType  keyType  type  [TYPE]  Class[]  ANNOTATIONS_TO_INFER_DESER  ANNOTATIONS_TO_INFER_SER  [TYPE]  boolean  _cfgConstructorPropertiesImpliesCreator  false  true  [TYPE]  LRUMap  _annotationsInside  [TYPE]  MapperConfig  config  [TYPE]  Class  contentClass  currRaw  keyClass  serClass  [TYPE]  TypeFactory  tf  [TYPE]  long  serialVersionUID  [TYPE]  IllegalArgumentException  iae  [TYPE]  Java7Support  _java7Helper  [CONTEXT]  type  ,  keyClass  .  getName  (  )  ,  a  .  getName  (  )  ,  iae  .  getMessage  (  )  )  ,  iae  )  ;  }  }  type  =  (  (  MapLikeType  )  type  )  .  withKeyType  (  keyType  )  ;  }  }  JavaType  contentType  =  type  .  getContentType  (  )  ;  if  (  contentType  !  =  null  )  {  //  collection[like]  ,  map[like]  ,  array  ,  reference  final  Class<?>  contentClass  =  (  jsonSer  =  =  null  )  ?  null  :  _classIfExplicit  (  jsonSer  .  contentAs  (  )  )  ;  if  (  contentClass  !  =  null  )  {  if  (  contentType  .  hasRawClass  (  contentClass  )  )  {  contentType  =  contentType  .  withStaticTyping  (  )  ;  }  else  {    Class<?>  currRaw  =  contentType  .  getRawClass  (  )  ;  try  {  if  (  contentClass  .  isAssignableFrom  (  currRaw  )  )  {  //  common  case  contentType  =  tf  .  constructGeneralizedType  (  contentType  ,  contentClass  )  ;  }  else  if  (  currRaw  .  isAssignableFrom  (  contentClass  )  )  {  //  specialization  ,  ok  as  well  contentType  =  tf  .  constructSpecializedType  (  contentType  ,  contentClass  )  ;  [BUGGY]  }  else  {  throw  new  JsonMappingException  (  null  ,  String  .  format  (   "Can  not  refine  serialization  content  type  %s  into  %s  ;  types  not  related "  ,  contentType  ,  contentClass  .  getName  (  )  )  )  ;  }  	JacksonDatabind_81_JacksonAnnotationIntrospector_7_3	831	0	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1389	if  ((valueClass  !=  null)  &&  !type.hasRawClass(valueClass)  &&  !_primitiveAndWrapper(type,  valueClass))  {  	[BUGGY]  if  (  (  valueClass  !  =  null  )  &&  !type  .  hasRawClass  (  valueClass  )  )  {  [FE]  jacksondatabindexcInvalidDefinitionException:  Invalid  definition  for  property   "i "  (  of  type  comfasterxmljacksondatabindintrospectTypeCoercion1592Test$Bean1592  )  :  Can  not  refine  serialization  type  [simple  type  ,  class  int]  into  javalangInteger  ;  types  not  related  assertNotNull  (  result  )  ;  [METHOD]  refineDeserializationType  [TYPE]  JavaType  [PARAMETER]  MapperConfig<?>  config  Annotated  a  JavaType  baseType  [CLASS]  JacksonAnnotationIntrospector  [TYPE]  Annotated  a  [TYPE]  JavaType  baseType  contentType  keyType  type  [TYPE]  Class[]  ANNOTATIONS_TO_INFER_DESER  ANNOTATIONS_TO_INFER_SER  [TYPE]  boolean  _cfgConstructorPropertiesImpliesCreator  false  true  [TYPE]  LRUMap  _annotationsInside  [TYPE]  MapperConfig  config  [TYPE]  JsonDeserialize  jsonDeser  [TYPE]  Class  contentClass  keyClass  valueClass  [TYPE]  TypeFactory  tf  [TYPE]  long  serialVersionUID  [TYPE]  IllegalArgumentException  iae  [TYPE]  Java7Support  _java7Helper  [CONTEXT]  public  JavaType  refineDeserializationType  (  final  MapperConfig<?>  config  ,  final  Annotated  a  ,  final  JavaType  baseType  )  throws  JsonMappingException  {  JavaType  type  =  baseType  ;  final  TypeFactory  tf  =  config  .  getTypeFactory  (  )  ;  final  JsonDeserialize  jsonDeser  =  _findAnnotation  (  a  ,  JsonDeserialize  .  class  )  ;    final  Class<?>  valueClass  =  (  jsonDeser  =  =  null  )  ?  null  :  _classIfExplicit  (  jsonDeser  .  as  (  )  )  ;  [BUGGY]  if  (  (  valueClass  !  =  null  )  &&  !type  .  hasRawClass  (  valueClass  )  )  {  try  {  type  =  tf  .  constructSpecializedType  (  type  ,  valueClass  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (  null  ,  String  .  format  (   "Failed  to  narrow  type  %s  with  annotation  (  value  %s  )  ,  from  '%s':  %s "  ,  	JacksonDatabind_81_JacksonAnnotationIntrospector_7_4	1119	1	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1390	if  ((keyClass  !=  null)  &&  !_primitiveAndWrapper(keyType,  keyClass))  {  	[BUGGY]  if  (  keyClass  !  =  null  )  {  [FE]  jacksondatabindexcInvalidDefinitionException:  Invalid  definition  for  property   "i "  (  of  type  comfasterxmljacksondatabindintrospectTypeCoercion1592Test$Bean1592  )  :  Can  not  refine  serialization  type  [simple  type  ,  class  int]  into  javalangInteger  ;  types  not  related  assertNotNull  (  result  )  ;  [METHOD]  refineDeserializationType  [TYPE]  JavaType  [PARAMETER]  MapperConfig<?>  config  Annotated  a  JavaType  baseType  [CLASS]  JacksonAnnotationIntrospector  [TYPE]  Annotated  a  [TYPE]  JavaType  baseType  contentType  keyType  type  [TYPE]  Class[]  ANNOTATIONS_TO_INFER_DESER  ANNOTATIONS_TO_INFER_SER  [TYPE]  boolean  _cfgConstructorPropertiesImpliesCreator  false  true  [TYPE]  LRUMap  _annotationsInside  [TYPE]  MapperConfig  config  [TYPE]  JsonDeserialize  jsonDeser  [TYPE]  Class  contentClass  keyClass  valueClass  [TYPE]  TypeFactory  tf  [TYPE]  long  serialVersionUID  [TYPE]  IllegalArgumentException  iae  [TYPE]  Java7Support  _java7Helper  [CONTEXT]  final  Annotated  a  ,  final  JavaType  baseType  )  throws  JsonMappingException  {  JavaType  type  =  baseType  ;  final  TypeFactory  tf  =  config  .  getTypeFactory  (  )  ;  final  JsonDeserialize  jsonDeser  =  _findAnnotation  (  a  ,  JsonDeserialize  .  class  )  ;    final  Class<?>  valueClass  =  (  jsonDeser  =  =  null  )  ?  null  :  _classIfExplicit  (  jsonDeser  .  as  (  )  )  ;  if  (  (  valueClass  !  =  null  )  &&  !type  .  hasRawClass  (  valueClass  )  )  {  try  {  type  =  tf  .  constructSpecializedType  (  type  ,  valueClass  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (  null  ,  String  .  format  (   "Failed  to  narrow  type  %s  with  annotation  (  value  %s  )  ,  from  '%s':  %s "  ,  type  ,  valueClass  .  getName  (  )  ,  a  .  getName  (  )  ,  iae  .  getMessage  (  )  )  ,  iae  )  ;  }  }    if  (  type  .  isMapLikeType  (  )  )  {  JavaType  keyType  =  type  .  getKeyType  (  )  ;  final  Class<?>  keyClass  =  (  jsonDeser  =  =  null  )  ?  null  :  _classIfExplicit  (  jsonDeser  .  keyAs  (  )  )  ;  [BUGGY]  if  (  keyClass  !  =  null  )  {  try  {  keyType  =  tf  .  constructSpecializedType  (  keyType  ,  keyClass  )  ;  type  =  (  (  MapLikeType  )  type  )  .  withKeyType  (  keyType  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (  null  ,  	JacksonDatabind_81_JacksonAnnotationIntrospector_7_5	1135	1	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1391	if  ((contentClass  !=  null)  &&  !_primitiveAndWrapper(contentType,  contentClass))  {  	[BUGGY]  if  (  contentClass  !  =  null  )  {  [FE]  jacksondatabindexcInvalidDefinitionException:  Invalid  definition  for  property   "i "  (  of  type  comfasterxmljacksondatabindintrospectTypeCoercion1592Test$Bean1592  )  :  Can  not  refine  serialization  type  [simple  type  ,  class  int]  into  javalangInteger  ;  types  not  related  assertNotNull  (  result  )  ;  [METHOD]  refineDeserializationType  [TYPE]  JavaType  [PARAMETER]  MapperConfig<?>  config  Annotated  a  JavaType  baseType  [CLASS]  JacksonAnnotationIntrospector  [TYPE]  Annotated  a  [TYPE]  JavaType  baseType  contentType  keyType  type  [TYPE]  Class[]  ANNOTATIONS_TO_INFER_DESER  ANNOTATIONS_TO_INFER_SER  [TYPE]  boolean  _cfgConstructorPropertiesImpliesCreator  false  true  [TYPE]  LRUMap  _annotationsInside  [TYPE]  MapperConfig  config  [TYPE]  JsonDeserialize  jsonDeser  [TYPE]  Class  contentClass  keyClass  valueClass  [TYPE]  TypeFactory  tf  [TYPE]  long  serialVersionUID  [TYPE]  IllegalArgumentException  iae  [TYPE]  Java7Support  _java7Helper  [CONTEXT]  iae  )  ;  }  }    if  (  type  .  isMapLikeType  (  )  )  {  JavaType  keyType  =  type  .  getKeyType  (  )  ;  final  Class<?>  keyClass  =  (  jsonDeser  =  =  null  )  ?  null  :  _classIfExplicit  (  jsonDeser  .  keyAs  (  )  )  ;  if  (  keyClass  !  =  null  )  {  try  {  keyType  =  tf  .  constructSpecializedType  (  keyType  ,  keyClass  )  ;  type  =  (  (  MapLikeType  )  type  )  .  withKeyType  (  keyType  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (  null  ,  String  .  format  (   "Failed  to  narrow  key  type  of  %s  with  concrete-type  annotation  (  value  %s  )  ,  from  '%s':  %s "  ,  type  ,  keyClass  .  getName  (  )  ,  a  .  getName  (  )  ,  iae  .  getMessage  (  )  )  ,  iae  )  ;  }  }  }  JavaType  contentType  =  type  .  getContentType  (  )  ;  if  (  contentType  !  =  null  )  {  //  collection[like]  ,  map[like]  ,  array  ,  reference  final  Class<?>  contentClass  =  (  jsonDeser  =  =  null  )  ?  null  :  _classIfExplicit  (  jsonDeser  .  contentAs  (  )  )  ;  [BUGGY]  if  (  contentClass  !  =  null  )  {  try  {  contentType  =  tf  .  constructSpecializedType  (  contentType  ,  contentClass  )  ;  type  =  type  .  withContentType  (  contentType  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  throw  new  JsonMappingException  (  null  ,  	JacksonDatabind_81_JacksonAnnotationIntrospector_7_6	1151	1	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1392	private  boolean  _primitiveAndWrapper(Class<?>  baseType,  Class<?>  refinement)  {  if  (baseType.isPrimitive())  {  return  baseType  ==  ClassUtil.primitiveType(refinement);  }  if  (refinement.isPrimitive())  {  return  refinement  ==  ClassUtil.primitiveType(baseType);  }  return  false;  }  private  boolean  _primitiveAndWrapper(JavaType  baseType,  Class<?>  refinement)  {  if  (baseType.isPrimitive())  {  return  baseType.hasRawClass(ClassUtil.primitiveType(refinement));  }  if  (refinement.isPrimitive())  {  return  refinement  ==  ClassUtil.primitiveType(baseType.getRawClass());  }  return  false;  }  	[BUGGY]  [FE]  jacksondatabindexcInvalidDefinitionException:  Invalid  definition  for  property   "i "  (  of  type  comfasterxmljacksondatabindintrospectTypeCoercion1592Test$Bean1592  )  :  Can  not  refine  serialization  type  [simple  type  ,  class  int]  into  javalangInteger  ;  types  not  related  assertNotNull  (  result  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_81_JacksonAnnotationIntrospector_7_7	1457	0	src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java
1393	ignored  =  ignorals.findIgnoredForDeserialization();  	[BUGGY]  ignored  =  ignorals  .  getIgnored  (  )  ;  [FE]  ComparisonFailure:  expected:<jack>  but  was:<null>  assertEquals  (   "jack "  ,  des  .  getName  (  )  )  ;  [METHOD]  addBeanProps  [TYPE]  void  [PARAMETER]  DeserializationContext  ctxt  BeanDescription  beanDesc  BeanDeserializerBuilder  builder  [CLASS]  BeanDeserializerFactory  [TYPE]  BeanDeserializerModifier  mod  [TYPE]  Class[]  INIT_CAUSE_PARAMS  NO_VIEWS  views  [TYPE]  Set  DEFAULT_NO_DESER_CLASS_NAMES  _cfgIllegalClassNames  ignored  [TYPE]  AnnotatedMethod  anySetterMethod  getter  [TYPE]  SettableBeanProperty  cp  prop  [TYPE]  BeanDescription  beanDesc  [TYPE]  AnnotatedMember  anySetterField  [TYPE]  SettableBeanProperty[]  creatorProps  [TYPE]  String  name  propName  [TYPE]  CreatorProperty  cprop  [TYPE]  long  serialVersionUID  [TYPE]  BeanDeserializerBuilder  builder  [TYPE]  JavaType  propertyType  [TYPE]  boolean  false  hasCreatorProps  ignoreAny  isConcrete  true  useGettersAsSetters  [TYPE]  BeanDeserializerFactory  instance  [TYPE]  Value  ignorals  [TYPE]  BeanPropertyDefinition  propDef  [TYPE]  DeserializationContext  ctxt  [TYPE]  Collection  ignored2  [TYPE]  List  n  propDefs  [TYPE]  Class  rawPropertyType  [CONTEXT]  protected  void  addBeanProps  (  DeserializationContext  ctxt  ,  BeanDescription  beanDesc  ,  BeanDeserializerBuilder  builder  )  throws  JsonMappingException  {  final  boolean  isConcrete  =  !beanDesc  .  getType  (  )  .  isAbstract  (  )  ;  final  SettableBeanProperty[]  creatorProps  =  isConcrete  ?  builder  .  getValueInstantiator  (  )  .  getFromObjectArguments  (  ctxt  .  getConfig  (  )  )  :  null  ;  final  boolean  hasCreatorProps  =  (  creatorProps  !  =  null  )  ;      JsonIgnoreProperties  .  Value  ignorals  =  ctxt  .  getConfig  (  )    .  getDefaultPropertyIgnorals  (  beanDesc  .  getBeanClass  (  )  ,  beanDesc  .  getClassInfo  (  )  )  ;  Set<String>  ignored  ;  if  (  ignorals  !  =  null  )  {  boolean  ignoreAny  =  ignorals  .  getIgnoreUnknown  (  )  ;  builder  .  setIgnoreUnknownProperties  (  ignoreAny  )  ;  [BUGGY]  ignored  =  ignorals  .  getIgnored  (  )  ;  for  (  String  propName  :  ignored  )  {  builder  .  addIgnorable  (  propName  )  ;  }  }  else  {  ignored  =  Collections  .  emptySet  (  )  ;  	JacksonDatabind_82_BeanDeserializerFactory_1_1	495	1	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1394	return _deserialize(text, ctxt);	[BUGGY]  if  (  _deserialize  (  text  ,  ctxt  )  !  =  null  )  { return _deserialize(text, ctxt); }  [FE]  jacksondatabindexcInvalidFormatException:  Can  not  deserialize  value  of  type  javautilUUID  from  String   "not  a  uuid! ":  not  a  valid  textual  representation  assertNull  (  result2  )  ;  [METHOD]  deserialize  [TYPE]  T  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  FromStringDeserializer  [TYPE]  MalformedURLException  me  [TYPE]  boolean  false  true  [TYPE]  JsonMappingException  e  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonToken  t  [TYPE]  Object  ob  [TYPE]  String  m2  msg  text  [TYPE]  long  serialVersionUID  [TYPE]  int  STD_CHARSET  STD_CLASS  STD_CURRENCY  STD_FILE  STD_INET_ADDRESS  STD_INET_SOCKET_ADDRESS  STD_JAVA_TYPE  STD_LOCALE  STD_PATTERN  STD_STRING_BUILDER  STD_TIME_ZONE  STD_URI  STD_URL  _kind  [TYPE]  Exception  cause  [TYPE]  IllegalArgumentException  iae  [TYPE]  JsonParser  p  [CONTEXT]  public  T  deserialize  (  JsonParser  p  ,  DeserializationContext  ctxt  )  throws  IOException  {  String  text  =  p  .  getValueAsString  (  )  ;  if  (  text  !  =  null  )  {  //  has  String  representation  if  (  text  .  length  (  )  =  =  0  ||  (  text  =  text  .  trim  (  )  )  .  length  (  )  =  =  0  )  {  return  _deserializeFromEmptyString  (  )  ;  }  Exception  cause  =  null  ;  try  {    [BUGGY]  if  (  _deserialize  (  text  ,  ctxt  )  !  =  null  )  {  return  _deserialize  (  text  ,  ctxt  )  ;  }  }  catch  (  IllegalArgumentException  iae  )  {  cause  =  iae  ;  }  catch  (  MalformedURLException  me  )  {  	JacksonDatabind_83_FromStringDeserializer_1_1	119	2	src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java
1395	@Override  public  JavaType  getSuperClass()  {  \tif  (_referencedType  !=  null)  {  \t\treturn  _referencedType.getSuperClass();  \t}  \treturn  super.getSuperClass();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "[base ":1  ,   "]sub ":2}>  but  was:<{ "[]sub ":2}>  assertEquals  (   "{\ "base\ ":1  ,  \ "sub\ ":2} "  ,  serialized  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_84_ResolvedRecursiveType_1_1	29	0	src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java
1396	if  (format.hasPattern())  {  	[BUGGY]  if  (  (  shape  =  =  JsonFormat  .  Shape  .  STRING  )  ||  format  .  hasPattern  (  )  ||  format  .  hasLocale  (  )  ||  format  .  hasTimeZone  (  )  )  {  TimeZone  tz  =  format  .  getTimeZone  (  )  ;  final  String  pattern  =  format  .  hasPattern  (  )  ?  format  .  getPattern  (  )  :  StdDateFormat  .  DATE_FORMAT_STR_ISO8601  ;  [FE]  ComparisonFailure:  expected:<{ "date ": "1970-01-01[X01:00:]00 "}>  but  was:<{ "date ": "1970-01-01[T01:00:00000+01]00 "}>  assertEquals  (  aposToQuotes  (   "{'date':'1970-01-01X01:00:00'} "  )  ,  json  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  serializers  BeanProperty  property  [CLASS]  DateTimeSerializerBase  [TYPE]  Locale  loc  [TYPE]  TimeZone  tz  [TYPE]  Shape  shape  [TYPE]  boolean  false  true  [TYPE]  DateFormat  _customFormat  [TYPE]  Value  format  [TYPE]  String  pattern  [TYPE]  Boolean  _useTimestamp  [TYPE]  SerializerProvider  serializers  [TYPE]  SimpleDateFormat  df  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonSerializer<?>  createContextual  (  SerializerProvider  serializers  ,  BeanProperty  property  )  throws  JsonMappingException  {  if  (  property  =  =  null  )  {  return  this  ;  }  JsonFormat  .  Value  format  =  findFormatOverrides  (  serializers  ,  property  ,  handledType  (  )  )  ;  if  (  format  =  =  null  )  {  return  this  ;  }  JsonFormat  .  Shape  shape  =  format  .  getShape  (  )  ;  if  (  shape  .  isNumeric  (  )  )  {  return  withFormat  (  Boolean  .  TRUE  ,  null  )  ;  }    [BUGGY]  if  (  (  shape  =  =  JsonFormat  .  Shape  .  STRING  )  ||  format  .  hasPattern  (  )  ||  format  .  hasLocale  (  )  ||  format  .  hasTimeZone  (  )  )  {  TimeZone  tz  =  format  .  getTimeZone  (  )  ;  final  String  pattern  =  format  .  hasPattern  (  )  ?  format  .  getPattern  (  )  :  StdDateFormat  .  DATE_FORMAT_STR_ISO8601  ;  	JacksonDatabind_85_DateTimeSerializerBase_4_1	67	6	src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java
1397	SimpleDateFormat  df  =  new  SimpleDateFormat(format.getPattern(),  loc);  TimeZone  tz  =  format.hasTimeZone()  ?  format.getTimeZone()  :  serializers.getTimeZone();  	[BUGGY]  SimpleDateFormat  df  =  new  SimpleDateFormat  (  pattern  ,  loc  )  ;  if  (  tz  =  =  null  )  {  tz  =  serializers  .  getTimeZone  (  )  ;  }  [FE]  ComparisonFailure:  expected:<{ "date ": "1970-01-01[X01:00:]00 "}>  but  was:<{ "date ": "1970-01-01[T01:00:00000+01]00 "}>  assertEquals  (  aposToQuotes  (   "{'date':'1970-01-01X01:00:00'} "  )  ,  json  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  serializers  BeanProperty  property  [CLASS]  DateTimeSerializerBase  [TYPE]  Locale  loc  [TYPE]  TimeZone  tz  [TYPE]  Shape  shape  [TYPE]  boolean  false  true  [TYPE]  DateFormat  _customFormat  [TYPE]  Value  format  [TYPE]  String  pattern  [TYPE]  Boolean  _useTimestamp  [TYPE]  SerializerProvider  serializers  [TYPE]  SimpleDateFormat  df  [TYPE]  BeanProperty  property  [CONTEXT]  {  if  (  property  =  =  null  )  {  return  this  ;  }  JsonFormat  .  Value  format  =  findFormatOverrides  (  serializers  ,  property  ,  handledType  (  )  )  ;  if  (  format  =  =  null  )  {  return  this  ;  }  JsonFormat  .  Shape  shape  =  format  .  getShape  (  )  ;  if  (  shape  .  isNumeric  (  )  )  {  return  withFormat  (  Boolean  .  TRUE  ,  null  )  ;  }    if  (  (  shape  =  =  JsonFormat  .  Shape  .  STRING  )  ||  format  .  hasPattern  (  )  ||  format  .  hasLocale  (  )  ||  format  .  hasTimeZone  (  )  )  {  TimeZone  tz  =  format  .  getTimeZone  (  )  ;  final  String  pattern  =  format  .  hasPattern  (  )  ?  format  .  getPattern  (  )  :  StdDateFormat  .  DATE_FORMAT_STR_ISO8601  ;  final  Locale  loc  =  format  .  hasLocale  (  )  ?  format  .  getLocale  (  )  :  serializers  .  getLocale  (  )  ;  [BUGGY]  SimpleDateFormat  df  =  new  SimpleDateFormat  (  pattern  ,  loc  )  ;  if  (  tz  =  =  null  )  {  tz  =  serializers  .  getTimeZone  (  )  ;  }  df  .  setTimeZone  (  tz  )  ;  return  withFormat  (  Boolean  .  FALSE  ,  df  )  ;  	JacksonDatabind_85_DateTimeSerializerBase_4_2	76	4	src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java
1398	final  boolean  hasLocale  =  format.hasLocale();  final  boolean  hasTZ  =  format.hasTimeZone();  final  boolean  asString  =  (shape  ==  JsonFormat.Shape.STRING);  if  (!hasLocale  &&  !hasTZ  &&  !asString)  {  return  this;  }  DateFormat  df0  =  serializers.getConfig().getDateFormat();\n',   "                    StdDateFormat  std  =  (StdDateFormat)  df0;  if  (format.hasLocale())  {  std  =  std.withLocale(format.getLocale());  }  if  (format.hasTimeZone())  {  std  =  std.withTimeZone(format.getTimeZone());  }  return  withFormat(Boolean.FALSE,  std);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "date ": "1970-01-01[X01:00:]00 "}>  but  was:<{ "date ": "1970-01-01[T01:00:00000+01]00 "}>  assertEquals  (  aposToQuotes  (   "{'date':'1970-01-01X01:00:00'} "  )  ,  json  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  serializers  BeanProperty  property  [CLASS]  DateTimeSerializerBase  [TYPE]  Locale  loc  [TYPE]  TimeZone  tz  [TYPE]  Shape  shape  [TYPE]  boolean  false  true  [TYPE]  DateFormat  _customFormat  [TYPE]  Value  format  [TYPE]  String  pattern  [TYPE]  Boolean  _useTimestamp  [TYPE]  SerializerProvider  serializers  [TYPE]  SimpleDateFormat  df  [TYPE]  BeanProperty  property  [CONTEXT]  JsonFormat  .  Shape  shape  =  format  .  getShape  (  )  ;  if  (  shape  .  isNumeric  (  )  )  {  return  withFormat  (  Boolean  .  TRUE  ,  null  )  ;  }    if  (  (  shape  =  =  JsonFormat  .  Shape  .  STRING  )  ||  format  .  hasPattern  (  )  ||  format  .  hasLocale  (  )  ||  format  .  hasTimeZone  (  )  )  {  TimeZone  tz  =  format  .  getTimeZone  (  )  ;  final  String  pattern  =  format  .  hasPattern  (  )  ?  format  .  getPattern  (  )  :  StdDateFormat  .  DATE_FORMAT_STR_ISO8601  ;  final  Locale  loc  =  format  .  hasLocale  (  )  ?  format  .  getLocale  (  )  :  serializers  .  getLocale  (  )  ;  SimpleDateFormat  df  =  new  SimpleDateFormat  (  pattern  ,  loc  )  ;  if  (  tz  =  =  null  )  {  tz  =  serializers  .  getTimeZone  (  )  ;  }  df  .  setTimeZone  (  tz  )  ;  return  withFormat  (  Boolean  .  FALSE  ,  df  )  ;  }  [BUGGY]      	JacksonDatabind_85_DateTimeSerializerBase_4_3	85	0	src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java
1399	serializers.reportMappingProblem(   "Configured  `DateFormat`  (%s)  not  a  `SimpleDateFormat`;  can  not  configure  `Locale`  or  `TimeZone` ",  df0.getClass().getName());  }  SimpleDateFormat  df  =  (SimpleDateFormat)  df0;  if  (hasLocale)  {  df  =  new  SimpleDateFormat(df.toPattern(),  format.getLocale());  }  else  {  df  =  (SimpleDateFormat)  df.clone();  }  TimeZone  newTz  =  format.getTimeZone();  boolean  changeTZ  =  (newTz  !=  null)  &&  !newTz.equals(df.getTimeZone());  if  (changeTZ)  {  df.setTimeZone(newTz);  }  return  withFormat(Boolean.FALSE,  df);  	[BUGGY]  return  this  ;  [FE]  ComparisonFailure:  expected:<{ "date ": "1970-01-01[X01:00:]00 "}>  but  was:<{ "date ": "1970-01-01[T01:00:00000+01]00 "}>  assertEquals  (  aposToQuotes  (   "{'date':'1970-01-01X01:00:00'} "  )  ,  json  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  serializers  BeanProperty  property  [CLASS]  DateTimeSerializerBase  [TYPE]  Locale  loc  [TYPE]  TimeZone  tz  [TYPE]  Shape  shape  [TYPE]  boolean  false  true  [TYPE]  DateFormat  _customFormat  [TYPE]  Value  format  [TYPE]  String  pattern  [TYPE]  Boolean  _useTimestamp  [TYPE]  SerializerProvider  serializers  [TYPE]  SimpleDateFormat  df  [TYPE]  BeanProperty  property  [CONTEXT]  if  (  (  shape  =  =  JsonFormat  .  Shape  .  STRING  )  ||  format  .  hasPattern  (  )  ||  format  .  hasLocale  (  )  ||  format  .  hasTimeZone  (  )  )  {  TimeZone  tz  =  format  .  getTimeZone  (  )  ;  final  String  pattern  =  format  .  hasPattern  (  )  ?  format  .  getPattern  (  )  :  StdDateFormat  .  DATE_FORMAT_STR_ISO8601  ;  final  Locale  loc  =  format  .  hasLocale  (  )  ?  format  .  getLocale  (  )  :  serializers  .  getLocale  (  )  ;  SimpleDateFormat  df  =  new  SimpleDateFormat  (  pattern  ,  loc  )  ;  if  (  tz  =  =  null  )  {  tz  =  serializers  .  getTimeZone  (  )  ;  }  df  .  setTimeZone  (  tz  )  ;  return  withFormat  (  Boolean  .  FALSE  ,  df  )  ;  }        [BUGGY]    return  this  ;  }  	JacksonDatabind_85_DateTimeSerializerBase_4_4	92	1	src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java
1400	@Override  public  JavaType  getSuperClass()  {  \tif  (_referencedType  !=  null)  {  \t\treturn  _referencedType.getSuperClass();  \t}  \treturn  super.getSuperClass();  }  	[BUGGY]  [FE]  AssertionFailedError  assertNotNull  (  baseTypeFromSub  .  getSuperClass  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_86_ResolvedRecursiveType_1_1	29	0	src/main/java/com/fasterxml/jackson/databind/type/ResolvedRecursiveType.java
1401	protected  final  static  String  DATE_FORMAT_STR_ISO8601_NO_TZ  =   "yyyy-MM-dd\'T\'HH:mm:ss.SSS ";  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_87_StdDateFormat_10_1	47	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1402	DATE_FORMAT_STR_ISO8601_NO_TZ,  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_87_StdDateFormat_10_2	65	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1403	protected  final  static  DateFormat  DATE_FORMAT_ISO8601_NO_TZ;    	[BUGGY]  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_87_StdDateFormat_10_3	84	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1404	DATE_FORMAT_ISO8601_NO_TZ  =  new  SimpleDateFormat(DATE_FORMAT_STR_ISO8601_NO_TZ,  DEFAULT_LOCALE);  DATE_FORMAT_ISO8601_NO_TZ.setTimeZone(DEFAULT_TIMEZONE);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_87_StdDateFormat_10_4	102	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1405	protected  transient  DateFormat  _formatISO8601_noTz;    	[BUGGY]  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_87_StdDateFormat_10_5	132	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1406		[BUGGY]  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  \n'  ,   "          int  timeLen  =  len  -  dateStr  .  lastIndexOf  (  'T'  )  -  1  ;  \n "  ,  '  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [METHOD]  parseAsISO8601  [TYPE]  Date  [PARAMETER]  String  dateStr  ParsePosition  pos  boolean  throwErrors  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  [TYPE]  StringBuilder  sb  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_ISO8601_Z  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  dateStr  formatStr  [TYPE]  String[]  ALL_FORMATS  [TYPE]  int  len  offset  timeLen  [TYPE]  Date  dt  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  [TYPE]  boolean  false  throwErrors  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_ISO8601_Z  DATE_FORMAT_PLAIN  DATE_FORMAT_RFC1123  _formatISO8601  _formatISO8601_z  _formatPlain  _formatRFC1123  df  [TYPE]  char  c  [TYPE]  Boolean  _lenient  [TYPE]  ParsePosition  pos  [CONTEXT]  case  11:  sb  .  insert  (  offset  ,  '0'  )  ;  break  ;  case  10:  sb  .  insert  (  offset  ,   "00 "  )  ;  break  ;  case  9:  //  is  this  legal?  (  just  second  fraction  marker  )  sb  .  insert  (  offset  ,   "000 "  )  ;  break  ;  case  8:  sb  .  insert  (  offset  ,   "  .  000 "  )  ;  break  ;  case  7:  //  not  legal  to  have  single-digit  second  break  ;  case  6:  //  probably  not  legal  ,  but  let's  allow  sb  .  insert  (  offset  ,   "00  .  000 "  )  ;  case  5:  //  is  legal  to  omit  seconds  sb  .  insert  (  offset  ,   ":00  .  000 "  )  ;  }  dateStr  =  sb  .  toString  (  )  ;  }  df  =  _formatISO8601  ;  formatStr  =  DATE_FORMAT_STR_ISO8601  ;  if  (  _formatISO8601  =  =  null  )  {  df  =  _formatISO8601  =  _cloneFormat  (  DATE_FORMAT_ISO8601  ,  formatStr  ,  _timezone  ,  _locale  ,  _lenient  )  ;  }  }  else  {  [BUGGY]  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  int  timeLen  =  len  -  dateStr  .  lastIndexOf  (  'T'  )  -  1  ;  if  (  timeLen  <  12  )  {  //  missing  ,  or  partial  switch  (  timeLen  )  {  case  11:  sb  .  append  (  '0'  )  ;  	JacksonDatabind_87_StdDateFormat_10_6	514	1	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1407	StringBuilder  sb  =  new  StringBuilder(dateStr);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [METHOD]  parseAsISO8601  [TYPE]  Date  [PARAMETER]  String  dateStr  ParsePosition  pos  boolean  throwErrors  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  [TYPE]  StringBuilder  sb  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_ISO8601_Z  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  dateStr  formatStr  [TYPE]  String[]  ALL_FORMATS  [TYPE]  int  len  offset  timeLen  [TYPE]  Date  dt  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  [TYPE]  boolean  false  throwErrors  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_ISO8601_Z  DATE_FORMAT_PLAIN  DATE_FORMAT_RFC1123  _formatISO8601  _formatISO8601_z  _formatPlain  _formatRFC1123  df  [TYPE]  char  c  [TYPE]  Boolean  _lenient  [TYPE]  ParsePosition  pos  [CONTEXT]  case  9:  //  is  this  legal?  (  just  second  fraction  marker  )  sb  .  insert  (  offset  ,   "000 "  )  ;  break  ;  case  8:  sb  .  insert  (  offset  ,   "  .  000 "  )  ;  break  ;  case  7:  //  not  legal  to  have  single-digit  second  break  ;  case  6:  //  probably  not  legal  ,  but  let's  allow  sb  .  insert  (  offset  ,   "00  .  000 "  )  ;  case  5:  //  is  legal  to  omit  seconds  sb  .  insert  (  offset  ,   ":00  .  000 "  )  ;  }  dateStr  =  sb  .  toString  (  )  ;  }  df  =  _formatISO8601  ;  formatStr  =  DATE_FORMAT_STR_ISO8601  ;  if  (  _formatISO8601  =  =  null  )  {  df  =  _formatISO8601  =  _cloneFormat  (  DATE_FORMAT_ISO8601  ,  formatStr  ,  _timezone  ,  _locale  ,  _lenient  )  ;  }  }  else  {  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  int  timeLen  =  len  -  dateStr  .  lastIndexOf  (  'T'  )  -  1  ;  if  (  timeLen  <  12  )  {  //  missing  ,  or  partial  [BUGGY]  switch  (  timeLen  )  {  case  11:  sb  .  append  (  '0'  )  ;  case  10:  sb  .  append  (  '0'  )  ;  case  9:  sb  .  append  (  '0'  )  ;  break  ;  default:  	JacksonDatabind_87_StdDateFormat_10_7	518	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1408	dateStr  =  sb.toString();  df  =  _formatISO8601_noTz;  formatStr  =  DATE_FORMAT_STR_ISO8601_NO_TZ;  	[BUGGY]  df  =  _formatISO8601_z  ;  formatStr  =  DATE_FORMAT_STR_ISO8601_Z  ;  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [METHOD]  parseAsISO8601  [TYPE]  Date  [PARAMETER]  String  dateStr  ParsePosition  pos  boolean  throwErrors  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  [TYPE]  StringBuilder  sb  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_ISO8601_Z  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  dateStr  formatStr  [TYPE]  String[]  ALL_FORMATS  [TYPE]  int  len  offset  timeLen  [TYPE]  Date  dt  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  [TYPE]  boolean  false  throwErrors  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_ISO8601_Z  DATE_FORMAT_PLAIN  DATE_FORMAT_RFC1123  _formatISO8601  _formatISO8601_z  _formatPlain  _formatRFC1123  df  [TYPE]  char  c  [TYPE]  Boolean  _lenient  [TYPE]  ParsePosition  pos  [CONTEXT]  case  5:  //  is  legal  to  omit  seconds  sb  .  insert  (  offset  ,   ":00  .  000 "  )  ;  }  dateStr  =  sb  .  toString  (  )  ;  }  df  =  _formatISO8601  ;  formatStr  =  DATE_FORMAT_STR_ISO8601  ;  if  (  _formatISO8601  =  =  null  )  {  df  =  _formatISO8601  =  _cloneFormat  (  DATE_FORMAT_ISO8601  ,  formatStr  ,  _timezone  ,  _locale  ,  _lenient  )  ;  }  }  else  {  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  int  timeLen  =  len  -  dateStr  .  lastIndexOf  (  'T'  )  -  1  ;  if  (  timeLen  <  12  )  {  //  missing  ,  or  partial  switch  (  timeLen  )  {  case  11:  sb  .  append  (  '0'  )  ;  case  10:  sb  .  append  (  '0'  )  ;  case  9:  sb  .  append  (  '0'  )  ;  break  ;  default:  sb  .  append  (   "  .  000 "  )  ;  }  [BUGGY]  }  sb  .  append  (  'Z'  )  ;  dateStr  =  sb  .  toString  (  )  ;  df  =  _formatISO8601_z  ;  formatStr  =  DATE_FORMAT_STR_ISO8601_Z  ;  if  (  df  =  =  null  )  {  	JacksonDatabind_87_StdDateFormat_10_8	526	2	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1409	df  =  _formatISO8601_noTz  =  _cloneFormat(DATE_FORMAT_ISO8601_NO_TZ,  formatStr,  _timezone,  _locale,  _lenient);  	[BUGGY]  df  =  _formatISO8601_z  =  _cloneFormat  (  DATE_FORMAT_ISO8601_Z  ,  formatStr  ,  DEFAULT_TIMEZONE  ,  _locale  ,  _lenient  )  ;  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [METHOD]  parseAsISO8601  [TYPE]  Date  [PARAMETER]  String  dateStr  ParsePosition  pos  boolean  throwErrors  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  [TYPE]  StringBuilder  sb  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_ISO8601_Z  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  dateStr  formatStr  [TYPE]  String[]  ALL_FORMATS  [TYPE]  int  len  offset  timeLen  [TYPE]  Date  dt  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  [TYPE]  boolean  false  throwErrors  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_ISO8601_Z  DATE_FORMAT_PLAIN  DATE_FORMAT_RFC1123  _formatISO8601  _formatISO8601_z  _formatPlain  _formatRFC1123  df  [TYPE]  char  c  [TYPE]  Boolean  _lenient  [TYPE]  ParsePosition  pos  [CONTEXT]  _timezone  ,  _locale  ,  _lenient  )  ;  }  }  else  {  StringBuilder  sb  =  new  StringBuilder  (  dateStr  )  ;  int  timeLen  =  len  -  dateStr  .  lastIndexOf  (  'T'  )  -  1  ;  if  (  timeLen  <  12  )  {  //  missing  ,  or  partial  switch  (  timeLen  )  {  case  11:  sb  .  append  (  '0'  )  ;  case  10:  sb  .  append  (  '0'  )  ;  case  9:  sb  .  append  (  '0'  )  ;  break  ;  default:  sb  .  append  (   "  .  000 "  )  ;  }  }  sb  .  append  (  'Z'  )  ;  dateStr  =  sb  .  toString  (  )  ;  df  =  _formatISO8601_z  ;  formatStr  =  DATE_FORMAT_STR_ISO8601_Z  ;  if  (  df  =  =  null  )  {    [BUGGY]  df  =  _formatISO8601_z  =  _cloneFormat  (  DATE_FORMAT_ISO8601_Z  ,  formatStr  ,  DEFAULT_TIMEZONE  ,  _locale  ,  _lenient  )  ;  }  }  }  Date  dt  =  df  .  parse  (  dateStr  ,  pos  )  ;  	JacksonDatabind_87_StdDateFormat_10_9	535	2	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1410	_formatISO8601_noTz  =  null;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Wed  Dec  31  16:00:00  PST  1969>  but  was:<Wed  Dec  31  18:00:00  PST  1969>  assertEquals  (  2  ,  c  .  get  (  Calendar  .  HOUR_OF_DAY  )  )  ;  [METHOD]  _clearFormats  [TYPE]  void  [PARAMETER]  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  [TYPE]  boolean  false  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_ISO8601_Z  DATE_FORMAT_PLAIN  DATE_FORMAT_RFC1123  _formatISO8601  _formatISO8601_z  _formatPlain  _formatRFC1123  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_ISO8601_Z  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  [TYPE]  String[]  ALL_FORMATS  [TYPE]  Boolean  _lenient  [CONTEXT]  protected  void  _clearFormats  (  )  {  _formatRFC1123  =  null  ;  _formatISO8601  =  null  ;  _formatISO8601_z  =  null  ;  [BUGGY]  _formatPlain  =  null  ;  }  	JacksonDatabind_87_StdDateFormat_10_10	597	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1411	if  (!t.isTypeOrSubTypeOf(_baseType.getRawClass()))  {\n',   "                                     "Class  %s  not  subtype  of  %s ",  t.getRawClass().getName(),  _baseType));  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [not  subtype  of]  )  :  got  one  (  of  type  comfasterxmljacksondatabindJsonMappingException  )  with  message   "Problem  deserializing  property  [METHOD]  _typeFromId  [TYPE]  JavaType  [PARAMETER]  String  id  DatabindContext  ctxt  [CLASS]  ClassNameIdResolver  [TYPE]  DatabindContext  ctxt  [TYPE]  JavaType  t  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  dctxt  [TYPE]  Class  cls  [TYPE]  String  id  [TYPE]  TypeFactory  tf  [TYPE]  ClassNotFoundException  e  [TYPE]  Exception  e  [CONTEXT]  protected  JavaType  _typeFromId  (  String  id  ,  DatabindContext  ctxt  )  throws  IOException  {      TypeFactory  tf  =  ctxt  .  getTypeFactory  (  )  ;  if  (  id  .  indexOf  (  '<'  )  >  0  )  {      JavaType  t  =  tf  .  constructFromCanonical  (  id  )  ;  [BUGGY]  return  t  ;  }  Class<?>  cls  ;  try  {  cls  =  tf  .  findClass  (  id  )  ;  	JacksonDatabind_88_ClassNameIdResolver_1_1	58	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java
1412	s.add( "java.util.logging.FileHandler ");  s.add( "java.rmi.server.UnicastRemoteObject ");  s.add( "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor ");  s.add( "org.springframework.beans.factory.config.PropertyPathFactoryBean ");  s.add( "com.mchange.v2.c3p0.JndiRefForwardingDataSource ");  s.add( "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource ");  	[BUGGY]  [FE]  AssertionFailedError:  Should  not  pass  [CLASS]  [CONTEXT]  	JacksonDatabind_89_BeanDeserializerFactory_1_1	65	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1413	||  canCreateUsingDelegate()  ||  canCreateUsingArrayDelegate()  	[BUGGY]  ||  canCreateUsingDelegate  (  )  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindcreatorsDelegatingArrayCreator1804Test$MyType:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  contain  additional  type  information  assertNotNull  (  thing  )  ;  [METHOD]  canInstantiate  [TYPE]  boolean  [PARAMETER]  [CLASS]  ValueInstantiator  [TYPE]  Class  _valueType  [TYPE]  boolean  false  true  [CONTEXT]  public  boolean  canInstantiate  (  )  {  return  canCreateUsingDefault  (  )  [BUGGY]  ||  canCreateUsingDelegate  (  )  ||  canCreateFromObjectWith  (  )  ||  canCreateFromString  (  )  ||  canCreateFromInt  (  )  ||  canCreateFromLong  (  )  ||  canCreateFromDouble  (  )  ||  canCreateFromBoolean  (  )  ;  }  	JacksonDatabind_90_ValueInstantiator_1_1	72	1	src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java
1414	@Override  public  boolean  canInstantiate()  {  return  canCreateUsingDefault()  ||  canCreateUsingDelegate()  ||  canCreateUsingArrayDelegate()  ||  canCreateFromObjectWith()  ||  canCreateFromString()  ||  canCreateFromInt()  ||  canCreateFromLong()  ||  canCreateFromDouble()  ||  canCreateFromBoolean();  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Can  not  construct  instance  of  comfasterxmljacksondatabindcreatorsDelegatingArrayCreator1804Test$MyType:  abstract  types  either  need  to  be  mapped  to  concrete  types  ,  have  custom  deserializer  ,  or  contain  additional  type  information  assertNotNull  (  thing  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_90_StdValueInstantiator_1_1	232	0	src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java
1415	if  ((ct.getValueHandler()  !=  null)  ||  (ct.getTypeHandler()  !=  null))  {  return  true;  }  }  if  (t.isMapLikeType())  {  JavaType  kt  =  t.getKeyType();  if  (kt.getValueHandler()  !=  null)  {  return  true;  }  	[BUGGY]  return  (  ct  .  getValueHandler  (  )  !  =  null  )  ||  (  ct  .  getTypeHandler  (  )  !  =  null  )  ;  [FE]  AssertionFailedError:  Not  using  custom  key  deserializer  for  input:  { "data ":{ "1st ": "onedata "  ,   "2nd ": "twodata "}}  ;  resulted  in:  {1st  =  onedata  ,  2nd  =  twodata}  assertTrue  (  ignored  .  data  .  containsKey  (   "2nd "  )  )  ;  [METHOD]  _hasCustomHandlers  [TYPE]  boolean  [PARAMETER]  JavaType  t  [CLASS]  DeserializerCache  [TYPE]  JavaType  ct  t  [TYPE]  boolean  false  true  [TYPE]  ConcurrentHashMap  _cachedDeserializers  [TYPE]  HashMap  _incompleteDeserializers  [TYPE]  long  serialVersionUID  [CONTEXT]  private  boolean  _hasCustomHandlers  (  JavaType  t  )  {  if  (  t  .  isContainerType  (  )  )  {  JavaType  ct  =  t  .  getContentType  (  )  ;  if  (  ct  !  =  null  )  {  [BUGGY]  return  (  ct  .  getValueHandler  (  )  !  =  null  )  ||  (  ct  .  getTypeHandler  (  )  !  =  null  )  ;  }  }  return  false  ;  }  	JacksonDatabind_91_DeserializerCache_1_1	541	1	src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
1416	s.add( "java.util.logging.FileHandler ");  s.add( "java.rmi.server.UnicastRemoteObject ");  s.add( "org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor ");  s.add( "org.springframework.beans.factory.config.PropertyPathFactoryBean ");  s.add( "com.mchange.v2.c3p0.JndiRefForwardingDataSource ");  s.add( "com.mchange.v2.c3p0.WrapperConnectionPoolDataSource ");  	[BUGGY]  [FE]  AssertionFailedError:  Should  not  pass  [CLASS]  [CONTEXT]  	JacksonDatabind_92_BeanDeserializerFactory_1_1	64	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1417	if  (!raw.isInterface()  &&  full.startsWith(PREFIX_STRING))  {  for  (Class<?>  cls  =  raw;  (cls  !=  null)  &&  (cls  !=  Object.class);  cls  =  cls.getSuperclass())  {  	[BUGGY]  if  (  full  .  startsWith  (  PREFIX_STRING  )  )  {  for  (  Class<?>  cls  =  raw  ;  cls  !  =  Object  .  class  ;  cls  =  cls  .  getSuperclass  (  )  )  {  [FE]  NullPointerException  assertNotNull  (  result  )  ;  [METHOD]  validateSubType  [TYPE]  void  [PARAMETER]  DeserializationContext  ctxt  JavaType  type  [CLASS]  SubTypeValidator  [TYPE]  JavaType  type  [TYPE]  Set  DEFAULT_NO_DESER_CLASS_NAMES  _cfgIllegalClassNames  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  SubTypeValidator  instance  [TYPE]  Class  cls  raw  [TYPE]  String  PREFIX_STRING  full  name  [CONTEXT]  public  void  validateSubType  (  DeserializationContext  ctxt  ,  JavaType  type  )  throws  JsonMappingException  {    final  Class<?>  raw  =  type  .  getRawClass  (  )  ;  String  full  =  raw  .  getName  (  )  ;  main_check:  do  {  if  (  _cfgIllegalClassNames  .  contains  (  full  )  )  {  break  ;  }    [BUGGY]  if  (  full  .  startsWith  (  PREFIX_STRING  )  )  {  for  (  Class<?>  cls  =  raw  ;  cls  !  =  Object  .  class  ;  cls  =  cls  .  getSuperclass  (  )  )  {  String  name  =  cls  .  getSimpleName  (  )  ;  if  (   "AbstractPointcutAdvisor "  .  equals  (  name  )    	JacksonDatabind_93_SubTypeValidator_1_1	83	2	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java
1418	protected  final  static  String  PREFIX_C3P0  =   "com.mchange.v2.c3p0. ";  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "Can  not  instantiate  value  of  type  [simple  type  ,  class  commchangev2c3p0jacksontestComboPooledDataSource]  from  String  value  (    [CLASS]  [CONTEXT]  	JacksonDatabind_94_SubTypeValidator_3_1	23	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java
1419	}  }  else  if  (full.startsWith(PREFIX_C3P0))  {  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "Can  not  instantiate  value  of  type  [simple  type  ,  class  commchangev2c3p0jacksontestComboPooledDataSource]  from  String  value  (  [METHOD]  validateSubType  [TYPE]  void  [PARAMETER]  DeserializationContext  ctxt  JavaType  type  [CLASS]  SubTypeValidator  [TYPE]  JavaType  type  [TYPE]  Set  DEFAULT_NO_DESER_CLASS_NAMES  _cfgIllegalClassNames  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  SubTypeValidator  instance  [TYPE]  Class  cls  raw  [TYPE]  String  PREFIX_SPRING  full  name  [CONTEXT]    final  Class<?>  raw  =  type  .  getRawClass  (  )  ;  String  full  =  raw  .  getName  (  )  ;  main_check:  do  {  if  (  _cfgIllegalClassNames  .  contains  (  full  )  )  {  break  ;  }    if  (  raw  .  isInterface  (  )  )  {  ;  }  else  if  (  full  .  startsWith  (  PREFIX_SPRING  )  )  {  for  (  Class<?>  cls  =  raw  ;  (  cls  !  =  null  )  &&  (  cls  !  =  Object  .  class  )  ;  cls  =  cls  .  getSuperclass  (  )  )  {  String  name  =  cls  .  getSimpleName  (  )  ;  if  (   "AbstractPointcutAdvisor "  .  equals  (  name  )    ||   "AbstractApplicationContext "  .  equals  (  name  )  )  {  break  main_check  ;  }  [BUGGY]        	JacksonDatabind_94_SubTypeValidator_3_2	98	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java
1420	if  (full.endsWith( "DataSource "))  {  break  main_check;  	[BUGGY]  [FE]  AssertionFailedError:  Expected  an  exception  with  one  of  substrings  (  [Illegal  type]  )  :  got  one  with  message   "Can  not  instantiate  value  of  type  [simple  type  ,  class  commchangev2c3p0jacksontestComboPooledDataSource]  from  String  value  (  [METHOD]  validateSubType  [TYPE]  void  [PARAMETER]  DeserializationContext  ctxt  JavaType  type  [CLASS]  SubTypeValidator  [TYPE]  JavaType  type  [TYPE]  Set  DEFAULT_NO_DESER_CLASS_NAMES  _cfgIllegalClassNames  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  SubTypeValidator  instance  [TYPE]  Class  cls  raw  [TYPE]  String  PREFIX_SPRING  full  name  [CONTEXT]  do  {  if  (  _cfgIllegalClassNames  .  contains  (  full  )  )  {  break  ;  }    if  (  raw  .  isInterface  (  )  )  {  ;  }  else  if  (  full  .  startsWith  (  PREFIX_SPRING  )  )  {  for  (  Class<?>  cls  =  raw  ;  (  cls  !  =  null  )  &&  (  cls  !  =  Object  .  class  )  ;  cls  =  cls  .  getSuperclass  (  )  )  {  String  name  =  cls  .  getSimpleName  (  )  ;  if  (   "AbstractPointcutAdvisor "  .  equals  (  name  )    ||   "AbstractApplicationContext "  .  equals  (  name  )  )  {  break  main_check  ;  }        [BUGGY]  }  }  return  ;  }  while  (  false  )  ;  throw  JsonMappingException  .  from  (  ctxt  ,  	JacksonDatabind_94_SubTypeValidator_3_3	104	0	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java
1421	newType  =  _fromClass(null,  subclass,  EMPTY_BINDINGS);  	[BUGGY]  newType  =  _fromClass  (  null  ,  subclass  ,  TypeBindings  .  emptyBindings  (  )  )  ;  [FE]  NullPointerException  assertEquals  (  t  ,  tf  .  constructFromCanonical  (  can  )  )  ;  [METHOD]  constructSpecializedType  [TYPE]  JavaType  [PARAMETER]  JavaType  baseType  Class<?>  subclass  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  long  serialVersionUID  [TYPE]  int  typeParamCount  [TYPE]  TypeBindings  EMPTY_BINDINGS  tb  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  JavaType  baseType  newType  [TYPE]  boolean  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  rawBase  subclass  [TYPE]  TypeFactory  instance  [CONTEXT]  public  JavaType  constructSpecializedType  (  JavaType  baseType  ,  Class<?>  subclass  )  {  final  Class<?>  rawBase  =  baseType  .  getRawClass  (  )  ;  if  (  rawBase  =  =  subclass  )  {  return  baseType  ;  }  JavaType  newType  ;    do  {  //  bogus  loop  to  be  able  to  break  if  (  rawBase  =  =  Object  .  class  )  {  [BUGGY]  newType  =  _fromClass  (  null  ,  subclass  ,  TypeBindings  .  emptyBindings  (  )  )  ;  break  ;  }  if  (  !rawBase  .  isAssignableFrom  (  subclass  )  )  {  throw  new  IllegalArgumentException  (  String  .  format  (   "Class  %s  not  subtype  of  %s "  ,  subclass  .  getName  (  )  ,  baseType  )  )  ;  	JacksonDatabind_95_TypeFactory_3_1	355	1	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1422	newType  =  _fromClass(null,  subclass,  EMPTY_BINDINGS);  	[BUGGY]  newType  =  _fromClass  (  null  ,  subclass  ,  TypeBindings  .  emptyBindings  (  )  )  ;  [FE]  NullPointerException  assertEquals  (  t  ,  tf  .  constructFromCanonical  (  can  )  )  ;  [METHOD]  constructSpecializedType  [TYPE]  JavaType  [PARAMETER]  JavaType  baseType  Class<?>  subclass  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  long  serialVersionUID  [TYPE]  int  typeParamCount  [TYPE]  TypeBindings  EMPTY_BINDINGS  tb  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  JavaType  baseType  newType  [TYPE]  boolean  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  rawBase  subclass  [TYPE]  TypeFactory  instance  [CONTEXT]  public  JavaType  constructSpecializedType  (  JavaType  baseType  ,  Class<?>  subclass  )  {  final  Class<?>  rawBase  =  baseType  .  getRawClass  (  )  ;  if  (  rawBase  =  =  subclass  )  {  return  baseType  ;  }  JavaType  newType  ;    do  {  //  bogus  loop  to  be  able  to  break  if  (  rawBase  =  =  Object  .  class  )  {  newType  =  _fromClass  (  null  ,  subclass  ,  TypeBindings  .  emptyBindings  (  )  )  ;  break  ;  }  if  (  !rawBase  .  isAssignableFrom  (  subclass  )  )  {  throw  new  IllegalArgumentException  (  String  .  format  (   "Class  %s  not  subtype  of  %s "  ,  subclass  .  getName  (  )  ,  baseType  )  )  ;  }    if  (  baseType  .  getBindings  (  )  .  isEmpty  (  )  )  {  [BUGGY]  newType  =  _fromClass  (  null  ,  subclass  ,  TypeBindings  .  emptyBindings  (  )  )  ;  break  ;  }  if  (  baseType  .  isContainerType  (  )  )  {  if  (  baseType  .  isMapLikeType  (  )  )  {  	JacksonDatabind_95_TypeFactory_3_2	366	1	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1423	pt[i]  =  _fromClass(null,  parameterClasses[i],  EMPTY_BINDINGS);  	[BUGGY]  pt[i]  =  _fromClass  (  null  ,  parameterClasses[i]  ,  null  )  ;  [FE]  NullPointerException  assertEquals  (  t  ,  tf  .  constructFromCanonical  (  can  )  )  ;  [METHOD]  constructParametricType  [TYPE]  JavaType  [PARAMETER]  Class<?>  parametrized  parameterClasses  [CLASS]  TypeFactory  [TYPE]  TypeModifier[]  _modifiers  [TYPE]  TypeParser  _parser  [TYPE]  Class[]  parameterClasses  [TYPE]  long  serialVersionUID  [TYPE]  int  i  len  [TYPE]  TypeBindings  EMPTY_BINDINGS  [TYPE]  SimpleType  CORE_TYPE_BOOL  CORE_TYPE_CLASS  CORE_TYPE_COMPARABLE  CORE_TYPE_ENUM  CORE_TYPE_INT  CORE_TYPE_LONG  CORE_TYPE_OBJECT  CORE_TYPE_STRING  [TYPE]  boolean  false  true  [TYPE]  LRUMap  _typeCache  [TYPE]  ClassLoader  _classLoader  [TYPE]  JavaType[]  NO_TYPES  pt  [TYPE]  Class  CLS_BOOL  CLS_CLASS  CLS_COMPARABLE  CLS_ENUM  CLS_INT  CLS_LONG  CLS_OBJECT  CLS_STRING  parametrized  [TYPE]  TypeFactory  instance  [CONTEXT]  public  JavaType  constructParametricType  (  Class<?>  parametrized  ,  Class<?>  .  .  .  parameterClasses  )  {  int  len  =  parameterClasses  .  length  ;  JavaType[]  pt  =  new  JavaType[len]  ;  for  (  int  i  =  0  ;  i  <  len  ;  ++i  )  {  [BUGGY]  pt[i]  =  _fromClass  (  null  ,  parameterClasses[i]  ,  null  )  ;  }  return  constructParametricType  (  parametrized  ,  pt  )  ;  }  	JacksonDatabind_95_TypeFactory_3_3	896	1	src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java
1424	return  _factory._fromClass(null,  base,  TypeBindings.emptyBindings());  	[BUGGY]  return  _factory  .  _fromClass  (  null  ,  base  ,  null  )  ;  [FE]  NullPointerException  assertEquals  (  t  ,  tf  .  constructFromCanonical  (  can  )  )  ;  [METHOD]  parseType  [TYPE]  JavaType  [PARAMETER]  MyTokenizer  tokens  [CLASS]  TypeParser  [TYPE]  MyTokenizer  tokens  [TYPE]  boolean  false  true  [TYPE]  Class  base  [TYPE]  List  parameterTypes  [TYPE]  String  _input  _pushbackToken  token  [TYPE]  TypeFactory  _factory  [TYPE]  long  serialVersionUID  [TYPE]  int  _index  [TYPE]  TypeBindings  b  [CONTEXT]  protected  JavaType  parseType  (  MyTokenizer  tokens  )  throws  IllegalArgumentException  {  if  (  !tokens  .  hasMoreTokens  (  )  )  {  throw  _problem  (  tokens  ,   "Unexpected  end-of-string "  )  ;  }  Class<?>  base  =  findClass  (  tokens  .  nextToken  (  )  ,  tokens  )  ;    if  (  tokens  .  hasMoreTokens  (  )  )  {  String  token  =  tokens  .  nextToken  (  )  ;  if  (   "< "  .  equals  (  token  )  )  {  List<JavaType>  parameterTypes  =  parseTypes  (  tokens  )  ;  TypeBindings  b  =  TypeBindings  .  create  (  base  ,  parameterTypes  )  ;  return  _factory  .  _fromClass  (  null  ,  base  ,  b  )  ;  }  tokens  .  pushBack  (  token  )  ;  }  [BUGGY]  return  _factory  .  _fromClass  (  null  ,  base  ,  null  )  ;  }  	JacksonDatabind_95_TypeParser_1_1	59	1	src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java
1425	paramName  =  candidate.paramName(0);  	[BUGGY]  paramName  =  candidate  .  findImplicitParamName  (  0  )  ;  [FE]  jacksondatabindexcInvalidDefinitionException:  Invalid  definition  for  property  `param_name0`  (  of  type  `comfasterxmljacksondatabinddesercreatorsCreatorWithNamingStrategyTest$OneProperty`  )  :  Could  not  find  creator  property  with  name  'param_name0'  (  known  Creator  properties:  [paramName0]  )  assertEquals  (   "CTOR: "+MSG  ,  actual  .  paramName0  )  ;  [METHOD]  _addExplicitAnyCreator  [TYPE]  void  [PARAMETER]  DeserializationContext  ctxt  BeanDescription  beanDesc  CreatorCollector  creators  CreatorCandidate  candidate  [CLASS]  BasicDeserializerFactory  [TYPE]  PropertyName  UNWRAPPED_CREATOR_PARAM_NAME  paramName  [TYPE]  DeserializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _collectionFallbacks  _mapFallbacks  [TYPE]  AnnotatedParameter  param  [TYPE]  BeanDescription  beanDesc  [TYPE]  SettableBeanProperty[]  properties  [TYPE]  int  oneNotInjected  [TYPE]  boolean  false  true  useProps  [TYPE]  Value  injectId  [TYPE]  BeanPropertyDefinition  paramDef  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  CLASS_CHAR_SEQUENCE  CLASS_ITERABLE  CLASS_MAP_ENTRY  CLASS_OBJECT  CLASS_STRING  [TYPE]  CreatorCollector  creators  [TYPE]  CreatorCandidate  candidate  [CONTEXT]  int  oneNotInjected  =  candidate  .  findOnlyParamWithoutInjection  (  )  ;  if  (  oneNotInjected  >  =  0  )  {  if  (  candidate  .  paramName  (  oneNotInjected  )  =  =  null  )  {  _addExplicitDelegatingCreator  (  ctxt  ,  beanDesc  ,  creators  ,  candidate  )  ;  return  ;  }  }  _addExplicitPropertyCreator  (  ctxt  ,  beanDesc  ,  creators  ,  candidate  )  ;  return  ;  }  AnnotatedParameter  param  =  candidate  .  parameter  (  0  )  ;  JacksonInject  .  Value  injectId  =  candidate  .  injection  (  0  )  ;  PropertyName  paramName  =  candidate  .  explicitParamName  (  0  )  ;  BeanPropertyDefinition  paramDef  =  candidate  .  propertyDef  (  0  )  ;    boolean  useProps  =  (  paramName  !  =  null  )  ||  (  injectId  !  =  null  )  ;  if  (  !useProps  &&  (  paramDef  !  =  null  )  )  {      [BUGGY]  paramName  =  candidate  .  findImplicitParamName  (  0  )  ;  useProps  =  (  paramName  !  =  null  )  &&  paramDef  .  couldSerialize  (  )  ;  }  if  (  useProps  )  {  SettableBeanProperty[]  properties  =  new  SettableBeanProperty[]  {  constructCreatorProperty  (  ctxt  ,  beanDesc  ,  paramName  ,  0  ,  param  ,  injectId  )  	JacksonDatabind_96_BasicDeserializerFactory_1_1	735	1	src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
1426	ctxt.defaultSerializeValue(_value,  gen);  	[BUGGY]  gen  .  writeObject  (  _value  )  ;  [FE]  ComparisonFailure:  expected:<Str ": "The  value  is:  [Hello!] "}}>  but  was:<Str ": "The  value  is:  [NULL] "}}>  assertEquals  (  EXP  ,  treeOut  )  ;  [METHOD]  serialize  [TYPE]  void  [PARAMETER]  JsonGenerator  gen  SerializerProvider  ctxt  [CLASS]  POJONode  [TYPE]  JsonGenerator  gen  [TYPE]  Object  _value  [TYPE]  boolean  false  true  [TYPE]  SerializerProvider  ctxt  [CONTEXT]  public  final  void  serialize  (  JsonGenerator  gen  ,  SerializerProvider  ctxt  )  throws  IOException  {  if  (  _value  =  =  null  )  {  ctxt  .  defaultSerializeNull  (  gen  )  ;  }  else  if  (  _value  instanceof  JsonSerializable  )  {  (  (  JsonSerializable  )  _value  )  .  serialize  (  gen  ,  ctxt  )  ;  }  else  {    [BUGGY]  gen  .  writeObject  (  _value  )  ;  }  }  	JacksonDatabind_97_POJONode_1_1	114	1	src/main/java/com/fasterxml/jackson/databind/node/POJONode.java
1427	final  Object  v;  if  (typeProp.getType().hasRawClass(String.class))  {  v  =  typeId;  }  else  {  TokenBuffer  tb  =  new  TokenBuffer(p,  ctxt);  tb.writeString(typeId);  v  =  typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(),  ctxt);  tb.close();  }  buffer.assignParameter(typeProp,  v);  	[BUGGY]  buffer  .  assignParameter  (  typeProp  ,  typeId  )  ;  [FE]  jacksondatabindexcInvalidDefinitionException:  Cannot  construct  instance  of  `comfasterxmljacksondatabindjsontypeextExternalTypeIdWithEnum1328Test$AnimalAndType`  ,  problem:  argument  type  mismatch  assertNotNull  (  list  )  ;  [METHOD]  complete  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  PropertyValueBuffer  buffer  PropertyBasedCreator  creator  [CLASS]  ExternalTypeHandler  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  SettableBeanProperty  _property  _typeProperty  prop  typeProp  [TYPE]  TokenBuffer[]  _tokens  [TYPE]  String[]  _typeIds  [TYPE]  String  _typePropertyName  typeId  [TYPE]  PropertyBasedCreator  creator  [TYPE]  int  i  len  [TYPE]  JavaType  _beanType  [TYPE]  boolean  false  true  [TYPE]  ExtTypedProperty  extProp  [TYPE]  DeserializationContext  ctxt  [TYPE]  List  _properties  [TYPE]  Object  bean  [TYPE]  ExtTypedProperty[]  _properties  [TYPE]  TypeDeserializer  _typeDeserializer  [TYPE]  Map  _nameToPropertyIndex  [TYPE]  Object[]  values  [TYPE]  JsonParser  p  [CONTEXT]  ctxt  .  reportInputMismatch  (  _beanType  ,   "Missing  external  type  id  property  '%s' "  ,  extProp  .  getTypePropertyName  (  )  )  ;  }  else  {  typeId  =  extProp  .  getDefaultTypeId  (  )  ;  }  }  else  if  (  _tokens[i]  =  =  null  )  {  SettableBeanProperty  prop  =  extProp  .  getProperty  (  )  ;  ctxt  .  reportInputMismatch  (  _beanType  ,   "Missing  property  '%s'  for  external  type  id  '%s' "  ,  prop  .  getName  (  )  ,  _properties[i]  .  getTypePropertyName  (  )  )  ;  }  values[i]  =  _deserialize  (  p  ,  ctxt  ,  i  ,  typeId  )  ;  final  SettableBeanProperty  prop  =  extProp  .  getProperty  (  )  ;  if  (  prop  .  getCreatorIndex  (  )  >  =  0  )  {  buffer  .  assignParameter  (  prop  ,  values[i]  )  ;    SettableBeanProperty  typeProp  =  extProp  .  getTypeProperty  (  )  ;  if  (  (  typeProp  !  =  null  )  &&  (  typeProp  .  getCreatorIndex  (  )  >  =  0  )  )  {    [BUGGY]  buffer  .  assignParameter  (  typeProp  ,  typeId  )  ;  }  }  }  Object  bean  =  creator  .  build  (  ctxt  ,  buffer  )  ;  	JacksonDatabind_98_ExternalTypeHandler_1_1	298	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java
1428	sb.append('>');	[BUGGY]  [FE]  ComparisonFailure:  expected:<rence<javalangLong[>]>  but  was:<rence<javalangLong[]>  assertEquals  (  t  ,  tf  .  constructFromCanonical  (  can  )  )  ;  [METHOD]  buildCanonicalName  [TYPE]  String  [PARAMETER]  [CLASS]  ReferenceType  [TYPE]  JavaType  _anchorType  _referencedType  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  sb  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  String  buildCanonicalName  (  )  {  StringBuilder  sb  =  new  StringBuilder  (  )  ;  sb  .  append  (  _class  .  getName  (  )  )  ;  sb  .  append  (  '<'  )  ;  sb  .  append  (  _referencedType  .  toCanonical  (  )  )  ;  [BUGGY]  return  sb  .  toString  (  )  ;  }  	JacksonDatabind_99_ReferenceType_1_1	169	0	src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java
1429	if  (n  instanceof  TextNode)  {  return  ((TextNode)  n).getBinaryValue(b64variant);  return  n.binaryValue();  	[BUGGY]  byte[]  data  =  n  .  binaryValue  (  )  ;  if  (  data  !  =  null  )  {  return  data  ;  }  if  (  n  .  isPojo  (  )  )  {  Object  ob  =  (  (  POJONode  )  n  )  .  getPojo  (  )  ;  if  (  ob  instanceof  byte[]  )  {  return  (  byte[]  )  ob  ;  }  [FE]  AssertionFailedError:  Failed  (  variant  MODIFIED-FOR-URL  ,  data  length  1  )  :  Cannot  access  contents  of  TextNode  as  binary  due  to  broken  Base64  encoding:  Unexpected  end-of-String  in  base64  content  assertArrayEquals  (  data  ,  input  )  ;  [METHOD]  getBinaryValue  [TYPE]  byte[]  [PARAMETER]  Base64Variant  b64variant  [CLASS]  TreeTraversingParser  [TYPE]  byte[]  data  [TYPE]  boolean  _closed  _startContainer  false  true  [TYPE]  Base64Variant  b64variant  [TYPE]  NodeCursor  _nodeCursor  [TYPE]  JsonToken  _nextToken  [TYPE]  JsonNode  n  [TYPE]  Object  ob  [TYPE]  ObjectCodec  _objectCodec  [CONTEXT]  public  byte[]  getBinaryValue  (  Base64Variant  b64variant  )  throws  IOException  ,  JsonParseException  {  JsonNode  n  =  currentNode  (  )  ;  if  (  n  !  =  null  )  {    [BUGGY]  byte[]  data  =  n  .  binaryValue  (  )  ;  if  (  data  !  =  null  )  {  return  data  ;  }  if  (  n  .  isPojo  (  )  )  {  Object  ob  =  (  (  POJONode  )  n  )  .  getPojo  (  )  ;  if  (  ob  instanceof  byte[]  )  {  return  (  byte[]  )  ob  ;  }  }  }  return  null  ;  }  	JacksonDatabind_100_TreeTraversingParser_1_1	363	9	src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java
1430		[BUGGY]  p  .  nextToken  (  )  ;  [FE]  AssertionFailedError:  expected:<4>  but  was:<0>  assertEquals  (  4  ,  bean  .  w  .  b  )  ;  [METHOD]  deserializeUsingPropertyBasedWithUnwrapped  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializer  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  SettableBeanProperty  _prop  creatorProp  prop  [TYPE]  String  propName  [TYPE]  PropertyBasedCreator  creator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  _nullFromCreator  e  [TYPE]  NameTransformer  _currentlyTransforming  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  b2  tokens  [TYPE]  DeserializationContext  _context  ctxt  [TYPE]  Object  _bean  bean  [TYPE]  JsonToken  t  [TYPE]  JsonParser  p  [CONTEXT]  TokenBuffer  tokens  =  new  TokenBuffer  (  p  ,  ctxt  )  ;  tokens  .  writeStartObject  (  )  ;  JsonToken  t  =  p  .  getCurrentToken  (  )  ;  for  (  ;  t  =  =  JsonToken  .  FIELD_NAME  ;  t  =  p  .  nextToken  (  )  )  {  String  propName  =  p  .  getCurrentName  (  )  ;  p  .  nextToken  (  )  ;  //  to  point  to  value  SettableBeanProperty  creatorProp  =  creator  .  findCreatorProperty  (  propName  )  ;  if  (  creatorProp  !  =  null  )  {  if  (  buffer  .  assignParameter  (  creatorProp  ,  _deserializeWithErrorWrapping  (  p  ,  ctxt  ,  creatorProp  )  )  )  {  t  =  p  .  nextToken  (  )  ;  //  to  move  to  following  FIELD_NAME/END_OBJECT  Object  bean  ;  try  {  bean  =  creator  .  build  (  ctxt  ,  buffer  )  ;  }  catch  (  Exception  e  )  {  bean  =  wrapInstantiationProblem  (  e  ,  ctxt  )  ;  }  p  .  setCurrentValue  (  bean  )  ;  while  (  t  =  =  JsonToken  .  FIELD_NAME  )  {  [BUGGY]  p  .  nextToken  (  )  ;  tokens  .  copyCurrentStructure  (  p  )  ;  t  =  p  .  nextToken  (  )  ;  }    	JacksonDatabind_101_BeanDeserializer_2_1	771	1	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1431	if  (t  !=  JsonToken.END_OBJECT)  {  ctxt.reportWrongTokenException(this,  JsonToken.END_OBJECT,   "Attempted  to  unwrap  \'%s\'  value ",  handledType().getName());  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<4>  but  was:<0>  assertEquals  (  4  ,  bean  .  w  .  b  )  ;  [METHOD]  deserializeUsingPropertyBasedWithUnwrapped  [TYPE]  Object  [PARAMETER]  JsonParser  p  DeserializationContext  ctxt  [CLASS]  BeanDeserializer  [TYPE]  PropertyValueBuffer  buffer  [TYPE]  SettableBeanProperty  _prop  creatorProp  prop  [TYPE]  String  propName  [TYPE]  PropertyBasedCreator  creator  [TYPE]  long  serialVersionUID  [TYPE]  Exception  _nullFromCreator  e  [TYPE]  NameTransformer  _currentlyTransforming  [TYPE]  boolean  false  true  [TYPE]  TokenBuffer  b2  tokens  [TYPE]  DeserializationContext  _context  ctxt  [TYPE]  Object  _bean  bean  [TYPE]  JsonToken  t  [TYPE]  JsonParser  p  [CONTEXT]  p  .  nextToken  (  )  ;  //  to  point  to  value  SettableBeanProperty  creatorProp  =  creator  .  findCreatorProperty  (  propName  )  ;  if  (  creatorProp  !  =  null  )  {  if  (  buffer  .  assignParameter  (  creatorProp  ,  _deserializeWithErrorWrapping  (  p  ,  ctxt  ,  creatorProp  )  )  )  {  t  =  p  .  nextToken  (  )  ;  //  to  move  to  following  FIELD_NAME/END_OBJECT  Object  bean  ;  try  {  bean  =  creator  .  build  (  ctxt  ,  buffer  )  ;  }  catch  (  Exception  e  )  {  bean  =  wrapInstantiationProblem  (  e  ,  ctxt  )  ;  }  p  .  setCurrentValue  (  bean  )  ;  while  (  t  =  =  JsonToken  .  FIELD_NAME  )  {  p  .  nextToken  (  )  ;  tokens  .  copyCurrentStructure  (  p  )  ;  t  =  p  .  nextToken  (  )  ;  }    [BUGGY]  tokens  .  writeEndObject  (  )  ;  if  (  bean  .  getClass  (  )  !  =  _beanType  .  getRawClass  (  )  )  {    ctxt  .  reportInputMismatch  (  creatorProp  ,   "Cannot  create  polymorphic  instances  with  unwrapped  values "  )  ;  	JacksonDatabind_101_BeanDeserializer_2_2	777	0	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java
1432		[BUGGY]  if  (  property  =  =  null  )  {  return  this  ;  }  [FE]  ComparisonFailure:  expected:<[ "1980+04+14 "]>  but  was:<[324547200000]>  assertEquals  (   "\ "1980+04+14\ " "  ,  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  serializers  BeanProperty  property  [CLASS]  DateTimeSerializerBase  [TYPE]  Locale  loc  [TYPE]  TimeZone  newTz  tz  [TYPE]  Shape  shape  [TYPE]  boolean  asString  changeTZ  false  hasLocale  hasTZ  true  [TYPE]  DateFormat  _customFormat  df0  [TYPE]  Value  format  [TYPE]  AtomicReference  _reusedCustomFormat  [TYPE]  StdDateFormat  std  [TYPE]  Boolean  _useTimestamp  [TYPE]  SerializerProvider  serializers  [TYPE]  SimpleDateFormat  df  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonSerializer<?>  createContextual  (  SerializerProvider  serializers  ,  BeanProperty  property  )  throws  JsonMappingException  {    [BUGGY]  if  (  property  =  =  null  )  {  return  this  ;  }  JsonFormat  .  Value  format  =  findFormatOverrides  (  serializers  ,  property  ,  handledType  (  )  )  ;  if  (  format  =  =  null  )  {  return  this  ;  	JacksonDatabind_102_DateTimeSerializerBase_1_1	67	3	src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java
1433	ClassUtil.exceptionMessage(e)));  	[BUGGY]  e  .  getMessage  (  )  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  resolveSubType  [TYPE]  JavaType  [PARAMETER]  JavaType  baseType  String  subClass  [CLASS]  DatabindContext  [TYPE]  JavaType  baseType  t  [TYPE]  boolean  false  true  [TYPE]  Class  cls  [TYPE]  String  subClass  [TYPE]  ClassNotFoundException  e  [TYPE]  int  MAX_ERROR_STR_LEN  [TYPE]  Exception  e  [CONTEXT]  public  JavaType  resolveSubType  (  JavaType  baseType  ,  String  subClass  )  throws  JsonMappingException  {    if  (  subClass  .  indexOf  (  '<'  )  >  0  )  {      JavaType  t  =  getTypeFactory  (  )  .  constructFromCanonical  (  subClass  )  ;  if  (  t  .  isTypeOrSubTypeOf  (  baseType  .  getRawClass  (  )  )  )  {  return  t  ;  }  }  else  {  Class<?>  cls  ;  try  {  cls  =  getTypeFactory  (  )  .  findClass  (  subClass  )  ;  }  catch  (  ClassNotFoundException  e  )  {  //  let  caller  handle  this  problem  return  null  ;  }  catch  (  Exception  e  )  {  throw  invalidTypeIdException  (  baseType  ,  subClass  ,  String  .  format  (   "problem:  (  %s  )  %s "  ,  e  .  getClass  (  )  .  getName  (  )  ,  [BUGGY]  e  .  getMessage  (  )  )  )  ;  }  if  (  baseType  .  isTypeOrSuperTypeOf  (  cls  )  )  {  return  getTypeFactory  (  )  .  constructSpecializedType  (  baseType  ,  cls  )  ;  }  }  	JacksonDatabind_103_DatabindContext_1_1	195	1	src/main/java/com/fasterxml/jackson/databind/DatabindContext.java
1434	ClassUtil.exceptionMessage(e)));  	[BUGGY]  e  .  getMessage  (  )  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  parseDate  [TYPE]  Date  [PARAMETER]  String  dateStr  [CLASS]  DeserializationContext  [TYPE]  LinkedNode  _currentType  [TYPE]  ArrayBuilders  _arrayBuilders  [TYPE]  DeserializationConfig  _config  [TYPE]  String  dateStr  [TYPE]  InjectableValues  _injectableValues  [TYPE]  long  serialVersionUID  [TYPE]  int  _featureFlags  [TYPE]  DeserializerFactory  _factory  [TYPE]  ObjectBuffer  _objectBuffer  [TYPE]  boolean  false  true  [TYPE]  ContextAttributes  _attributes  [TYPE]  DateFormat  _dateFormat  df  [TYPE]  Class  _view  [TYPE]  ParseException  e  [TYPE]  DeserializerCache  _cache  [TYPE]  JsonParser  _parser  [CONTEXT]  public  Date  parseDate  (  String  dateStr  )  throws  IllegalArgumentException  {  try  {  DateFormat  df  =  getDateFormat  (  )  ;  return  df  .  parse  (  dateStr  )  ;  }  catch  (  ParseException  e  )  {  throw  new  IllegalArgumentException  (  String  .  format  (   "Failed  to  parse  Date  value  '%s':  %s "  ,  dateStr  ,  [BUGGY]  e  .  getMessage  (  )  )  )  ;  }  }  	JacksonDatabind_103_DeserializationContext_2_1	714	1	src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java
1435	}  else  if  ((excMsg  =  ClassUtil.exceptionMessage(cause))  ==  null)  {  	[BUGGY]  }  else  if  (  (  excMsg  =  cause  .  getMessage  (  )  )  =  =  null  )  {  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  instantiationException  [TYPE]  JsonMappingException  [PARAMETER]  Class<?>  instClass  Throwable  cause  [CLASS]  DeserializationContext  [TYPE]  LinkedNode  _currentType  [TYPE]  InvalidDefinitionException  e  [TYPE]  ArrayBuilders  _arrayBuilders  [TYPE]  DeserializationConfig  _config  [TYPE]  String  excMsg  msg  [TYPE]  InjectableValues  _injectableValues  [TYPE]  long  serialVersionUID  [TYPE]  int  _featureFlags  [TYPE]  DeserializerFactory  _factory  [TYPE]  ObjectBuffer  _objectBuffer  [TYPE]  JavaType  type  [TYPE]  boolean  false  true  [TYPE]  ContextAttributes  _attributes  [TYPE]  DateFormat  _dateFormat  [TYPE]  Throwable  cause  [TYPE]  Class  _view  instClass  [TYPE]  DeserializerCache  _cache  [TYPE]  JsonParser  _parser  [CONTEXT]  public  JsonMappingException  instantiationException  (  Class<?>  instClass  ,  Throwable  cause  )  {  final  JavaType  type  =  constructType  (  instClass  )  ;  String  excMsg  ;  if  (  cause  =  =  null  )  {  excMsg  =   "N/A "  ;  [BUGGY]  }  else  if  (  (  excMsg  =  cause  .  getMessage  (  )  )  =  =  null  )  {  excMsg  =  ClassUtil  .  nameOf  (  cause  .  getClass  (  )  )  ;  }  String  msg  =  String  .  format  (   "Cannot  construct  instance  of  %s  ,  problem:  %s "  ,  ClassUtil  .  nameOf  (  instClass  )  ,  excMsg  )  ;  InvalidDefinitionException  e  =  InvalidDefinitionException  .  from  (  _parser  ,  msg  ,  type  )  ;  e  .  initCause  (  cause  )  ;  return  e  ;  }  	JacksonDatabind_103_DeserializationContext_2_2	1603	1	src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java
1436		[BUGGY]  [FE]  AssertionFailedError:  Should  only  get  one  [CLASS]  [CONTEXT]  	JacksonDatabind_103_JsonMappingException_3_1	10	0	src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
1437	ClassUtil.exceptionMessage(src)));  	[BUGGY]  src  .  getMessage  (  )  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  fromUnexpectedIOE  [TYPE]  JsonMappingException  [PARAMETER]  IOException  src  [CLASS]  JsonMappingException  [TYPE]  boolean  false  true  [TYPE]  Closeable  _processor  [TYPE]  Object  _from  [TYPE]  String  _desc  _fieldName  [TYPE]  IOException  src  [TYPE]  long  serialVersionUID  [TYPE]  int  MAX_REFS_TO_LIST  _index  [TYPE]  LinkedList  _path  [CONTEXT]  public  static  JsonMappingException  fromUnexpectedIOE  (  IOException  src  )  {  return  new  JsonMappingException  (  null  ,  String  .  format  (   "Unexpected  IOException  (  of  type  %s  )  :  %s "  ,  src  .  getClass  (  )  .  getName  (  )  ,  [BUGGY]  src  .  getMessage  (  )  )  )  ;  }  	JacksonDatabind_103_JsonMappingException_3_2	339	1	src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
1438	String  msg  =  ClassUtil.exceptionMessage(src);\n',   "                            	[BUGGY]  String  msg  =  src  .  getMessage  (  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  wrapWithPath  [TYPE]  JsonMappingException  [PARAMETER]  Throwable  src  Reference  ref  [CLASS]  JsonMappingException  [TYPE]  boolean  false  true  [TYPE]  Reference  ref  [TYPE]  Closeable  _processor  proc  [TYPE]  JsonMappingException  jme  [TYPE]  Throwable  src  [TYPE]  Object  _from  proc0  [TYPE]  String  _desc  _fieldName  msg  [TYPE]  long  serialVersionUID  [TYPE]  int  MAX_REFS_TO_LIST  _index  [TYPE]  LinkedList  _path  [CONTEXT]  public  static  JsonMappingException  wrapWithPath  (  Throwable  src  ,  Reference  ref  )  {  JsonMappingException  jme  ;  if  (  src  instanceof  JsonMappingException  )  {  jme  =  (  JsonMappingException  )  src  ;  }  else  {  [BUGGY]  String  msg  =  src  .  getMessage  (  )  ;  if  (  msg  =  =  null  ||  msg  .  length  (  )  =  =  0  )  {  msg  =   "  (  was   "+src  .  getClass  (  )  .  getName  (  )  + "  )   "  ;  }  Closeable  proc  =  null  ;  if  (  src  instanceof  JsonProcessingException  )  {  Object  proc0  =  (  (  JsonProcessingException  )  src  )  .  getProcessor  (  )  ;  if  (  proc0  instanceof  Closeable  )  {  proc  =  (  Closeable  )  proc0  ;  }  }  jme  =  new  JsonMappingException  (  proc  ,  msg  ,  src  )  ;  }  jme  .  prependPath  (  ref  )  ;  return  jme  ;  }  	JacksonDatabind_103_JsonMappingException_3_3	380	1	src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java
1439	reportMappingProblem(iae,  ClassUtil.exceptionMessage(iae));  	[BUGGY]  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _createAndCacheUntypedSerializer  [TYPE]  JsonSerializer  [PARAMETER]  Class<?>  rawType  [CLASS]  SerializerProvider  [TYPE]  SerializerFactory  _serializerFactory  [TYPE]  JavaType  fullType  [TYPE]  boolean  CACHE_UNKNOWN_MAPPINGS  _stdNullValueSerializer  false  true  [TYPE]  ContextAttributes  _attributes  [TYPE]  SerializationConfig  _config  [TYPE]  DateFormat  _dateFormat  [TYPE]  ReadOnlyClassToSerializerMap  _knownSerializers  [TYPE]  SerializerCache  _serializerCache  [TYPE]  Class  _serializationView  rawType  [TYPE]  JsonSerializer  DEFAULT_NULL_KEY_SERIALIZER  DEFAULT_UNKNOWN_SERIALIZER  _keySerializer  _nullKeySerializer  _nullValueSerializer  _unknownTypeSerializer  ser  [TYPE]  IllegalArgumentException  iae  [CONTEXT]  protected  JsonSerializer<Object>  _createAndCacheUntypedSerializer  (  Class<?>  rawType  )  throws  JsonMappingException  {  JavaType  fullType  =  _config  .  constructType  (  rawType  )  ;  JsonSerializer<Object>  ser  ;  try  {  ser  =  _createUntypedSerializer  (  fullType  )  ;  }  catch  (  IllegalArgumentException  iae  )  {    ser  =  null  ;  //  doesn't  matter  but  compiler  whines  otherwise  [BUGGY]  reportMappingProblem  (  iae  ,  iae  .  getMessage  (  )  )  ;  }  if  (  ser  !  =  null  )  {  _serializerCache  .  addAndResolveNonTypedSerializer  (  rawType  ,  fullType  ,  ser  ,  this  )  ;  }  return  ser  ;  }  	JacksonDatabind_103_SerializerProvider_2_1	1341	0	src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
1440	reportMappingProblem(iae,  ClassUtil.exceptionMessage(iae));  	[BUGGY]  reportMappingProblem  (  iae  ,  iae  .  getMessage  (  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _createAndCacheUntypedSerializer  [TYPE]  JsonSerializer  [PARAMETER]  JavaType  type  [CLASS]  SerializerProvider  [TYPE]  SerializerFactory  _serializerFactory  [TYPE]  JavaType  type  [TYPE]  boolean  CACHE_UNKNOWN_MAPPINGS  _stdNullValueSerializer  false  true  [TYPE]  ContextAttributes  _attributes  [TYPE]  SerializationConfig  _config  [TYPE]  DateFormat  _dateFormat  [TYPE]  ReadOnlyClassToSerializerMap  _knownSerializers  [TYPE]  SerializerCache  _serializerCache  [TYPE]  Class  _serializationView  [TYPE]  JsonSerializer  DEFAULT_NULL_KEY_SERIALIZER  DEFAULT_UNKNOWN_SERIALIZER  _keySerializer  _nullKeySerializer  _nullValueSerializer  _unknownTypeSerializer  ser  [TYPE]  IllegalArgumentException  iae  [CONTEXT]  protected  JsonSerializer<Object>  _createAndCacheUntypedSerializer  (  JavaType  type  )  throws  JsonMappingException  {  JsonSerializer<Object>  ser  ;  try  {  ser  =  _createUntypedSerializer  (  type  )  ;  }  catch  (  IllegalArgumentException  iae  )  {    ser  =  null  ;  [BUGGY]  reportMappingProblem  (  iae  ,  iae  .  getMessage  (  )  )  ;  }  if  (  ser  !  =  null  )  {  _serializerCache  .  addAndResolveNonTypedSerializer  (  type  ,  ser  ,  this  )  ;  }  return  ser  ;  }  	JacksonDatabind_103_SerializerProvider_2_2	1361	1	src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java
1441	ClassUtil.exceptionMessage(e0),  baseType);  	[BUGGY]  e0  .  getMessage  (  )  ,  baseType  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  findTypeDeserializer  [TYPE]  TypeDeserializer  [PARAMETER]  DeserializationConfig  config  JavaType  baseType  [CLASS]  BasicDeserializerFactory  [TYPE]  PropertyName  UNWRAPPED_CREATOR_PARAM_NAME  [TYPE]  DeserializerFactoryConfig  _factoryConfig  [TYPE]  HashMap  _collectionFallbacks  _mapFallbacks  [TYPE]  InvalidDefinitionException  e  [TYPE]  BeanDescription  bean  [TYPE]  TypeResolverBuilder  b  [TYPE]  AnnotationIntrospector  ai  [TYPE]  DeserializationConfig  config  [TYPE]  JavaType  baseType  defaultType  [TYPE]  boolean  false  true  [TYPE]  AnnotatedClass  ac  [TYPE]  Collection  subtypes  [TYPE]  Class  CLASS_CHAR_SEQUENCE  CLASS_ITERABLE  CLASS_MAP_ENTRY  CLASS_OBJECT  CLASS_STRING  [TYPE]  IllegalArgumentException  e0  [CONTEXT]    Collection<NamedType>  subtypes  =  null  ;  if  (  b  =  =  null  )  {  b  =  config  .  getDefaultTyper  (  baseType  )  ;  if  (  b  =  =  null  )  {  return  null  ;  }  }  else  {  subtypes  =  config  .  getSubtypeResolver  (  )  .  collectAndResolveSubtypesByTypeId  (  config  ,  ac  )  ;  }    if  (  (  b  .  getDefaultImpl  (  )  =  =  null  )  &&  baseType  .  isAbstract  (  )  )  {  JavaType  defaultType  =  mapAbstractType  (  config  ,  baseType  )  ;  if  (  (  defaultType  !  =  null  )  &&  !defaultType  .  hasRawClass  (  baseType  .  getRawClass  (  )  )  )  {  b  =  b  .  defaultImpl  (  defaultType  .  getRawClass  (  )  )  ;  }  }    try  {  return  b  .  buildTypeDeserializer  (  config  ,  baseType  ,  subtypes  )  ;  }  catch  (  IllegalArgumentException  e0  )  {  InvalidDefinitionException  e  =  InvalidDefinitionException  .  from  (  (  JsonParser  )  null  ,  [BUGGY]  e0  .  getMessage  (  )  ,  baseType  )  ;  e  .  initCause  (  e0  )  ;  throw  e  ;  }  }  	JacksonDatabind_103_BasicDeserializerFactory_1_1	1589	1	src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java
1442	ClassUtil.exceptionMessage(e),  	[BUGGY]  e  .  getMessage  (  )  ,  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  buildBeanDeserializer  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  JavaType  type  BeanDescription  beanDesc  [CLASS]  BeanDeserializerFactory  [TYPE]  BeanDeserializerModifier  mod  [TYPE]  Class[]  INIT_CAUSE_PARAMS  [TYPE]  ValueInstantiator  valueInstantiator  [TYPE]  BeanDescription  beanDesc  [TYPE]  DeserializationConfig  config  [TYPE]  JsonDeserializer  deserializer  [TYPE]  long  serialVersionUID  [TYPE]  JavaType  type  [TYPE]  BeanDeserializerBuilder  builder  [TYPE]  boolean  false  true  [TYPE]  NoClassDefFoundError  error  [TYPE]  BeanDeserializerFactory  instance  [TYPE]  DeserializationContext  ctxt  [TYPE]  IllegalArgumentException  e  [CONTEXT]  public  JsonDeserializer<Object>  buildBeanDeserializer  (  DeserializationContext  ctxt  ,  JavaType  type  ,  BeanDescription  beanDesc  )  throws  JsonMappingException  {  ValueInstantiator  valueInstantiator  ;      try  {  valueInstantiator  =  findValueInstantiator  (  ctxt  ,  beanDesc  )  ;  }  catch  (  NoClassDefFoundError  error  )  {  return  new  ErrorThrowingDeserializer  (  error  )  ;  }  catch  (  IllegalArgumentException  e  )  {    throw  InvalidDefinitionException  .  from  (  ctxt  .  getParser  (  )  ,  [BUGGY]  e  .  getMessage  (  )  ,  beanDesc  ,  null  )  ;  }  BeanDeserializerBuilder  builder  =  constructBeanDeserializerBuilder  (  ctxt  ,  beanDesc  )  ;  builder  .  setValueInstantiator  (  valueInstantiator  )  ;  	JacksonDatabind_103_BeanDeserializerFactory_2_1	222	1	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1443	ClassUtil.exceptionMessage(e),  	[BUGGY]  e  .  getMessage  (  )  ,  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  buildBuilderBasedDeserializer  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  JavaType  valueType  BeanDescription  builderDesc  [CLASS]  BeanDeserializerFactory  [TYPE]  BeanDeserializerModifier  mod  [TYPE]  Class[]  INIT_CAUSE_PARAMS  [TYPE]  AnnotatedMethod  buildMethod  [TYPE]  ValueInstantiator  valueInstantiator  [TYPE]  BeanDescription  builderDesc  [TYPE]  DeserializationConfig  config  [TYPE]  String  buildMethodName  [TYPE]  JsonDeserializer  deserializer  [TYPE]  long  serialVersionUID  [TYPE]  JavaType  valueType  [TYPE]  BeanDeserializerBuilder  builder  [TYPE]  boolean  false  true  [TYPE]  NoClassDefFoundError  error  [TYPE]  BeanDeserializerFactory  instance  [TYPE]  Value  builderConfig  [TYPE]  DeserializationContext  ctxt  [TYPE]  IllegalArgumentException  e  [CONTEXT]  protected  JsonDeserializer<Object>  buildBuilderBasedDeserializer  (  DeserializationContext  ctxt  ,  JavaType  valueType  ,  BeanDescription  builderDesc  )  throws  JsonMappingException  {  ValueInstantiator  valueInstantiator  ;  try  {  valueInstantiator  =  findValueInstantiator  (  ctxt  ,  builderDesc  )  ;  }  catch  (  NoClassDefFoundError  error  )  {  return  new  ErrorThrowingDeserializer  (  error  )  ;  }  catch  (  IllegalArgumentException  e  )  {    throw  InvalidDefinitionException  .  from  (  ctxt  .  getParser  (  )  ,  [BUGGY]  e  .  getMessage  (  )  ,  builderDesc  ,  null  )  ;  }  final  DeserializationConfig  config  =  ctxt  .  getConfig  (  )  ;  BeanDeserializerBuilder  builder  =  constructBeanDeserializerBuilder  (  ctxt  ,  builderDesc  )  ;  builder  .  setValueInstantiator  (  valueInstantiator  )  ;  	JacksonDatabind_103_BeanDeserializerFactory_2_2	281	1	src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java
1444	throw  JsonMappingException.from(ctxt,  ClassUtil.exceptionMessage(iae),  iae);  	[BUGGY]  throw  JsonMappingException  .  from  (  ctxt  ,  iae  .  getMessage  (  )  ,  iae  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _createAndCache2  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  DeserializerFactory  factory  JavaType  type  [CLASS]  DeserializerCache  [TYPE]  DeserializerFactory  factory  [TYPE]  JavaType  type  [TYPE]  boolean  addToCache  false  true  [TYPE]  HashMap  _incompleteDeserializers  [TYPE]  DeserializationContext  ctxt  [TYPE]  ConcurrentHashMap  _cachedDeserializers  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  IllegalArgumentException  iae  [CONTEXT]  protected  JsonDeserializer<Object>  _createAndCache2  (  DeserializationContext  ctxt  ,  DeserializerFactory  factory  ,  JavaType  type  )  throws  JsonMappingException  {  JsonDeserializer<Object>  deser  ;  try  {  deser  =  _createDeserializer  (  ctxt  ,  factory  ,  type  )  ;  }  catch  (  IllegalArgumentException  iae  )  {    [BUGGY]  throw  JsonMappingException  .  from  (  ctxt  ,  iae  .  getMessage  (  )  ,  iae  )  ;  }  if  (  deser  =  =  null  )  {  return  null  ;  }  	JacksonDatabind_103_DeserializerCache_1_1	268	1	src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java
1445	String  origMsg  =  ClassUtil.exceptionMessage(e);  	[BUGGY]  String  origMsg  =  e  .  getMessage  (  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _throwAsIOE  [TYPE]  void  [PARAMETER]  Exception  e  Object  propName  Object  value  [CLASS]  SettableAnyProperty  [TYPE]  StringBuilder  msg  [TYPE]  AnnotatedMember  _setter  [TYPE]  String  _propName  actType  origMsg  [TYPE]  JsonDeserializer  _valueDeserializer  [TYPE]  long  serialVersionUID  [TYPE]  KeyDeserializer  _keyDeserializer  [TYPE]  Exception  e  [TYPE]  BeanProperty  _property  [TYPE]  SettableAnyProperty  _parent  [TYPE]  JavaType  _type  [TYPE]  boolean  _setterIsField  false  true  [TYPE]  Throwable  t  [TYPE]  Object  _pojo  propName  value  [TYPE]  TypeDeserializer  _valueTypeDeserializer  [CONTEXT]  protected  void  _throwAsIOE  (  Exception  e  ,  Object  propName  ,  Object  value  )  throws  IOException  {  if  (  e  instanceof  IllegalArgumentException  )  {  String  actType  =  ClassUtil  .  classNameOf  (  value  )  ;  StringBuilder  msg  =  new  StringBuilder  (   "Problem  deserializing  \ "any\ "  property  ' "  )  .  append  (  propName  )  ;  msg  .  append  (   "'  of  class   "+getClassName  (  )  + "  (  expected  type:   "  )  .  append  (  _type  )  ;  msg  .  append  (   "  ;  actual  type:   "  )  .  append  (  actType  )  .  append  (   "  )   "  )  ;  [BUGGY]  String  origMsg  =  e  .  getMessage  (  )  ;  if  (  origMsg  !  =  null  )  {  msg  .  append  (   "  ,  problem:   "  )  .  append  (  origMsg  )  ;  }  else  {  msg  .  append  (   "  (  no  error  message  provided  )   "  )  ;  }  throw  new  JsonMappingException  (  null  ,  msg  .  toString  (  )  ,  e  )  ;  }  ClassUtil  .  throwIfIOE  (  e  )  ;  ClassUtil  .  throwIfRTE  (  e  )  ;  Throwable  t  =  ClassUtil  .  getRootCause  (  e  )  ;  throw  new  JsonMappingException  (  null  ,  t  .  getMessage  (  )  ,  t  )  ;  }  	JacksonDatabind_103_SettableAnyProperty_2_1	202	1	src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java
1446	throw  new  JsonMappingException(null,  ClassUtil.exceptionMessage(t),  t);  	[BUGGY]  throw  new  JsonMappingException  (  null  ,  t  .  getMessage  (  )  ,  t  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _throwAsIOE  [TYPE]  void  [PARAMETER]  Exception  e  Object  propName  Object  value  [CLASS]  SettableAnyProperty  [TYPE]  StringBuilder  msg  [TYPE]  AnnotatedMember  _setter  [TYPE]  String  _propName  actType  origMsg  [TYPE]  JsonDeserializer  _valueDeserializer  [TYPE]  long  serialVersionUID  [TYPE]  KeyDeserializer  _keyDeserializer  [TYPE]  Exception  e  [TYPE]  BeanProperty  _property  [TYPE]  SettableAnyProperty  _parent  [TYPE]  JavaType  _type  [TYPE]  boolean  _setterIsField  false  true  [TYPE]  Throwable  t  [TYPE]  Object  _pojo  propName  value  [TYPE]  TypeDeserializer  _valueTypeDeserializer  [CONTEXT]  protected  void  _throwAsIOE  (  Exception  e  ,  Object  propName  ,  Object  value  )  throws  IOException  {  if  (  e  instanceof  IllegalArgumentException  )  {  String  actType  =  ClassUtil  .  classNameOf  (  value  )  ;  StringBuilder  msg  =  new  StringBuilder  (   "Problem  deserializing  \ "any\ "  property  ' "  )  .  append  (  propName  )  ;  msg  .  append  (   "'  of  class   "+getClassName  (  )  + "  (  expected  type:   "  )  .  append  (  _type  )  ;  msg  .  append  (   "  ;  actual  type:   "  )  .  append  (  actType  )  .  append  (   "  )   "  )  ;  String  origMsg  =  e  .  getMessage  (  )  ;  if  (  origMsg  !  =  null  )  {  msg  .  append  (   "  ,  problem:   "  )  .  append  (  origMsg  )  ;  }  else  {  msg  .  append  (   "  (  no  error  message  provided  )   "  )  ;  }  throw  new  JsonMappingException  (  null  ,  msg  .  toString  (  )  ,  e  )  ;  }  ClassUtil  .  throwIfIOE  (  e  )  ;  ClassUtil  .  throwIfRTE  (  e  )  ;  Throwable  t  =  ClassUtil  .  getRootCause  (  e  )  ;  [BUGGY]  throw  new  JsonMappingException  (  null  ,  t  .  getMessage  (  )  ,  t  )  ;  }  	JacksonDatabind_103_SettableAnyProperty_2_2	214	1	src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java
1447	String  origMsg  =  ClassUtil.exceptionMessage(e);  	[BUGGY]  String  origMsg  =  e  .  getMessage  (  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _throwAsIOE  [TYPE]  void  [PARAMETER]  JsonParser  p  Exception  e  Object  value  [CLASS]  SettableBeanProperty  [TYPE]  PropertyName  _propName  _wrapperName  [TYPE]  SettableBeanProperty  delegate  [TYPE]  StringBuilder  msg  [TYPE]  String  _managedReferenceName  actType  origMsg  [TYPE]  JsonDeserializer  MISSING_VALUE_DESERIALIZER  _valueDeserializer  [TYPE]  ObjectIdInfo  _objectIdInfo  [TYPE]  int  _propertyIndex  [TYPE]  Exception  e  [TYPE]  JavaType  _type  [TYPE]  Annotations  _contextAnnotations  [TYPE]  boolean  false  true  [TYPE]  NullValueProvider  _nullProvider  [TYPE]  Object  value  [TYPE]  ViewMatcher  _viewMatcher  [TYPE]  TypeDeserializer  _valueTypeDeserializer  [TYPE]  JsonParser  p  [CONTEXT]  protected  void  _throwAsIOE  (  JsonParser  p  ,  Exception  e  ,  Object  value  )  throws  IOException  {  if  (  e  instanceof  IllegalArgumentException  )  {  String  actType  =  ClassUtil  .  classNameOf  (  value  )  ;  StringBuilder  msg  =  new  StringBuilder  (   "Problem  deserializing  property  ' "  )    .  append  (  getName  (  )  )    .  append  (   "'  (  expected  type:   "  )    .  append  (  getType  (  )  )    .  append  (   "  ;  actual  type:   "  )    .  append  (  actType  )  .  append  (   "  )   "  )  ;  [BUGGY]  String  origMsg  =  e  .  getMessage  (  )  ;  if  (  origMsg  !  =  null  )  {  msg  .  append  (   "  ,  problem:   "  )    .  append  (  origMsg  )  ;  }  else  {  msg  .  append  (   "  (  no  error  message  provided  )   "  )  ;  }  throw  JsonMappingException  .  from  (  p  ,  msg  .  toString  (  )  ,  e  )  ;  }  _throwAsIOE  (  p  ,  e  )  ;  }  	JacksonDatabind_103_SettableBeanProperty_2_1	590	1	src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java
1448	throw  JsonMappingException.from(p,  ClassUtil.exceptionMessage(th),  th);  	[BUGGY]  throw  JsonMappingException  .  from  (  p  ,  th  .  getMessage  (  )  ,  th  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _throwAsIOE  [TYPE]  IOException  [PARAMETER]  JsonParser  p  Exception  e  [CLASS]  SettableBeanProperty  [TYPE]  PropertyName  _propName  _wrapperName  [TYPE]  SettableBeanProperty  delegate  [TYPE]  String  _managedReferenceName  [TYPE]  JsonDeserializer  MISSING_VALUE_DESERIALIZER  _valueDeserializer  [TYPE]  ObjectIdInfo  _objectIdInfo  [TYPE]  int  _propertyIndex  [TYPE]  Exception  e  [TYPE]  JavaType  _type  [TYPE]  Annotations  _contextAnnotations  [TYPE]  boolean  false  true  [TYPE]  NullValueProvider  _nullProvider  [TYPE]  Throwable  th  [TYPE]  ViewMatcher  _viewMatcher  [TYPE]  TypeDeserializer  _valueTypeDeserializer  [TYPE]  JsonParser  p  [CONTEXT]  protected  IOException  _throwAsIOE  (  JsonParser  p  ,  Exception  e  )  throws  IOException  {  ClassUtil  .  throwIfIOE  (  e  )  ;  ClassUtil  .  throwIfRTE  (  e  )  ;  Throwable  th  =  ClassUtil  .  getRootCause  (  e  )  ;  [BUGGY]  throw  JsonMappingException  .  from  (  p  ,  th  .  getMessage  (  )  ,  th  )  ;  }  	JacksonDatabind_103_SettableBeanProperty_2_2	611	1	src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java
1449	ClassUtil.exceptionMessage(iae));  	[BUGGY]  iae  .  getMessage  (  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _parseDate  [TYPE]  Date  [PARAMETER]  String  value  DeserializationContext  ctxt  [CLASS]  StdDeserializer  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  _valueClass  [TYPE]  String  value  [TYPE]  long  serialVersionUID  [TYPE]  int  F_MASK_ACCEPT_ARRAYS  F_MASK_INT_COERCIONS  [TYPE]  IllegalArgumentException  iae  [CONTEXT]  protected  java  .  util  .  Date  _parseDate  (  String  value  ,  DeserializationContext  ctxt  )  throws  IOException  {  try  {  if  (  _isEmptyOrTextualNull  (  value  )  )  {  return  (  java  .  util  .  Date  )  getNullValue  (  ctxt  )  ;  }  return  ctxt  .  parseDate  (  value  )  ;  }  catch  (  IllegalArgumentException  iae  )  {  return  (  java  .  util  .  Date  )  ctxt  .  handleWeirdStringValue  (  _valueClass  ,  value  ,   "not  a  valid  representation  (  error:  %s  )   "  ,  [BUGGY]  iae  .  getMessage  (  )  )  ;  }  }  	JacksonDatabind_103_StdDeserializer_1_1	526	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java
1450	ClassUtil.exceptionMessage(re));  	[BUGGY]  re  .  getMessage  (  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  deserializeKey  [TYPE]  Object  [PARAMETER]  String  key  DeserializationContext  ctxt  [CLASS]  StdKeyDeserializer  [TYPE]  Enum  _enumDefaultValue  [TYPE]  AnnotatedMethod  _factory  [TYPE]  FromStringDeserializer  _deser  [TYPE]  Constructor  _ctor  [TYPE]  Method  _factoryMethod  [TYPE]  String  key  [TYPE]  JsonDeserializer  _delegate  [TYPE]  long  serialVersionUID  [TYPE]  int  TYPE_BOOLEAN  TYPE_BYTE  TYPE_BYTE_ARRAY  TYPE_CALENDAR  TYPE_CHAR  TYPE_CLASS  TYPE_CURRENCY  TYPE_DATE  TYPE_DOUBLE  TYPE_FLOAT  TYPE_INT  TYPE_LOCALE  TYPE_LONG  TYPE_SHORT  TYPE_URI  TYPE_URL  TYPE_UUID  _kind  [TYPE]  Exception  re  [TYPE]  StringKD  sObject  sString  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  _keyClass  [TYPE]  Object  result  [TYPE]  EnumResolver  _byNameResolver  _byToStringResolver  [CONTEXT]  public  Object  deserializeKey  (  String  key  ,  DeserializationContext  ctxt  )  throws  IOException  {  if  (  key  =  =  null  )  {  //  is  this  even  legal  call?  return  null  ;  }  try  {  Object  result  =  _parse  (  key  ,  ctxt  )  ;  if  (  result  !  =  null  )  {  return  result  ;  }  }  catch  (  Exception  re  )  {  return  ctxt  .  handleWeirdKey  (  _keyClass  ,  key  ,   "not  a  valid  representation  ,  problem:  (  %s  )  %s "  ,  re  .  getClass  (  )  .  getName  (  )  ,  [BUGGY]  re  .  getMessage  (  )  )  ;  }  if  (  _keyClass  .  isEnum  (  )  &&  ctxt  .  getConfig  (  )  .  isEnabled  (  DeserializationFeature  .  READ_UNKNOWN_ENUM_VALUES_AS_NULL  )  )  {  return  null  ;  }  return  ctxt  .  handleWeirdKey  (  _keyClass  ,  key  ,   "not  a  valid  representation "  )  ;  }  	JacksonDatabind_103_StdKeyDeserializer_2_1	135	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java
1451	ClassUtil.exceptionMessage(e));  	[BUGGY]  e  .  getMessage  (  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _weirdKey  [TYPE]  Object  [PARAMETER]  DeserializationContext  ctxt  String  key  Exception  e  [CLASS]  StdKeyDeserializer  [TYPE]  Enum  _enumDefaultValue  [TYPE]  AnnotatedMethod  _factory  [TYPE]  FromStringDeserializer  _deser  [TYPE]  Constructor  _ctor  [TYPE]  Method  _factoryMethod  [TYPE]  String  key  [TYPE]  JsonDeserializer  _delegate  [TYPE]  long  serialVersionUID  [TYPE]  int  TYPE_BOOLEAN  TYPE_BYTE  TYPE_BYTE_ARRAY  TYPE_CALENDAR  TYPE_CHAR  TYPE_CLASS  TYPE_CURRENCY  TYPE_DATE  TYPE_DOUBLE  TYPE_FLOAT  TYPE_INT  TYPE_LOCALE  TYPE_LONG  TYPE_SHORT  TYPE_URI  TYPE_URL  TYPE_UUID  _kind  [TYPE]  Exception  e  [TYPE]  StringKD  sObject  sString  [TYPE]  boolean  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  Class  _keyClass  [TYPE]  EnumResolver  _byNameResolver  _byToStringResolver  [CONTEXT]  protected  Object  _weirdKey  (  DeserializationContext  ctxt  ,  String  key  ,  Exception  e  )  throws  IOException  {  return  ctxt  .  handleWeirdKey  (  _keyClass  ,  key  ,   "problem:  %s "  ,  [BUGGY]  e  .  getMessage  (  )  )  ;  }  	JacksonDatabind_103_StdKeyDeserializer_2_2	262	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java
1452	 "Instantiation  of   "+getValueTypeDesc()+ "  value  failed:   "+ClassUtil.exceptionMessage(t),  t);  	[BUGGY]   "Instantiation  of   "+getValueTypeDesc  (  )  + "  value  failed:   "+t  .  getMessage  (  )  ,  t  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  wrapException  [TYPE]  JsonMappingException  [PARAMETER]  Throwable  t  [CLASS]  StdValueInstantiator  [TYPE]  AnnotatedWithParams  _arrayDelegateCreator  _defaultCreator  _delegateCreator  _fromBooleanCreator  _fromDoubleCreator  _fromIntCreator  _fromLongCreator  _fromStringCreator  _withArgsCreator  [TYPE]  JavaType  _arrayDelegateType  _delegateType  [TYPE]  boolean  false  true  [TYPE]  AnnotatedParameter  _incompleteParameter  [TYPE]  Throwable  curr  t  [TYPE]  Class  _valueClass  [TYPE]  SettableBeanProperty[]  _arrayDelegateArguments  _constructorArguments  _delegateArguments  [TYPE]  String  _valueTypeDesc  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  JsonMappingException  wrapException  (  Throwable  t  )  {    for  (  Throwable  curr  =  t  ;  curr  !  =  null  ;  curr  =  curr  .  getCause  (  )  )  {  if  (  curr  instanceof  JsonMappingException  )  {  return  (  JsonMappingException  )  curr  ;  }  }  return  new  JsonMappingException  (  null  ,  [BUGGY]   "Instantiation  of   "+getValueTypeDesc  (  )  + "  value  failed:   "+t  .  getMessage  (  )  ,  t  )  ;  }  	JacksonDatabind_103_StdValueInstantiator_1_1	456	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java
1453	+ClassUtil.exceptionMessage(t),  t);  	[BUGGY]  +t  .  getMessage  (  )  ,  t  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  instantiateBean  [TYPE]  Object  [PARAMETER]  boolean  fixAccess  [CLASS]  BasicBeanDescription  [TYPE]  Class[]  NO_VIEWS  _defaultViews  [TYPE]  boolean  _defaultViewsResolved  false  fixAccess  true  [TYPE]  AnnotatedConstructor  ac  [TYPE]  AnnotatedClass  _classInfo  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  MapperConfig  _config  [TYPE]  Throwable  t  [TYPE]  List  _properties  [TYPE]  ObjectIdInfo  _objectIdInfo  [TYPE]  POJOPropertiesCollector  _propCollector  [TYPE]  Exception  e  [CONTEXT]  public  Object  instantiateBean  (  boolean  fixAccess  )  {  AnnotatedConstructor  ac  =  _classInfo  .  getDefaultConstructor  (  )  ;  if  (  ac  =  =  null  )  {  return  null  ;  }  if  (  fixAccess  )  {  ac  .  fixAccess  (  _config  .  isEnabled  (  MapperFeature  .  OVERRIDE_PUBLIC_ACCESS_MODIFIERS  )  )  ;  }  try  {  return  ac  .  getAnnotated  (  )  .  newInstance  (  )  ;  }  catch  (  Exception  e  )  {  Throwable  t  =  e  ;  while  (  t  .  getCause  (  )  !  =  null  )  {  t  =  t  .  getCause  (  )  ;  }  ClassUtil  .  throwIfError  (  t  )  ;  ClassUtil  .  throwIfRTE  (  t  )  ;  throw  new  IllegalArgumentException  (   "Failed  to  instantiate  bean  of  type   "  +_classInfo  .  getAnnotated  (  )  .  getName  (  )  + ":  (   "+t  .  getClass  (  )  .  getName  (  )  + "  )   "  [BUGGY]  +t  .  getMessage  (  )  ,  t  )  ;  }  }  	JacksonDatabind_103_BasicBeanDescription_1_1	364	1	src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java
1454	filter.getClass().getName(),  t.getClass().getName(),  ClassUtil.exceptionMessage(t));  	[BUGGY]  filter  .  getClass  (  )  .  getName  (  )  ,  t  .  getClass  (  )  .  getName  (  )  ,  t  .  getMessage  (  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  includeFilterSuppressNulls  [TYPE]  boolean  [PARAMETER]  Object  filter  [CLASS]  DefaultSerializerProvider  [TYPE]  boolean  false  true  [TYPE]  ArrayList  _objectIdGenerators  [TYPE]  JsonGenerator  _generator  [TYPE]  Throwable  t  [TYPE]  Object  filter  [TYPE]  String  msg  [TYPE]  Map  _seenObjectIds  [TYPE]  long  serialVersionUID  [CONTEXT]  public  boolean  includeFilterSuppressNulls  (  Object  filter  )  throws  JsonMappingException  {  if  (  filter  =  =  null  )  {  return  true  ;  }    try  {  return  filter  .  equals  (  null  )  ;  }  catch  (  Throwable  t  )  {  String  msg  =  String  .  format  (   "Problem  determining  whether  filter  of  type  '%s'  should  filter  out  `null`  values:  (  %s  )  %s "  ,  [BUGGY]  filter  .  getClass  (  )  .  getName  (  )  ,  t  .  getClass  (  )  .  getName  (  )  ,  t  .  getMessage  (  )  )  ;  reportBadDefinition  (  filter  .  getClass  (  )  ,  msg  ,  t  )  ;  return  false  ;  //  never  gets  here  }  }  	JacksonDatabind_103_DefaultSerializerProvider_2_1	171	1	src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java
1455	String  msg  =  ClassUtil.exceptionMessage(e);  	[BUGGY]  String  msg  =  e  .  getMessage  (  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  _wrapAsIOE  [TYPE]  IOException  [PARAMETER]  JsonGenerator  g  Exception  e  [CLASS]  DefaultSerializerProvider  [TYPE]  boolean  false  true  [TYPE]  ArrayList  _objectIdGenerators  [TYPE]  JsonGenerator  _generator  g  [TYPE]  String  msg  [TYPE]  Map  _seenObjectIds  [TYPE]  long  serialVersionUID  [TYPE]  Exception  e  [CONTEXT]  private  IOException  _wrapAsIOE  (  JsonGenerator  g  ,  Exception  e  )  {  if  (  e  instanceof  IOException  )  {  return  (  IOException  )  e  ;  }  [BUGGY]  String  msg  =  e  .  getMessage  (  )  ;  if  (  msg  =  =  null  )  {  msg  =   "[no  message  for   "+e  .  getClass  (  )  .  getName  (  )  + "] "  ;  }  return  new  JsonMappingException  (  g  ,  msg  ,  e  )  ;  }  	JacksonDatabind_103_DefaultSerializerProvider_2_2	505	1	src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java
1456	return  prov.reportBadDefinition(declaredType,  ClassUtil.exceptionMessage(e));  return  prov.reportBadPropertyDefinition(_beanDesc,  propDef,  ClassUtil.exceptionMessage(e));  	[BUGGY]  return  prov  .  reportBadDefinition  (  declaredType  ,  e  .  getMessage  (  )  )  ;  return  prov  .  reportBadPropertyDefinition  (  _beanDesc  ,  propDef  ,  e  .  getMessage  (  )  )  ;  [FE]  AssertionFailedError:  Should  only  get  one  [METHOD]  buildWriter  [TYPE]  BeanPropertyWriter  [PARAMETER]  SerializerProvider  prov  BeanPropertyDefinition  propDef  JavaType  declaredType  JsonSerializer<?>  ser  TypeSerializer  typeSer  TypeSerializer  contentTypeSer  AnnotatedMember  am  boolean  defaultUseStaticTyping  [CLASS]  PropertyBuilder  [TYPE]  Class[]  views  [TYPE]  SerializationConfig  _config  [TYPE]  BeanDescription  _beanDesc  [TYPE]  AnnotationIntrospector  _annotationIntrospector  [TYPE]  AnnotatedMember  accessor  am  [TYPE]  Include  inclusion  [TYPE]  JsonSerializer  ser  [TYPE]  Exception  e  [TYPE]  NameTransformer  unwrapper  [TYPE]  JavaType  actualType  ct  declaredType  serializationType  [TYPE]  boolean  _useRealPropertyDefaults  defaultUseStaticTyping  false  suppressNulls  true  [TYPE]  JsonMappingException  e  [TYPE]  Value  _defaultInclusion  inclV  [TYPE]  BeanPropertyDefinition  propDef  [TYPE]  TypeSerializer  contentTypeSer  typeSer  [TYPE]  Object  NO_DEFAULT_MARKER  _defaultBean  defaultBean  serDef  valueToSuppress  [TYPE]  Class  rawPropertyType  [TYPE]  SerializerProvider  prov  [TYPE]  BeanPropertyWriter  bpw  [CONTEXT]  protected  BeanPropertyWriter  buildWriter  (  SerializerProvider  prov  ,  BeanPropertyDefinition  propDef  ,  JavaType  declaredType  ,  JsonSerializer<?>  ser  ,  TypeSerializer  typeSer  ,  TypeSerializer  contentTypeSer  ,  AnnotatedMember  am  ,  boolean  defaultUseStaticTyping  )  throws  JsonMappingException  {  JavaType  serializationType  ;  try  {  serializationType  =  findSerializationType  (  am  ,  defaultUseStaticTyping  ,  declaredType  )  ;  }  catch  (  JsonMappingException  e  )  {  if  (  propDef  =  =  null  )  {  [BUGGY]  return  prov  .  reportBadDefinition  (  declaredType  ,  e  .  getMessage  (  )  )  ;  }  return  prov  .  reportBadPropertyDefinition  (  _beanDesc  ,  propDef  ,  e  .  getMessage  (  )  )  ;  }  	JacksonDatabind_103_PropertyBuilder_1_1	103	2	src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java
1457		[BUGGY]  [FE]  AssertionFailedError:  Should  only  get  one  [CLASS]  [CONTEXT]  	JacksonDatabind_103_ClassUtil_2_1	10	0	src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java
1458	public  static  String  exceptionMessage(Throwable  t)  {  if  (t  instanceof  JsonProcessingException)  {  return  ((JsonProcessingException)  t).getOriginalMessage();  }  return  t.getMessage();  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  only  get  one  [CLASS]  [CONTEXT]  	JacksonDatabind_103_ClassUtil_2_2	752	0	src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java
1459	if  (cal.get(Calendar.ERA)  ==  GregorianCalendar.BC)  {  _formatBCEYear(buffer,  year);  }  else  {  if  (year  >  9999)  {  	[BUGGY]  [FE]  ComparisonFailure:  expected:< "[+10]204-01-01T00:00:000>  but  was:< "[:]204-01-01T00:00:000>  [METHOD]  _format  [TYPE]  void  [PARAMETER]  TimeZone  tz  Locale  loc  Date  date  StringBuffer  buffer  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  loc  [TYPE]  Pattern  PATTERN_ISO8601  PATTERN_PLAIN  [TYPE]  Calendar  CALENDAR  _calendar  cal  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  PATTERN_PLAIN_STR  [TYPE]  String[]  ALL_FORMATS  [TYPE]  Date  date  [TYPE]  int  hours  minutes  offset  year  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  tz  [TYPE]  StringBuffer  buffer  [TYPE]  boolean  _tzSerializedWithColon  false  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_RFC1123  _formatRFC1123  [TYPE]  Boolean  _lenient  [CONTEXT]  protected  void  _format  (  TimeZone  tz  ,  Locale  loc  ,  Date  date  ,  StringBuffer  buffer  )  {  Calendar  cal  =  _getCalendar  (  tz  )  ;  cal  .  setTime  (  date  )  ;  final  int  year  =  cal  .  get  (  Calendar  .  YEAR  )  ;    [BUGGY]      pad4  (  buffer  ,  year  )  ;  	JacksonDatabind_104_StdDateFormat_5_1	441	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1460	}\n',   "                  buffer.append('-');\n ",  '  	[BUGGY]  [FE]  ComparisonFailure:  expected:< "[+10]204-01-01T00:00:000>  but  was:< "[:]204-01-01T00:00:000>  [METHOD]  _format  [TYPE]  void  [PARAMETER]  TimeZone  tz  Locale  loc  Date  date  StringBuffer  buffer  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  loc  [TYPE]  Pattern  PATTERN_ISO8601  PATTERN_PLAIN  [TYPE]  Calendar  CALENDAR  _calendar  cal  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  PATTERN_PLAIN_STR  [TYPE]  String[]  ALL_FORMATS  [TYPE]  Date  date  [TYPE]  int  hours  minutes  offset  year  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  tz  [TYPE]  StringBuffer  buffer  [TYPE]  boolean  _tzSerializedWithColon  false  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_RFC1123  _formatRFC1123  [TYPE]  Boolean  _lenient  [CONTEXT]  protected  void  _format  (  TimeZone  tz  ,  Locale  loc  ,  Date  date  ,  StringBuffer  buffer  )  {  Calendar  cal  =  _getCalendar  (  tz  )  ;  cal  .  setTime  (  date  )  ;  final  int  year  =  cal  .  get  (  Calendar  .  YEAR  )  ;        [BUGGY]  pad4  (  buffer  ,  year  )  ;  buffer  .  append  (  '-'  )  ;  pad2  (  buffer  ,  cal  .  get  (  Calendar  .  MONTH  )  +  1  )  ;  buffer  .  append  (  '-'  )  ;  pad2  (  buffer  ,  cal  .  get  (  Calendar  .  DAY_OF_MONTH  )  )  ;  buffer  .  append  (  'T'  )  ;  	JacksonDatabind_104_StdDateFormat_5_2	446	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1461	protected  void  _formatBCEYear(StringBuffer  buffer,  int  bceYearNoSign)  {  if  (bceYearNoSign  ==  1)  {  buffer.append( "+0000 ");  return;  }  final  int  isoYear  =  bceYearNoSign  -  1;\n',   "+                buffer.append('-');\n ",  '                    	[BUGGY]  [FE]  ComparisonFailure:  expected:< "[+10]204-01-01T00:00:000>  but  was:< "[:]204-01-01T00:00:000>  [CLASS]  [CONTEXT]  	JacksonDatabind_104_StdDateFormat_5_3	483	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1462	pad4(buffer,  isoYear);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:< "[+10]204-01-01T00:00:000>  but  was:< "[:]204-01-01T00:00:000>  [CLASS]  [CONTEXT]  	JacksonDatabind_104_StdDateFormat_5_4	488	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1463	if  (h  >  99)  {    buffer.append(h);  }  else  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:< "[+10]204-01-01T00:00:000>  but  was:< "[:]204-01-01T00:00:000>  [METHOD]  pad4  [TYPE]  void  [PARAMETER]  StringBuffer  buffer  int  value  [CLASS]  StdDateFormat  [TYPE]  Locale  DEFAULT_LOCALE  _locale  [TYPE]  Pattern  PATTERN_ISO8601  PATTERN_PLAIN  [TYPE]  TimeZone  DEFAULT_TIMEZONE  _timezone  [TYPE]  StringBuffer  buffer  [TYPE]  boolean  _tzSerializedWithColon  false  true  [TYPE]  DateFormat  DATE_FORMAT_ISO8601  DATE_FORMAT_RFC1123  _formatRFC1123  [TYPE]  Calendar  CALENDAR  _calendar  [TYPE]  StdDateFormat  instance  [TYPE]  String  DATE_FORMAT_STR_ISO8601  DATE_FORMAT_STR_PLAIN  DATE_FORMAT_STR_RFC1123  PATTERN_PLAIN_STR  [TYPE]  String[]  ALL_FORMATS  [TYPE]  Boolean  _lenient  [TYPE]  int  h  value  [CONTEXT]  private  static  void  pad4  (  StringBuffer  buffer  ,  int  value  )  {  int  h  =  value  /  100  ;  if  (  h  =  =  0  )  {  buffer  .  append  (  '0'  )  .  append  (  '0'  )  ;  }  else  {  [BUGGY]  pad2  (  buffer  ,  h  )  ;  value  -  =  (  100  *  h  )  ;  }  pad2  (  buffer  ,  value  )  ;  }  	JacksonDatabind_104_StdDateFormat_5_5	516	0	src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java
1464	ByteBuffer.class,  Void.class  	[BUGGY]  ByteBuffer  .  class  [FE]  jacksondatabindexcMismatchedInputException:  Cannot  construct  instance  of  `javalangVoid`  (  although  at  least  one  Creator  exists  )  :  no  int/Int-argument  constructor/factory  method  to  deserialize  from  Number  value  (  123  )  assertNull  (  bean  .  value  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_105_JdkDeserializers_2_1	22	1	src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java
1465	if  (rawType  ==  Void.class)  {  return  NullifyingDeserializer.instance;  }  	[BUGGY]  [FE]  jacksondatabindexcMismatchedInputException:  Cannot  construct  instance  of  `javalangVoid`  (  although  at  least  one  Creator  exists  )  :  no  int/Int-argument  constructor/factory  method  to  deserialize  from  Number  value  (  123  )  assertNull  (  bean  .  value  )  ;  [METHOD]  find  [TYPE]  JsonDeserializer  [PARAMETER]  Class<?>  rawType  String  clsName  [CLASS]  JdkDeserializers  [TYPE]  Class  rawType  [TYPE]  String  clsName  [TYPE]  boolean  false  true  [TYPE]  JsonDeserializer  d  [TYPE]  HashSet  _classNames  [CONTEXT]  public  static  JsonDeserializer<?>  find  (  Class<?>  rawType  ,  String  clsName  )  {  if  (  _classNames  .  contains  (  clsName  )  )  {  JsonDeserializer<?>  d  =  FromStringDeserializer  .  findDeserializer  (  rawType  )  ;  if  (  d  !  =  null  )  {  return  d  ;  }  if  (  rawType  =  =  UUID  .  class  )  {  return  new  UUIDDeserializer  (  )  ;  }  if  (  rawType  =  =  StackTraceElement  .  class  )  {  return  new  StackTraceElementDeserializer  (  )  ;  }  if  (  rawType  =  =  AtomicBoolean  .  class  )  {  return  new  AtomicBooleanDeserializer  (  )  ;  }  if  (  rawType  =  =  ByteBuffer  .  class  )  {  return  new  ByteBufferDeserializer  (  )  ;  }  [BUGGY]  }  return  null  ;  }  	JacksonDatabind_105_JdkDeserializers_2_2	48	0	src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java
1466	if  (!node.canConvertToInt())  {  reportOverflowInt();  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  failure  for  `long`  overflow  assertEquals  (  NumberType  .  DOUBLE  ,  p  .  getNumberType  (  )  )  ;  [METHOD]  getIntValue  [TYPE]  int  [PARAMETER]  [CLASS]  TreeTraversingParser  [TYPE]  NodeCursor  _nodeCursor  [TYPE]  JsonToken  _nextToken  [TYPE]  boolean  _closed  _startContainer  false  true  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  NumericNode  node  [CONTEXT]  public  int  getIntValue  (  )  throws  IOException  {  final  NumericNode  node  =  (  NumericNode  )  currentNumericNode  (  )  ;  [BUGGY]  return  node  .  intValue  (  )  ;  }  	JacksonDatabind_106_TreeTraversingParser_2_1	308	0	src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java
1467	if  (!node.canConvertToInt())  {  reportOverflowLong();  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  failure  for  `long`  overflow  assertEquals  (  NumberType  .  DOUBLE  ,  p  .  getNumberType  (  )  )  ;  [METHOD]  getLongValue  [TYPE]  long  [PARAMETER]  [CLASS]  TreeTraversingParser  [TYPE]  NodeCursor  _nodeCursor  [TYPE]  JsonToken  _nextToken  [TYPE]  boolean  _closed  _startContainer  false  true  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  NumericNode  node  [CONTEXT]  public  long  getLongValue  (  )  throws  IOException  {  final  NumericNode  node  =  (  NumericNode  )  currentNumericNode  (  )  ;  [BUGGY]  return  node  .  longValue  (  )  ;  }  	JacksonDatabind_106_TreeTraversingParser_2_2	314	0	src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java
1468	return  NullifyingDeserializer.instance;  	[BUGGY]  return  null  ;  [FE]  jacksondatabindJsonMappingException:  (  was  javalangNullPointerException  )    (  through  reference  chain:  comfasterxmljacksondatabinddeserfilterProblemHandlerUnknownTypeId2221Test$GenericContent[ "innerObjects "]->javautilArrayList[1]  )  assertEquals  (  2  ,  processableContent  .  getInnerObjects  (  )  .  size  (  )  )  ;  [METHOD]  _findDeserializer  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  String  typeId  [CLASS]  TypeDeserializerBase  [TYPE]  JavaType  _baseType  _defaultImpl  actual  type  [TYPE]  boolean  _typeIdVisible  false  true  [TYPE]  DeserializationContext  ctxt  [TYPE]  String  _typePropertyName  typeId  [TYPE]  JsonDeserializer  _defaultImplDeserializer  deser  [TYPE]  Map  _deserializers  [TYPE]  long  serialVersionUID  [TYPE]  TypeIdResolver  _idResolver  [TYPE]  BeanProperty  _property  [CONTEXT]  protected  final  JsonDeserializer<Object>  _findDeserializer  (  DeserializationContext  ctxt  ,  String  typeId  )  throws  IOException  {  JsonDeserializer<Object>  deser  =  _deserializers  .  get  (  typeId  )  ;  if  (  deser  =  =  null  )  {      JavaType  type  =  _idResolver  .  typeFromId  (  ctxt  ,  typeId  )  ;  if  (  type  =  =  null  )  {  deser  =  _findDefaultImplDeserializer  (  ctxt  )  ;  if  (  deser  =  =  null  )  {  JavaType  actual  =  _handleUnknownTypeId  (  ctxt  ,  typeId  )  ;  if  (  actual  =  =  null  )  {  //  what  should  this  be  taken  to  mean?  [BUGGY]  return  null  ;  }  deser  =  ctxt  .  findContextualValueDeserializer  (  actual  ,  _property  )  ;  }  }  else  {  	JacksonDatabind_107_TypeDeserializerBase_1_1	165	1	src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java
1469	return  (T)  _bindAsTreeOrNull(p);  	[BUGGY]  return  (  T  )  _bindAsTree  (  p  )  ;  [FE]  AssertionFailedError:  Should  get  `null`  for  reads  with  `JsonParser`  ,  instead  got:  comfasterxmljacksondatabindnodeMissingNode  _assertNullTree  (  MAPPER  .  reader  (  )  .  readTree  (  p  )  )  ;  [METHOD]  readTree  [TYPE]  <T  [PARAMETER]  JsonParser  p  [CLASS]  ObjectReader  [TYPE]  DefaultDeserializationContext  _context  [TYPE]  FormatSchema  _schema  [TYPE]  JsonFactory  _parserFactory  [TYPE]  DeserializationConfig  _config  [TYPE]  DataFormatReaders  _dataFormatReaders  [TYPE]  JsonDeserializer  _rootDeserializer  [TYPE]  InjectableValues  _injectableValues  [TYPE]  long  serialVersionUID  [TYPE]  JavaType  JSON_NODE_TYPE  _valueType  [TYPE]  boolean  _unwrapRoot  false  true  [TYPE]  Object  _valueToUpdate  [TYPE]  ConcurrentHashMap  _rootDeserializers  [TYPE]  TokenFilter  _filter  [TYPE]  JsonParser  p  [CONTEXT]  public  <T  extends  TreeNode>  T  readTree  (  JsonParser  p  )  throws  IOException  {  [BUGGY]  return  (  T  )  _bindAsTree  (  p  )  ;  }  	JacksonDatabind_108_ObjectReader_2_1	1169	1	src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
1470	protected  final  JsonNode  _bindAsTreeOrNull(JsonParser  p)  throws  IOException  {  _config.initialize(p);  if  (_schema  !=  null)  {  p.setSchema(_schema);  }  JsonToken  t  =  p.getCurrentToken();  if  (t  ==  null)  {  t  =  p.nextToken();  if  (t  ==  null)  {  return  null;  }  }  final  JsonNode  resultNode;  if  (t  ==  JsonToken.VALUE_NULL)  {  resultNode  =  _config.getNodeFactory().nullNode();  }  else  {  final  DeserializationContext  ctxt  =  createDeserializationContext(p);  final  JsonDeserializer<Object>  deser  =  _findTreeDeserializer(ctxt);  if  (_unwrapRoot)  {  resultNode  =  (JsonNode)  _unwrapAndDeserialize(p,  ctxt,  JSON_NODE_TYPE,  deser);  }  else  {  resultNode  =  (JsonNode)  deser.deserialize(p,  ctxt);  if  (_config.isEnabled(DeserializationFeature.FAIL_ON_TRAILING_TOKENS))  {  _verifyNoTrailingTokens(p,  ctxt,  JSON_NODE_TYPE);  }  }  }  return  resultNode;  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  get  `null`  for  reads  with  `JsonParser`  ,  instead  got:  comfasterxmljacksondatabindnodeMissingNode  _assertNullTree  (  MAPPER  .  reader  (  )  .  readTree  (  p  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_108_ObjectReader_2_2	1707	0	src/main/java/com/fasterxml/jackson/databind/ObjectReader.java
1471	protected  final  static  int  MAX_BIG_DECIMAL_SCALE  =  9999;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "value ": "[00000000005] "}>  but  was:<{ "value ": "[5E-10] "}>  assertEquals  (   "{\ "value\ ":\ " "+NORM_VALUE+ "\ "} "  ,  m  .  writeValueAsString  (  INPUT  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_109_NumberSerializer_3_1	37	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java
1472	if  (((Class<?>)  handledType())  ==  BigDecimal.class)  {  return  bigDecimalAsStringSerializer();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "value ": "[00000000005] "}>  but  was:<{ "value ": "[5E-10] "}>  assertEquals  (   "{\ "value\ ":\ " "+NORM_VALUE+ "\ "} "  ,  m  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  BeanProperty  property  [CLASS]  NumberSerializer  [TYPE]  NumberSerializer  instance  [TYPE]  Value  format  [TYPE]  boolean  _isInt  false  true  [TYPE]  SerializerProvider  prov  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonSerializer<?>  createContextual  (  SerializerProvider  prov  ,  BeanProperty  property  )  throws  JsonMappingException  {  JsonFormat  .  Value  format  =  findFormatOverrides  (  prov  ,  property  ,  handledType  (  )  )  ;  if  (  format  !  =  null  )  {  switch  (  format  .  getShape  (  )  )  {  case  STRING:  [BUGGY]  return  ToStringSerializer  .  instance  ;  default:  }  }  return  this  ;  }  	JacksonDatabind_109_NumberSerializer_3_2	58	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java
1473	public  static  JsonSerializer<?>  bigDecimalAsStringSerializer()  {  return  BigDecimalAsStringSerializer.BD_INSTANCE;  }  final  static  class  BigDecimalAsStringSerializer  extends  ToStringSerializerBase  {  final  static  BigDecimalAsStringSerializer  BD_INSTANCE  =  new  BigDecimalAsStringSerializer();    public  BigDecimalAsStringSerializer()  {  super(BigDecimal.class);  }  @Override  public  boolean  isEmpty(SerializerProvider  prov,  Object  value)  {  return  valueToString(value).isEmpty();  }  @Override  public  void  serialize(Object  value,  JsonGenerator  gen,  SerializerProvider  provider)  throws  IOException  {  final  String  text;  if  (gen.isEnabled(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN))  {  final  BigDecimal  bd  =  (BigDecimal)  value;  if  (!_verifyBigDecimalRange(gen,  bd))  {\n',   "                                             "Attempt  to  write  plain  `java.math.BigDecimal`  (see  JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN)  with  illegal  scale  (%d):  needs  to  be  between  [-%d,  %d] ",  bd.scale(),  MAX_BIG_DECIMAL_SCALE,  MAX_BIG_DECIMAL_SCALE);  provider.reportMappingProblem(errorMsg);  }  text  =  bd.toPlainString();  }  else  {  text  =  value.toString();  }  gen.writeString(text);  }  @Override  public  String  valueToString(Object  value)  {  throw  new  IllegalStateException();  }  protected  boolean  _verifyBigDecimalRange(JsonGenerator  gen,  BigDecimal  value)  throws  IOException  {  int  scale  =  value.scale();  return  ((scale  >=  -MAX_BIG_DECIMAL_SCALE)  &&  (scale  <=  MAX_BIG_DECIMAL_SCALE));  }  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "value ": "[00000000005] "}>  but  was:<{ "value ": "[5E-10] "}>  assertEquals  (   "{\ "value\ ":\ " "+NORM_VALUE+ "\ "} "  ,  m  .  writeValueAsString  (  INPUT  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_109_NumberSerializer_3_3	113	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java
1474		[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "value ": "[00000000005] "}>  but  was:<{ "value ": "[5E-10] "}>  assertEquals  (   "{\ "value\ ":\ " "+NORM_VALUE+ "\ "} "  ,  m  .  writeValueAsString  (  INPUT  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_109_NumberSerializers_2_1	5	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1475	if  (((Class<?>)  handledType())  ==  BigDecimal.class)  {  return  NumberSerializer.bigDecimalAsStringSerializer();  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<{ "value ": "[00000000005] "}>  but  was:<{ "value ": "[5E-10] "}>  assertEquals  (   "{\ "value\ ":\ " "+NORM_VALUE+ "\ "} "  ,  m  .  writeValueAsString  (  INPUT  )  )  ;  [METHOD]  createContextual  [TYPE]  JsonSerializer  [PARAMETER]  SerializerProvider  prov  BeanProperty  property  [CLASS]  Base  [TYPE]  Value  format  [TYPE]  NumberType  _numberType  [TYPE]  boolean  _isInt  false  true  [TYPE]  String  _schemaType  [TYPE]  SerializerProvider  prov  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonSerializer<?>  createContextual  (  SerializerProvider  prov  ,  BeanProperty  property  )  throws  JsonMappingException  {  JsonFormat  .  Value  format  =  findFormatOverrides  (  prov  ,  property  ,  handledType  (  )  )  ;  if  (  format  !  =  null  )  {  switch  (  format  .  getShape  (  )  )  {  case  STRING:  [BUGGY]  return  ToStringSerializer  .  instance  ;  default:  }  }  return  this  ;  }  	JacksonDatabind_109_NumberSerializers_2_2	100	0	src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java
1476	private  final  static  Class<?>  CLASS_UNMODIFIABLE_LIST_ALIAS;  	[BUGGY]  [FE]  jacksondatabindexcInvalidDefinitionException:  Cannot  construct  instance  of  `javautilCollections$UnmodifiableList`  (  no  Creators  ,  like  default  construct  ,  exist  )  :  no  default  no-arguments  constructor  found  assertEquals  (  Collections  .  unmodifiableList  (  new  ArrayList<>  (  input  )  )  .  getClass  (  )  ,  act  .  getClass  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_110_JavaUtilCollectionsDeserializers_3_1	47	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java
1477	CLASS_UNMODIFIABLE_LIST_ALIAS  =  Collections.unmodifiableList(new  LinkedList<Object>()).getClass();  	[BUGGY]  [FE]  jacksondatabindexcInvalidDefinitionException:  Cannot  construct  instance  of  `javautilCollections$UnmodifiableList`  (  no  Creators  ,  like  default  construct  ,  exist  )  :  no  default  no-arguments  constructor  found  assertEquals  (  Collections  .  unmodifiableList  (  new  ArrayList<>  (  input  )  )  .  getClass  (  )  ,  act  .  getClass  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_110_JavaUtilCollectionsDeserializers_3_2	58	0	src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java
1478	}  else  if  (type.hasRawClass(CLASS_UNMODIFIABLE_LIST)  ||  type.hasRawClass(CLASS_UNMODIFIABLE_LIST_ALIAS))  {  	[BUGGY]  }  else  if  (  type  .  hasRawClass  (  CLASS_UNMODIFIABLE_LIST  )  )  {  [FE]  jacksondatabindexcInvalidDefinitionException:  Cannot  construct  instance  of  `javautilCollections$UnmodifiableList`  (  no  Creators  ,  like  default  construct  ,  exist  )  :  no  default  no-arguments  constructor  found  assertEquals  (  Collections  .  unmodifiableList  (  new  ArrayList<>  (  input  )  )  .  getClass  (  )  ,  act  .  getClass  (  )  )  ;  [METHOD]  findForCollection  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  JavaType  type  [CLASS]  JavaUtilCollectionsDeserializers  [TYPE]  DeserializationContext  ctxt  [TYPE]  JavaType  _inputType  type  [TYPE]  Class  CLASS_AS_ARRAYS_LIST  CLASS_SINGLETON_LIST  CLASS_SINGLETON_MAP  CLASS_SINGLETON_SET  CLASS_UNMODIFIABLE_LIST  CLASS_UNMODIFIABLE_MAP  CLASS_UNMODIFIABLE_SET  [TYPE]  boolean  false  true  [TYPE]  JavaUtilCollectionsConverter  conv  [TYPE]  int  TYPE_AS_LIST  TYPE_SINGLETON_LIST  TYPE_SINGLETON_MAP  TYPE_SINGLETON_SET  TYPE_UNMODIFIABLE_LIST  TYPE_UNMODIFIABLE_MAP  TYPE_UNMODIFIABLE_SET  _kind  [CONTEXT]  public  static  JsonDeserializer<?>  findForCollection  (  DeserializationContext  ctxt  ,  JavaType  type  )  throws  JsonMappingException  {  JavaUtilCollectionsConverter  conv  ;    if  (  type  .  hasRawClass  (  CLASS_AS_ARRAYS_LIST  )  )  {  conv  =  converter  (  TYPE_AS_LIST  ,  type  ,  List  .  class  )  ;  }  else  if  (  type  .  hasRawClass  (  CLASS_SINGLETON_LIST  )  )  {  conv  =  converter  (  TYPE_SINGLETON_LIST  ,  type  ,  List  .  class  )  ;  }  else  if  (  type  .  hasRawClass  (  CLASS_SINGLETON_SET  )  )  {  conv  =  converter  (  TYPE_SINGLETON_SET  ,  type  ,  Set  .  class  )  ;  [BUGGY]  }  else  if  (  type  .  hasRawClass  (  CLASS_UNMODIFIABLE_LIST  )  )  {  conv  =  converter  (  TYPE_UNMODIFIABLE_LIST  ,  type  ,  List  .  class  )  ;  }  else  if  (  type  .  hasRawClass  (  CLASS_UNMODIFIABLE_SET  )  )  {  conv  =  converter  (  TYPE_UNMODIFIABLE_SET  ,  type  ,  Set  .  class  )  ;  }  else  {  return  null  ;  }  return  new  StdDelegatingDeserializer<Object>  (  conv  )  ;  }  	JacksonDatabind_110_JavaUtilCollectionsDeserializers_3_3	78	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/JavaUtilCollectionsDeserializers.java
1479	NullValueProvider  nvp  =  (_valueDeserializer  ==  _nullProvider)  ?  deser  :  _nullProvider;  return  new  CreatorProperty(this,  deser,  nvp);  	[BUGGY]  return  new  CreatorProperty  (  this  ,  deser  ,  _nullProvider  )  ;  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [METHOD]  withValueDeserializer  [TYPE]  SettableBeanProperty  [PARAMETER]  JsonDeserializer<?>  deser  [CLASS]  CreatorProperty  [TYPE]  boolean  _ignorable  false  true  [TYPE]  SettableBeanProperty  _fallbackSetter  [TYPE]  AnnotatedParameter  _annotated  [TYPE]  Object  _injectableValueId  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  int  _creatorIndex  [CONTEXT]  public  SettableBeanProperty  withValueDeserializer  (  JsonDeserializer<?>  deser  )  {  if  (  _valueDeserializer  =  =  deser  )  {  return  this  ;  }  [BUGGY]  return  new  CreatorProperty  (  this  ,  deser  ,  _nullProvider  )  ;  }  	JacksonDatabind_111_CreatorProperty_1_1	135	1	src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java
1480	NullValueProvider  nvp  =  (_valueDeserializer  ==  _nullProvider)  ?  deser  :  _nullProvider;  return  new  FieldProperty(this,  deser,  nvp);  	[BUGGY]  return  new  FieldProperty  (  this  ,  deser  ,  _nullProvider  )  ;  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [METHOD]  withValueDeserializer  [TYPE]  SettableBeanProperty  [PARAMETER]  JsonDeserializer<?>  deser  [CLASS]  FieldProperty  [TYPE]  Field  _field  [TYPE]  boolean  _skipNulls  false  true  [TYPE]  AnnotatedField  _annotated  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [CONTEXT]  public  SettableBeanProperty  withValueDeserializer  (  JsonDeserializer<?>  deser  )  {  if  (  _valueDeserializer  =  =  deser  )  {  return  this  ;  }  [BUGGY]  return  new  FieldProperty  (  this  ,  deser  ,  _nullProvider  )  ;  }  	JacksonDatabind_111_FieldProperty_2_1	93	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java
1481	}  	[BUGGY]  }  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_111_FieldProperty_2_2	217	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java
1482	NullValueProvider  nvp  =  (_valueDeserializer  ==  _nullProvider)  ?  deser  :  _nullProvider;  return  new  MethodProperty(this,  deser,  nvp);  	[BUGGY]  return  new  MethodProperty  (  this  ,  deser  ,  _nullProvider  )  ;  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [METHOD]  withValueDeserializer  [TYPE]  SettableBeanProperty  [PARAMETER]  JsonDeserializer<?>  deser  [CLASS]  MethodProperty  [TYPE]  boolean  _skipNulls  false  true  [TYPE]  Method  _setter  [TYPE]  AnnotatedMethod  _annotated  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [CONTEXT]  public  SettableBeanProperty  withValueDeserializer  (  JsonDeserializer<?>  deser  )  {  if  (  _valueDeserializer  =  =  deser  )  {  return  this  ;  }  [BUGGY]  return  new  MethodProperty  (  this  ,  deser  ,  _nullProvider  )  ;  }  	JacksonDatabind_111_MethodProperty_1_1	84	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java
1483	NullValueProvider  nvp  =  (_valueDeserializer  ==  _nullProvider)  ?  deser  :  _nullProvider;  return  new  ObjectIdReferenceProperty(this,  deser,  nvp);  	[BUGGY]  return  new  ObjectIdReferenceProperty  (  this  ,  deser  ,  _nullProvider  )  ;  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [METHOD]  withValueDeserializer  [TYPE]  SettableBeanProperty  [PARAMETER]  JsonDeserializer<?>  deser  [CLASS]  ObjectIdReferenceProperty  [TYPE]  Object  _pojo  [TYPE]  boolean  false  true  [TYPE]  SettableBeanProperty  _forward  [TYPE]  JsonDeserializer  deser  [TYPE]  ObjectIdReferenceProperty  _parent  [TYPE]  long  serialVersionUID  [CONTEXT]  public  SettableBeanProperty  withValueDeserializer  (  JsonDeserializer<?>  deser  )  {  if  (  _valueDeserializer  =  =  deser  )  {  return  this  ;  }  [BUGGY]  return  new  ObjectIdReferenceProperty  (  this  ,  deser  ,  _nullProvider  )  ;  }  	JacksonDatabind_111_ObjectIdReferenceProperty_1_1	54	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java
1484	NullValueProvider  nvp  =  (_valueDeserializer  ==  _nullProvider)  ?  deser  :  _nullProvider;  return  new  ObjectIdValueProperty(this,  deser,  nvp);  	[BUGGY]  return  new  ObjectIdValueProperty  (  this  ,  deser  ,  _nullProvider  )  ;  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [METHOD]  withValueDeserializer  [TYPE]  SettableBeanProperty  [PARAMETER]  JsonDeserializer<?>  deser  [CLASS]  ObjectIdValueProperty  [TYPE]  boolean  false  true  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [TYPE]  ObjectIdReader  _objectIdReader  [CONTEXT]  public  SettableBeanProperty  withValueDeserializer  (  JsonDeserializer<?>  deser  )  {  if  (  _valueDeserializer  =  =  deser  )  {  return  this  ;  }  [BUGGY]  return  new  ObjectIdValueProperty  (  this  ,  deser  ,  _nullProvider  )  ;  }  	JacksonDatabind_111_ObjectIdValueProperty_1_1	55	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java
1485	NullValueProvider  nvp  =  (_valueDeserializer  ==  _nullProvider)  ?  deser  :  _nullProvider;  return  new  SetterlessProperty(this,  deser,  nvp);  	[BUGGY]  return  new  SetterlessProperty  (  this  ,  deser  ,  _nullProvider  )  ;  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [METHOD]  withValueDeserializer  [TYPE]  SettableBeanProperty  [PARAMETER]  JsonDeserializer<?>  deser  [CLASS]  SetterlessProperty  [TYPE]  Method  _getter  [TYPE]  boolean  false  true  [TYPE]  AnnotatedMethod  _annotated  [TYPE]  JsonDeserializer  deser  [TYPE]  long  serialVersionUID  [CONTEXT]  public  SettableBeanProperty  withValueDeserializer  (  JsonDeserializer<?>  deser  )  {  if  (  _valueDeserializer  =  =  deser  )  {  return  this  ;  }  [BUGGY]  return  new  SetterlessProperty  (  this  ,  deser  ,  _nullProvider  )  ;  }  	JacksonDatabind_111_SetterlessProperty_2_1	68	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java
1486	}  	[BUGGY]  }  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [CLASS]  [CONTEXT]  	JacksonDatabind_111_SetterlessProperty_2_2	156	1	src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java
1487	return  new  AtomicReference<Object>(_valueDeserializer.getNullValue(ctxt));  	[BUGGY]  return  new  AtomicReference<Object>  (  )  ;  [FE]  AssertionFailedError  assertNull  (  nullRef  .  refRef  .  get  (  )  .  get  (  )  )  ;  [METHOD]  getNullValue  [TYPE]  AtomicReference  [PARAMETER]  DeserializationContext  ctxt  [CLASS]  AtomicReferenceDeserializer  [TYPE]  DeserializationContext  ctxt  [TYPE]  long  serialVersionUID  [TYPE]  boolean  false  true  [CONTEXT]  public  AtomicReference<Object>  getNullValue  (  DeserializationContext  ctxt  )  throws  JsonMappingException  {  [BUGGY]  return  new  AtomicReference<Object>  (  )  ;  }  	JacksonDatabind_111_AtomicReferenceDeserializer_1_1	43	1	src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java
1488	AnnotatedWithParams  delegateCreator  =  _valueInstantiator.getArrayDelegateCreator();  JavaType  delegateType  =  _valueInstantiator.getArrayDelegateType(ctxt.getConfig());  delegate  =  findDeserializer(ctxt,  delegateType,  property);  }  else  if  ((delegateCreator  =  _valueInstantiator.getDelegateCreator())  !=  null)  {  	[BUGGY]  AnnotatedWithParams  delegateCreator  =  _valueInstantiator  .  getDelegateCreator  (  )  ;  [FE]  jacksondatabindexcMismatchedInputException:  Cannot  construct  instance  of  `comfasterxmljacksondatabinddesercreatorsDelegatingArrayCreator2324Test$ImmutableBag`  (  although  at  least  one  Creator  exists  )  :  no  default  no-arguments  constructor  found  assertEquals  (  3  ,  result  .  getStrings  (  )  .  size  (  )  )  ;  [METHOD]  createContextual  [TYPE]  JsonDeserializer  [PARAMETER]  DeserializationContext  ctxt  BeanProperty  property  [CLASS]  StringCollectionDeserializer  [TYPE]  AnnotatedWithParams  delegateCreator  [TYPE]  JavaType  delegateType  valueType  [TYPE]  boolean  false  true  [TYPE]  ValueInstantiator  _valueInstantiator  [TYPE]  NullValueProvider  nuller  [TYPE]  DeserializationContext  ctxt  [TYPE]  JsonDeserializer  _delegateDeserializer  _valueDeserializer  delegate  valueDeser  [TYPE]  Boolean  unwrapSingle  [TYPE]  long  serialVersionUID  [TYPE]  BeanProperty  property  [CONTEXT]  public  JsonDeserializer<?>  createContextual  (  DeserializationContext  ctxt  ,  BeanProperty  property  )  throws  JsonMappingException  {  JsonDeserializer<Object>  delegate  =  null  ;  if  (  _valueInstantiator  !  =  null  )  {  [BUGGY]  AnnotatedWithParams  delegateCreator  =  _valueInstantiator  .  getDelegateCreator  (  )  ;  if  (  delegateCreator  !  =  null  )  {  JavaType  delegateType  =  _valueInstantiator  .  getDelegateType  (  ctxt  .  getConfig  (  )  )  ;  delegate  =  findDeserializer  (  ctxt  ,  delegateType  ,  property  )  ;  }  }  	JacksonDatabind_112_StringCollectionDeserializer_1_1	107	1	src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java
1489	protected  boolean  _mixedText;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<27>  but  was:<0>  assertEquals  (  20  ,  result  .  radius  .  value  )  ;  [CLASS]  [CONTEXT]  	JacksonXml_2_XmlTokenStream_6_1	62	0	src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
1490	final  boolean  startElementNext  =  _xmlReader.getEventType()  ==  XMLStreamReader.START_ELEMENT;  if  (startElementNext)  {  if  (text  ==  null  ||  _allWs(text))  {  _mixedText  =  false;  }  _mixedText  =  true;  _textValue  =  text;  return  (_currentState  =  XML_TEXT);  	[BUGGY]  if  (  _xmlReader  .  getEventType  (  )  =  =  XMLStreamReader  .  START_ELEMENT  )  {  [FE]  AssertionFailedError:  expected:<27>  but  was:<0>  assertEquals  (  20  ,  result  .  radius  .  value  )  ;  [METHOD]  _next  [TYPE]  int  [PARAMETER]  [CLASS]  XmlTokenStream  [TYPE]  XMLStreamReader2  _xmlReader  [TYPE]  Object  _sourceReference  [TYPE]  String  _localName  _namespaceURI  _nextLocalName  _nextNamespaceURI  _textValue  text  [TYPE]  boolean  false  true  [TYPE]  int  REPLAY_END  REPLAY_START_DELAYED  REPLAY_START_DUP  XML_ATTRIBUTE_NAME  XML_ATTRIBUTE_VALUE  XML_END  XML_END_ELEMENT  XML_START_ELEMENT  XML_TEXT  _attributeCount  _currentState  _nextAttributeIndex  _repeatElement  [TYPE]  ElementWrapper  _currentWrapper  [CONTEXT]  private  final  int  _next  (  )  throws  XMLStreamException  {  switch  (  _currentState  )  {  case  XML_ATTRIBUTE_VALUE:  ++_nextAttributeIndex  ;  case  XML_START_ELEMENT:  //  attributes  to  return?  if  (  _nextAttributeIndex  <  _attributeCount  )  {  _localName  =  _xmlReader  .  getAttributeLocalName  (  _nextAttributeIndex  )  ;  _namespaceURI  =  _xmlReader  .  getAttributeNamespace  (  _nextAttributeIndex  )  ;  _textValue  =  _xmlReader  .  getAttributeValue  (  _nextAttributeIndex  )  ;  return  (  _currentState  =  XML_ATTRIBUTE_NAME  )  ;  }  String  text  =  _collectUntilTag  (  )  ;  [BUGGY]  if  (  _xmlReader  .  getEventType  (  )  =  =  XMLStreamReader  .  START_ELEMENT  )  {  return  _initStartElement  (  )  ;  }  if  (  text  !  =  null  )  {  	JacksonXml_2_XmlTokenStream_6_2	324	1	src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
1491	_mixedText  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<27>  but  was:<0>  assertEquals  (  20  ,  result  .  radius  .  value  )  ;  [METHOD]  _next  [TYPE]  int  [PARAMETER]  [CLASS]  XmlTokenStream  [TYPE]  XMLStreamReader2  _xmlReader  [TYPE]  Object  _sourceReference  [TYPE]  String  _localName  _namespaceURI  _nextLocalName  _nextNamespaceURI  _textValue  text  [TYPE]  boolean  false  true  [TYPE]  int  REPLAY_END  REPLAY_START_DELAYED  REPLAY_START_DUP  XML_ATTRIBUTE_NAME  XML_ATTRIBUTE_VALUE  XML_END  XML_END_ELEMENT  XML_START_ELEMENT  XML_TEXT  _attributeCount  _currentState  _nextAttributeIndex  _repeatElement  [TYPE]  ElementWrapper  _currentWrapper  [CONTEXT]  private  final  int  _next  (  )  throws  XMLStreamException  {  switch  (  _currentState  )  {  case  XML_ATTRIBUTE_VALUE:  ++_nextAttributeIndex  ;  case  XML_START_ELEMENT:  //  attributes  to  return?  if  (  _nextAttributeIndex  <  _attributeCount  )  {  _localName  =  _xmlReader  .  getAttributeLocalName  (  _nextAttributeIndex  )  ;  _namespaceURI  =  _xmlReader  .  getAttributeNamespace  (  _nextAttributeIndex  )  ;  _textValue  =  _xmlReader  .  getAttributeValue  (  _nextAttributeIndex  )  ;  return  (  _currentState  =  XML_ATTRIBUTE_NAME  )  ;  }  String  text  =  _collectUntilTag  (  )  ;  if  (  _xmlReader  .  getEventType  (  )  =  =  XMLStreamReader  .  START_ELEMENT  )  {  return  _initStartElement  (  )  ;  }  if  (  text  !  =  null  )  {  [BUGGY]  _textValue  =  text  ;  return  (  _currentState  =  XML_TEXT  )  ;  }  return  _handleEndElement  (  )  ;  case  XML_ATTRIBUTE_NAME:  	JacksonXml_2_XmlTokenStream_6_3	330	0	src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
1492	_mixedText  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<27>  but  was:<0>  assertEquals  (  20  ,  result  .  radius  .  value  )  ;  [METHOD]  _next  [TYPE]  int  [PARAMETER]  [CLASS]  XmlTokenStream  [TYPE]  XMLStreamReader2  _xmlReader  [TYPE]  Object  _sourceReference  [TYPE]  String  _localName  _namespaceURI  _nextLocalName  _nextNamespaceURI  _textValue  text  [TYPE]  boolean  false  true  [TYPE]  int  REPLAY_END  REPLAY_START_DELAYED  REPLAY_START_DUP  XML_ATTRIBUTE_NAME  XML_ATTRIBUTE_VALUE  XML_END  XML_END_ELEMENT  XML_START_ELEMENT  XML_TEXT  _attributeCount  _currentState  _nextAttributeIndex  _repeatElement  [TYPE]  ElementWrapper  _currentWrapper  [CONTEXT]  private  final  int  _next  (  )  throws  XMLStreamException  {  switch  (  _currentState  )  {  case  XML_ATTRIBUTE_VALUE:  ++_nextAttributeIndex  ;  case  XML_START_ELEMENT:  //  attributes  to  return?  if  (  _nextAttributeIndex  <  _attributeCount  )  {  _localName  =  _xmlReader  .  getAttributeLocalName  (  _nextAttributeIndex  )  ;  _namespaceURI  =  _xmlReader  .  getAttributeNamespace  (  _nextAttributeIndex  )  ;  _textValue  =  _xmlReader  .  getAttributeValue  (  _nextAttributeIndex  )  ;  return  (  _currentState  =  XML_ATTRIBUTE_NAME  )  ;  }  String  text  =  _collectUntilTag  (  )  ;  if  (  _xmlReader  .  getEventType  (  )  =  =  XMLStreamReader  .  START_ELEMENT  )  {  return  _initStartElement  (  )  ;  }  if  (  text  !  =  null  )  {  _textValue  =  text  ;  return  (  _currentState  =  XML_TEXT  )  ;  }  [BUGGY]  return  _handleEndElement  (  )  ;  case  XML_ATTRIBUTE_NAME:  return  (  _currentState  =  XML_ATTRIBUTE_VALUE  )  ;  case  XML_TEXT:  	JacksonXml_2_XmlTokenStream_6_4	333	0	src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
1493	if  (_mixedText){  _mixedText  =  false;  return  _initStartElement();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<27>  but  was:<0>  assertEquals  (  20  ,  result  .  radius  .  value  )  ;  [METHOD]  _next  [TYPE]  int  [PARAMETER]  [CLASS]  XmlTokenStream  [TYPE]  XMLStreamReader2  _xmlReader  [TYPE]  Object  _sourceReference  [TYPE]  String  _localName  _namespaceURI  _nextLocalName  _nextNamespaceURI  _textValue  text  [TYPE]  boolean  false  true  [TYPE]  int  REPLAY_END  REPLAY_START_DELAYED  REPLAY_START_DUP  XML_ATTRIBUTE_NAME  XML_ATTRIBUTE_VALUE  XML_END  XML_END_ELEMENT  XML_START_ELEMENT  XML_TEXT  _attributeCount  _currentState  _nextAttributeIndex  _repeatElement  [TYPE]  ElementWrapper  _currentWrapper  [CONTEXT]  case  XML_START_ELEMENT:  //  attributes  to  return?  if  (  _nextAttributeIndex  <  _attributeCount  )  {  _localName  =  _xmlReader  .  getAttributeLocalName  (  _nextAttributeIndex  )  ;  _namespaceURI  =  _xmlReader  .  getAttributeNamespace  (  _nextAttributeIndex  )  ;  _textValue  =  _xmlReader  .  getAttributeValue  (  _nextAttributeIndex  )  ;  return  (  _currentState  =  XML_ATTRIBUTE_NAME  )  ;  }  String  text  =  _collectUntilTag  (  )  ;  if  (  _xmlReader  .  getEventType  (  )  =  =  XMLStreamReader  .  START_ELEMENT  )  {  return  _initStartElement  (  )  ;  }  if  (  text  !  =  null  )  {  _textValue  =  text  ;  return  (  _currentState  =  XML_TEXT  )  ;  }  return  _handleEndElement  (  )  ;  case  XML_ATTRIBUTE_NAME:  return  (  _currentState  =  XML_ATTRIBUTE_VALUE  )  ;  case  XML_TEXT:  [BUGGY]  return  _handleEndElement  (  )  ;  case  XML_END:  return  XML_END  ;  }  	JacksonXml_2_XmlTokenStream_6_5	340	0	src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
1494	protected  boolean  _allWs(String  str)  {  final  int  len  =  (str  ==  null)  ?  0  :  str.length();  if  (len  >  0)  {  for  (int  i  =  0;  i  <  len;  ++i)  {\n',   "+                                if  (str.charAt(i)  >  '  ')  {\n ",  '+                                        return  false;  }  }  }  return  true;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<27>  but  was:<0>  assertEquals  (  20  ,  result  .  radius  .  value  )  ;  [CLASS]  [CONTEXT]  	JacksonXml_2_XmlTokenStream_6_6	506	0	src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java
1495	return  (_currText  =  _xmlTokens.getText());  	[BUGGY]  _currText  =  _xmlTokens  .  getText  (  )  ;  break  ;  [FE]  ComparisonFailure:  expected:<7>  but  was:<null>  assertToken  (  JsonToken  .  END_OBJECT  ,  xp  .  nextToken  (  )  )  ;  //  </data>  [METHOD]  nextTextValue  [TYPE]  String  [PARAMETER]  [CLASS]  FromXmlParser  [TYPE]  byte[]  _binaryValue  [TYPE]  boolean  _closed  _defaultState  _mayBeLeaf  false  true  [TYPE]  Set  _namesToWrap  [TYPE]  XmlReadContext  _parsingContext  [TYPE]  XmlTokenStream  _xmlTokens  [TYPE]  IOContext  _ioContext  [TYPE]  JsonToken  _nextToken  t  [TYPE]  String  DEFAULT_UNNAMED_TEXT_PROPERTY  _cfgNameForTextElement  _currText  name  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  ByteArrayBuilder  _byteArrayBuilder  [TYPE]  int  _formatFeatures  _mask  token  [CONTEXT]  case  XmlTokenStream  .  XML_END_ELEMENT:  if  (  _mayBeLeaf  )  {  _mayBeLeaf  =  false  ;  _currToken  =  JsonToken  .  VALUE_STRING  ;  return  (  _currText  =   " "  )  ;  }  _currToken  =  _parsingContext  .  inArray  (  )  ?  JsonToken  .  END_ARRAY  :  JsonToken  .  END_OBJECT  ;  _parsingContext  =  _parsingContext  .  getParent  (  )  ;  _namesToWrap  =  _parsingContext  .  getNamesToWrap  (  )  ;  break  ;  case  XmlTokenStream  .  XML_ATTRIBUTE_NAME:  if  (  _mayBeLeaf  )  {  _mayBeLeaf  =  false  ;  _nextToken  =  JsonToken  .  FIELD_NAME  ;  _currText  =  _xmlTokens  .  getText  (  )  ;  _parsingContext  =  _parsingContext  .  createChildObjectContext  (  -1  ,  -1  )  ;  _currToken  =  JsonToken  .  START_OBJECT  ;  }  else  {  _parsingContext  .  setCurrentName  (  _xmlTokens  .  getLocalName  (  )  )  ;  _currToken  =  JsonToken  .  FIELD_NAME  ;  }  break  ;  case  XmlTokenStream  .  XML_ATTRIBUTE_VALUE:  [BUGGY]  _currText  =  _xmlTokens  .  getText  (  )  ;  _currToken  =  JsonToken  .  VALUE_STRING  ;  break  ;  case  XmlTokenStream  .  XML_TEXT:  _currText  =  _xmlTokens  .  getText  (  )  ;  if  (  _mayBeLeaf  )  {  	JacksonXml_3_FromXmlParser_1_1	669	2	src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java
1496	QName  rootName  =  _rootNameFromConfig();  if  (rootName  ==  null)  {  rootName  =  ROOT_NAME_FOR_NULL;  }  _initWithRootName((ToXmlGenerator)  jgen,  rootName);  	[BUGGY]  _initWithRootName  (  (  ToXmlGenerator  )  jgen  ,  ROOT_NAME_FOR_NULL  )  ;  [FE]  ComparisonFailure:  expected:<<[rudy]/>>  but  was:<<[null]/>>  assertEquals  (   "<rudy/> "  ,  xml  )  ;  [METHOD]  _serializeXmlNull  [TYPE]  void  [PARAMETER]  JsonGenerator  jgen  [CLASS]  XmlSerializerProvider  [TYPE]  XmlRootNameLookup  _rootNameLookup  [TYPE]  JsonGenerator  jgen  [TYPE]  boolean  false  true  [TYPE]  QName  ROOT_NAME_FOR_NULL  [TYPE]  long  serialVersionUID  [CONTEXT]  protected  void  _serializeXmlNull  (  JsonGenerator  jgen  )  throws  IOException  {    [BUGGY]  if  (  jgen  instanceof  ToXmlGenerator  )  {  _initWithRootName  (  (  ToXmlGenerator  )  jgen  ,  ROOT_NAME_FOR_NULL  )  ;  }  super  .  serializeValue  (  jgen  ,  null  )  ;  }  	JacksonXml_4_XmlSerializerProvider_1_1	204	1	src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java
1497	_rootNameLookup  =  new  XmlRootNameLookup();  	[BUGGY]  _rootNameLookup  =  src  .  _rootNameLookup  ;  [FE]  AssertionFailedError:  Should  NOT  use  name  'AnnotatedName'  but  'Pojo282'  ,  xml  =  <AnnotatedName><a>3</a></AnnotatedName>  [CLASS]  [CONTEXT]  	JacksonXml_5_XmlSerializerProvider_1_1	59	1	src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java
1498	@Override  public  int  writeBinary(Base64Variant  b64variant,  InputStream  data,  int  dataLength)  throws  IOException  {  if  (data  ==  null)  {  writeNull();  return  0;  }  _verifyValueWrite( "write  Binary  value ");  if  (_nextName  ==  null)  {  handleMissingName();  }  try  {  if  (_nextIsAttribute)  {\n',   "                                    _xmlWriter.writeBinaryAttribute( " ",  _nextName.getNamespaceURI(),  _nextName.getLocalPart(),  fullBuffer);  }  else  if  (checkNextIsUnwrapped())  {  writeStreamAsBinary(data,  dataLength);  }  else  {  if  (_xmlPrettyPrinter  !=  null)  {  _xmlPrettyPrinter.writeLeafElement(_xmlWriter,  _nextName.getNamespaceURI(),  _nextName.getLocalPart(),  toFullBuffer(data,  dataLength),  0,  dataLength);  }  else  {  _xmlWriter.writeStartElement(_nextName.getNamespaceURI(),  _nextName.getLocalPart());  writeStreamAsBinary(data,  dataLength);  _xmlWriter.writeEndElement();  }  }  }  catch  (XMLStreamException  e)  {  StaxUtil.throwAsGenerationException(e,  this);  }  return  dataLength;  }  private  void  writeStreamAsBinary(InputStream  data,  int  len)  throws  IOException,  XMLStreamException  {  byte[]  tmp  =  new  byte[3];  int  offset  =  0;  int  read;  while((read  =  data.read(tmp,  offset,  Math.min(3  -  offset,  len)))  !=  -1)  {  offset  +=  read;  len  -=  read;  if(offset  ==  3)  {  offset  =  0;  _xmlWriter.writeBinary(tmp,  0,  3);  }  if  (len  ==  0)  {  break;  }  }  if(offset  >  0)  {  _xmlWriter.writeBinary(tmp,  0,  offset);  }  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Operation  not  supported  by  generator  of  type  comfasterxmljacksondataformatxmlserToXmlGenerator  (  through  reference  chain:  comfasterxmljacksondataformatxmlserTestBinaryStreamToXMLSerialization$TestPojo[ "field "]  )  assertEquals  (   "<TestPojo><field/></TestPojo> "  ,  xml  )  ;  [CLASS]  [CONTEXT]  	JacksonXml_6_ToXmlGenerator_2_1	843	0	src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java
1499	private  byte[]  toFullBuffer(InputStream  data,  final  int  len)  throws  IOException  {  byte[]  result  =  new  byte[len];  int  offset  =  0;  for  (;  offset  <  len;  )  {  int  count  =  data.read(result,  offset,  len  -  offset);  if  (count  <  0)  {  _reportError( "Too  few  bytes  available:  missing   "+(len  -  offset)+ "  bytes  (out  of   "+len+ ") ");  }  offset  +=  count;  }  return  result;  }  	[BUGGY]  [FE]  jacksondatabindJsonMappingException:  Operation  not  supported  by  generator  of  type  comfasterxmljacksondataformatxmlserToXmlGenerator  (  through  reference  chain:  comfasterxmljacksondataformatxmlserTestBinaryStreamToXMLSerialization$TestPojo[ "field "]  )  assertEquals  (   "<TestPojo><field/></TestPojo> "  ,  xml  )  ;  [CLASS]  [CONTEXT]  	JacksonXml_6_ToXmlGenerator_2_2	866	0	src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java
1500	popStackToClose(tag);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<dy>pre  <script>inner[</script>  aft]</body></html>>  but  was:<dy>pre  <script>inner[  aft</script>]</body></html>>  assertEquals  (   "<html><head></head><body>pre  <script>inner</script>  aft</body></html> "  ,  TextUtil  .  stripNewlines  (  doc  .  html  (  )  )  )  ;  [METHOD]  parseStartTag  [TYPE]  void  [PARAMETER]  [CLASS]  Parser  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  [TYPE]  Attribute  attribute  [TYPE]  Element  child  [TYPE]  Node  dataNode  [TYPE]  Attributes  attributes  [TYPE]  String  DQ  SQ  baseUri  data  href  tagName  [TYPE]  Tag  bodyTag  headTag  htmlTag  tag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [CONTEXT]  return  ;  }  Attributes  attributes  =  new  Attributes  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  isEmpty  (  )  )  {  Attribute  attribute  =  parseAttribute  (  )  ;  if  (  attribute  !  =  null  )  attributes  .  put  (  attribute  )  ;  }  Tag  tag  =  Tag  .  valueOf  (  tagName  )  ;  Element  child  =  new  Element  (  tag  ,  baseUri  ,  attributes  )  ;  boolean  isEmptyElement  =  tag  .  isEmpty  (  )  ;  //  empty  element  if  empty  tag  (  e  .  g  .  img  )  or  self-closed  el  (  <div/>  if  (  tq  .  matchChomp  (   "/> "  )  )  {  //  close  empty  element  or  tag  isEmptyElement  =  true  ;  }  else  {  tq  .  matchChomp  (   "> "  )  ;  }  addChildToParent  (  child  ,  isEmptyElement  )  ;    if  (  tag  .  isData  (  )  )  {  String  data  =  tq  .  chompTo  (   "</ "  +  tagName  )  ;  tq  .  chompTo  (   "> "  )  ;  [BUGGY]  Node  dataNode  ;  if  (  tag  .  equals  (  titleTag  )  ||  tag  .  equals  (  textareaTag  )  )  //  want  to  show  as  text  ,  but  not  contain  inside  tags  (  so  not  a  data  tag?  )  dataNode  =  TextNode  .  createFromEncoded  (  data  ,  baseUri  )  ;  else  dataNode  =  new  DataNode  (  data  ,  baseUri  )  ;  //  data  not  encoded  but  raw  (  for   "  in  script  )  	Jsoup_2_Parser_1_1	148	0	src/main/java/org/jsoup/parser/Parser.java
1501	Element  fragment  =  Parser.parseBodyFragmentRelaxed(html,  baseUri()).body();  	[BUGGY]  Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  append  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [CONTEXT]  public  Element  append  (  String  html  )  {  Validate  .  notNull  (  html  )  ;  [BUGGY]  Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  for  (  Node  node  :  fragment  .  childNodes  (  )  )  {  node  .  parentNode  =  null  ;  appendChild  (  node  )  ;  }  return  this  ;  }  	Jsoup_3_Element_3_1	270	1	src/main/java/org/jsoup/nodes/Element.java
1502	Element  fragment  =  Parser.parseBodyFragmentRelaxed(html,  baseUri()).body();  	[BUGGY]  Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  prepend  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element  [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  fragment  [TYPE]  Node  node  [TYPE]  List  nodes  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  int  i  [CONTEXT]  public  Element  prepend  (  String  html  )  {  Validate  .  notNull  (  html  )  ;  [BUGGY]  Element  fragment  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  List<Node>  nodes  =  fragment  .  childNodes  (  )  ;  for  (  int  i  =  nodes  .  size  (  )  -  1  ;  i  >  =  0  ;  i--  )  {  Node  node  =  nodes  .  get  (  i  )  ;  node  .  parentNode  =  null  ;  prependChild  (  node  )  ;  }  return  this  ;  }  	Jsoup_3_Element_3_2	287	1	src/main/java/org/jsoup/nodes/Element.java
1503	Element  wrapBody  =  Parser.parseBodyFragmentRelaxed(html,  baseUri).body();  	[BUGGY]  Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  wrap  [TYPE]  Element  [PARAMETER]  String  html  [CLASS]  Element  [TYPE]  Set  classNames  [TYPE]  boolean  false  true  [TYPE]  Element  deepest  remainder  wrap  wrapBody  [TYPE]  Tag  tag  [TYPE]  String  html  [TYPE]  Elements  wrapChildren  [TYPE]  int  i  [CONTEXT]  public  Element  wrap  (  String  html  )  {  Validate  .  notEmpty  (  html  )  ;  [BUGGY]  Element  wrapBody  =  Parser  .  parseBodyFragment  (  html  ,  baseUri  )  .  body  (  )  ;  Elements  wrapChildren  =  wrapBody  .  children  (  )  ;  Element  wrap  =  wrapChildren  .  first  (  )  ;  if  (  wrap  =  =  null  )  //  nothing  to  wrap  with  ;  noop  return  null  ;  Element  deepest  =  getDeepChild  (  wrap  )  ;  parentNode  .  replaceChild  (  this  ,  wrap  )  ;  deepest  .  addChild  (  this  )  ;    if  (  wrapChildren  .  size  (  )  >  1  )  {  for  (  int  i  =  1  ;  i  <  wrapChildren  .  size  (  )  ;  i++  )  {  //  skip  first  Element  remainder  =  wrapChildren  .  get  (  i  )  ;  remainder  .  parentNode  .  removeChild  (  remainder  )  ;  wrap  .  appendChild  (  remainder  )  ;  }  }  return  this  ;  }  	Jsoup_3_Element_3_3	314	1	src/main/java/org/jsoup/nodes/Element.java
1504	private  boolean  relaxed  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Parser_5_1	26	0	src/main/java/org/jsoup/parser/Parser.java
1505	public  static  Document  parseBodyFragmentRelaxed(String  bodyHtml,  String  baseUri)  {  Parser  parser  =  new  Parser(bodyHtml,  baseUri,  true);  parser.relaxed  =  true;  return  parser.parse();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Parser_5_2	73	0	src/main/java/org/jsoup/parser/Parser.java
1506	if  (!validAncestor  &&  !relaxed)  {  	[BUGGY]  if  (  !validAncestor  )  {  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  addChildToParent  [TYPE]  Element  [PARAMETER]  Element  child  boolean  isEmptyElement  [CLASS]  Parser  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  isEmptyElement  true  validAncestor  [TYPE]  Element  child  head  implicit  parent  root  [TYPE]  String  DQ  SQ  baseUri  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parentTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [CONTEXT]  private  Element  addChildToParent  (  Element  child  ,  boolean  isEmptyElement  )  {  Element  parent  =  popStackToSuitableContainer  (  child  .  tag  (  )  )  ;  Tag  childTag  =  child  .  tag  (  )  ;  boolean  validAncestor  =  stackHasValidParent  (  childTag  )  ;  [BUGGY]  if  (  !validAncestor  )  {  Tag  parentTag  =  childTag  .  getImplicitParent  (  )  ;  Element  implicit  =  new  Element  (  parentTag  ,  baseUri  )  ;  if  (  child  .  tag  (  )  .  equals  (  bodyTag  )  )  {  Element  head  =  new  Element  (  headTag  ,  baseUri  )  ;  implicit  .  appendChild  (  head  )  ;  }  implicit  .  appendChild  (  child  )  ;    Element  root  =  addChildToParent  (  implicit  ,  false  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  root  ;  }  parent  .  appendChild  (  child  )  ;  if  (  !isEmptyElement  )  stack  .  addLast  (  child  )  ;  return  parent  ;  }  	Jsoup_3_Parser_5_3	224	1	src/main/java/org/jsoup/parser/Parser.java
1507	if  (childTag.requiresSpecificParent())  return  stack.getLast().tag().isValidParent(childTag);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )  =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node  [BUGGY]  for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }  	Jsoup_3_Parser_5_4	253	0	src/main/java/org/jsoup/parser/Parser.java
1508	if  (parent2.isValidAncestor(childTag))  {  	[BUGGY]  if  (  parent2  .  isValidParent  (  childTag  )  )  {  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  stackHasValidParent  [TYPE]  boolean  [PARAMETER]  Tag  childTag  [CLASS]  Parser  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  String  DQ  SQ  baseUri  [TYPE]  Tag  bodyTag  childTag  headTag  htmlTag  parent2  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [TYPE]  int  i  [CONTEXT]  private  boolean  stackHasValidParent  (  Tag  childTag  )  {  if  (  stack  .  size  (  )  =  =  1  &&  childTag  .  equals  (  htmlTag  )  )  return  true  ;  //  root  is  valid  for  html  node    for  (  int  i  =  stack  .  size  (  )  -1  ;  i  >  =  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  Tag  parent2  =  el  .  tag  (  )  ;  [BUGGY]  if  (  parent2  .  isValidParent  (  childTag  )  )  {  return  true  ;  }  }  return  false  ;  }  	Jsoup_3_Parser_5_5	258	1	src/main/java/org/jsoup/parser/Parser.java
1509	private  Tag  parent;    	[BUGGY]  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Tag_9_1	28	0	src/main/java/org/jsoup/parser/Tag.java
1510	return  false;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  canContain  [TYPE]  boolean  [PARAMETER]  Tag  child  [CLASS]  Tag  [TYPE]  List  ancestors  [TYPE]  boolean  canContainBlock  canContainInline  empty  false  isBlock  optionalClosing  preserveWhitespace  true  [TYPE]  Tag  child  defaultAncestor  [TYPE]  String  tagName  [TYPE]  Map  tags  [CONTEXT]  return  false  ;  if  (  this  .  optionalClosing  &&  this  .  equals  (  child  )  )  return  false  ;  if  (  this  .  empty  ||  this  .  isData  (  )  )  return  false  ;    if  (  this  .  tagName  .  equals  (   "head "  )  )  {  if  (  child  .  tagName  .  equals  (   "base "  )  ||  child  .  tagName  .  equals  (   "script "  )  ||  child  .  tagName  .  equals  (   "noscript "  )  ||  child  .  tagName  .  equals  (   "link "  )  ||  child  .  tagName  .  equals  (   "meta "  )  ||  child  .  tagName  .  equals  (   "title "  )  ||  child  .  tagName  .  equals  (   "style "  )  ||  child  .  tagName  .  equals  (   "object "  )  )  {  return  true  ;  }  return  false  ;  }  if  (  this  .  tagName  .  equals  (   "dt "  )  &&  child  .  tagName  .  equals  (   "dd "  )  )  return  false  ;  if  (  this  .  tagName  .  equals  (   "dd "  )  &&  child  .  tagName  .  equals  (   "dt "  )  )  return  false  ;    [BUGGY]  return  true  ;  }  Gets  if  this  is  a  block  tag  .  	Jsoup_3_Tag_9_2	99	0	src/main/java/org/jsoup/parser/Tag.java
1511	boolean  requiresSpecificParent()  {  return  this.parent  !=  null;  }  return  this.equals(child.parent);  }  boolean  isValidAncestor(Tag  child)  {  	[BUGGY]  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Tag_9_3	155	0	src/main/java/org/jsoup/parser/Tag.java
1512	createBlock( "FRAME ").setParent( "FRAMESET ").setEmpty();  createBlock( "NOFRAMES ").setParent( "FRAMESET ").setContainDataOnly();  	[BUGGY]  createBlock  (   "FRAME "  )  .  setAncestor  (   "FRAMESET "  )  .  setEmpty  (  )  ;  createBlock  (   "NOFRAMES "  )  .  setAncestor  (   "FRAMESET "  )  .  setContainDataOnly  (  )  ;  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Tag_9_4	224	2	src/main/java/org/jsoup/parser/Tag.java
1513	createInline( "OPTGROUP ").setParent( "SELECT ");    createInline( "OPTION ").setParent( "SELECT ").setContainDataOnly();  	[BUGGY]  createInline  (   "OPTGROUP "  )  .  setAncestor  (   "SELECT "  )  ;  createInline  (   "OPTION "  )  .  setAncestor  (   "SELECT "  )  .  setContainDataOnly  (  )  ;  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Tag_9_5	288	2	src/main/java/org/jsoup/parser/Tag.java
1514	createInline( "PARAM ").setParent( "OBJECT ").setEmpty();  	[BUGGY]  createInline  (   "PARAM "  )  .  setAncestor  (   "OBJECT "  )  .  setEmpty  (  )  ;  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Tag_9_6	295	1	src/main/java/org/jsoup/parser/Tag.java
1515	createInline( "DT ").setParent( "DL ").setOptionalClosing();    createInline( "DD ").setParent( "DL ").setOptionalClosing();    	[BUGGY]  createInline  (   "DT "  )  .  setAncestor  (   "DL "  )  .  setOptionalClosing  (  )  ;  createInline  (   "DD "  )  .  setAncestor  (   "DL "  )  .  setOptionalClosing  (  )  ;  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Tag_9_7	300	2	src/main/java/org/jsoup/parser/Tag.java
1516	createBlock( "CAPTION ").setParent( "TABLE ");  createBlock( "THEAD ").setParent( "TABLE ").setOptionalClosing();    createBlock( "TFOOT ").setParent( "TABLE ").setOptionalClosing();    createBlock( "TBODY ").setParent( "TABLE ").setOptionalClosing();    createBlock( "COLGROUP ").setParent( "TABLE ").setOptionalClosing();    createBlock( "COL ").setParent( "COLGROUP ").setEmpty();  createBlock( "TR ").setParent( "TABLE ").setOptionalClosing();    createBlock( "TH ").setParent( "TR ").setOptionalClosing();  createBlock( "TD ").setParent( "TR ").setOptionalClosing();  	[BUGGY]  createBlock  (   "CAPTION "  )  .  setAncestor  (   "TABLE "  )  ;  createBlock  (   "THEAD "  )  .  setAncestor  (   "TABLE "  )  .  setOptionalClosing  (  )  ;  createBlock  (   "TFOOT "  )  .  setAncestor  (   "TABLE "  )  .  setOptionalClosing  (  )  ;  createBlock  (   "TBODY "  )  .  setAncestor  (   "TABLE "  )  .  setOptionalClosing  (  )  ;  createBlock  (   "COLGROUP "  )  .  setAncestor  (   "TABLE "  )  .  setOptionalClosing  (  )  ;  createBlock  (   "COL "  )  .  setAncestor  (   "COLGROUP "  )  .  setEmpty  (  )  ;  createBlock  (   "TR "  )  .  setAncestor  (   "TABLE "  )  .  setOptionalClosing  (  )  ;  createBlock  (   "TH "  )  .  setAncestor  (   "TR "  )  .  setOptionalClosing  (  )  ;  createBlock  (   "TD "  )  .  setAncestor  (   "TR "  )  .  setOptionalClosing  (  )  ;  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Tag_9_8	307	9	src/main/java/org/jsoup/parser/Tag.java
1517	private  Tag  setParent(String  tagName)  {  parent  =  Tag.valueOf(tagName);  setAncestor(tagName);  return  this;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<tr><td>1</td></tr><t[r><td>2</td></tr]></table>>  but  was:<tr><td>1</td></tr><t[able><tr><td>2</td></tr></table]></table>>  assertEquals  (   "<table><tr><td>1</td></tr><tr><td>2</td></tr></table> "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_3_Tag_9_9	379	0	src/main/java/org/jsoup/parser/Tag.java
1518	String  name  =  m.group(1);  	[BUGGY]  String  name  =  m  .  group  (  1  )  .  toLowerCase  (  )  ;  [FE]  AssertionFailedError:  expected:<ello  &amp  ;  &lt  ;  &gt  ;  &[A]ring  ;  &aring  ;  &#960  ;  >  but  was:<ello  &amp  ;  &lt  ;  &gt  ;  &[a]ring  ;  &aring  ;  &#960  ;  >  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [METHOD]  unescape  [TYPE]  String  [PARAMETER]  String  string  [CLASS]  Entities  [TYPE]  Pattern  unescapePattern  [TYPE]  StringBuffer  accum  [TYPE]  boolean  false  true  [TYPE]  Matcher  m  [TYPE]  EscapeMode  base  extended  [TYPE]  Object[][]  baseArray  fullArray  [TYPE]  NumberFormatException  e  [TYPE]  String  c  name  num  string  [TYPE]  Map  baseByVal  full  fullByVal  [TYPE]  int  base  charval  [CONTEXT]  static  String  unescape  (  String  string  )  {  if  (  !string  .  contains  (   "& "  )  )  return  string  ;  Matcher  m  =  unescapePattern  .  matcher  (  string  )  ;  //  &  (  #  (  x|X  )  ?  (  [0-9a-fA-F]+  )  |[a-zA-Z]+  )  ;  ?  StringBuffer  accum  =  new  StringBuffer  (  string  .  length  (  )  )  ;  //  pity  matcher  can't  use  stringbuilder  ,  avoid  syncs  while  (  m  .  find  (  )  )  {  int  charval  =  -1  ;  String  num  =  m  .  group  (  3  )  ;  if  (  num  !  =  null  )  {  try  {  int  base  =  m  .  group  (  2  )  !  =  null  ?  16  :  10  ;  //  2  is  hex  indicator  charval  =  Integer  .  valueOf  (  num  ,  base  )  ;  }  catch  (  NumberFormatException  e  )  {  }  //  skip  }  else  {  [BUGGY]  String  name  =  m  .  group  (  1  )  .  toLowerCase  (  )  ;  if  (  full  .  containsKey  (  name  )  )  charval  =  full  .  get  (  name  )  ;  }  if  (  charval  !  =  -1  ||  charval  >  0xFFFF  )  {  //  out  of  range  	Jsoup_4_Entities_3_1	64	1	src/main/java/org/jsoup/nodes/Entities.java
1519	baseByVal.put(c,  ((String)  entity[0]));  	[BUGGY]  baseByVal  .  put  (  c  ,  (  (  String  )  entity[0]  )  .  toLowerCase  (  )  )  ;  [FE]  AssertionFailedError:  expected:<ello  &amp  ;  &lt  ;  &gt  ;  &[A]ring  ;  &aring  ;  &#960  ;  >  but  was:<ello  &amp  ;  &lt  ;  &gt  ;  &[a]ring  ;  &aring  ;  &#960  ;  >  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_4_Entities_3_2	2235	1	src/main/java/org/jsoup/nodes/Entities.java
1520	fullByVal.put(c,  ((String)  entity[0]));  	[BUGGY]  fullByVal  .  put  (  c  ,  (  (  String  )  entity[0]  )  .  toLowerCase  (  )  )  ;  [FE]  AssertionFailedError:  expected:<ello  &amp  ;  &lt  ;  &gt  ;  &[A]ring  ;  &aring  ;  &#960  ;  >  but  was:<ello  &amp  ;  &lt  ;  &gt  ;  &[a]ring  ;  &aring  ;  &#960  ;  >  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_4_Entities_3_3	2240	1	src/main/java/org/jsoup/nodes/Entities.java
1521	if  (value.length()  ==  0)    tq.advance();  	[BUGGY]  tq  .  consume  (  )  ;  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  14  assertEquals  (   "<p></p>\n<p></p> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  parseAttribute  [TYPE]  Attribute  [PARAMETER]  [CLASS]  Parser  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  relaxed  true  [TYPE]  StringBuilder  valueAccum  [TYPE]  String  DQ  SQ  baseUri  key  value  [TYPE]  Tag  bodyTag  headTag  htmlTag  textareaTag  titleTag  [TYPE]  Document  doc  [TYPE]  LinkedList  stack  [CONTEXT]  private  Attribute  parseAttribute  (  )  {  tq  .  consumeWhitespace  (  )  ;  String  key  =  tq  .  consumeAttributeKey  (  )  ;  String  value  =   " "  ;  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  =   "  )  )  {  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (  SQ  )  )  {  value  =  tq  .  chompTo  (  SQ  )  ;  }  else  if  (  tq  .  matchChomp  (  DQ  )  )  {  value  =  tq  .  chompTo  (  DQ  )  ;  }  else  {  StringBuilder  valueAccum  =  new  StringBuilder  (  )  ;  while  (  !tq  .  matchesAny  (   "< "  ,   "/> "  ,   "> "  )  &&  !tq  .  matchesWhitespace  (  )  &&  !tq  .  isEmpty  (  )  )  {  valueAccum  .  append  (  tq  .  consume  (  )  )  ;  }  value  =  valueAccum  .  toString  (  )  ;  }  tq  .  consumeWhitespace  (  )  ;  }  if  (  key  .  length  (  )  !  =  0  )  return  Attribute  .  createFromEncoded  (  key  ,  value  )  ;  else  {  [BUGGY]  tq  .  consume  (  )  ;  return  null  ;  }  }  	Jsoup_5_Parser_1_1	206	1	src/main/java/org/jsoup/parser/Parser.java
1522	m.appendReplacement(accum,  Matcher.quoteReplacement(c));  m.appendReplacement(accum,  Matcher.quoteReplacement(m.group(0)));    	[BUGGY]  m  .  appendReplacement  (  accum  ,  c  )  ;  m  .  appendReplacement  (  accum  ,  m  .  group  (  0  )  )  ;  [FE]  IllegalArgumentException:  Illegal  group  reference:  group  index  is  missing  assertEquals  (   "In  July  ,  GM  said  its  electric  Chevrolet  Volt  will  be  sold  in  the  United  States  at  $41  ,  000  --  $8  ,  000  more  than  its  nearest  competitor  ,  the  Nissan  Leaf  .   "  ,  p  .  text  (  )  )  ;  [METHOD]  unescape  [TYPE]  String  [PARAMETER]  String  string  [CLASS]  Entities  [TYPE]  Pattern  unescapePattern  [TYPE]  StringBuffer  accum  [TYPE]  boolean  false  true  [TYPE]  Matcher  m  [TYPE]  EscapeMode  base  extended  [TYPE]  Object[][]  baseArray  fullArray  [TYPE]  NumberFormatException  e  [TYPE]  String  c  name  num  string  [TYPE]  Map  baseByVal  full  fullByVal  [TYPE]  int  base  charval  [CONTEXT]  static  String  unescape  (  String  string  )  {  if  (  !string  .  contains  (   "& "  )  )  return  string  ;  Matcher  m  =  unescapePattern  .  matcher  (  string  )  ;  //  &  (  #  (  x|X  )  ?  (  [0-9a-fA-F]+  )  |[a-zA-Z]+  )  ;  ?  StringBuffer  accum  =  new  StringBuffer  (  string  .  length  (  )  )  ;  //  pity  matcher  can't  use  stringbuilder  ,  avoid  syncs  while  (  m  .  find  (  )  )  {  int  charval  =  -1  ;  String  num  =  m  .  group  (  3  )  ;  if  (  num  !  =  null  )  {  try  {  int  base  =  m  .  group  (  2  )  !  =  null  ?  16  :  10  ;  //  2  is  hex  indicator  charval  =  Integer  .  valueOf  (  num  ,  base  )  ;  }  catch  (  NumberFormatException  e  )  {  }  //  skip  }  else  {  String  name  =  m  .  group  (  1  )  ;  if  (  full  .  containsKey  (  name  )  )  charval  =  full  .  get  (  name  )  ;  }  if  (  charval  !  =  -1  ||  charval  >  0xFFFF  )  {  //  out  of  range  String  c  =  Character  .  toString  (  (  char  )  charval  )  ;  [BUGGY]  m  .  appendReplacement  (  accum  ,  c  )  ;  }  else  {  m  .  appendReplacement  (  accum  ,  m  .  group  (  0  )  )  ;  }  }  m  .  appendTail  (  accum  )  ;  	Jsoup_6_Entities_1_1	70	2	src/main/java/org/jsoup/nodes/Entities.java
1523		[BUGGY]  [FE]  AssertionFailedError:  expected:<</script><noscript><[/noscript></head><body><p>two</p><p>three</p></body]></html>>  but  was:<</script><noscript><[body><p>two</p><body><p>three</p></body></body></noscript></head]></html>>  assertEquals  (   "<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p></body></html> "  ,  TextUtil  .  stripNewlines  (  doc  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_7_Document_3_1	5	0	src/main/java/org/jsoup/nodes/Document.java
1524	normaliseStructure( "head ",  htmlEl);  normaliseStructure( "body ",  htmlEl);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<</script><noscript><[/noscript></head><body><p>two</p><p>three</p></body]></html>>  but  was:<</script><noscript><[body><p>two</p><body><p>three</p></body></body></noscript></head]></html>>  assertEquals  (   "<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p></body></html> "  ,  TextUtil  .  stripNewlines  (  doc  .  html  (  )  )  )  ;  [METHOD]  normalise  [TYPE]  Document  [PARAMETER]  [CLASS]  Document  [TYPE]  boolean  false  prettyPrint  true  [TYPE]  OutputSettings  outputSettings  [TYPE]  Element  htmlEl  [TYPE]  EscapeMode  escapeMode  [TYPE]  Charset  charset  [TYPE]  CharsetEncoder  charsetEncoder  [TYPE]  int  indentAmount  [CONTEXT]  public  Document  normalise  (  )  {  Element  htmlEl  =  findFirstElementByTagName  (   "html "  ,  this  )  ;  if  (  htmlEl  =  =  null  )  htmlEl  =  appendElement  (   "html "  )  ;  if  (  head  (  )  =  =  null  )  htmlEl  .  prependElement  (   "head "  )  ;  if  (  body  (  )  =  =  null  )  htmlEl  .  appendElement  (   "body "  )  ;    normaliseTextNodes  (  head  (  )  )  ;  normaliseTextNodes  (  htmlEl  )  ;  normaliseTextNodes  (  this  )  ;  [BUGGY]  return  this  ;  }  	Jsoup_7_Document_3_2	113	0	src/main/java/org/jsoup/nodes/Document.java
1525	private  void  normaliseStructure(String  tag,  Element  htmlEl)  {  Elements  elements  =  this.getElementsByTag(tag);  Element  master  =  elements.first();    if  (elements.size()  >  1)  {    List<Node>  toMove  =  new  ArrayList<Node>();  for  (int  i  =  1;  i  <  elements.size();  i++)  {  Node  dupe  =  elements.get(i);  for  (Node  node  :  dupe.childNodes)  toMove.add(node);  dupe.remove();  }    for  (Node  dupe  :  toMove)  master.appendChild(dupe);  }  if  (!master.parent().equals(htmlEl))  {  htmlEl.appendChild(master);    }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<</script><noscript><[/noscript></head><body><p>two</p><p>three</p></body]></html>>  but  was:<</script><noscript><[body><p>two</p><body><p>three</p></body></body></noscript></head]></html>>  assertEquals  (   "<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p></body></html> "  ,  TextUtil  .  stripNewlines  (  doc  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_7_Document_3_3	137	0	src/main/java/org/jsoup/nodes/Document.java
1526	new  NodeTraversor(new  OuterHtmlVisitor(accum,  getOutputSettings())).traverse(this);  	[BUGGY]  new  NodeTraversor  (  new  OuterHtmlVisitor  (  accum  ,  ownerDocument  (  )  .  outputSettings  (  )  )  )  .  traverse  (  this  )  ;  [FE]  NullPointerException  assertEquals  (   "<img  src  =  \ "foo\ "  /> "  ,  img  .  toString  (  )  )  ;  [METHOD]  outerHtml  [TYPE]  void  [PARAMETER]  StringBuilder  accum  [CLASS]  Node  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  int  siblingIndex  [CONTEXT]  protected  void  outerHtml  (  StringBuilder  accum  )  {  [BUGGY]  new  NodeTraversor  (  new  OuterHtmlVisitor  (  accum  ,  ownerDocument  (  )  .  outputSettings  (  )  )  )  .  traverse  (  this  )  ;  }  	Jsoup_8_Node_2_1	363	1	src/main/java/org/jsoup/nodes/Node.java
1527	private  Document.OutputSettings  getOutputSettings()  {  return  ownerDocument()  !=  null  ?  ownerDocument().outputSettings()  :  (new  Document( " ")).outputSettings();  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (   "<img  src  =  \ "foo\ "  /> "  ,  img  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_8_Node_2_2	367	0	src/main/java/org/jsoup/nodes/Node.java
1528	private  static  final  Pattern  unescapePattern  =  Pattern.compile( "&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);? ");  	[BUGGY]  private  static  final  Pattern  unescapePattern  =  Pattern  .  compile  (   "&  (  #  (  x|X  )  ?  (  [0-9a-fA-F]+  )  |[a-zA-Z]+  )  ;  ? "  )  ;  [FE]  AssertionFailedError:  expected:<<>  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_9_Entities_1_1	38	1	src/main/java/org/jsoup/nodes/Entities.java
1529	relUrl  =  base.getPath()  +  relUrl;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<tp://jsouporg/path/[file]?foo>  but  was:<tp://jsouporg/path/[]?foo>  assertEquals  (   "http://jsoup  .  org/path/bar  .  html?foo "  ,  a2  .  absUrl  (   "href "  )  )  ;  [METHOD]  absUrl  [TYPE]  String  [PARAMETER]  String  attributeKey  [CLASS]  Node  [TYPE]  MalformedURLException  e  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  relUrl  [TYPE]  int  siblingIndex  [TYPE]  URL  abs  base  [CONTEXT]  public  String  absUrl  (  String  attributeKey  )  {  Validate  .  notEmpty  (  attributeKey  )  ;  String  relUrl  =  attr  (  attributeKey  )  ;  if  (  !hasAttr  (  attributeKey  )  )  {  return   " "  ;  //  nothing  to  make  absolute  with  }  else  {  URL  base  ;  try  {  try  {  base  =  new  URL  (  baseUri  )  ;  }  catch  (  MalformedURLException  e  )  {  URL  abs  =  new  URL  (  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  [BUGGY]  URL  abs  =  new  URL  (  base  ,  relUrl  )  ;  return  abs  .  toExternalForm  (  )  ;  }  catch  (  MalformedURLException  e  )  {  return   " "  ;  }  }  }  	Jsoup_10_Node_1_1	173	0	src/main/java/org/jsoup/nodes/Node.java
1530	}  else  if  (tq.matches( ":has( "))  {  elements.addAll(root.getAllElements());  	[BUGGY]  [FE]  selectSelector$SelectorParseException:  Could  not  parse  query  ':not  (  p  )  ':  unexpected  token  at  ':not  (  p  )  '  assertEquals  (   "span "  ,  el1  .  last  (  )  .  tagName  (  )  )  ;  [METHOD]  select  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Element  root  [TYPE]  String[]  combinators  [TYPE]  String  query  subQuery  [TYPE]  Elements  candidates  [CONTEXT]  private  Elements  select  (  )  {  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  elements  .  add  (  root  )  ;  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  [BUGGY]  }  else  {  addElements  (  findElements  (  )  )  ;  //  chomp  first  element  matcher  off  queue  }  while  (  !tq  .  isEmpty  (  )  )  {  boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  //  group  or  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  elements  .  addAll  (  select  (  subQuery  ,  root  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  combinator  (  tq  .  consume  (  )  .  toString  (  )  )  ;  }  else  if  (  seenWhite  )  {  combinator  (   "   "  )  ;  }  else  {  //  E  .  class  ,  E#id  ,  E[attr]  etc  .  AND  Elements  candidates  =  findElements  (  )  ;  //  take  next  el  ,  #  .  etc  off  queue  intersectElements  (  filterForSelf  (  elements  ,  candidates  )  )  ;  }  }  return  new  Elements  (  elements  )  ;  }  	Jsoup_11_Selector_4_1	110	0	src/main/java/org/jsoup/select/Selector.java
1531	}  else  if  (tq.matches( ":not( "))  {  return  not();  	[BUGGY]  [FE]  selectSelector$SelectorParseException:  Could  not  parse  query  ':not  (  p  )  ':  unexpected  token  at  ':not  (  p  )  '  assertEquals  (   "span "  ,  el1  .  last  (  )  .  tagName  (  )  )  ;  [METHOD]  findElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Selector  [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  String[]  combinators  [TYPE]  String  query  [TYPE]  boolean  false  true  [TYPE]  Element  root  [CONTEXT]  return  byId  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "  .   "  )  )  {  return  byClass  (  )  ;  }  else  if  (  tq  .  matchesWord  (  )  )  {  return  byTag  (  )  ;  }  else  if  (  tq  .  matches  (   "[ "  )  )  {  return  byAttribute  (  )  ;  }  else  if  (  tq  .  matchChomp  (   "* "  )  )  {  return  allElements  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":lt  (   "  )  )  {  return  indexLessThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":gt  (   "  )  )  {  return  indexGreaterThan  (  )  ;  }  else  if  (  tq  .  matchChomp  (   ":eq  (   "  )  )  {  return  indexEquals  (  )  ;  }  else  if  (  tq  .  matches  (   ":has  (   "  )  )  {  return  has  (  )  ;  }  else  if  (  tq  .  matches  (   ":contains  (   "  )  )  {  return  contains  (  false  )  ;  }  else  if  (  tq  .  matches  (   ":containsOwn  (   "  )  )  {  return  contains  (  true  )  ;  }  else  if  (  tq  .  matches  (   ":matches  (   "  )  )  {  return  matches  (  false  )  ;  }  else  if  (  tq  .  matches  (   ":matchesOwn  (   "  )  )  {  return  matches  (  true  )  ;  [BUGGY]  }  else  {  //  unhandled  throw  new  SelectorParseException  (   "Could  not  parse  query  '%s':  unexpected  token  at  '%s' "  ,  query  ,  tq  .  remainder  (  )  )  ;  }  }  private  void  addElements  (  Collection<Element>  add  )  {  	Jsoup_11_Selector_4_2	181	0	src/main/java/org/jsoup/select/Selector.java
1532	private  Elements  not()  {  tq.consume( ":not ");\n',   "+                String  subQuery  =  tq.chompBalanced('(',  ')');\n ",  '+                Validate.notEmpty(subQuery,   ":not(selector)  subselect  must  not  be  empty ");  return  filterOut(root.getAllElements(),  select(subQuery,  root));  }  	[BUGGY]  [FE]  selectSelector$SelectorParseException:  Could  not  parse  query  ':not  (  p  )  ':  unexpected  token  at  ':not  (  p  )  '  assertEquals  (   "span "  ,  el1  .  last  (  )  .  tagName  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_11_Selector_4_3	305	0	src/main/java/org/jsoup/select/Selector.java
1533	static  Elements  filterOut(Collection<Element>  elements,  Collection<Element>  outs)  {  Elements  output  =  new  Elements();  for  (Element  el:  elements)  {  boolean  found  =  false;  for  (Element  out:  outs)  {  if  (el.equals(out))  {  found  =  true;  break;  }  }  if  (!found)  output.add(el);  }  return  output;  }  	[BUGGY]  [FE]  selectSelector$SelectorParseException:  Could  not  parse  query  ':not  (  p  )  ':  unexpected  token  at  ':not  (  p  )  '  assertEquals  (   "span "  ,  el1  .  last  (  )  .  tagName  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_11_Selector_4_4	399	0	src/main/java/org/jsoup/select/Selector.java
1534	String  subQuery  =  consumeSubQuery();    	[BUGGY]  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  [FE]  selectSelector$SelectorParseException:  Could  not  parse  query  '  =  x|y]':  unexpected  token  at  '  =  x|y]'  assertEquals  (   "Hello "  ,  els  .  text  (  )  )  ;  [METHOD]  combinator  [TYPE]  void  [PARAMETER]  char  combinator  [CLASS]  Selector  [TYPE]  LinkedHashSet  elements  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  Element  root  [TYPE]  char  combinator  [TYPE]  String[]  combinators  [TYPE]  String  query  subQuery  [TYPE]  Elements  output  [CONTEXT]  private  void  combinator  (  char  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  [BUGGY]  String  subQuery  =  tq  .  consumeToAny  (  combinators  )  ;  Elements  output  ;  if  (  combinator  =  =  '>'  )  output  =  filterForChildren  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  =  =  '  '  )  output  =  filterForDescendants  (  elements  ,  select  (  subQuery  ,  elements  )  )  ;  else  if  (  combinator  =  =  '+'  )  output  =  filterForAdjacentSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  if  (  combinator  =  =  '~'  )  output  =  filterForGeneralSiblings  (  elements  ,  select  (  subQuery  ,  root  )  )  ;  else  throw  new  IllegalStateException  (   "Unknown  combinator:   "  +  combinator  )  ;  elements  .  clear  (  )  ;  elements  .  addAll  (  output  )  ;  }  	Jsoup_12_Selector_2_1	139	1	src/main/java/org/jsoup/select/Selector.java
1535	private  String  consumeSubQuery()  {  StringBuilder  sq  =  new  StringBuilder();  while  (!tq.isEmpty())  {  if  (tq.matches( "( "))  sq.append( "( ").append(tq.chompBalanced(\'(\',  \')\')).append( ") ");  else  if  (tq.matches( "[ "))  sq.append( "[ ").append(tq.chompBalanced(\'[\',  \']\')).append( "] ");  else  if  (tq.matchesAny(combinators))  break;  else  sq.append(tq.consume());  }  return  sq.toString();  }  	[BUGGY]  [FE]  selectSelector$SelectorParseException:  Could  not  parse  query  '  =  x|y]':  unexpected  token  at  '  =  x|y]'  assertEquals  (   "Hello "  ,  els  .  text  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_12_Selector_2_2	156	0	src/main/java/org/jsoup/select/Selector.java
1536	if  (attributeKey.toLowerCase().startsWith( "abs: "))  {  String  key  =  attributeKey.substring( "abs: ".length());  if  (attributes.hasKey(key)  &&  !absUrl(key).equals( " "))  return  true;  }  	[BUGGY]  [FE]  AssertionFailedError  assertEquals  (   "http://jsoup  .  org/ "  ,  two  .  absUrl  (   "href "  )  )  ;  [METHOD]  hasAttr  [TYPE]  boolean  [PARAMETER]  String  attributeKey  [CLASS]  Node  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  attributeKey  baseUri  [TYPE]  int  siblingIndex  [CONTEXT]  public  boolean  hasAttr  (  String  attributeKey  )  {  Validate  .  notNull  (  attributeKey  )  ;  [BUGGY]  return  attributes  .  hasKey  (  attributeKey  )  ;  }  	Jsoup_13_Node_1_1	107	0	src/main/java/org/jsoup/nodes/Node.java
1537	String  appropriateEndTagName()  {  return  lastStartTag.tagName;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<one[]>  but  was:<one[<p>two]>  assertEquals  (   "two "  ,  doc  .  select  (   "p "  )  .  get  (  1  )  .  text  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_14_Tokeniser_1_1	197	0	src/main/java/org/jsoup/parser/Tokeniser.java
1538	}  else  if  (r.matchesLetter()  &&  !r.containsIgnoreCase( "</ "  +  t.appropriateEndTagName()))  {\n',   "                                    t.tagPending  =  new  Token.EndTag(t.appropriateEndTagName());  t.emitTagPending();  r.unconsume();    t.transition(Data);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<one[]>  but  was:<one[<p>two]>  assertEquals  (   "two "  ,  doc  .  select  (   "p "  )  .  get  (  1  )  .  text  (  )  )  ;  [METHOD]  read  [TYPE]  void  [PARAMETER]  Tokeniser  t  CharacterReader  r  [CLASS]  11  [TYPE]  CharacterReader  r  [TYPE]  boolean  false  true  [TYPE]  Tokeniser  t  [CONTEXT]  void  read  (  Tokeniser  t  ,  CharacterReader  r  )  {  if  (  r  .  matches  (  '/'  )  )  {  t  .  createTempBuffer  (  )  ;  t  .  advanceTransition  (  RCDATAEndTagOpen  )  ;  [BUGGY]    }  else  {  t  .  emit  (   "< "  )  ;  t  .  transition  (  Rcdata  )  ;  }  }  	Jsoup_14_TokeniserState_1_1	218	0	src/main/java/org/jsoup/parser/TokeniserState.java
1539	}  else  if  (StringUtil.in(name,   "base ",   "basefont ",   "bgsound ",   "command ",   "link ",   "meta ",   "noframes ",   "script ",   "style ",   "title "))  {  	[BUGGY]  }  else  if  (  StringUtil  .  in  (  name  ,   "base "  ,   "basefont "  ,   "bgsound "  ,   "command "  ,   "link "  ,   "meta "  ,   "noframes "  ,   "style "  ,   "title "  )  )  {  [FE]  AssertionFailedError:  expected:<Hello  []There>  but  was:<Hello  ['  )  ;  i++  ;  ]There>  assertEquals  (   "obj  .  insert  (  '<a  rel  =  \ "none\ "  />'  )  ;  \ni++  ;   "  ,  doc  .  data  (  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  TreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  LinkedList  stack  [TYPE]  int  i  j  si  [TYPE]  TreeBuilder  tb  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [TYPE]  TreeBuilderState  state  [CONTEXT]  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  c  )  ;  tb  .  framesetOk  (  false  )  ;  }  break  ;  }  case  Comment:  {  tb  .  insert  (  t  .  asComment  (  )  )  ;  break  ;  }  case  Doctype:  {  tb  .  error  (  this  )  ;  return  false  ;  }  case  StartTag:  Token  .  StartTag  startTag  =  t  .  asStartTag  (  )  ;  String  name  =  startTag  .  name  (  )  ;  if  (  name  .  equals  (   "html "  )  )  {  tb  .  error  (  this  )  ;  Element  html  =  tb  .  getStack  (  )  .  getFirst  (  )  ;  for  (  Attribute  attribute  :  startTag  .  getAttributes  (  )  )  {  if  (  !html  .  hasAttr  (  attribute  .  getKey  (  )  )  )  html  .  attributes  (  )  .  put  (  attribute  )  ;  }  [BUGGY]  }  else  if  (  StringUtil  .  in  (  name  ,   "base "  ,   "basefont "  ,   "bgsound "  ,   "command "  ,   "link "  ,   "meta "  ,   "noframes "  ,   "style "  ,   "title "  )  )  {  return  tb  .  process  (  t  ,  InHead  )  ;  }  else  if  (  name  .  equals  (   "body "  )  )  {  tb  .  error  (  this  )  ;  LinkedList<Element>  stack  =  tb  .  getStack  (  )  ;  if  (  stack  .  size  (  )  =  =  1  ||  (  stack  .  size  (  )  >  2  &&  !stack  .  get  (  1  )  .  nodeName  (  )  .  equals  (   "body "  )  )  )  {  	Jsoup_15_TreeBuilderState_1_1	283	1	src/main/java/org/jsoup/parser/TreeBuilderState.java
1540		[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [ "]http://wwwibmcom/d>  but  was:<<!DOCTYPE  html  []http://wwwibmcom/d>  assertEquals  (   "<!DOCTYPE  notHtml  PUBLIC  \ "--public\ "  \ "--system\ "> "  ,  combo  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_16_DocumentType_4_1	4	0	src/main/java/org/jsoup/nodes/DocumentType.java
1541	Validate.notEmpty(name);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [ "]http://wwwibmcom/d>  but  was:<<!DOCTYPE  html  []http://wwwibmcom/d>  assertEquals  (   "<!DOCTYPE  notHtml  PUBLIC  \ "--public\ "  \ "--system\ "> "  ,  combo  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_16_DocumentType_4_2	21	0	src/main/java/org/jsoup/nodes/DocumentType.java
1542	accum.append( "<!DOCTYPE   ").append(attr( "name "));  	[BUGGY]  accum  .  append  (   "<!DOCTYPE  html "  )  ;  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [ "]http://wwwibmcom/d>  but  was:<<!DOCTYPE  html  []http://wwwibmcom/d>  assertEquals  (   "<!DOCTYPE  notHtml  PUBLIC  \ "--public\ "  \ "--system\ "> "  ,  combo  .  outerHtml  (  )  )  ;  [METHOD]  outerHtmlHead  [TYPE]  void  [PARAMETER]  StringBuilder  accum  int  depth  OutputSettings  out  [CLASS]  DocumentType  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  int  depth  [CONTEXT]  void  outerHtmlHead  (  StringBuilder  accum  ,  int  depth  ,  Document  .  OutputSettings  out  )  {  [BUGGY]  accum  .  append  (   "<!DOCTYPE  html "  )  ;  if  (  !StringUtil  .  isBlank  (  attr  (   "publicId "  )  )  )  accum  .  append  (   "  PUBLIC  \ " "  )  .  append  (  attr  (   "publicId "  )  )  .  append  (   "\ " "  )  ;  if  (  !StringUtil  .  isBlank  (  attr  (   "systemId "  )  )  )  accum  .  append  (  '  '  )  .  append  (  attr  (   "systemId "  )  )  .  append  (   "\ " "  )  ;  accum  .  append  (  '>'  )  ;  }  	Jsoup_16_DocumentType_4_3	33	1	src/main/java/org/jsoup/nodes/DocumentType.java
1543	accum.append( "  \\ " ").append(attr( "systemId ")).append( "\\ " ");\n',   "                  accum.append('>');\n "]  	[BUGGY]  accum  .  append  (  \'  \'  )  .  append  (  attr  (   "systemId "  )  )  .  append  (   "\\ " "  )  ;  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [ "]http://wwwibmcom/d>  but  was:<<!DOCTYPE  html  []http://wwwibmcom/d>  assertEquals  (   "<!DOCTYPE  notHtml  PUBLIC  \ "--public\ "  \ "--system\ "> "  ,  combo  .  outerHtml  (  )  )  ;  [METHOD]  outerHtmlHead  [TYPE]  void  [PARAMETER]  StringBuilder  accum  int  depth  OutputSettings  out  [CLASS]  DocumentType  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  int  depth  [CONTEXT]  void  outerHtmlHead  (  StringBuilder  accum  ,  int  depth  ,  Document  .  OutputSettings  out  )  {  accum  .  append  (   "<!DOCTYPE  html "  )  ;  if  (  !StringUtil  .  isBlank  (  attr  (   "publicId "  )  )  )  accum  .  append  (   "  PUBLIC  \ " "  )  .  append  (  attr  (   "publicId "  )  )  .  append  (   "\ " "  )  ;  if  (  !StringUtil  .  isBlank  (  attr  (   "systemId "  )  )  )  [BUGGY]  accum  .  append  (  '  '  )  .  append  (  attr  (   "systemId "  )  )  .  append  (   "\ " "  )  ;  accum  .  append  (  '>'  )  ;  }  	Jsoup_16_DocumentType_4_4	37	1	src/main/java/org/jsoup/nodes/DocumentType.java
1544	private static String nullString = String.valueOf('\u0000');	[BUGGY]  private  static  String  nullString  =  String  .  valueOf  (  0x0000  )  ;  \n'  ,   "+  private  static  String  nullString  =  String  .  valueOf  (  '\\u0000'  )  ;  \n "  ,  '  \n']  [FE]  AssertionFailedError:  expected:<[0  assertEquals  (   "0\n<p>0</p> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_17_TreeBuilderState_1_1	1451	1	src/main/java/org/jsoup/parser/TreeBuilderState.java
1545	input  =  input.replaceAll( "\\r\\n? ",   "\\n ");    	[BUGGY]  [FE]  AssertionFailedError:  expected:<one  []>  but  was:<one  [  assertEquals  (   "\n  two  \n  three "  ,  r  .  consumeToEnd  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_18_CharacterReader_2_1	18	0	src/main/java/org/jsoup/parser/CharacterReader.java
1546	String  data  =  input.substring(pos,  input.length());  	[BUGGY]  String  data  =  input  .  substring  (  pos  ,  input  .  length  (  )  -  1  )  ;  [FE]  AssertionFailedError:  expected:<one  []>  but  was:<one  [  assertEquals  (   "\n  two  \n  three "  ,  r  .  consumeToEnd  (  )  )  ;  [METHOD]  consumeToEnd  [TYPE]  String  [PARAMETER]  [CLASS]  CharacterReader  [TYPE]  char  EOF  [TYPE]  String  data  input  [TYPE]  boolean  false  true  [TYPE]  int  length  mark  pos  [CONTEXT]  String  consumeToEnd  (  )  {  [BUGGY]  String  data  =  input  .  substring  (  pos  ,  input  .  length  (  )  -  1  )  ;  pos  =  input  .  length  (  )  ;  return  data  ;  }  	Jsoup_18_CharacterReader_2_2	99	1	src/main/java/org/jsoup/parser/CharacterReader.java
1547	if  (value.length()  ==  0)  value  =  attr.getValue();    	[BUGGY]  [FE]  AssertionFailedError:  expected:<<img  [src  =   "cid:12345 "  />  assertEquals  (   "<img  src  =  \ "cid:12345\ "  />  \n<img  src  =  \ "data:gzzt\ "  /> "  ,  preserved  )  ;  [METHOD]  testValidProtocol  [TYPE]  boolean  [PARAMETER]  Element  el  Attribute  attr  Protocol>  protocols  [CLASS]  Whitelist  [TYPE]  Set  protocols  tagNames  [TYPE]  boolean  false  preserveRelativeLinks  true  [TYPE]  Attribute  attr  [TYPE]  Element  el  [TYPE]  String  prot  value  [TYPE]  Protocol  protocol  [TYPE]  Map  attributes  enforcedAttributes  protocols  [CONTEXT]  private  boolean  testValidProtocol  (  Element  el  ,  Attribute  attr  ,  Set<Protocol>  protocols  )  {    String  value  =  el  .  absUrl  (  attr  .  getKey  (  )  )  ;  [BUGGY]  if  (  !preserveRelativeLinks  )  attr  .  setValue  (  value  )  ;  for  (  Protocol  protocol  :  protocols  )  {  String  prot  =  protocol  .  toString  (  )  +   ": "  ;  if  (  value  .  toLowerCase  (  )  .  startsWith  (  prot  )  )  {  return  true  ;  }  }  return  false  ;  }  	Jsoup_19_Whitelist_1_1	342	0	src/main/java/org/jsoup/safety/Whitelist.java
1548	if  (docData.charAt(0)  ==  65279)  docData  =  docData.substring(1);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[One]>  but  was:<[]>  assertEquals  (   "One "  ,  doc  .  head  (  )  .  text  (  )  )  ;  [METHOD]  parseByteData  [TYPE]  Document  [PARAMETER]  ByteBuffer  byteData  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  boolean  false  true  [TYPE]  Element  meta  [TYPE]  String  baseUri  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  ByteBuffer  byteData  [TYPE]  int  bufferSize  [TYPE]  Parser  parser  [CONTEXT]  static  Document  parseByteData  (  ByteBuffer  byteData  ,  String  charsetName  ,  String  baseUri  ,  Parser  parser  )  {  String  docData  ;  Document  doc  =  null  ;  if  (  charsetName  =  =  null  )  {  //  determine  from  meta  .  safe  parse  as  UTF-8  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  parser  .  parseInput  (  docData  ,  baseUri  )  ;  Element  meta  =  doc  .  select  (   "meta[http-equiv  =  content-type]  ,  meta[charset] "  )  .  first  (  )  ;  if  (  meta  !  =  null  )  {  //  if  not  found  ,  will  keep  utf-8  as  best  attempt  String  foundCharset  =  meta  .  hasAttr  (   "http-equiv "  )  ?  getCharsetFromContentType  (  meta  .  attr  (   "content "  )  )  :  meta  .  attr  (   "charset "  )  ;  if  (  foundCharset  !  =  null  &&  foundCharset  .  length  (  )  !  =  0  &&  !foundCharset  .  equals  (  defaultCharset  )  )  {  //  need  to  re-decode  charsetName  =  foundCharset  ;  byteData  .  rewind  (  )  ;  docData  =  Charset  .  forName  (  foundCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  null  ;  }  }  }  else  {  //  specified  by  content  type  header  (  or  by  user  on  file  load  )  Validate  .  notEmpty  (  charsetName  ,   "Must  set  charset  arg  to  character  set  of  file  to  parse  .  Set  to  null  to  attempt  to  detect  from  HTML "  )  ;  docData  =  Charset  .  forName  (  charsetName  )  .  decode  (  byteData  )  .  toString  (  )  ;  }  if  (  doc  =  =  null  )  {    [BUGGY]  doc  =  parser  .  parseInput  (  docData  ,  baseUri  )  ;  doc  .  outputSettings  (  )  .  charset  (  charsetName  )  ;  }  return  doc  ;  }  	Jsoup_20_DataUtil_1_1	98	0	src/main/java/org/jsoup/helper/DataUtil.java
1549	Or()  {  super();  }  	[BUGGY]  [FE]  regexPatternSyntaxException:  Unclosed  character  class  near  index  3  assertEquals  (   "123 "  ,  containers  .  get  (  1  )  .  text  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_21_CombiningEvaluator_1_1	64	0	src/main/java/org/jsoup/select/CombiningEvaluator.java
1550	if  (tq.matchesAny(combinators))  {  	[BUGGY]  if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  CombiningEvaluator  .  Or  or  =  new  CombiningEvaluator  .  Or  (  evals  )  ;  evals  .  clear  (  )  ;  evals  .  add  (  or  )  ;  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  or  .  add  (  parse  (  subQuery  )  )  ;  }  }  else  if  (  tq  .  matchesAny  (  combinators  )  )  {  [FE]  regexPatternSyntaxException:  Unclosed  character  class  near  index  3  assertEquals  (   "123 "  ,  containers  .  get  (  1  )  .  text  (  )  )  ;  [METHOD]  parse  [TYPE]  Evaluator  [PARAMETER]  [CLASS]  QueryParser  [TYPE]  TokenQueue  tq  [TYPE]  List  evals  [TYPE]  String[]  combinators  [TYPE]  String  query  subQuery  [TYPE]  boolean  false  seenWhite  true  [TYPE]  Or  or  [CONTEXT]  Evaluator  parse  (  )  {  tq  .  consumeWhitespace  (  )  ;  if  (  tq  .  matchesAny  (  combinators  )  )  {  //  if  starts  with  a  combinator  ,  use  root  as  elements  evals  .  add  (  new  StructuralEvaluator  .  Root  (  )  )  ;  combinator  (  tq  .  consume  (  )  )  ;  }  else  {  findElements  (  )  ;  }  while  (  !tq  .  isEmpty  (  )  )  {  boolean  seenWhite  =  tq  .  consumeWhitespace  (  )  ;  [BUGGY]  if  (  tq  .  matchChomp  (   "  ,   "  )  )  {  CombiningEvaluator  .  Or  or  =  new  CombiningEvaluator  .  Or  (  evals  )  ;  evals  .  clear  (  )  ;  evals  .  add  (  or  )  ;  while  (  !tq  .  isEmpty  (  )  )  {  String  subQuery  =  tq  .  chompTo  (   "  ,   "  )  ;  	Jsoup_21_QueryParser_2_1	58	9	src/main/java/org/jsoup/select/QueryParser.java
1551	if  (e  instanceof  CombiningEvaluator.Or)  {  or  =  (CombiningEvaluator.Or)  e;  or.add(f);  }  else  {  or  =  new  CombiningEvaluator.Or();  or.add(e);  or.add(f);  }  evals.add(or);  }  	[BUGGY]  [FE]  regexPatternSyntaxException:  Unclosed  character  class  near  index  3  assertEquals  (   "123 "  ,  containers  .  get  (  1  )  .  text  (  )  )  ;  [METHOD]  combinator  [TYPE]  void  [PARAMETER]  char  combinator  [CLASS]  QueryParser  [TYPE]  TokenQueue  tq  [TYPE]  boolean  false  true  [TYPE]  char  combinator  [TYPE]  List  evals  [TYPE]  String[]  combinators  [TYPE]  String  query  subQuery  [TYPE]  Evaluator  e  f  [CONTEXT]  private  void  combinator  (  char  combinator  )  {  tq  .  consumeWhitespace  (  )  ;  String  subQuery  =  consumeSubQuery  (  )  ;  //  support  multi  >  childs  Evaluator  e  ;  if  (  evals  .  size  (  )  =  =  1  )  e  =  evals  .  get  (  0  )  ;  else  e  =  new  CombiningEvaluator  .  And  (  evals  )  ;  evals  .  clear  (  )  ;  Evaluator  f  =  parse  (  subQuery  )  ;  if  (  combinator  =  =  '>'  )  evals  .  add  (  new  CombiningEvaluator  .  And  (  f  ,  new  StructuralEvaluator  .  ImmediateParent  (  e  )  )  )  ;  else  if  (  combinator  =  =  '  '  )  evals  .  add  (  new  CombiningEvaluator  .  And  (  f  ,  new  StructuralEvaluator  .  Parent  (  e  )  )  )  ;  else  if  (  combinator  =  =  '+'  )  evals  .  add  (  new  CombiningEvaluator  .  And  (  f  ,  new  StructuralEvaluator  .  ImmediatePreviousSibling  (  e  )  )  )  ;  else  if  (  combinator  =  =  '~'  )  evals  .  add  (  new  CombiningEvaluator  .  And  (  f  ,  new  StructuralEvaluator  .  PreviousSibling  (  e  )  )  )  ;  [BUGGY]  else  throw  new  Selector  .  SelectorParseException  (   "Unknown  combinator:   "  +  combinator  )  ;  }  	Jsoup_21_QueryParser_2_2	101	0	src/main/java/org/jsoup/select/QueryParser.java
1552	if  (parentNode  ==  null)  return  new  Elements(0);  List<Element>  elements  =  parent().children();  Elements  siblings  =  new  Elements(elements.size()  -  1);  for  (Element  el:  elements)  if  (el  !=  this)  siblings.add(el);  return  siblings;  	[BUGGY]  return  parent  (  )  .  children  (  )  ;  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (   "<p>Three</p> "  ,  els  .  get  (  1  )  .  outerHtml  (  )  )  ;  [METHOD]  siblingElements  [TYPE]  Elements  [PARAMETER]  [CLASS]  Element  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [CONTEXT]  public  Elements  siblingElements  (  )  {  [BUGGY]  return  parent  (  )  .  children  (  )  ;  }  	Jsoup_22_Element_3_1	434	1	src/main/java/org/jsoup/nodes/Element.java
1553	if  (parentNode  ==  null)  return  null;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (   "<p>Three</p> "  ,  els  .  get  (  1  )  .  outerHtml  (  )  )  ;  [METHOD]  nextElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element  [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [CONTEXT]  public  Element  nextElementSibling  (  )  {  [BUGGY]  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  siblings  .  size  (  )  >  index+1  )  return  siblings  .  get  (  index+1  )  ;  else  return  null  ;  }  	Jsoup_22_Element_3_2	447	0	src/main/java/org/jsoup/nodes/Element.java
1554	if  (parentNode  ==  null)  return  null;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (   "<p>Three</p> "  ,  els  .  get  (  1  )  .  outerHtml  (  )  )  ;  [METHOD]  previousElementSibling  [TYPE]  Element  [PARAMETER]  [CLASS]  Element  [TYPE]  Integer  index  [TYPE]  List  siblings  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [CONTEXT]  public  Element  previousElementSibling  (  )  {  [BUGGY]  List<Element>  siblings  =  parent  (  )  .  children  (  )  ;  Integer  index  =  indexInList  (  this  ,  siblings  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }  	Jsoup_22_Element_3_3	462	0	src/main/java/org/jsoup/nodes/Element.java
1555	if  (parentNode  ==  null)  return  Collections.emptyList();  List<Node>  nodes  =  parentNode.childNodes;  List<Node>  siblings  =  new  ArrayList<Node>(nodes.size()  -  1);  for  (Node  node:  nodes)  if  (node  !=  this)  siblings.add(node);  return  siblings;  	[BUGGY]  return  parent  (  )  .  childNodes  (  )  ;  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (   "<p>Three</p> "  ,  els  .  get  (  1  )  .  outerHtml  (  )  )  ;  [METHOD]  siblingNodes  [TYPE]  List  [PARAMETER]  [CLASS]  Node  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  [TYPE]  String  baseUri  [TYPE]  int  siblingIndex  [CONTEXT]  public  List<Node>  siblingNodes  (  )  {  [BUGGY]  return  parent  (  )  .  childNodes  (  )  ;  }  	Jsoup_22_Node_2_1	444	1	src/main/java/org/jsoup/nodes/Node.java
1556	if  (parentNode  ==  null)  return  null;    	[BUGGY]  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (   "<p>Three</p> "  ,  els  .  get  (  1  )  .  outerHtml  (  )  )  ;  [METHOD]  previousSibling  [TYPE]  Node  [PARAMETER]  [CLASS]  Node  [TYPE]  Integer  index  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  Node  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  childNodes  siblings  [TYPE]  String  baseUri  [TYPE]  int  siblingIndex  [CONTEXT]  public  Node  previousSibling  (  )  {  [BUGGY]  List<Node>  siblings  =  parentNode  .  childNodes  ;  Integer  index  =  siblingIndex  (  )  ;  Validate  .  notNull  (  index  )  ;  if  (  index  >  0  )  return  siblings  .  get  (  index-1  )  ;  else  return  null  ;  }  	Jsoup_22_Node_2_2	470	0	src/main/java/org/jsoup/nodes/Node.java
1557	public  Elements(int  initialCapacity)  {  contents  =  new  ArrayList<Element>(initialCapacity);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (   "<p>Three</p> "  ,  els  .  get  (  1  )  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_22_Elements_1_1	22	0	src/main/java/org/jsoup/select/Elements.java
1558	String  consumeLetterThenDigitSequence()  {  int  start  =  pos;  while  (!isEmpty())  {  char  c  =  input.charAt(pos);\n',   "+                        if  ((c  >=  'A'  &&  c  <=  'Z')  ||  (c  >=  'a'  &&  c  <=  'z'))\n ",  '+                                pos++;  else  break;  }  while  (!isEmpty())  {  char  c  =  input.charAt(pos);\n',   "+                        if  (c  >=  '0'  &&  c  <=  '9')\n ",  '+                                pos++;  else  break;  }  return  input.substring(start,  pos);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[&sup1  ;  &sup2  ;  &sup3  ;  &frac14  ;  &frac12  ;  &]frac34  ;  >  but  was:<[  assertEquals  (   " "  ,  p  .  text  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_23_CharacterReader_1_1	118	0	src/main/java/org/jsoup/parser/CharacterReader.java
1559	String  nameRef  =  reader.consumeLetterThenDigitSequence();  	[BUGGY]  String  nameRef  =  reader  .  consumeLetterSequence  (  )  ;  [FE]  AssertionFailedError:  expected:<[&sup1  ;  &sup2  ;  &sup3  ;  &frac14  ;  &frac12  ;  &]frac34  ;  >  but  was:<[  assertEquals  (   " "  ,  p  .  text  (  )  )  ;  [METHOD]  consumeCharacterReference  [TYPE]  Character  [PARAMETER]  Character  additionalAllowedCharacter  boolean  inAttribute  [CLASS]  Tokeniser  [TYPE]  Comment  commentPending  [TYPE]  StringBuilder  charBuffer  dataBuffer  [TYPE]  Character  additionalAllowedCharacter  [TYPE]  Doctype  doctypePending  [TYPE]  NumberFormatException  e  [TYPE]  Token  emitPending  [TYPE]  ParseErrorList  errors  [TYPE]  String  nameRef  numRef  origNameRef  [TYPE]  StartTag  lastStartTag  [TYPE]  int  base  charval  [TYPE]  CharacterReader  reader  [TYPE]  boolean  false  found  inAttribute  isEmitPending  isHexMode  looksLegit  selfClosingFlagAcknowledged  true  [TYPE]  char  replacementChar  [TYPE]  Tag  tagPending  [TYPE]  TokeniserState  state  [CONTEXT]  boolean  isHexMode  =  reader  .  matchConsumeIgnoreCase  (   "X "  )  ;  String  numRef  =  isHexMode  ?  reader  .  consumeHexSequence  (  )  :  reader  .  consumeDigitSequence  (  )  ;  if  (  numRef  .  length  (  )  =  =  0  )  {  //  didn't  match  anything  characterReferenceError  (   "numeric  reference  with  no  numerals "  )  ;  reader  .  rewindToMark  (  )  ;  return  null  ;  }  if  (  !reader  .  matchConsume  (   "  ;   "  )  )  characterReferenceError  (   "missing  semicolon "  )  ;  //  missing  semi  int  charval  =  -1  ;  try  {  int  base  =  isHexMode  ?  16  :  10  ;  charval  =  Integer  .  valueOf  (  numRef  ,  base  )  ;  }  catch  (  NumberFormatException  e  )  {  }  //  skip  if  (  charval  =  =  -1  ||  (  charval  >  =  0xD800  &&  charval  <  =  0xDFFF  )  ||  charval  >  0x10FFFF  )  {  characterReferenceError  (   "character  outside  of  valid  range "  )  ;  return  replacementChar  ;  }  else  {    return  (  char  )  charval  ;  }  }  else  {  //  named  [BUGGY]  String  nameRef  =  reader  .  consumeLetterSequence  (  )  ;  String  origNameRef  =  new  String  (  nameRef  )  ;  //  for  error  reporting  .  nameRef  gets  chomped  looking  for  matches  boolean  looksLegit  =  reader  .  matches  (  '  ;  '  )  ;  boolean  found  =  false  ;  while  (  nameRef  .  length  (  )  >  0  &&  !found  )  {  if  (  Entities  .  isNamedEntity  (  nameRef  )  )  	Jsoup_23_Tokeniser_1_1	135	1	src/main/java/org/jsoup/parser/Tokeniser.java
1560		[BUGGY]  r  .  advance  (  )  ;  [FE]  AssertionFailedError:  expected:<ocumentwrite  (  '</scr[']  +  'ipt>'  )  ;  assertEquals  (   "<script>\n "  +  [METHOD]  read  [TYPE]  void  [PARAMETER]  Tokeniser  t  CharacterReader  r  [CLASS]  27  [TYPE]  CharacterReader  r  [TYPE]  boolean  false  true  [TYPE]  char  c  [TYPE]  Tokeniser  t  [TYPE]  String  name  [CONTEXT]  void  read  (  Tokeniser  t  ,  CharacterReader  r  )  {  if  (  r  .  matchesLetter  (  )  )  {  String  name  =  r  .  consumeLetterSequence  (  )  ;  t  .  tagPending  .  appendTagName  (  name  .  toLowerCase  (  )  )  ;  t  .  dataBuffer  .  append  (  name  )  ;  [BUGGY]  r  .  advance  (  )  ;  return  ;  }  if  (  t  .  isAppropriateEndTagToken  (  )  &&  !r  .  isEmpty  (  )  )  {  char  c  =  r  .  consume  (  )  ;  	Jsoup_24_TokeniserState_1_1	558	1	src/main/java/org/jsoup/parser/TokeniserState.java
1561	private  static  final  String[]  preserveWhitespaceTags  =  { "pre ",   "plaintext ",   "title ",   "textarea "};  	[BUGGY]  private  static  final  String[]  preserveWhitespaceTags  =  { "pre "  ,   "plaintext "  ,   "title "}  ;  [FE]  AssertionFailedError:  expected:<One[  assertEquals  (   "<textarea>\n\t "  +  expect  +   "\n</textarea> "  ,  el  .  outerHtml  (  )  )  ;  //  but  preserved  in  round-trip  html  [CLASS]  [CONTEXT]  	Jsoup_25_Tag_1_1	218	1	src/main/java/org/jsoup/parser/Tag.java
1562		[BUGGY]  [FE]  NullPointerException  assertEquals  (  0  ,  cleanDoc  .  body  (  )  .  childNodes  (  )  .  size  (  )  )  ;  [METHOD]  clean  [TYPE]  Document  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  [TYPE]  Element  el  [CONTEXT]  public  Document  clean  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  [BUGGY]  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;  return  clean  ;  }  	Jsoup_26_Cleaner_1_1	43	0	src/main/java/org/jsoup/safety/Cleaner.java
1563	if  (Charset.isSupported(charset))  return  charset;  if  (Charset.isSupported(charset))  return  charset;  	[BUGGY]  return  charset  ;  [FE]  AssertionFailedError:  expected:<[utf]-8>  but  was:<[UTF]-8>  assertEquals  (  null  ,  DataUtil  .  getCharsetFromContentType  (   "text/html  ;  charset  =  Unknown "  )  )  ;  [METHOD]  getCharsetFromContentType  [TYPE]  String  [PARAMETER]  String  contentType  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  String  charset  contentType  defaultCharset  [TYPE]  boolean  false  true  [TYPE]  Matcher  m  [TYPE]  int  bufferSize  [CONTEXT]  static  String  getCharsetFromContentType  (  String  contentType  )  {  if  (  contentType  =  =  null  )  return  null  ;  Matcher  m  =  charsetPattern  .  matcher  (  contentType  )  ;  if  (  m  .  find  (  )  )  {  String  charset  =  m  .  group  (  1  )  .  trim  (  )  ;  [BUGGY]  charset  =  charset  .  toUpperCase  (  Locale  .  ENGLISH  )  ;  return  charset  ;  }  return  null  ;  }  	Jsoup_27_DataUtil_1_1	132	1	src/main/java/org/jsoup/helper/DataUtil.java
1564		[BUGGY]  [FE]  AssertionFailedError:  expected:<Hello  &<>  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_28_Entities_3_1	3	0	src/main/java/org/jsoup/nodes/Entities.java
1565	public  static  boolean  isBaseNamedEntity(String  name)  {  return  base.containsKey(name);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Hello  &<>  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_28_Entities_3_2	61	0	src/main/java/org/jsoup/nodes/Entities.java
1566	return  Parser.unescapeEntities(string,  strict);  	[BUGGY]  if  (  !string  .  contains  (   "& "  )  )  return  string  ;  Matcher  m  =  strict?  strictUnescapePattern  .  matcher  (  string  )  :  unescapePattern  .  matcher  (  string  )  ;  StringBuffer  accum  =  new  StringBuffer  (  string  .  length  (  )  )  ;  while  (  m  .  find  (  )  )  {  int  charval  =  -1  ;  String  num  =  m  .  group  (  3  )  ;  if  (  num  !  =  null  )  {  try  {  int  base  =  m  .  group  (  2  )  !  =  null  ?  16  :  10  ;  charval  =  Integer  .  valueOf  (  num  ,  base  )  ;  }  catch  (  NumberFormatException  e  )  {  }  }  else  {  String  name  =  m  .  group  (  1  )  ;  if  (  full  .  containsKey  (  name  )  )  charval  =  full  .  get  (  name  )  ;  }  if  (  charval  !  =  -1  ||  charval  >  0xFFFF  )  {  String  c  =  Character  .  toString  (  (  char  )  charval  )  ;  m  .  appendReplacement  (  accum  ,  Matcher  .  quoteReplacement  (  c  )  )  ;  }  else  {  m  .  appendReplacement  (  accum  ,  Matcher  .  quoteReplacement  (  m  .  group  (  0  )  )  )  ;  }  }  m  .  appendTail  (  accum  )  ;  return  accum  .  toString  (  )  ;  [FE]  AssertionFailedError:  expected:<Hello  &<>  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [METHOD]  unescape  [TYPE]  String  [PARAMETER]  String  string  boolean  strict  [CLASS]  Entities  [TYPE]  Pattern  strictUnescapePattern  unescapePattern  [TYPE]  StringBuffer  accum  [TYPE]  boolean  false  strict  true  [TYPE]  Matcher  m  [TYPE]  EscapeMode  base  extended  xhtml  [TYPE]  Object[][]  xhtmlArray  [TYPE]  NumberFormatException  e  [TYPE]  String  c  name  num  string  [TYPE]  Map  base  baseByVal  full  fullByVal  map  xhtmlByVal  [TYPE]  int  base  charval  [CONTEXT]  static  String  unescape  (  String  string  ,  boolean  strict  )  {  [BUGGY]  if  (  !string  .  contains  (   "& "  )  )  return  string  ;  Matcher  m  =  strict?  strictUnescapePattern  .  matcher  (  string  )  :  unescapePattern  .  matcher  (  string  )  ;  StringBuffer  accum  =  new  StringBuffer  (  string  .  length  (  )  )  ;  while  (  m  .  find  (  )  )  {  int  charval  =  -1  ;  String  num  =  m  .  group  (  3  )  ;  if  (  num  !  =  null  )  {  try  {  int  base  =  m  .  group  (  2  )  !  =  null  ?  16  :  10  ;  charval  =  Integer  .  valueOf  (  num  ,  base  )  ;  }  catch  (  NumberFormatException  e  )  {  }  }  else  {  String  name  =  m  .  group  (  1  )  ;  if  (  full  .  containsKey  (  name  )  )  charval  =  full  .  get  (  name  )  ;  }  if  (  charval  !  =  -1  ||  charval  >  0xFFFF  )  {  String  c  =  Character  .  toString  (  (  char  )  charval  )  ;  m  .  appendReplacement  (  accum  ,  Matcher  .  quoteReplacement  (  c  )  )  ;  }  else  {  m  .  appendReplacement  (  accum  ,  Matcher  .  quoteReplacement  (  m  .  group  (  0  )  )  )  ;  }  }  m  .  appendTail  (  accum  )  ;  return  accum  .  toString  (  )  ;  }  	Jsoup_28_Entities_3_3	103	27	src/main/java/org/jsoup/nodes/Entities.java
1567	public  static  String  unescapeEntities(String  string,  boolean  inAttribute)  {  Tokeniser  tokeniser  =  new  Tokeniser(new  CharacterReader(string),  ParseErrorList.noTracking());  return  tokeniser.unescapeEntities(inAttribute);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Hello  &<>  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_28_Parser_1_1	133	0	src/main/java/org/jsoup/parser/Parser.java
1568	boolean  found  =  (Entities.isBaseNamedEntity(nameRef)  ||  (Entities.isNamedEntity(nameRef)  &&  looksLegit));  	[BUGGY]  String  origNameRef  =  new  String  (  nameRef  )  ;  \n'  ,   "        boolean  looksLegit  =  reader  .  matches  (  '  ;  '  )  ;  \n "  ,  '        boolean  found  =  false  ;  while  (  nameRef  .  length  (  )  >  0  &&  !found  )  {  if  (  Entities  .  isNamedEntity  (  nameRef  )  )  found  =  true  ;  else  {  nameRef  =  nameRef  .  substring  (  0  ,  nameRef  .  length  (  )  -1  )  ;  reader  .  unconsume  (  )  ;  }  }  [FE]  AssertionFailedError:  expected:<Hello  &<>  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [METHOD]  consumeCharacterReference  [TYPE]  Character  [PARAMETER]  Character  additionalAllowedCharacter  boolean  inAttribute  [CLASS]  Tokeniser  [TYPE]  Comment  commentPending  [TYPE]  StringBuilder  charBuffer  dataBuffer  [TYPE]  Character  additionalAllowedCharacter  [TYPE]  Doctype  doctypePending  [TYPE]  NumberFormatException  e  [TYPE]  Token  emitPending  [TYPE]  ParseErrorList  errors  [TYPE]  String  nameRef  numRef  origNameRef  [TYPE]  StartTag  lastStartTag  [TYPE]  int  base  charval  [TYPE]  CharacterReader  reader  [TYPE]  boolean  false  found  inAttribute  isEmitPending  isHexMode  looksLegit  selfClosingFlagAcknowledged  true  [TYPE]  char  replacementChar  [TYPE]  Tag  tagPending  [TYPE]  TokeniserState  state  [CONTEXT]  String  numRef  =  isHexMode  ?  reader  .  consumeHexSequence  (  )  :  reader  .  consumeDigitSequence  (  )  ;  if  (  numRef  .  length  (  )  =  =  0  )  {  //  didn't  match  anything  characterReferenceError  (   "numeric  reference  with  no  numerals "  )  ;  reader  .  rewindToMark  (  )  ;  return  null  ;  }  if  (  !reader  .  matchConsume  (   "  ;   "  )  )  characterReferenceError  (   "missing  semicolon "  )  ;  //  missing  semi  int  charval  =  -1  ;  try  {  int  base  =  isHexMode  ?  16  :  10  ;  charval  =  Integer  .  valueOf  (  numRef  ,  base  )  ;  }  catch  (  NumberFormatException  e  )  {  }  //  skip  if  (  charval  =  =  -1  ||  (  charval  >  =  0xD800  &&  charval  <  =  0xDFFF  )  ||  charval  >  0x10FFFF  )  {  characterReferenceError  (   "character  outside  of  valid  range "  )  ;  return  replacementChar  ;  }  else  {    return  (  char  )  charval  ;  }  }  else  {  //  named  String  nameRef  =  reader  .  consumeLetterThenDigitSequence  (  )  ;  [BUGGY]  String  origNameRef  =  new  String  (  nameRef  )  ;  boolean  looksLegit  =  reader  .  matches  (  '  ;  '  )  ;  boolean  found  =  false  ;  while  (  nameRef  .  length  (  )  >  0  &&  !found  )  {  if  (  Entities  .  isNamedEntity  (  nameRef  )  )  	Jsoup_28_Tokeniser_3_1	136	10	src/main/java/org/jsoup/parser/Tokeniser.java
1569	characterReferenceError(String.format( "invalid  named  referenece  \'%s\' ",  nameRef));  	[BUGGY]  characterReferenceError  (  String  .  format  (   "invalid  named  referenece  \'%s\' "  ,  origNameRef  )  )  ;  [FE]  AssertionFailedError:  expected:<Hello  &<>  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [METHOD]  consumeCharacterReference  [TYPE]  Character  [PARAMETER]  Character  additionalAllowedCharacter  boolean  inAttribute  [CLASS]  Tokeniser  [TYPE]  Comment  commentPending  [TYPE]  StringBuilder  charBuffer  dataBuffer  [TYPE]  Character  additionalAllowedCharacter  [TYPE]  Doctype  doctypePending  [TYPE]  NumberFormatException  e  [TYPE]  Token  emitPending  [TYPE]  ParseErrorList  errors  [TYPE]  String  nameRef  numRef  origNameRef  [TYPE]  StartTag  lastStartTag  [TYPE]  int  base  charval  [TYPE]  CharacterReader  reader  [TYPE]  boolean  false  found  inAttribute  isEmitPending  isHexMode  looksLegit  selfClosingFlagAcknowledged  true  [TYPE]  char  replacementChar  [TYPE]  Tag  tagPending  [TYPE]  TokeniserState  state  [CONTEXT]  return  replacementChar  ;  }  else  {    return  (  char  )  charval  ;  }  }  else  {  //  named  String  nameRef  =  reader  .  consumeLetterThenDigitSequence  (  )  ;  String  origNameRef  =  new  String  (  nameRef  )  ;  boolean  looksLegit  =  reader  .  matches  (  '  ;  '  )  ;  boolean  found  =  false  ;  while  (  nameRef  .  length  (  )  >  0  &&  !found  )  {  if  (  Entities  .  isNamedEntity  (  nameRef  )  )  found  =  true  ;  else  {  nameRef  =  nameRef  .  substring  (  0  ,  nameRef  .  length  (  )  -1  )  ;  reader  .  unconsume  (  )  ;  }  }  if  (  !found  )  {  reader  .  rewindToMark  (  )  ;  if  (  looksLegit  )  //  named  with  semicolon  [BUGGY]  characterReferenceError  (  String  .  format  (   "invalid  named  referenece  '%s' "  ,  origNameRef  )  )  ;  return  null  ;  }  if  (  inAttribute  &&  (  reader  .  matchesLetter  (  )  ||  reader  .  matchesDigit  (  )  ||  reader  .  matchesAny  (  '  =  '  ,  '-'  ,  '_'  )  )  )  {  reader  .  rewindToMark  (  )  ;  	Jsoup_28_Tokeniser_3_2	152	1	src/main/java/org/jsoup/parser/Tokeniser.java
1570	String  unescapeEntities(boolean  inAttribute)  {  StringBuilder  builder  =  new  StringBuilder();  while  (!reader.isEmpty())  {\n',   "+                        builder.append(reader.consumeTo('&'));\n ",   "+                        if  (reader.matches('&'))  {\n ",  '+                                reader.consume();  Character  c  =  consumeCharacterReference(null,  inAttribute);  if  (c  ==  null)\n',   "+                                        builder.append('&');\n ",  '+                                else  builder.append(c);  }  }  return  builder.toString();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Hello  &<>  assertEquals  (   "&0987654321  ;  &unknown "  ,  Entities  .  unescape  (   "&0987654321  ;  &unknown "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_28_Tokeniser_3_3	238	0	src/main/java/org/jsoup/parser/Tokeniser.java
1571		[BUGGY]  [FE]  AssertionFailedError:  expected:<Hello[  there]  now>  but  was:<Hello[  assertEquals  (   "Hello  there  now "  ,  normaliseTitle  .  title  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_29_Document_2_1	3	0	src/main/java/org/jsoup/nodes/Document.java
1572	return  titleEl  !=  null  ?  StringUtil.normaliseWhitespace(titleEl.text()).trim()  :   " ";  	[BUGGY]  return  titleEl  !  =  null  ?  titleEl  .  text  (  )  .  trim  (  )  :   " "  ;  [FE]  AssertionFailedError:  expected:<Hello[  there]  now>  but  was:<Hello[  assertEquals  (   "Hello  there  now "  ,  normaliseTitle  .  title  (  )  )  ;  [METHOD]  title  [TYPE]  String  [PARAMETER]  [CLASS]  Document  [TYPE]  boolean  false  prettyPrint  true  [TYPE]  OutputSettings  outputSettings  [TYPE]  Element  titleEl  [TYPE]  EscapeMode  escapeMode  [TYPE]  Charset  charset  [TYPE]  QuirksMode  limitedQuirks  noQuirks  quirks  quirksMode  [TYPE]  CharsetEncoder  charsetEncoder  [TYPE]  int  indentAmount  [CONTEXT]  public  String  title  (  )  {  Element  titleEl  =  getElementsByTag  (   "title "  )  .  first  (  )  ;  [BUGGY]  return  titleEl  !  =  null  ?  titleEl  .  text  (  )  .  trim  (  )  :   " "  ;  }  	Jsoup_29_Document_2_2	69	1	src/main/java/org/jsoup/nodes/Document.java
1573		[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  Jsoup  .  isValid  (  nok3  ,  Whitelist  .  basic  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_30_Cleaner_4_1	6	0	src/main/java/org/jsoup/safety/Cleaner.java
1574	private  final  class  CleaningVisitor  implements  NodeVisitor  {  private  int  numDiscarded  =  0;  private  final  Element  root;  private  Element  destination;      private  CleaningVisitor(Element  root,  Element  destination)  {  this.root  =  root;  this.destination  =  destination;  }  public  void  head(Node  source,  int  depth)  {  	[BUGGY]  private  int  copySafeNodes  (  Element  root  ,  Element  destination  )  {  List<Node>  sourceChildren  =  root  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;  for  (  Node  source  :  sourceChildren  )  {  [FE]  AssertionFailedError  assertFalse  (  Jsoup  .  isValid  (  nok3  ,  Whitelist  .  basic  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_30_Cleaner_4_2	70	4	src/main/java/org/jsoup/safety/Cleaner.java
1575	destination  =  destChild;\n',   "+                                }  else  if  (source  !=  root)  {    	[BUGGY]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  }  else  {  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destination  )  ;  [FE]  AssertionFailedError  assertFalse  (  Jsoup  .  isValid  (  nok3  ,  Whitelist  .  basic  (  )  )  )  ;  [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  root  Element  destination  [CLASS]  Cleaner  [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  destChild  destination  el  root  sourceEl  [TYPE]  Node  source  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  [CONTEXT]  private  int  copySafeNodes  (  Element  root  ,  Element  destination  )  {  List<Node>  sourceChildren  =  root  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;  for  (  Node  source  :  sourceChildren  )  {  if  (  source  instanceof  Element  )  {  Element  sourceEl  =  (  Element  )  source  ;  if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  destination  .  appendChild  (  destChild  )  ;  numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  [BUGGY]  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  }  else  {  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destination  )  ;  }  }  else  if  (  source  instanceof  TextNode  )  {  TextNode  sourceText  =  (  TextNode  )  source  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  source  .  baseUri  (  )  )  ;  destination  .  appendChild  (  destText  )  ;  }  }  return  numDiscarded  ;  }  	Jsoup_30_Cleaner_4_3	84	3	src/main/java/org/jsoup/safety/Cleaner.java
1576	public  void  tail(Node  source,  int  depth)  {  if  (source  instanceof  Element  &&  whitelist.isSafeTag(source.nodeName()))  {  destination  =  destination.parent();    }  }  }  private  int  copySafeNodes(Element  source,  Element  dest)  {  CleaningVisitor  cleaningVisitor  =  new  CleaningVisitor(source,  dest);  NodeTraversor  traversor  =  new  NodeTraversor(cleaningVisitor);  traversor.traverse(source);  return  cleaningVisitor.numDiscarded;  	[BUGGY]  return  numDiscarded  ;  [FE]  AssertionFailedError  assertFalse  (  Jsoup  .  isValid  (  nok3  ,  Whitelist  .  basic  (  )  )  )  ;  [METHOD]  copySafeNodes  [TYPE]  int  [PARAMETER]  Element  root  Element  destination  [CLASS]  Cleaner  [TYPE]  ElementMeta  meta  [TYPE]  boolean  false  true  [TYPE]  Element  destChild  destination  el  root  sourceEl  [TYPE]  Node  source  [TYPE]  Whitelist  whitelist  [TYPE]  List  sourceChildren  [TYPE]  TextNode  destText  sourceText  [TYPE]  int  numAttribsDiscarded  numDiscarded  [CONTEXT]  private  int  copySafeNodes  (  Element  root  ,  Element  destination  )  {  List<Node>  sourceChildren  =  root  .  childNodes  (  )  ;  int  numDiscarded  =  0  ;  for  (  Node  source  :  sourceChildren  )  {  if  (  source  instanceof  Element  )  {  Element  sourceEl  =  (  Element  )  source  ;  if  (  whitelist  .  isSafeTag  (  sourceEl  .  tagName  (  )  )  )  {  //  safe  ,  clone  and  copy  safe  attrs  ElementMeta  meta  =  createSafeElement  (  sourceEl  )  ;  Element  destChild  =  meta  .  el  ;  destination  .  appendChild  (  destChild  )  ;  numDiscarded  +  =  meta  .  numAttribsDiscarded  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destChild  )  ;  }  else  {  numDiscarded++  ;  numDiscarded  +  =  copySafeNodes  (  sourceEl  ,  destination  )  ;  }  }  else  if  (  source  instanceof  TextNode  )  {  TextNode  sourceText  =  (  TextNode  )  source  ;  TextNode  destText  =  new  TextNode  (  sourceText  .  getWholeText  (  )  ,  source  .  baseUri  (  )  )  ;  destination  .  appendChild  (  destText  )  ;  [BUGGY]  }  }  return  numDiscarded  ;  }  	Jsoup_30_Cleaner_4_4	93	1	src/main/java/org/jsoup/safety/Cleaner.java
1577	boolean  bogus  =  false;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<[?xml  encoding  =  'UTF-8'  ?]>  <body>  One  </body>>  but  was:<<[!--?xml  encoding  =  'UTF-8'  ?--]>  <body>  One  </body>>  assertEquals  (   "#comment "  ,  doc  .  childNode  (  2  )  .  nodeName  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_31_Token_1_1	171	0	src/main/java/org/jsoup/parser/Token.java
1578	comment.bogus  =  true;\n',   "                          comment.data.append(r.consumeTo('>'));\n "]  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<[?xml  encoding  =  'UTF-8'  ?]>  <body>  One  </body>>  but  was:<<[!--?xml  encoding  =  'UTF-8'  ?--]>  <body>  One  </body>>  assertEquals  (   "#comment "  ,  doc  .  childNode  (  2  )  .  nodeName  (  )  )  ;  [METHOD]  read  [TYPE]  void  [PARAMETER]  Tokeniser  t  CharacterReader  r  [CLASS]  43  [TYPE]  Comment  comment  [TYPE]  CharacterReader  r  [TYPE]  boolean  false  true  [TYPE]  Tokeniser  t  [CONTEXT]  void  read  (  Tokeniser  t  ,  CharacterReader  r  )  {    r  .  unconsume  (  )  ;  Token  .  Comment  comment  =  new  Token  .  Comment  (  )  ;  [BUGGY]  comment  .  data  .  append  (  r  .  consumeTo  (  '>'  )  )  ;  t  .  emit  (  comment  )  ;  t  .  advanceTransition  (  Data  )  ;  }  	Jsoup_31_TokeniserState_1_1	1094	0	src/main/java/org/jsoup/parser/TokeniserState.java
1579	if  (commentToken.bogus)  {    String  data  =  comment.getData();  if  (data.length()  >  1  &&  (data.startsWith( "! ")  ||  data.startsWith( "? ")))  {  String  declaration  =  data.substring(1);  insert  =  new  XmlDeclaration(declaration,  comment.baseUri(),  data.startsWith( "! "));  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<[?xml  encoding  =  'UTF-8'  ?]>  <body>  One  </body>>  but  was:<<[!--?xml  encoding  =  'UTF-8'  ?--]>  <body>  One  </body>>  assertEquals  (   "#comment "  ,  doc  .  childNode  (  2  )  .  nodeName  (  )  )  ;  [METHOD]  insert  [TYPE]  void  [PARAMETER]  Comment  commentToken  [CLASS]  XmlTreeBuilder  [TYPE]  Comment  comment  commentToken  [TYPE]  boolean  false  true  [TYPE]  Node  insert  [CONTEXT]  void  insert  (  Token  .  Comment  commentToken  )  {  Comment  comment  =  new  Comment  (  commentToken  .  getData  (  )  ,  baseUri  )  ;  Node  insert  =  comment  ;  [BUGGY]  insertNode  (  insert  )  ;  }  	Jsoup_31_XmlTreeBuilder_1_1	67	0	src/main/java/org/jsoup/parser/XmlTreeBuilder.java
1580	clone.classNames  =  null;    	[BUGGY]  clone  .  classNames  (  )  ;  [FE]  AssertionFailedError  assertEquals  (   " "  ,  copy  .  html  (  )  )  ;  [METHOD]  clone  [TYPE]  Element  [PARAMETER]  [CLASS]  Element  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  clone  [CONTEXT]  public  Element  clone  (  )  {  Element  clone  =  (  Element  )  super  .  clone  (  )  ;  [BUGGY]  clone  .  classNames  (  )  ;  return  clone  ;  }  	Jsoup_32_Element_1_1	1138	1	src/main/java/org/jsoup/nodes/Element.java
1581	tokeniser.transition(TokeniserState.Data);    	[BUGGY]  [FE]  AssertionFailedError:  expected:<src  =   "/foo "></script>[<div  id  =   "2 "><img  /><img  /></div><a  id  =   "3 "></a><i></i><foo  /><foo>One</foo>  <hr  />  hr  text  <hr  />]  hr  text  two>  but  was:<src  =   "/foo "></script>[&lt  ;  div  id  =  2&gt  ;  &lt  ;  img  /&gt  ;  &lt  ;  img&gt  ;  &lt  ;  /div&gt  ;  &lt  ;  a  id  =  3  /&gt  ;  &lt  ;  i  /&gt  ;  &lt  ;  foo  /&gt  ;  &lt  ;  foo&gt  ;  One&lt  ;  /foo&gt  ;  &lt  ;  hr  /&gt  ;  hr  text  &lt  ;  hr&gt  ;  ]  hr  text  two>  assertEquals  (   "<div  id  =  \ "1\ "></div><script  src  =  \ "/foo\ "></script><div  id  =  \ "2\ "><img  /><img  /></div><a  id  =  \ "3\ "></a><i></i><foo  /><foo>One</foo>  <hr  />  hr  text  <hr  />  hr  text  two "  ,  TextUtil  .  stripNewlines  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  insert  [TYPE]  Element  [PARAMETER]  StartTag  startTag  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  DescendableLinkedList  formattingElements  [TYPE]  Element  contextElement  el  headElement  [TYPE]  List  pendingTableCharacters  [TYPE]  FormElement  formElement  [TYPE]  StartTag  startTag  [CONTEXT]  Element  insert  (  Token  .  StartTag  startTag  )  {    if  (  startTag  .  isSelfClosing  (  )  )  {  Element  el  =  insertEmpty  (  startTag  )  ;  stack  .  add  (  el  )  ;  [BUGGY]  tokeniser  .  emit  (  new  Token  .  EndTag  (  el  .  tagName  (  )  )  )  ;  //  ensure  we  get  out  of  whatever  state  we  are  in  .  emitted  for  yielded  processing  return  el  ;  }  Element  el  =  new  Element  (  Tag  .  valueOf  (  startTag  .  name  (  )  )  ,  baseUri  ,  startTag  .  attributes  )  ;  insert  (  el  )  ;  return  el  ;  }  	Jsoup_33_HtmlTreeBuilder_1_1	162	0	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1582	if  (offset  <  length  &&  last  <=  length)  {  	[BUGGY]  if  (  offset  <  length  )  {  [FE]  ArrayIndexOutOfBoundsException:  8  assertEquals  (  -1  ,  r  .  nextIndexOf  (   "]]> "  )  )  ;  [METHOD]  nextIndexOf  [TYPE]  int  [PARAMETER]  CharSequence  seq  [CLASS]  CharacterReader  [TYPE]  char  EOF  startChar  [TYPE]  CharSequence  seq  [TYPE]  boolean  false  true  [TYPE]  int  i  j  last  length  mark  offset  pos  [TYPE]  char[]  input  [CONTEXT]  int  nextIndexOf  (  CharSequence  seq  )  {  char  startChar  =  seq  .  charAt  (  0  )  ;  for  (  int  offset  =  pos  ;  offset  <  length  ;  offset++  )  {  if  (  startChar  !  =  input[offset]  )  while  (  ++offset  <  length  &&  startChar  !  =  input[offset]  )  ;  int  i  =  offset  +  1  ;  int  last  =  i  +  seq  .  length  (  )  -1  ;  [BUGGY]  if  (  offset  <  length  )  {  for  (  int  j  =  1  ;  i  <  last  &&  seq  .  charAt  (  j  )  =  =  input[i]  ;  i++  ,  j++  )  ;  if  (  i  =  =  last  )  //  found  full  sequence  return  offset  -  pos  ;  }  }  return  -1  ;  }  	Jsoup_34_CharacterReader_1_1	91	1	src/main/java/org/jsoup/parser/CharacterReader.java
1583	adopter.attributes().addAll(formatEl.attributes());  	[BUGGY]  [FE]  AssertionFailedError:  expected:<com/ ">Link</a>  assertEquals  (  want  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  LinkedList  stack  [TYPE]  int  i  j  si  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  replaceOnStack  (  node  ,  replacement  )  ;  node  =  replacement  ;  if  (  lastNode  =  =  furthestBlock  )  {    }  if  (  lastNode  .  parent  (  )  !  =  null  )  lastNode  .  remove  (  )  ;  node  .  appendChild  (  lastNode  )  ;  lastNode  =  node  ;  }  if  (  StringUtil  .  in  (  commonAncestor  .  nodeName  (  )  ,   "table "  ,   "tbody "  ,   "tfoot "  ,   "thead "  ,   "tr "  )  )  {  if  (  lastNode  .  parent  (  )  !  =  null  )  lastNode  .  remove  (  )  ;  tb  .  insertInFosterParent  (  lastNode  )  ;  }  else  {  if  (  lastNode  .  parent  (  )  !  =  null  )  lastNode  .  remove  (  )  ;  commonAncestor  .  appendChild  (  lastNode  )  ;  }  Element  adopter  =  new  Element  (  formatEl  .  tag  (  )  ,  tb  .  getBaseUri  (  )  )  ;  [BUGGY]  Node[]  childNodes  =  furthestBlock  .  childNodes  (  )  .  toArray  (  new  Node[furthestBlock  .  childNodeSize  (  )  ]  )  ;  for  (  Node  childNode  :  childNodes  )  {  adopter  .  appendChild  (  childNode  )  ;  //  append  will  reparent  .  thus  the  clone  to  avoid  concurrent  mod  .  }  furthestBlock  .  appendChild  (  adopter  )  ;  tb  .  removeFromActiveFormattingElements  (  formatEl  )  ;  	Jsoup_35_HtmlTreeBuilderState_1_1	726	0	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1584		[BUGGY]  [FE]  charsetIllegalCharsetNameException:  charset  =  iso-8859-1  assertEquals  (   "iso-8859-1 "  ,  DataUtil  .  getCharsetFromContentType  (   "text/html  ;  charset  =  charset  =  iso-8859-1 "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_36_DataUtil_6_1	10	0	src/main/java/org/jsoup/helper/DataUtil.java
1585	private  static  final  Pattern  charsetPattern  =  Pattern.compile( "(?i)\\\\bcharset=\\\\s*(?:\\ "|\')?([^\\\\s,;\\ "\']*) ");  	[BUGGY]  private  static  final  Pattern  charsetPattern  =  Pattern  .  compile  (   "  (  ?i  )  \\\\bcharset  =  \\\\s*\\ "?  (  [^\\\\s  ;  \\ "]*  )   "  )  ;  [FE]  charsetIllegalCharsetNameException:  charset  =  iso-8859-1  assertEquals  (   "iso-8859-1 "  ,  DataUtil  .  getCharsetFromContentType  (   "text/html  ;  charset  =  charset  =  iso-8859-1 "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_36_DataUtil_6_2	19	1	src/main/java/org/jsoup/helper/DataUtil.java
1586	if  (foundCharset  ==  null  &&  meta.hasAttr( "charset "))  {  try  {  if  (Charset.isSupported(meta.attr( "charset ")))  {  foundCharset  =  meta.attr( "charset ");  }  }  catch  (IllegalCharsetNameException  e)  {  foundCharset  =  null;  }  }  	[BUGGY]  [FE]  charsetIllegalCharsetNameException:  charset  =  iso-8859-1  assertEquals  (   "iso-8859-1 "  ,  DataUtil  .  getCharsetFromContentType  (   "text/html  ;  charset  =  charset  =  iso-8859-1 "  )  )  ;  [METHOD]  parseByteData  [TYPE]  Document  [PARAMETER]  ByteBuffer  byteData  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  boolean  false  true  [TYPE]  Element  meta  [TYPE]  String  baseUri  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  ByteBuffer  byteData  [TYPE]  int  bufferSize  [TYPE]  Parser  parser  [CONTEXT]  static  Document  parseByteData  (  ByteBuffer  byteData  ,  String  charsetName  ,  String  baseUri  ,  Parser  parser  )  {  String  docData  ;  Document  doc  =  null  ;  if  (  charsetName  =  =  null  )  {  //  determine  from  meta  .  safe  parse  as  UTF-8  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  parser  .  parseInput  (  docData  ,  baseUri  )  ;  Element  meta  =  doc  .  select  (   "meta[http-equiv  =  content-type]  ,  meta[charset] "  )  .  first  (  )  ;  if  (  meta  !  =  null  )  {  //  if  not  found  ,  will  keep  utf-8  as  best  attempt  String  foundCharset  ;  if  (  meta  .  hasAttr  (   "http-equiv "  )  )  {  foundCharset  =  getCharsetFromContentType  (  meta  .  attr  (   "content "  )  )  ;  [BUGGY]  }  else  {  foundCharset  =  meta  .  attr  (   "charset "  )  ;  }  if  (  foundCharset  !  =  null  &&  foundCharset  .  length  (  )  !  =  0  &&  !foundCharset  .  equals  (  defaultCharset  )  )  {  //  need  to  re-decode  charsetName  =  foundCharset  ;  	Jsoup_36_DataUtil_6_3	87	0	src/main/java/org/jsoup/helper/DataUtil.java
1587	foundCharset  =  foundCharset.trim().replaceAll( "[\\ "\'] ",   " ");  	[BUGGY]  [FE]  charsetIllegalCharsetNameException:  charset  =  iso-8859-1  assertEquals  (   "iso-8859-1 "  ,  DataUtil  .  getCharsetFromContentType  (   "text/html  ;  charset  =  charset  =  iso-8859-1 "  )  )  ;  [METHOD]  parseByteData  [TYPE]  Document  [PARAMETER]  ByteBuffer  byteData  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  boolean  false  true  [TYPE]  Element  meta  [TYPE]  String  baseUri  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  ByteBuffer  byteData  [TYPE]  int  bufferSize  [TYPE]  Parser  parser  [CONTEXT]  static  Document  parseByteData  (  ByteBuffer  byteData  ,  String  charsetName  ,  String  baseUri  ,  Parser  parser  )  {  String  docData  ;  Document  doc  =  null  ;  if  (  charsetName  =  =  null  )  {  //  determine  from  meta  .  safe  parse  as  UTF-8  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  parser  .  parseInput  (  docData  ,  baseUri  )  ;  Element  meta  =  doc  .  select  (   "meta[http-equiv  =  content-type]  ,  meta[charset] "  )  .  first  (  )  ;  if  (  meta  !  =  null  )  {  //  if  not  found  ,  will  keep  utf-8  as  best  attempt  String  foundCharset  ;  if  (  meta  .  hasAttr  (   "http-equiv "  )  )  {  foundCharset  =  getCharsetFromContentType  (  meta  .  attr  (   "content "  )  )  ;  }  else  {  foundCharset  =  meta  .  attr  (   "charset "  )  ;  }  if  (  foundCharset  !  =  null  &&  foundCharset  .  length  (  )  !  =  0  &&  !foundCharset  .  equals  (  defaultCharset  )  )  {  //  need  to  re-decode  [BUGGY]  charsetName  =  foundCharset  ;  byteData  .  rewind  (  )  ;  docData  =  Charset  .  forName  (  foundCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  null  ;  }  }  	Jsoup_36_DataUtil_6_4	92	0	src/main/java/org/jsoup/helper/DataUtil.java
1588	charset  =  charset.replace( "charset= ",   " ");  if  (charset.isEmpty())  return  null;  try  {  	[BUGGY]  [FE]  charsetIllegalCharsetNameException:  charset  =  iso-8859-1  assertEquals  (   "iso-8859-1 "  ,  DataUtil  .  getCharsetFromContentType  (   "text/html  ;  charset  =  charset  =  iso-8859-1 "  )  )  ;  [METHOD]  getCharsetFromContentType  [TYPE]  String  [PARAMETER]  String  contentType  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  String  charset  contentType  defaultCharset  [TYPE]  boolean  false  true  [TYPE]  Matcher  m  [TYPE]  int  bufferSize  [CONTEXT]  static  String  getCharsetFromContentType  (  String  contentType  )  {  if  (  contentType  =  =  null  )  return  null  ;  Matcher  m  =  charsetPattern  .  matcher  (  contentType  )  ;  if  (  m  .  find  (  )  )  {  String  charset  =  m  .  group  (  1  )  .  trim  (  )  ;  [BUGGY]  if  (  Charset  .  isSupported  (  charset  )  )  return  charset  ;  charset  =  charset  .  toUpperCase  (  Locale  .  ENGLISH  )  ;  if  (  Charset  .  isSupported  (  charset  )  )  return  charset  ;  }  return  null  ;  }  	Jsoup_36_DataUtil_6_5	161	0	src/main/java/org/jsoup/helper/DataUtil.java
1589	}  catch  (IllegalCharsetNameException  e)  {  return  null;  }  	[BUGGY]  [FE]  charsetIllegalCharsetNameException:  charset  =  iso-8859-1  assertEquals  (   "iso-8859-1 "  ,  DataUtil  .  getCharsetFromContentType  (   "text/html  ;  charset  =  charset  =  iso-8859-1 "  )  )  ;  [METHOD]  getCharsetFromContentType  [TYPE]  String  [PARAMETER]  String  contentType  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  String  charset  contentType  defaultCharset  [TYPE]  boolean  false  true  [TYPE]  Matcher  m  [TYPE]  int  bufferSize  [CONTEXT]  static  String  getCharsetFromContentType  (  String  contentType  )  {  if  (  contentType  =  =  null  )  return  null  ;  Matcher  m  =  charsetPattern  .  matcher  (  contentType  )  ;  if  (  m  .  find  (  )  )  {  String  charset  =  m  .  group  (  1  )  .  trim  (  )  ;  if  (  Charset  .  isSupported  (  charset  )  )  return  charset  ;  charset  =  charset  .  toUpperCase  (  Locale  .  ENGLISH  )  ;  if  (  Charset  .  isSupported  (  charset  )  )  return  charset  ;  [BUGGY]  }  return  null  ;  }  	Jsoup_36_DataUtil_6_6	164	0	src/main/java/org/jsoup/helper/DataUtil.java
1590	return  getOutputSettings().prettyPrint()  ?  accum.toString().trim()  :  accum.toString();  	[BUGGY]  return  accum  .  toString  (  )  .  trim  (  )  ;  [FE]  AssertionFailedError:  expected:<[  assertEquals  (   "  \n<p>Hello\n  there\n</p> "  ,  div  .  html  (  )  )  ;  [METHOD]  html  [TYPE]  String  [PARAMETER]  [CLASS]  Element  [TYPE]  Set  classNames  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [CONTEXT]  public  String  html  (  )  {  StringBuilder  accum  =  new  StringBuilder  (  )  ;  html  (  accum  )  ;  [BUGGY]  return  accum  .  toString  (  )  .  trim  (  )  ;  }  	Jsoup_37_Element_1_1	1101	1	src/main/java/org/jsoup/nodes/Element.java
1591	if  (tb.getFromStack( "svg ")  ==  null)  else  tb.insert(startTag);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<img  />  assertEquals  (   "<img  />\n<svg>\n  <image  />\n</svg> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  LinkedList  stack  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  }  else  if  (  name  .  equals  (   "table "  )  )  {  if  (  tb  .  getDocument  (  )  .  quirksMode  (  )  !  =  Document  .  QuirksMode  .  quirks  &&  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  process  (  new  Token  .  EndTag  (   "p "  )  )  ;  }  tb  .  insert  (  startTag  )  ;  tb  .  framesetOk  (  false  )  ;  tb  .  transition  (  InTable  )  ;  }  else  if  (  StringUtil  .  in  (  name  ,  Constants  .  InBodyStartEmptyFormatters  )  )  {  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insertEmpty  (  startTag  )  ;  tb  .  framesetOk  (  false  )  ;  }  else  if  (  name  .  equals  (   "input "  )  )  {  tb  .  reconstructFormattingElements  (  )  ;  Element  el  =  tb  .  insertEmpty  (  startTag  )  ;  if  (  !el  .  attr  (   "type "  )  .  equalsIgnoreCase  (   "hidden "  )  )  tb  .  framesetOk  (  false  )  ;  }  else  if  (  StringUtil  .  in  (  name  ,  Constants  .  InBodyStartMedia  )  )  {  tb  .  insertEmpty  (  startTag  )  ;  }  else  if  (  name  .  equals  (   "hr "  )  )  {  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  process  (  new  Token  .  EndTag  (   "p "  )  )  ;  }  tb  .  insertEmpty  (  startTag  )  ;  tb  .  framesetOk  (  false  )  ;  }  else  if  (  name  .  equals  (   "image "  )  )  {  [BUGGY]  return  tb  .  process  (  startTag  .  name  (   "img "  )  )  ;  //  change  <image>  to  <img>  ,  unless  in  svg  }  else  if  (  name  .  equals  (   "isindex "  )  )  {  tb  .  error  (  this  )  ;  if  (  tb  .  getFormElement  (  )  !  =  null  )  return  false  ;  	Jsoup_38_HtmlTreeBuilderState_1_1	455	0	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1592	doc  =  null;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[One]>  but  was:<[]>  assertEquals  (   "UTF-8 "  ,  doc  .  outputSettings  (  )  .  charset  (  )  .  displayName  (  )  )  ;  [METHOD]  parseByteData  [TYPE]  Document  [PARAMETER]  ByteBuffer  byteData  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  IllegalCharsetNameException  e  [TYPE]  boolean  false  true  [TYPE]  Element  meta  [TYPE]  String  baseUri  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  ByteBuffer  byteData  [TYPE]  int  bufferSize  [TYPE]  Parser  parser  [CONTEXT]  foundCharset  =  null  ;  }  }  }  else  {  foundCharset  =  meta  .  attr  (   "charset "  )  ;  }  if  (  foundCharset  !  =  null  &&  foundCharset  .  length  (  )  !  =  0  &&  !foundCharset  .  equals  (  defaultCharset  )  )  {  //  need  to  re-decode  foundCharset  =  foundCharset  .  trim  (  )  .  replaceAll  (   "[\ "'] "  ,   " "  )  ;  charsetName  =  foundCharset  ;  byteData  .  rewind  (  )  ;  docData  =  Charset  .  forName  (  foundCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  null  ;  }  }  }  else  {  //  specified  by  content  type  header  (  or  by  user  on  file  load  )  Validate  .  notEmpty  (  charsetName  ,   "Must  set  charset  arg  to  character  set  of  file  to  parse  .  Set  to  null  to  attempt  to  detect  from  HTML "  )  ;  docData  =  Charset  .  forName  (  charsetName  )  .  decode  (  byteData  )  .  toString  (  )  ;  }  if  (  docData  .  length  (  )  >  0  &&  docData  .  charAt  (  0  )  =  =  65279  )  {  byteData  .  rewind  (  )  ;  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  docData  =  docData  .  substring  (  1  )  ;  charsetName  =  defaultCharset  ;  [BUGGY]  }  if  (  doc  =  =  null  )  {  doc  =  parser  .  parseInput  (  docData  ,  baseUri  )  ;  doc  .  outputSettings  (  )  .  charset  (  charsetName  )  ;  }  return  doc  ;  	Jsoup_39_DataUtil_1_1	119	0	src/main/java/org/jsoup/helper/DataUtil.java
1593		[BUGGY]  Validate  .  notEmpty  (  name  )  ;  [FE]  IllegalArgumentException:  String  must  not  be  empty  [CLASS]  [CONTEXT]  	Jsoup_40_DocumentType_1_1	22	1	src/main/java/org/jsoup/nodes/DocumentType.java
1594	return  tag.equals(element.tag);  	[BUGGY]  return  this  =  =  o  ;  [FE]  AssertionFailedError:  expected:  orgjsoupnodesElement<<p  class  =   "one ">One</p>>  but  was:  orgjsoupnodesElement<<p  class  =   "one ">One</p>>  assertFalse  (  e0  .  hashCode  (  )  =  =  (  e7  )  .  hashCode  (  )  )  ;  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  Element  [TYPE]  Object  o  [TYPE]  Tag  tag  [TYPE]  boolean  false  true  [TYPE]  Element  element  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  if  (  this  =  =  o  )  return  true  ;  if  (  o  =  =  null  ||  getClass  (  )  !  =  o  .  getClass  (  )  )  return  false  ;  if  (  !super  .  equals  (  o  )  )  return  false  ;  Element  element  =  (  Element  )  o  ;  [BUGGY]  return  this  =  =  o  ;  }  	Jsoup_41_Element_1_1	1175	1	src/main/java/org/jsoup/nodes/Element.java
1595	if  (el.hasAttr( "disabled "))  continue;    	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<7>  assertEquals  (   "eight  =  on "  ,  data  .  get  (  5  )  .  toString  (  )  )  ;  //  default  [METHOD]  formData  [TYPE]  List  [PARAMETER]  [CLASS]  FormElement  [TYPE]  ArrayList  data  [TYPE]  String  name  type  val  [TYPE]  boolean  false  set  true  [TYPE]  Elements  elements  options  [TYPE]  Element  el  option  [CONTEXT]  public  List<Connection  .  KeyVal>  formData  (  )  {  ArrayList<Connection  .  KeyVal>  data  =  new  ArrayList<Connection  .  KeyVal>  (  )  ;    for  (  Element  el:  elements  )  {  if  (  !el  .  tag  (  )  .  isFormSubmittable  (  )  )  continue  ;  //  contents  are  form  listable  ,  superset  of  submitable  [BUGGY]  String  name  =  el  .  attr  (   "name "  )  ;  if  (  name  .  length  (  )  =  =  0  )  continue  ;  String  type  =  el  .  attr  (   "type "  )  ;  if  (   "select "  .  equals  (  el  .  tagName  (  )  )  )  {  Elements  options  =  el  .  select  (   "option[selected] "  )  ;  	Jsoup_42_FormElement_2_1	80	0	src/main/java/org/jsoup/nodes/FormElement.java
1596	final  String  val  =  el.val().length()  >    0  ?  el.val()  :   "on ";  	[BUGGY]  final  String  val  =  el  .  val  (  )  ;  [FE]  AssertionFailedError:  expected:<6>  but  was:<7>  assertEquals  (   "eight  =  on "  ,  data  .  get  (  5  )  .  toString  (  )  )  ;  //  default  [METHOD]  formData  [TYPE]  List  [PARAMETER]  [CLASS]  FormElement  [TYPE]  ArrayList  data  [TYPE]  String  name  type  val  [TYPE]  boolean  false  set  true  [TYPE]  Elements  elements  options  [TYPE]  Element  el  option  [CONTEXT]  public  List<Connection  .  KeyVal>  formData  (  )  {  ArrayList<Connection  .  KeyVal>  data  =  new  ArrayList<Connection  .  KeyVal>  (  )  ;    for  (  Element  el:  elements  )  {  if  (  !el  .  tag  (  )  .  isFormSubmittable  (  )  )  continue  ;  //  contents  are  form  listable  ,  superset  of  submitable  String  name  =  el  .  attr  (   "name "  )  ;  if  (  name  .  length  (  )  =  =  0  )  continue  ;  String  type  =  el  .  attr  (   "type "  )  ;  if  (   "select "  .  equals  (  el  .  tagName  (  )  )  )  {  Elements  options  =  el  .  select  (   "option[selected] "  )  ;  boolean  set  =  false  ;  for  (  Element  option:  options  )  {  data  .  add  (  HttpConnection  .  KeyVal  .  create  (  name  ,  option  .  val  (  )  )  )  ;  set  =  true  ;  }  if  (  !set  )  {  Element  option  =  el  .  select  (   "option "  )  .  first  (  )  ;  if  (  option  !  =  null  )  data  .  add  (  HttpConnection  .  KeyVal  .  create  (  name  ,  option  .  val  (  )  )  )  ;  }  }  else  if  (   "checkbox "  .  equalsIgnoreCase  (  type  )  ||   "radio "  .  equalsIgnoreCase  (  type  )  )  {  if  (  el  .  hasAttr  (   "checked "  )  )  {  [BUGGY]  final  String  val  =  el  .  val  (  )  ;  data  .  add  (  HttpConnection  .  KeyVal  .  create  (  name  ,  val  )  )  ;  }  }  else  {  data  .  add  (  HttpConnection  .  KeyVal  .  create  (  name  ,  el  .  val  (  )  )  )  ;  }  	Jsoup_42_FormElement_2_2	99	1	src/main/java/org/jsoup/nodes/FormElement.java
1597	if  (element  ==  search)  	[BUGGY]  if  (  element  .  equals  (  search  )  )  [FE]  AssertionFailedError  assertTrue  (  2  =  =  ps  .  get  (  2  )  .  elementSiblingIndex  (  )  )  ;  [METHOD]  indexInList  [TYPE]  <E  [PARAMETER]  Element  search  List<E>  elements  [CLASS]  Element  [TYPE]  Pattern  classSplit  [TYPE]  boolean  false  true  [TYPE]  E  element  [TYPE]  Element  search  [TYPE]  List  elements  [TYPE]  Tag  tag  [TYPE]  int  i  [CONTEXT]  private  static  <E  extends  Element>  Integer  indexInList  (  Element  search  ,  List<E>  elements  )  {  Validate  .  notNull  (  search  )  ;  Validate  .  notNull  (  elements  )  ;  for  (  int  i  =  0  ;  i  <  elements  .  size  (  )  ;  i++  )  {  E  element  =  elements  .  get  (  i  )  ;  [BUGGY]  if  (  element  .  equals  (  search  )  )  return  i  ;  }  return  null  ;  }  	Jsoup_43_Element_1_1	574	1	src/main/java/org/jsoup/nodes/Element.java
1598	if (currentToken == start) { return process(new Token.StartTag().name(name)); }  	[BUGGY]  [FE]  AssertionFailedError:  Search  text  did  not  come  after  comment  assertTrue  (   "Search  text  did  not  come  after  comment "  ,  guarantee  >  endOfEmail  )  ;  [METHOD]  processStartTag  [TYPE]  boolean  [PARAMETER]  String  name  [CLASS]  TreeBuilder  [TYPE]  CharacterReader  reader  [TYPE]  boolean  false  true  [TYPE]  EndTag  end  [TYPE]  ArrayList  stack  [TYPE]  Tokeniser  tokeniser  [TYPE]  Token  currentToken  [TYPE]  String  baseUri  name  [TYPE]  ParseErrorList  errors  [TYPE]  Document  doc  [TYPE]  StartTag  start  [CONTEXT]  protected  boolean  processStartTag  (  String  name  )  {  [BUGGY]  return  process  (  start  .  reset  (  )  .  name  (  name  )  )  ;  }  	Jsoup_44_TreeBuilder_3_1	61	0	src/main/java/org/jsoup/parser/TreeBuilder.java
1599	if (currentToken == start) { return process(new Token.StartTag().nameAttr(name, attrs));  }  	[BUGGY]  [FE]  AssertionFailedError:  Search  text  did  not  come  after  comment  assertTrue  (   "Search  text  did  not  come  after  comment "  ,  guarantee  >  endOfEmail  )  ;  [METHOD]  processStartTag  [TYPE]  boolean  [PARAMETER]  String  name  Attributes  attrs  [CLASS]  TreeBuilder  [TYPE]  CharacterReader  reader  [TYPE]  boolean  false  true  [TYPE]  EndTag  end  [TYPE]  ArrayList  stack  [TYPE]  Attributes  attrs  [TYPE]  Tokeniser  tokeniser  [TYPE]  Token  currentToken  [TYPE]  String  baseUri  name  [TYPE]  ParseErrorList  errors  [TYPE]  Document  doc  [TYPE]  StartTag  start  [CONTEXT]  public  boolean  processStartTag  (  String  name  ,  Attributes  attrs  )  {  [BUGGY]  start  .  reset  (  )  ;  start  .  nameAttr  (  name  ,  attrs  )  ;  return  process  (  start  )  ;  }  	Jsoup_44_TreeBuilder_3_2	65	0	src/main/java/org/jsoup/parser/TreeBuilder.java
1600	if (currentToken == end) {  return process(new Token.EndTag().name(name)); }  	[BUGGY]  [FE]  AssertionFailedError:  Search  text  did  not  come  after  comment  assertTrue  (   "Search  text  did  not  come  after  comment "  ,  guarantee  >  endOfEmail  )  ;  [METHOD]  processEndTag  [TYPE]  boolean  [PARAMETER]  String  name  [CLASS]  TreeBuilder  [TYPE]  CharacterReader  reader  [TYPE]  boolean  false  true  [TYPE]  EndTag  end  [TYPE]  ArrayList  stack  [TYPE]  Tokeniser  tokeniser  [TYPE]  Token  currentToken  [TYPE]  String  baseUri  name  [TYPE]  ParseErrorList  errors  [TYPE]  Document  doc  [TYPE]  StartTag  start  [CONTEXT]  protected  boolean  processEndTag  (  String  name  )  {  [BUGGY]  return  process  (  end  .  reset  (  )  .  name  (  name  )  )  ;  }  	Jsoup_44_TreeBuilder_3_3	71	0	src/main/java/org/jsoup/parser/TreeBuilder.java
1601	}  else  if  (( "td ".equals(name)  ||   "th ".equals(name)  &&  !last))  {  	[BUGGY]  }  else  if  (  (   "td "  .  equals  (  name  )  ||   "td "  .  equals  (  name  )  &&  !last  )  )  {  [FE]  AssertionFailedError:  expected:<1>  but  was:<5>  assertEquals  (  1  ,  doc  .  body  (  )  .  children  (  )  .  size  (  )  )  ;  [METHOD]  resetInsertionMode  [TYPE]  void  [PARAMETER]  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  last  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  node  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsScriptStyle  TagsSearchInScope  specificScopeTarget  [TYPE]  String  name  [TYPE]  FormElement  formElement  [TYPE]  int  pos  [CONTEXT]  void  resetInsertionMode  (  )  {  boolean  last  =  false  ;  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  node  =  stack  .  get  (  pos  )  ;  if  (  pos  =  =  0  )  {  last  =  true  ;  node  =  contextElement  ;  }  String  name  =  node  .  nodeName  (  )  ;  if  (   "select "  .  equals  (  name  )  )  {  transition  (  HtmlTreeBuilderState  .  InSelect  )  ;  break  ;  //  frag  [BUGGY]  }  else  if  (  (   "td "  .  equals  (  name  )  ||   "td "  .  equals  (  name  )  &&  !last  )  )  {  transition  (  HtmlTreeBuilderState  .  InCell  )  ;  break  ;  }  else  if  (   "tr "  .  equals  (  name  )  )  {  transition  (  HtmlTreeBuilderState  .  InRow  )  ;  break  ;  	Jsoup_45_HtmlTreeBuilder_1_1	394	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1602	accum.append( "&#xa0; ");  	[BUGGY]  accum  .  append  (  c  )  ;  [FE]  AssertionFailedError:  Should  not  have  contained  a  '?'  assertTrue  (   "Should  have  contained  a  '&#xa0  ;  '  or  a  '&nbsp  ;  '  .   "  ,  [METHOD]  escape  [TYPE]  void  [PARAMETER]  StringBuilder  accum  String  string  OutputSettings  out  boolean  inAttribute  boolean  normaliseWhite  boolean  stripLeadingWhite  [CLASS]  Entities  [TYPE]  boolean  false  inAttribute  lastWasWhite  normaliseWhite  reachedNonWhite  stripLeadingWhite  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  CoreCharset  ascii  coreCharset  fallback  utf  [TYPE]  EscapeMode  base  escapeMode  extended  xhtml  [TYPE]  Object[][]  xhtmlArray  [TYPE]  char  c  [TYPE]  String  c  string  [TYPE]  Map  base  baseByVal  full  fullByVal  map  xhtmlByVal  [TYPE]  CharsetEncoder  encoder  [TYPE]  int  codePoint  length  offset  [CONTEXT]  if  (  normaliseWhite  )  {  if  (  StringUtil  .  isWhitespace  (  codePoint  )  )  {  if  (  (  stripLeadingWhite  &&  !reachedNonWhite  )  ||  lastWasWhite  )  continue  ;  accum  .  append  (  '  '  )  ;  lastWasWhite  =  true  ;  continue  ;  }  else  {  lastWasWhite  =  false  ;  reachedNonWhite  =  true  ;  }  }  if  (  codePoint  <  Character  .  MIN_SUPPLEMENTARY_CODE_POINT  )  {  final  char  c  =  (  char  )  codePoint  ;  switch  (  c  )  {  case  '&':  accum  .  append  (   "&amp  ;   "  )  ;  break  ;  case  0xA0:  if  (  escapeMode  !  =  EscapeMode  .  xhtml  )  accum  .  append  (   "&nbsp  ;   "  )  ;  else  [BUGGY]  accum  .  append  (  c  )  ;  break  ;  case  '<':  if  (  !inAttribute  )  accum  .  append  (   "&lt  ;   "  )  ;  else  	Jsoup_46_Entities_1_1	118	1	src/main/java/org/jsoup/nodes/Entities.java
1603	if  (!inAttribute  ||  escapeMode  ==  EscapeMode.xhtml)  	[BUGGY]  if  (  !inAttribute  )  [FE]  AssertionFailedError:  expected:<<a  title  =   "[&lt  ;  p>One&lt  ;  ]/p> ">One</a>>  but  was:<<a  title  =   "[<p>One<]/p> ">One</a>>  assertEquals  (   "<a  title  =  \ "&lt  ;  p>One&lt  ;  /p>\ ">One</a> "  ,  element  .  outerHtml  (  )  )  ;  [METHOD]  escape  [TYPE]  void  [PARAMETER]  StringBuilder  accum  String  string  OutputSettings  out  boolean  inAttribute  boolean  normaliseWhite  boolean  stripLeadingWhite  [CLASS]  Entities  [TYPE]  boolean  false  inAttribute  lastWasWhite  normaliseWhite  reachedNonWhite  stripLeadingWhite  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  CoreCharset  ascii  coreCharset  fallback  utf  [TYPE]  EscapeMode  base  escapeMode  extended  xhtml  [TYPE]  Object[][]  xhtmlArray  [TYPE]  char  c  [TYPE]  String  c  string  [TYPE]  Map  base  baseByVal  full  fullByVal  map  xhtmlByVal  [TYPE]  CharsetEncoder  encoder  [TYPE]  int  codePoint  length  offset  [CONTEXT]  continue  ;  accum  .  append  (  '  '  )  ;  lastWasWhite  =  true  ;  continue  ;  }  else  {  lastWasWhite  =  false  ;  reachedNonWhite  =  true  ;  }  }  if  (  codePoint  <  Character  .  MIN_SUPPLEMENTARY_CODE_POINT  )  {  final  char  c  =  (  char  )  codePoint  ;  switch  (  c  )  {  case  '&':  accum  .  append  (   "&amp  ;   "  )  ;  break  ;  case  0xA0:  if  (  escapeMode  !  =  EscapeMode  .  xhtml  )  accum  .  append  (   "&nbsp  ;   "  )  ;  else  accum  .  append  (   "&#xa0  ;   "  )  ;  break  ;  case  '<':  [BUGGY]  if  (  !inAttribute  )  accum  .  append  (   "&lt  ;   "  )  ;  else  accum  .  append  (  c  )  ;  break  ;  case  '>':  	Jsoup_47_Entities_1_1	122	1	src/main/java/org/jsoup/nodes/Entities.java
1604	if  (values.size()  ==  1)  else  if  (values.size()  >  1)  {  StringBuilder  accum  =  new  StringBuilder();  for  (int  i  =  0;  i  <  values.size();  i++)  {  final  String  val  =  values.get(i);  if  (i  !=  0)  accum.append( ",   ");  accum.append(val);  }  header(name,  accum.toString());  }  	[BUGGY]  if  (  !values  .  isEmpty  (  )  )  [FE]  AssertionFailedError:  expected:<no-cache[  ,  no-store]>  but  was:<no-cache[]>  assertEquals  (   "no-cache  ,  no-store "  ,  res  .  header  (   "Cache-Control "  )  )  ;  [METHOD]  processResponseHeaders  [TYPE]  void  [PARAMETER]  String>>  resHeaders  [CLASS]  Response  [TYPE]  Pattern  xmlContentTypeRxp  [TYPE]  TokenQueue  cd  [TYPE]  Entry  entry  [TYPE]  boolean  executed  false  true  [TYPE]  Request  req  [TYPE]  List  values  [TYPE]  String  LOCATION  charset  contentType  cookieName  cookieVal  name  statusMessage  value  [TYPE]  SSLSocketFactory  sslSocketFactory  [TYPE]  ByteBuffer  byteData  [TYPE]  Map  resHeaders  [TYPE]  int  MAX_REDIRECTS  numRedirects  statusCode  [CONTEXT]  void  processResponseHeaders  (  Map<String  ,  List<String>>  resHeaders  )  {  for  (  Map  .  Entry<String  ,  List<String>>  entry  :  resHeaders  .  entrySet  (  )  )  {  String  name  =  entry  .  getKey  (  )  ;  if  (  name  =  =  null  )  continue  ;  //  http/1  .  1  line  List<String>  values  =  entry  .  getValue  (  )  ;  if  (  name  .  equalsIgnoreCase  (   "Set-Cookie "  )  )  {  for  (  String  value  :  values  )  {  if  (  value  =  =  null  )  continue  ;  TokenQueue  cd  =  new  TokenQueue  (  value  )  ;  String  cookieName  =  cd  .  chompTo  (   "  =   "  )  .  trim  (  )  ;  String  cookieVal  =  cd  .  consumeTo  (   "  ;   "  )  .  trim  (  )  ;    if  (  cookieName  .  length  (  )  >  0  )  cookie  (  cookieName  ,  cookieVal  )  ;  }  }  else  {  //  combine  same  header  names  with  comma:  http://www  .  w3  .  org/Protocols/rfc2616/rfc2616-sec4  .  html#sec4  .  2  [BUGGY]  if  (  !values  .  isEmpty  (  )  )  header  (  name  ,  values  .  get  (  0  )  )  ;  }  }  }  	Jsoup_48_HttpConnection_1_1	773	1	src/main/java/org/jsoup/helper/HttpConnection.java
1605	reindexChildren(index);  	[BUGGY]  reindexChildren  (  index  )  ;  [FE]  AssertionFailedError:  expected:<><div3>Check</div3><[div4></div4><div1></div1><div2></div2><]/body>>  but  was:<><div3>Check</div3><[]/body>>  assertEquals  (   "<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body> "  ,  result  )  ;  [METHOD]  addChildren  [TYPE]  void  [PARAMETER]  int  index  children  [CLASS]  Node  [TYPE]  Node[]  children  [TYPE]  boolean  false  true  [TYPE]  StringBuilder  accum  [TYPE]  OutputSettings  out  [TYPE]  Node  in  parentNode  [TYPE]  Attributes  attributes  [TYPE]  List  EMPTY_NODES  childNodes  [TYPE]  String  baseUri  [TYPE]  int  i  index  siblingIndex  [CONTEXT]  protected  void  addChildren  (  int  index  ,  Node  .  .  .  children  )  {  Validate  .  noNullElements  (  children  )  ;  ensureChildNodes  (  )  ;  for  (  int  i  =  children  .  length  -  1  ;  i  >  =  0  ;  i--  )  {  Node  in  =  children[i]  ;  reparentChild  (  in  )  ;  childNodes  .  add  (  index  ,  in  )  ;  [BUGGY]  }  reindexChildren  (  index  )  ;  }  	Jsoup_49_Node_1_1	445	1	src/main/java/org/jsoup/nodes/Node.java
1606	byteData.mark();  byte[]  bom  =  new  byte[4];  byteData.get(bom);  byteData.rewind();  if  (bom[0]  ==  0x00  &&  bom[1]  ==  0x00  &&  bom[2]  ==  (byte)  0xFE  &&  bom[3]  ==  (byte)  0xFF  ||    bom[0]  ==  (byte)  0xFF  &&  bom[1]  ==  (byte)  0xFE  &&  bom[2]  ==  0x00  &&  bom[3]  ==  0x00)  {    charsetName  =   "UTF-32 ";    }  else  if  (bom[0]  ==  (byte)  0xFE  &&  bom[1]  ==  (byte)  0xFF  ||    bom[0]  ==  (byte)  0xFF  &&  bom[1]  ==  (byte)  0xFE)  {  charsetName  =   "UTF-16 ";    }  else  if  (bom[0]  ==  (byte)  0xEF  &&  bom[1]  ==  (byte)  0xBB  &&  bom[2]  ==  (byte)  0xBF)  {  charsetName  =   "UTF-8 ";    byteData.position(3);    }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  doc  .  text  (  )  .  contains  (   " "  )  )  ;  [METHOD]  parseByteData  [TYPE]  Document  [PARAMETER]  ByteBuffer  byteData  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  IllegalCharsetNameException  e  [TYPE]  boolean  false  true  [TYPE]  Element  meta  [TYPE]  String  baseUri  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  ByteBuffer  byteData  [TYPE]  int  UNICODE_BOM  boundaryLength  bufferSize  [TYPE]  char[]  mimeBoundaryChars  [TYPE]  Parser  parser  [CONTEXT]  static  Document  parseByteData  (  ByteBuffer  byteData  ,  String  charsetName  ,  String  baseUri  ,  Parser  parser  )  {  String  docData  ;  Document  doc  =  null  ;    [BUGGY]  if  (  charsetName  =  =  null  )  {  //  determine  from  meta  .  safe  parse  as  UTF-8  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  parser  .  parseInput  (  docData  ,  baseUri  )  ;  Element  meta  =  doc  .  select  (   "meta[http-equiv  =  content-type]  ,  meta[charset] "  )  .  first  (  )  ;  	Jsoup_50_DataUtil_2_1	93	0	src/main/java/org/jsoup/helper/DataUtil.java
1607		[BUGGY]  if  (  docData  .  length  (  )  >  0  &&  docData  .  charAt  (  0  )  =  =  UNICODE_BOM  )  {  byteData  .  rewind  (  )  ;  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  docData  =  docData  .  substring  (  1  )  ;  charsetName  =  defaultCharset  ;  doc  =  null  ;  }  [FE]  AssertionFailedError  assertTrue  (  doc  .  text  (  )  .  contains  (   " "  )  )  ;  [METHOD]  parseByteData  [TYPE]  Document  [PARAMETER]  ByteBuffer  byteData  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  IllegalCharsetNameException  e  [TYPE]  boolean  false  true  [TYPE]  Element  meta  [TYPE]  String  baseUri  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  ByteBuffer  byteData  [TYPE]  int  UNICODE_BOM  boundaryLength  bufferSize  [TYPE]  char[]  mimeBoundaryChars  [TYPE]  Parser  parser  [CONTEXT]  if  (  meta  .  hasAttr  (   "http-equiv "  )  )  {  foundCharset  =  getCharsetFromContentType  (  meta  .  attr  (   "content "  )  )  ;  }  if  (  foundCharset  =  =  null  &&  meta  .  hasAttr  (   "charset "  )  )  {  try  {  if  (  Charset  .  isSupported  (  meta  .  attr  (   "charset "  )  )  )  {  foundCharset  =  meta  .  attr  (   "charset "  )  ;  }  }  catch  (  IllegalCharsetNameException  e  )  {  foundCharset  =  null  ;  }  }  if  (  foundCharset  !  =  null  &&  foundCharset  .  length  (  )  !  =  0  &&  !foundCharset  .  equals  (  defaultCharset  )  )  {  //  need  to  re-decode  foundCharset  =  foundCharset  .  trim  (  )  .  replaceAll  (   "[\ "'] "  ,   " "  )  ;  charsetName  =  foundCharset  ;  byteData  .  rewind  (  )  ;  docData  =  Charset  .  forName  (  foundCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  null  ;  }  }  }  else  {  //  specified  by  content  type  header  (  or  by  user  on  file  load  )  Validate  .  notEmpty  (  charsetName  ,   "Must  set  charset  arg  to  character  set  of  file  to  parse  .  Set  to  null  to  attempt  to  detect  from  HTML "  )  ;  docData  =  Charset  .  forName  (  charsetName  )  .  decode  (  byteData  )  .  toString  (  )  ;  }  [BUGGY]  if  (  docData  .  length  (  )  >  0  &&  docData  .  charAt  (  0  )  =  =  UNICODE_BOM  )  {  byteData  .  rewind  (  )  ;  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  docData  =  docData  .  substring  (  1  )  ;  charsetName  =  defaultCharset  ;  doc  =  null  ;  	Jsoup_50_DataUtil_2_2	126	7	src/main/java/org/jsoup/helper/DataUtil.java
1608		[BUGGY]  [FE]  AssertionFailedError:  expected:<[Yes]>  but  was:<[]>  assertEquals  (   "Yes "  ,  els  .  text  (  )  )  ;  [METHOD]  matchesLetter  [TYPE]  boolean  [PARAMETER]  [CLASS]  CharacterReader  [TYPE]  char  EOF  c  [TYPE]  String[]  stringCache  [TYPE]  boolean  false  true  [TYPE]  int  length  mark  maxCacheLen  pos  [TYPE]  char[]  input  [CONTEXT]  boolean  matchesLetter  (  )  {  if  (  isEmpty  (  )  )  return  false  ;  char  c  =  input[pos]  ;  [BUGGY]  return  (  c  >  =  'A'  &&  c  <  =  'Z'  )  ||  (  c  >  =  'a'  &&  c  <  =  'z'  )  ;  }  	Jsoup_51_CharacterReader_1_1	300	0	src/main/java/org/jsoup/parser/CharacterReader.java
1609		[BUGGY]  try  {  if  (  Charset  .  isSupported  (  meta  .  attr  (   "charset "  )  )  )  {  }  }  catch  (  IllegalCharsetNameException  e  )  {  foundCharset  =  null  ;  }  [FE]  AssertionFailedError:  expected:<0 "  encoding  =   "UTF-8 "[?]>  assertEquals  (  charsetUtf8  ,  selectedNode  .  attr  (   "encoding "  )  )  ;  [METHOD]  parseByteData  [TYPE]  Document  [PARAMETER]  ByteBuffer  byteData  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  IllegalCharsetNameException  e  [TYPE]  boolean  false  true  [TYPE]  Element  meta  [TYPE]  XmlDeclaration  prolog  [TYPE]  String  baseUri  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  ByteBuffer  byteData  [TYPE]  int  UNICODE_BOM  boundaryLength  bufferSize  [TYPE]  char[]  mimeBoundaryChars  [TYPE]  Parser  parser  [CONTEXT]  static  Document  parseByteData  (  ByteBuffer  byteData  ,  String  charsetName  ,  String  baseUri  ,  Parser  parser  )  {  String  docData  ;  Document  doc  =  null  ;    charsetName  =  detectCharsetFromBom  (  byteData  ,  charsetName  )  ;  if  (  charsetName  =  =  null  )  {  //  determine  from  meta  .  safe  first  parse  as  UTF-8  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  byteData  )  .  toString  (  )  ;  doc  =  parser  .  parseInput  (  docData  ,  baseUri  )  ;  Element  meta  =  doc  .  select  (   "meta[http-equiv  =  content-type]  ,  meta[charset] "  )  .  first  (  )  ;  String  foundCharset  =  null  ;  //  if  not  found  ,  will  keep  utf-8  as  best  attempt  if  (  meta  !  =  null  )  {  if  (  meta  .  hasAttr  (   "http-equiv "  )  )  {  foundCharset  =  getCharsetFromContentType  (  meta  .  attr  (   "content "  )  )  ;  }  if  (  foundCharset  =  =  null  &&  meta  .  hasAttr  (   "charset "  )  )  {  [BUGGY]  try  {  if  (  Charset  .  isSupported  (  meta  .  attr  (   "charset "  )  )  )  {  foundCharset  =  meta  .  attr  (   "charset "  )  ;  }  }  catch  (  IllegalCharsetNameException  e  )  {  foundCharset  =  null  ;  	Jsoup_52_DataUtil_1_1	112	6	src/main/java/org/jsoup/helper/DataUtil.java
1610	return  attributes.html().trim();    	[BUGGY]  final  String  decl  =  this  .  name  ;  if  (  decl  .  equals  (   "xml "  )  &&  attributes  .  size  (  )  >  1  )  {  StringBuilder  sb  =  new  StringBuilder  (  decl  )  ;  final  String  version  =  attributes  .  get  (   "version "  )  ;  if  (  version  !  =  null  )  {  sb  .  append  (   "  version  =  \\ " "  )  .  append  (  version  )  .  append  (   "\\ " "  )  ;  }  final  String  encoding  =  attributes  .  get  (   "encoding "  )  ;  if  (  encoding  !  =  null  )  {  sb  .  append  (   "  encoding  =  \\ " "  )  .  append  (  encoding  )  .  append  (   "\\ " "  )  ;  }  return  sb  .  toString  (  )  ;  }  else  {  return  this  .  name  ;  }  [FE]  AssertionFailedError:  expected:<0 "  encoding  =   "UTF-8 "[?]>  assertEquals  (  charsetUtf8  ,  selectedNode  .  attr  (   "encoding "  )  )  ;  [METHOD]  getWholeDeclaration  [TYPE]  String  [PARAMETER]  [CLASS]  XmlDeclaration  [TYPE]  StringBuilder  sb  [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  decl  encoding  name  version  [CONTEXT]  public  String  getWholeDeclaration  (  )  {  [BUGGY]  final  String  decl  =  this  .  name  ;  if  (  decl  .  equals  (   "xml "  )  &&  attributes  .  size  (  )  >  1  )  {  StringBuilder  sb  =  new  StringBuilder  (  decl  )  ;  final  String  version  =  attributes  .  get  (   "version "  )  ;  if  (  version  !  =  null  )  {  sb  .  append  (   "  version  =  \ " "  )  .  append  (  version  )  .  append  (   "\ " "  )  ;  }  final  String  encoding  =  attributes  .  get  (   "encoding "  )  ;  if  (  encoding  !  =  null  )  {  sb  .  append  (   "  encoding  =  \ " "  )  .  append  (  encoding  )  .  append  (   "\ " "  )  ;  }  return  sb  .  toString  (  )  ;  }  else  {  return  this  .  name  ;  }  }  	Jsoup_52_XmlDeclaration_2_1	46	16	src/main/java/org/jsoup/nodes/XmlDeclaration.java
1611	.append(name);  attributes.html(accum,  out);  accum  .append(isProcessingInstruction  ?   "! "  :   "? ")  	[BUGGY]  .  append  (  getWholeDeclaration  (  )  )  [FE]  AssertionFailedError:  expected:<0 "  encoding  =   "UTF-8 "[?]>  assertEquals  (  charsetUtf8  ,  selectedNode  .  attr  (   "encoding "  )  )  ;  [METHOD]  outerHtmlHead  [TYPE]  void  [PARAMETER]  Appendable  accum  int  depth  OutputSettings  out  [CLASS]  XmlDeclaration  [TYPE]  boolean  false  isProcessingInstruction  true  [TYPE]  String  name  [TYPE]  OutputSettings  out  [TYPE]  int  depth  [TYPE]  Appendable  accum  [CONTEXT]  void  outerHtmlHead  (  Appendable  accum  ,  int  depth  ,  Document  .  OutputSettings  out  )  throws  IOException  {  accum  .  append  (   "< "  )    .  append  (  isProcessingInstruction  ?   "! "  :   "? "  )  [BUGGY]  .  append  (  getWholeDeclaration  (  )  )    .  append  (   "> "  )  ;  }  	Jsoup_52_XmlDeclaration_2_2	68	1	src/main/java/org/jsoup/nodes/XmlDeclaration.java
1612		[BUGGY]  [FE]  AssertionFailedError:  expected:<0 "  encoding  =   "UTF-8 "[?]>  assertEquals  (  charsetUtf8  ,  selectedNode  .  attr  (   "encoding "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_52_XmlTreeBuilder_2_1	3	0	src/main/java/org/jsoup/parser/XmlTreeBuilder.java
1613	Document  doc  =  Jsoup.parse( "< "  +  data.substring(1,  data.length()  -1)  +   "> ",  baseUri,  Parser.xmlParser());  Element  el  =  doc.child(0);  insert  =  new  XmlDeclaration(el.tagName(),  comment.baseUri(),  data.startsWith( "! "));  insert.attributes().addAll(el.attributes());  	[BUGGY]  String  declaration  =  data  .  substring  (  1  )  ;  insert  =  new  XmlDeclaration  (  declaration  ,  comment  .  baseUri  (  )  ,  data  .  startsWith  (   "! "  )  )  ;  [FE]  AssertionFailedError:  expected:<0 "  encoding  =   "UTF-8 "[?]>  assertEquals  (  charsetUtf8  ,  selectedNode  .  attr  (   "encoding "  )  )  ;  [METHOD]  insert  [TYPE]  void  [PARAMETER]  Comment  commentToken  [CLASS]  XmlTreeBuilder  [TYPE]  Comment  comment  commentToken  [TYPE]  boolean  false  true  [TYPE]  Node  insert  [TYPE]  String  data  declaration  [CONTEXT]  void  insert  (  Token  .  Comment  commentToken  )  {  Comment  comment  =  new  Comment  (  commentToken  .  getData  (  )  ,  baseUri  )  ;  Node  insert  =  comment  ;  if  (  commentToken  .  bogus  )  {  //  xml  declarations  are  emitted  as  bogus  comments  (  which  is  right  for  html  ,  but  not  xml  )    String  data  =  comment  .  getData  (  )  ;  if  (  data  .  length  (  )  >  1  &&  (  data  .  startsWith  (   "! "  )  ||  data  .  startsWith  (   "? "  )  )  )  {  [BUGGY]  String  declaration  =  data  .  substring  (  1  )  ;  insert  =  new  XmlDeclaration  (  declaration  ,  comment  .  baseUri  (  )  ,  data  .  startsWith  (   "! "  )  )  ;  }  }  insertNode  (  insert  )  ;  }  	Jsoup_52_XmlTreeBuilder_2_2	76	2	src/main/java/org/jsoup/parser/XmlTreeBuilder.java
1614	boolean  inQuote  =  false;  	[BUGGY]  [FE]  selectSelector$SelectorParseException:  Could  not  parse  query  'div[data  =  'End]'':  unexpected  token  at  '''  assertEquals  (   "Two "  ,  doc  .  select  (   "div[data  =  '[Another  )  ]]' "  )  .  first  (  )  .  text  (  )  )  ;  [METHOD]  chompBalanced  [TYPE]  String  [PARAMETER]  char  open  char  close  [CLASS]  TokenQueue  [TYPE]  char  ESC  close  last  open  [TYPE]  String  queue  [TYPE]  boolean  false  true  [TYPE]  Character  c  [TYPE]  int  depth  end  pos  start  [CONTEXT]  public  String  chompBalanced  (  char  open  ,  char  close  )  {  int  start  =  -1  ;  int  end  =  -1  ;  int  depth  =  0  ;  char  last  =  0  ;  [BUGGY]  do  {  if  (  isEmpty  (  )  )  break  ;  Character  c  =  consume  (  )  ;  if  (  last  =  =  0  ||  last  !  =  ESC  )  {  if  (  c  .  equals  (  open  )  )  {  depth++  ;  if  (  start  =  =  -1  )  start  =  pos  ;  }  else  if  (  c  .  equals  (  close  )  )  depth--  ;  }  if  (  depth  >  0  &&  last  !  =  0  )  end  =  pos  ;  //  don't  include  the  outer  match  pair  in  the  return  last  =  c  ;  }  while  (  depth  >  0  )  ;  return  (  end  >  =  0  )  ?  queue  .  substring  (  start  ,  end  )  :   " "  ;  }  	Jsoup_53_TokenQueue_2_1	265	0	src/main/java/org/jsoup/parser/TokenQueue.java
1615	if  (c.equals(\'\\\'\')  ||  c.equals(\' "\')  &&  c  !=  open)  inQuote  =  !inQuote;  if  (inQuote)  continue;  	[BUGGY]  [FE]  selectSelector$SelectorParseException:  Could  not  parse  query  'div[data  =  'End]'':  unexpected  token  at  '''  assertEquals  (   "Two "  ,  doc  .  select  (   "div[data  =  '[Another  )  ]]' "  )  .  first  (  )  .  text  (  )  )  ;  [METHOD]  chompBalanced  [TYPE]  String  [PARAMETER]  char  open  char  close  [CLASS]  TokenQueue  [TYPE]  char  ESC  close  last  open  [TYPE]  String  queue  [TYPE]  boolean  false  true  [TYPE]  Character  c  [TYPE]  int  depth  end  pos  start  [CONTEXT]  public  String  chompBalanced  (  char  open  ,  char  close  )  {  int  start  =  -1  ;  int  end  =  -1  ;  int  depth  =  0  ;  char  last  =  0  ;  do  {  if  (  isEmpty  (  )  )  break  ;  Character  c  =  consume  (  )  ;  if  (  last  =  =  0  ||  last  !  =  ESC  )  {  [BUGGY]  if  (  c  .  equals  (  open  )  )  {  depth++  ;  if  (  start  =  =  -1  )  start  =  pos  ;  }  else  if  (  c  .  equals  (  close  )  )  depth--  ;  }  if  (  depth  >  0  &&  last  !  =  0  )  end  =  pos  ;  //  don't  include  the  outer  match  pair  in  the  return  last  =  c  ;  }  while  (  depth  >  0  )  ;  return  (  end  >  =  0  )  ?  queue  .  substring  (  start  ,  end  )  :   " "  ;  }  	Jsoup_53_TokenQueue_2_2	270	0	src/main/java/org/jsoup/parser/TokenQueue.java
1616	if  (key.matches( "[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]* "))  	[BUGGY]  [FE]  domDOMException:  INVALID_CHARACTER_ERR:  An  invalid  or  illegal  XML  character  is  specified  assertTrue  (  body  .  hasAttr  (   "name\ " "  )  )  ;  [METHOD]  copyAttributes  [TYPE]  void  [PARAMETER]  Node  source  Element  el  [CLASS]  W3CBuilder  [TYPE]  boolean  false  true  [TYPE]  HashMap  namespaces  [TYPE]  Attribute  attribute  [TYPE]  Element  dest  el  [TYPE]  Node  source  [TYPE]  String  key  xmlnsKey  xmlnsPrefix  [TYPE]  Document  doc  [CONTEXT]  private  void  copyAttributes  (  org  .  jsoup  .  nodes  .  Node  source  ,  Element  el  )  {  for  (  Attribute  attribute  :  source  .  attributes  (  )  )  {  String  key  =  attribute  .  getKey  (  )  .  replaceAll  (   "[^-a-zA-Z0-9_:  .  ] "  ,   " "  )  ;  [BUGGY]  el  .  setAttribute  (  key  ,  attribute  .  getValue  (  )  )  ;  }  }  	Jsoup_54_W3CDom_1_1	126	0	src/main/java/org/jsoup/helper/W3CDom.java
1617	r.unconsume();  	[BUGGY]  [FE]  AssertionFailedError:  SelfClosingStartTag  ignores  last  character  assertEquals  (   "<img  onerror  =  \ "doMyJob\ "  /> "  ,  doc  .  html  (  )  )  ;  [METHOD]  read  [TYPE]  void  [PARAMETER]  Tokeniser  t  CharacterReader  r  [CLASS]  42  [TYPE]  CharacterReader  r  [TYPE]  boolean  false  true  [TYPE]  char  c  [TYPE]  Tokeniser  t  [CONTEXT]  void  read  (  Tokeniser  t  ,  CharacterReader  r  )  {  char  c  =  r  .  consume  (  )  ;  switch  (  c  )  {  case  '>':  t  .  tagPending  .  selfClosing  =  true  ;  t  .  emitTagPending  (  )  ;  t  .  transition  (  Data  )  ;  break  ;  case  eof:  t  .  eofError  (  this  )  ;  t  .  transition  (  Data  )  ;  break  ;  default:  t  .  error  (  this  )  ;  [BUGGY]  t  .  transition  (  BeforeAttributeName  )  ;  }  }  	Jsoup_55_TokeniserState_1_1	883	0	src/main/java/org/jsoup/parser/TokeniserState.java
1618	private  static  final  String  PUB_SYS_KEY  =   "pubSysKey ";    	[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_56_DocumentType_4_1	15	0	src/main/java/org/jsoup/nodes/DocumentType.java
1619	if  (has(PUBLIC_ID))  {  attr(PUB_SYS_KEY,  PUBLIC_KEY);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_56_DocumentType_4_2	31	0	src/main/java/org/jsoup/nodes/DocumentType.java
1620	public  DocumentType(String  name,  String  pubSysKey,  String  publicId,  String  systemId,  String  baseUri)  {  super(baseUri);  attr(NAME,  name);  if  (pubSysKey  !=  null)  {  attr(PUB_SYS_KEY,  pubSysKey);  }  attr(PUBLIC_ID,  publicId);  attr(SYSTEM_ID,  systemId);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_56_DocumentType_4_3	41	0	src/main/java/org/jsoup/nodes/DocumentType.java
1621	if  (has(PUB_SYS_KEY))  accum.append( "   ").append(attr(PUB_SYS_KEY));  accum.append( "  \\ " ").append(attr(PUBLIC_ID)).append(\' "\');  	[BUGGY]  accum  .  append  (   "  PUBLIC  \\ " "  )  .  append  (  attr  (  PUBLIC_ID  )  )  .  append  (  \' "\'  )  ;  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [METHOD]  outerHtmlHead  [TYPE]  void  [PARAMETER]  Appendable  accum  int  depth  OutputSettings  out  [CLASS]  DocumentType  [TYPE]  String  NAME  PUBLIC_ID  PUBLIC_KEY  SYSTEM_ID  SYSTEM_KEY  [TYPE]  boolean  false  true  [TYPE]  OutputSettings  out  [TYPE]  int  depth  [TYPE]  Appendable  accum  [CONTEXT]  void  outerHtmlHead  (  Appendable  accum  ,  int  depth  ,  Document  .  OutputSettings  out  )  throws  IOException  {  if  (  out  .  syntax  (  )  =  =  Syntax  .  html  &&  !has  (  PUBLIC_ID  )  &&  !has  (  SYSTEM_ID  )  )  {  accum  .  append  (   "<!doctype "  )  ;  }  else  {  accum  .  append  (   "<!DOCTYPE "  )  ;  }  if  (  has  (  NAME  )  )  accum  .  append  (   "   "  )  .  append  (  attr  (  NAME  )  )  ;  [BUGGY]  if  (  has  (  PUBLIC_ID  )  )  accum  .  append  (   "  PUBLIC  \ " "  )  .  append  (  attr  (  PUBLIC_ID  )  )  .  append  (  ' "'  )  ;  if  (  has  (  SYSTEM_ID  )  )  accum  .  append  (   "  \ " "  )  .  append  (  attr  (  SYSTEM_ID  )  )  .  append  (  ' "'  )  ;  accum  .  append  (  '>'  )  ;  }  	Jsoup_56_DocumentType_4_4	58	1	src/main/java/org/jsoup/nodes/DocumentType.java
1622	tb.settings.normalizeTag(d.getName()),  d.getPubSysKey(),  d.getPublicIdentifier(),  d.getSystemIdentifier(),  tb.getBaseUri());  	[BUGGY]  tb  .  settings  .  normalizeTag  (  d  .  getName  (  )  )  ,  d  .  getPublicIdentifier  (  )  ,  d  .  getSystemIdentifier  (  )  ,  tb  .  getBaseUri  (  )  )  ;  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  1  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Doctype  d  [TYPE]  DocumentType  doctype  [TYPE]  Token  t  [CONTEXT]  boolean  process  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  if  (  isWhitespace  (  t  )  )  {  return  true  ;  //  ignore  whitespace  }  else  if  (  t  .  isComment  (  )  )  {  tb  .  insert  (  t  .  asComment  (  )  )  ;  }  else  if  (  t  .  isDoctype  (  )  )  {    Token  .  Doctype  d  =  t  .  asDoctype  (  )  ;  DocumentType  doctype  =  new  DocumentType  (  [BUGGY]  tb  .  settings  .  normalizeTag  (  d  .  getName  (  )  )  ,  d  .  getPublicIdentifier  (  )  ,  d  .  getSystemIdentifier  (  )  ,  tb  .  getBaseUri  (  )  )  ;  tb  .  getDocument  (  )  .  appendChild  (  doctype  )  ;  if  (  d  .  isForceQuirks  (  )  )  tb  .  getDocument  (  )  .  quirksMode  (  Document  .  QuirksMode  .  quirks  )  ;  tb  .  transition  (  BeforeHtml  )  ;  }  else  {  tb  .  transition  (  BeforeHtml  )  ;  return  tb  .  process  (  t  )  ;  //  re-process  token  }  return  true  ;  }  	Jsoup_56_HtmlTreeBuilderState_1_1	23	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1623	String  pubSysKey  =  null;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_56_Token_3_1	35	0	src/main/java/org/jsoup/parser/Token.java
1624	pubSysKey  =  null;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [METHOD]  reset  [TYPE]  Token  [PARAMETER]  [CLASS]  Doctype  [TYPE]  StringBuilder  name  publicIdentifier  systemIdentifier  [TYPE]  boolean  false  forceQuirks  true  [CONTEXT]  Token  reset  (  )  {  reset  (  name  )  ;  [BUGGY]  reset  (  publicIdentifier  )  ;  reset  (  systemIdentifier  )  ;  forceQuirks  =  false  ;  return  this  ;  }  	Jsoup_56_Token_3_2	46	0	src/main/java/org/jsoup/parser/Token.java
1625	String  getPubSysKey()  {  return  pubSysKey;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_56_Token_3_3	56	0	src/main/java/org/jsoup/parser/Token.java
1626	t.doctypePending.pubSysKey  =  DocumentType.PUBLIC_KEY;  t.doctypePending.pubSysKey  =  DocumentType.SYSTEM_KEY;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [METHOD]  read  [TYPE]  void  [PARAMETER]  Tokeniser  t  CharacterReader  r  [CLASS]  54  [TYPE]  CharacterReader  r  [TYPE]  boolean  false  true  [TYPE]  Tokeniser  t  [CONTEXT]  void  read  (  Tokeniser  t  ,  CharacterReader  r  )  {  if  (  r  .  isEmpty  (  )  )  {  t  .  eofError  (  this  )  ;  t  .  doctypePending  .  forceQuirks  =  true  ;  t  .  emitDoctypePending  (  )  ;  t  .  transition  (  Data  )  ;  return  ;  }  if  (  r  .  matchesAny  (  '\t'  ,  '\n'  ,  '\r'  ,  '\f'  ,  '  '  )  )  r  .  advance  (  )  ;  //  ignore  whitespace  else  if  (  r  .  matches  (  '>'  )  )  {  t  .  emitDoctypePending  (  )  ;  t  .  advanceTransition  (  Data  )  ;  }  else  if  (  r  .  matchConsumeIgnoreCase  (  DocumentType  .  PUBLIC_KEY  )  )  {  [BUGGY]  t  .  transition  (  AfterDoctypePublicKeyword  )  ;  }  else  if  (  r  .  matchConsumeIgnoreCase  (  DocumentType  .  SYSTEM_KEY  )  )  {  t  .  transition  (  AfterDoctypeSystemKeyword  )  ;  }  else  {  t  .  error  (  this  )  ;  t  .  doctypePending  .  forceQuirks  =  true  ;  t  .  advanceTransition  (  BogusDoctype  )  ;  }  }  	Jsoup_56_TokeniserState_1_1	1195	0	src/main/java/org/jsoup/parser/TokeniserState.java
1627	DocumentType  doctypeNode  =  new  DocumentType(settings.normalizeTag(d.getName()),  d.getPubSysKey(),  d.getPublicIdentifier(),  d.getSystemIdentifier(),  baseUri);  	[BUGGY]  DocumentType  doctypeNode  =  new  DocumentType  (  settings  .  normalizeTag  (  d  .  getName  (  )  )  ,  d  .  getPublicIdentifier  (  )  ,  d  .  getSystemIdentifier  (  )  ,  baseUri  )  ;  [FE]  AssertionFailedError:  expected:<<!DOCTYPE  html  [SYSTEM  ] "exampledtdfiledtd ">  but  was:<<!DOCTYPE  html  [] "exampledtdfiledtd ">  assertEquals  (  legacyDoc  ,  xmlOutput  (  legacyDoc  )  )  ;  [METHOD]  insert  [TYPE]  void  [PARAMETER]  Doctype  d  [CLASS]  XmlTreeBuilder  [TYPE]  boolean  false  true  [TYPE]  Doctype  d  [TYPE]  DocumentType  doctypeNode  [CONTEXT]  void  insert  (  Token  .  Doctype  d  )  {  [BUGGY]  DocumentType  doctypeNode  =  new  DocumentType  (  settings  .  normalizeTag  (  d  .  getName  (  )  )  ,  d  .  getPublicIdentifier  (  )  ,  d  .  getSystemIdentifier  (  )  ,  baseUri  )  ;  insertNode  (  doctypeNode  )  ;  }  	Jsoup_56_XmlTreeBuilder_1_1	100	1	src/main/java/org/jsoup/parser/XmlTreeBuilder.java
1628	it.remove();  	[BUGGY]  attributes  .  remove  (  attrKey  )  ;  [FE]  ConcurrentModificationException  assertEquals  (   "<a>Text</a> "  ,  a  .  outerHtml  (  )  )  ;  [METHOD]  removeIgnoreCase  [TYPE]  void  [PARAMETER]  String  key  [CLASS]  Attributes  [TYPE]  Iterator  attrIter  it  [TYPE]  String  attrKey  dataPrefix  key  [TYPE]  boolean  false  true  [TYPE]  Attribute  attr  [TYPE]  LinkedHashMap  attributes  [CONTEXT]  public  void  removeIgnoreCase  (  String  key  )  {  Validate  .  notEmpty  (  key  )  ;  if  (  attributes  =  =  null  )  return  ;  for  (  Iterator<String>  it  =  attributes  .  keySet  (  )  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  {  String  attrKey  =  it  .  next  (  )  ;  if  (  attrKey  .  equalsIgnoreCase  (  key  )  )  [BUGGY]  attributes  .  remove  (  attrKey  )  ;  }  }  	Jsoup_57_Attributes_1_1	125	1	src/main/java/org/jsoup/nodes/Attributes.java
1629	return  new  Cleaner(whitelist).isValidBodyHtml(bodyHtml);  	[BUGGY]  return  new  Cleaner  (  whitelist  )  .  isValid  (  parseBodyFragment  (  bodyHtml  ,   " "  )  )  ;  [FE]  AssertionFailedError  assertFalse  (  Jsoup  .  isValid  (  nok7  ,  Whitelist  .  basic  (  )  )  )  ;  [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  String  bodyHtml  Whitelist  whitelist  [CLASS]  Jsoup  [TYPE]  boolean  false  true  [TYPE]  Whitelist  whitelist  [TYPE]  String  bodyHtml  [CONTEXT]  public  static  boolean  isValid  (  String  bodyHtml  ,  Whitelist  whitelist  )  {  [BUGGY]  return  new  Cleaner  (  whitelist  )  .  isValid  (  parseBodyFragment  (  bodyHtml  ,   " "  )  )  ;  }  	Jsoup_58_Jsoup_1_1	250	1	src/main/java/org/jsoup/Jsoup.java
1630	public  static  List<Node>  parseFragment(String  fragmentHtml,  Element  context,  String  baseUri,  ParseErrorList  errorList)  {  HtmlTreeBuilder  treeBuilder  =  new  HtmlTreeBuilder();  return  treeBuilder.parseFragment(fragmentHtml,  context,  baseUri,  errorList,  treeBuilder.defaultSettings());  }  	[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  Jsoup  .  isValid  (  nok7  ,  Whitelist  .  basic  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_58_Parser_1_1	129	0	src/main/java/org/jsoup/parser/Parser.java
1631		[BUGGY]  [FE]  AssertionFailedError  assertFalse  (  Jsoup  .  isValid  (  nok7  ,  Whitelist  .  basic  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_58_Cleaner_2_1	17	0	src/main/java/org/jsoup/safety/Cleaner.java
1632	return  numDiscarded  ==  0\n',   "+                        &&  dirtyDocument.head().childNodes().size()  ==  0;    public  boolean  isValidBodyHtml(String  bodyHtml)  {  Document  clean  =  Document.createShell( " ");  Document  dirty  =  Document.createShell( " ");  ParseErrorList  errorList  =  ParseErrorList.tracking(1);  List<Node>  nodes  =  Parser.parseFragment(bodyHtml,  dirty.body(),   " ",  errorList);  dirty.body().insertChildren(0,  nodes);  int  numDiscarded  =  copySafeNodes(dirty.body(),  clean.body());  return  numDiscarded  ==  0  &&  errorList.size()  ==  0;  }  	[BUGGY]  return  numDiscarded  =  =  0  ;  [FE]  AssertionFailedError  assertFalse  (  Jsoup  .  isValid  (  nok7  ,  Whitelist  .  basic  (  )  )  )  ;  [METHOD]  isValid  [TYPE]  boolean  [PARAMETER]  Document  dirtyDocument  [CLASS]  Cleaner  [TYPE]  Whitelist  whitelist  [TYPE]  boolean  false  true  [TYPE]  Document  clean  dirtyDocument  [TYPE]  int  numAttribsDiscarded  numDiscarded  [TYPE]  Element  destination  el  root  [CONTEXT]  public  boolean  isValid  (  Document  dirtyDocument  )  {  Validate  .  notNull  (  dirtyDocument  )  ;  Document  clean  =  Document  .  createShell  (  dirtyDocument  .  baseUri  (  )  )  ;  int  numDiscarded  =  copySafeNodes  (  dirtyDocument  .  body  (  )  ,  clean  .  body  (  )  )  ;  [BUGGY]  return  numDiscarded  =  =  0  ;  }  	Jsoup_58_Cleaner_2_2	78	1	src/main/java/org/jsoup/safety/Cleaner.java
1633	if  (pendingAttributeName.length()  >  0)  {  	[BUGGY]  [FE]  IllegalArgumentException:  String  must  not  be  empty  assertEquals  (   "<p><a>One</a><a></a><a  foo  =  \ "bar\ ">Two</a></p> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  newAttribute  [TYPE]  void  [PARAMETER]  [CLASS]  Tag  [TYPE]  Attributes  attributes  [TYPE]  boolean  false  hasEmptyAttributeValue  hasPendingAttributeValue  selfClosing  true  [TYPE]  String  normalName  pendingAttributeName  pendingAttributeValueS  tagName  [TYPE]  StringBuilder  pendingAttributeValue  [TYPE]  Attribute  attribute  [CONTEXT]  final  void  newAttribute  (  )  {  if  (  attributes  =  =  null  )  attributes  =  new  Attributes  (  )  ;  if  (  pendingAttributeName  !  =  null  )  {  pendingAttributeName  =  pendingAttributeName  .  trim  (  )  ;  [BUGGY]  Attribute  attribute  ;  if  (  hasPendingAttributeValue  )  attribute  =  new  Attribute  (  pendingAttributeName  ,  pendingAttributeValue  .  length  (  )  >  0  ?  pendingAttributeValue  .  toString  (  )  :  pendingAttributeValueS  )  ;  else  if  (  hasEmptyAttributeValue  )  attribute  =  new  Attribute  (  pendingAttributeName  ,   " "  )  ;  else  attribute  =  new  BooleanAttribute  (  pendingAttributeName  )  ;  attributes  .  put  (  attribute  )  ;  }  pendingAttributeName  =  null  ;  hasEmptyAttributeValue  =  false  ;  hasPendingAttributeValue  =  false  ;  reset  (  pendingAttributeValue  )  ;  pendingAttributeValueS  =  null  ;  }  	Jsoup_59_Token_2_1	107	0	src/main/java/org/jsoup/parser/Token.java
1634	}  	[BUGGY]  [FE]  IllegalArgumentException:  String  must  not  be  empty  assertEquals  (   "<p><a>One</a><a></a><a  foo  =  \ "bar\ ">Two</a></p> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  newAttribute  [TYPE]  void  [PARAMETER]  [CLASS]  Tag  [TYPE]  Attributes  attributes  [TYPE]  boolean  false  hasEmptyAttributeValue  hasPendingAttributeValue  selfClosing  true  [TYPE]  String  normalName  pendingAttributeName  pendingAttributeValueS  tagName  [TYPE]  StringBuilder  pendingAttributeValue  [TYPE]  Attribute  attribute  [CONTEXT]  final  void  newAttribute  (  )  {  if  (  attributes  =  =  null  )  attributes  =  new  Attributes  (  )  ;  if  (  pendingAttributeName  !  =  null  )  {  pendingAttributeName  =  pendingAttributeName  .  trim  (  )  ;  Attribute  attribute  ;  if  (  hasPendingAttributeValue  )  attribute  =  new  Attribute  (  pendingAttributeName  ,  pendingAttributeValue  .  length  (  )  >  0  ?  pendingAttributeValue  .  toString  (  )  :  pendingAttributeValueS  )  ;  else  if  (  hasEmptyAttributeValue  )  attribute  =  new  Attribute  (  pendingAttributeName  ,   " "  )  ;  else  attribute  =  new  BooleanAttribute  (  pendingAttributeName  )  ;  attributes  .  put  (  attribute  )  ;  [BUGGY]  }  pendingAttributeName  =  null  ;  hasEmptyAttributeValue  =  false  ;  hasPendingAttributeValue  =  false  ;  reset  (  pendingAttributeValue  )  ;  pendingAttributeValueS  =  null  ;  }  	Jsoup_59_Token_2_2	116	0	src/main/java/org/jsoup/parser/Token.java
1635	if  (depth  >  0)  {  Validate.fail( "Did  not  find  balanced  maker  at   "  +  out);  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exception:  orgjsoupselectSelector$SelectorParseException  [METHOD]  chompBalanced  [TYPE]  String  [PARAMETER]  char  open  char  close  [CLASS]  TokenQueue  [TYPE]  char  ESC  close  last  open  [TYPE]  String  out  queue  [TYPE]  boolean  false  inQuote  true  [TYPE]  Character  c  [TYPE]  int  depth  end  pos  start  [CONTEXT]  char  last  =  0  ;  boolean  inQuote  =  false  ;  do  {  if  (  isEmpty  (  )  )  break  ;  Character  c  =  consume  (  )  ;  if  (  last  =  =  0  ||  last  !  =  ESC  )  {  if  (  (  c  .  equals  (  '\''  )  ||  c  .  equals  (  ' "'  )  )  &&  c  !  =  open  )  inQuote  =  !inQuote  ;  if  (  inQuote  )  continue  ;  if  (  c  .  equals  (  open  )  )  {  depth++  ;  if  (  start  =  =  -1  )  start  =  pos  ;  }  else  if  (  c  .  equals  (  close  )  )  depth--  ;  }  if  (  depth  >  0  &&  last  !  =  0  )  end  =  pos  ;  //  don't  include  the  outer  match  pair  in  the  return  last  =  c  ;  }  while  (  depth  >  0  )  ;  final  String  out  =  (  end  >  =  0  )  ?  queue  .  substring  (  start  ,  end  )  :   " "  ;  [BUGGY]  return  out  ;  }    	Jsoup_60_TokenQueue_1_1	289	0	src/main/java/org/jsoup/parser/TokenQueue.java
1636	try  {  }  catch  (IllegalArgumentException  e)  {  throw  new  Selector.SelectorParseException(e.getMessage());  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected  exception:  orgjsoupselectSelector$SelectorParseException  [METHOD]  parse  [TYPE]  Evaluator  [PARAMETER]  String  query  [CLASS]  QueryParser  [TYPE]  TokenQueue  tq  [TYPE]  Pattern  NTH_AB  NTH_B  [TYPE]  QueryParser  p  [TYPE]  boolean  false  true  [TYPE]  List  evals  [TYPE]  String[]  AttributeEvals  combinators  [TYPE]  String  query  [CONTEXT]  public  static  Evaluator  parse  (  String  query  )  {  [BUGGY]  QueryParser  p  =  new  QueryParser  (  query  )  ;  return  p  .  parse  (  )  ;  }  	Jsoup_60_QueryParser_1_1	38	0	src/main/java/org/jsoup/select/QueryParser.java
1637	final  String  classAttr  =  attributes.getIgnoreCase( "class ");  	[BUGGY]  final  String  classAttr  =  attributes  .  get  (   "class "  )  ;  [FE]  AssertionFailedError  assertTrue  (  thr  .  hasClass  (   "three "  )  )  ;  [METHOD]  hasClass  [TYPE]  boolean  [PARAMETER]  String  className  [CLASS]  Element  [TYPE]  Pattern  classSplit  [TYPE]  Tag  tag  [TYPE]  String  classAttr  className  [TYPE]  boolean  false  inClass  true  [TYPE]  int  i  len  start  wantLen  [CONTEXT]  public  boolean  hasClass  (  String  className  )  {  [BUGGY]  final  String  classAttr  =  attributes  .  get  (   "class "  )  ;  final  int  len  =  classAttr  .  length  (  )  ;  final  int  wantLen  =  className  .  length  (  )  ;  if  (  len  =  =  0  ||  len  <  wantLen  )  {  return  false  ;  	Jsoup_61_Element_1_1	1092	1	src/main/java/org/jsoup/nodes/Element.java
1638	String  name  =  t.asEndTag().name();    	[BUGGY]  String  name  =  t  .  asEndTag  (  )  .  normalName  (  )  ;  [FE]  AssertionFailedError:  expected:<<r>  <X>  A  <[/X>  <y>  B  </y]>  </r>>  but  was:<<r>  <X>  A  <[y>  B  </y>  </X]>  </r>>  assertEquals  (   "<r>  <X>  A  </X>  <y>  B  </y>  </r> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  anyOtherEndTag  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Element  node  [TYPE]  ArrayList  stack  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  int  pos  [CONTEXT]  boolean  anyOtherEndTag  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  [BUGGY]  String  name  =  t  .  asEndTag  (  )  .  normalName  (  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  node  =  stack  .  get  (  pos  )  ;  if  (  node  .  nodeName  (  )  .  equals  (  name  )  )  {  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !name  .  equals  (  tb  .  currentElement  (  )  .  nodeName  (  )  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  break  ;  }  else  {  if  (  tb  .  isSpecial  (  node  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  }  }  return  true  ;  }  	Jsoup_62_HtmlTreeBuilderState_1_1	764	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1639	if  (!tag.isEmpty())  tokeniser.error( "Tag  cannot  be  self  closing;  not  a  void  tag ");  else    	[BUGGY]  if  (  tag  .  isSelfClosing  (  )  )  tokeniser  .  acknowledgeSelfClosingFlag  (  )  ;  else  {  tokeniser  .  acknowledgeSelfClosingFlag  (  )  ;  }  [FE]  AssertionFailedError:  expected:<18:  [Tag  cannot  be  self  closing  ;  not  a  void  tag]>  but  was:<18:  [Self  closing  flag  not  acknowledged]>  assertEquals  (   "<p>test</p>  <div></div>  <div>  Two  </div> "  ,  StringUtil  .  normaliseWhitespace  (  clean  )  )  ;  [METHOD]  insertEmpty  [TYPE]  Element  [PARAMETER]  StartTag  startTag  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  el  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  Tag  tag  [TYPE]  FormElement  formElement  [TYPE]  StartTag  startTag  [CONTEXT]  Element  insertEmpty  (  Token  .  StartTag  startTag  )  {  Tag  tag  =  Tag  .  valueOf  (  startTag  .  name  (  )  ,  settings  )  ;  Element  el  =  new  Element  (  tag  ,  baseUri  ,  startTag  .  attributes  )  ;  insertNode  (  el  )  ;  if  (  startTag  .  isSelfClosing  (  )  )  {  if  (  tag  .  isKnownTag  (  )  )  {  [BUGGY]  if  (  tag  .  isSelfClosing  (  )  )  tokeniser  .  acknowledgeSelfClosingFlag  (  )  ;  }  else  {  tag  .  setSelfClosing  (  )  ;  tokeniser  .  acknowledgeSelfClosingFlag  (  )  ;  }  }  return  el  ;  }  	Jsoup_63_HtmlTreeBuilder_1_1	227	4	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1640		[BUGGY]  private  boolean  selfClosingFlagAcknowledged  =  true  ;  [FE]  AssertionFailedError:  expected:<18:  [Tag  cannot  be  self  closing  ;  not  a  void  tag]>  but  was:<18:  [Self  closing  flag  not  acknowledged]>  assertEquals  (   "<p>test</p>  <div></div>  <div>  Two  </div> "  ,  StringUtil  .  normaliseWhitespace  (  clean  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_63_Tokeniser_4_1	36	1	src/main/java/org/jsoup/parser/Tokeniser.java
1641		[BUGGY]  if  (  !selfClosingFlagAcknowledged  )  {  error  (   "Self  closing  flag  not  acknowledged "  )  ;  selfClosingFlagAcknowledged  =  true  ;  }  [FE]  AssertionFailedError:  expected:<18:  [Tag  cannot  be  self  closing  ;  not  a  void  tag]>  but  was:<18:  [Self  closing  flag  not  acknowledged]>  assertEquals  (   "<p>test</p>  <div></div>  <div>  Two  </div> "  ,  StringUtil  .  normaliseWhitespace  (  clean  )  )  ;  [METHOD]  read  [TYPE]  Token  [PARAMETER]  [CLASS]  Tokeniser  [TYPE]  Comment  commentPending  [TYPE]  StringBuilder  charsBuilder  dataBuffer  [TYPE]  EndTag  endPending  [TYPE]  Character  charPending  [TYPE]  Doctype  doctypePending  [TYPE]  Token  emitPending  token  [TYPE]  int[]  codepointHolder  multipointHolder  [TYPE]  ParseErrorList  errors  [TYPE]  String  charsString  lastStartTag  str  [TYPE]  StartTag  startPending  [TYPE]  char[]  notCharRefCharsSorted  [TYPE]  CharacterReader  reader  [TYPE]  boolean  false  isEmitPending  selfClosingFlagAcknowledged  true  [TYPE]  char  replacementChar  [TYPE]  Tag  tagPending  [TYPE]  TokeniserState  state  [CONTEXT]  Token  read  (  )  {  [BUGGY]  if  (  !selfClosingFlagAcknowledged  )  {  error  (   "Self  closing  flag  not  acknowledged "  )  ;  selfClosingFlagAcknowledged  =  true  ;  }  while  (  !isEmitPending  )  state  .  read  (  this  ,  reader  )  ;    if  (  charsBuilder  .  length  (  )  >  0  )  {  String  str  =  charsBuilder  .  toString  (  )  ;  charsBuilder  .  delete  (  0  ,  charsBuilder  .  length  (  )  )  ;  charsString  =  null  ;  return  charPending  .  data  (  str  )  ;  }  else  if  (  charsString  !  =  null  )  {  Token  token  =  charPending  .  data  (  charsString  )  ;  charsString  =  null  ;  return  token  ;  }  else  {  isEmitPending  =  false  ;  return  emitPending  ;  }  }  	Jsoup_63_Tokeniser_4_2	44	4	src/main/java/org/jsoup/parser/Tokeniser.java
1642		[BUGGY]  if  (  startTag  .  selfClosing  )  selfClosingFlagAcknowledged  =  false  ;  [FE]  AssertionFailedError:  expected:<18:  [Tag  cannot  be  self  closing  ;  not  a  void  tag]>  but  was:<18:  [Self  closing  flag  not  acknowledged]>  assertEquals  (   "<p>test</p>  <div></div>  <div>  Two  </div> "  ,  StringUtil  .  normaliseWhitespace  (  clean  )  )  ;  [METHOD]  emit  [TYPE]  void  [PARAMETER]  Token  token  [CLASS]  Tokeniser  [TYPE]  Comment  commentPending  [TYPE]  StringBuilder  charsBuilder  dataBuffer  [TYPE]  EndTag  endPending  endTag  [TYPE]  Character  charPending  [TYPE]  Doctype  doctypePending  [TYPE]  Token  emitPending  token  [TYPE]  int[]  codepointHolder  multipointHolder  [TYPE]  ParseErrorList  errors  [TYPE]  String  charsString  lastStartTag  [TYPE]  StartTag  startPending  startTag  [TYPE]  char[]  notCharRefCharsSorted  [TYPE]  CharacterReader  reader  [TYPE]  boolean  false  isEmitPending  selfClosingFlagAcknowledged  true  [TYPE]  char  replacementChar  [TYPE]  Tag  tagPending  [TYPE]  TokeniserState  state  [CONTEXT]  void  emit  (  Token  token  )  {  Validate  .  isFalse  (  isEmitPending  ,   "There  is  an  unread  token  pending! "  )  ;  emitPending  =  token  ;  isEmitPending  =  true  ;  if  (  token  .  type  =  =  Token  .  TokenType  .  StartTag  )  {  Token  .  StartTag  startTag  =  (  Token  .  StartTag  )  token  ;  lastStartTag  =  startTag  .  tagName  ;  [BUGGY]  if  (  startTag  .  selfClosing  )  selfClosingFlagAcknowledged  =  false  ;  }  else  if  (  token  .  type  =  =  Token  .  TokenType  .  EndTag  )  {  Token  .  EndTag  endTag  =  (  Token  .  EndTag  )  token  ;  if  (  endTag  .  attributes  !  =  null  )  error  (   "Attributes  incorrectly  present  on  end  tag "  )  ;  }  }  	Jsoup_63_Tokeniser_4_3	76	2	src/main/java/org/jsoup/parser/Tokeniser.java
1643		[BUGGY]  void  acknowledgeSelfClosingFlag  (  )  {  selfClosingFlagAcknowledged  =  true  ;  }  [FE]  AssertionFailedError:  expected:<18:  [Tag  cannot  be  self  closing  ;  not  a  void  tag]>  but  was:<18:  [Self  closing  flag  not  acknowledged]>  assertEquals  (   "<p>test</p>  <div></div>  <div>  Two  </div> "  ,  StringUtil  .  normaliseWhitespace  (  clean  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_63_Tokeniser_4_4	124	3	src/main/java/org/jsoup/parser/Tokeniser.java
1644		[BUGGY]  tb  .  insert  (  startTag  )  ;  [FE]  AssertionFailedError:  expected:<ead><style></style><[meta  name  =   "foo "></head><body>One]</body></html>>  but  was:<ead><style></style><[/head><body>&lt  ;  meta  name  =  foo&gt  ;  &lt  ;  /head&gt  ;  &lt  ;  body&gt  ;  One&lt  ;  /body&gt  ;  &lt  ;  /html&gt  ;  ]</body></html>>  assertEquals  (   "<html><head><style></style><meta  name  =  \ "foo\ "></head><body>One</body></html> "  ,  TextUtil  .  stripNewlines  (  doc  .  html  (  )  )  )  ;  [METHOD]  handleRawtext  [TYPE]  void  [PARAMETER]  StartTag  startTag  HtmlTreeBuilder  tb  [CLASS]  HtmlTreeBuilderState  [TYPE]  HtmlTreeBuilderState  AfterAfterBody  AfterAfterFrameset  AfterBody  AfterFrameset  AfterHead  BeforeHead  BeforeHtml  ForeignContent  InBody  InCaption  InCell  InColumnGroup  InFrameset  InHead  InHeadNoscript  InRow  InSelect  InSelectInTable  InTable  InTableBody  InTableText  Initial  Text  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  String  nullString  [TYPE]  String[]  DdDt  Formatters  Headings  InBodyEndAdoptionFormatters  InBodyEndClosers  InBodyEndTableFosters  InBodyStartApplets  InBodyStartDrop  InBodyStartEmptyFormatters  InBodyStartInputAttribs  InBodyStartLiBreakers  InBodyStartMedia  InBodyStartOptions  InBodyStartPClosers  InBodyStartPreListing  InBodyStartRuby  InBodyStartToHead  [TYPE]  boolean  false  true  [TYPE]  StartTag  startTag  [CONTEXT]  private  static  void  handleRawtext  (  Token  .  StartTag  startTag  ,  HtmlTreeBuilder  tb  )  {  [BUGGY]  tb  .  insert  (  startTag  )  ;  tb  .  tokeniser  .  transition  (  TokeniserState  .  Rawtext  )  ;  tb  .  markInsertionMode  (  )  ;  tb  .  transition  (  Text  )  ;  }  	Jsoup_64_HtmlTreeBuilderState_2_1	1489	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1645	tb.insert(startTag);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<ead><style></style><[meta  name  =   "foo "></head><body>One]</body></html>>  but  was:<ead><style></style><[/head><body>&lt  ;  meta  name  =  foo&gt  ;  &lt  ;  /head&gt  ;  &lt  ;  body&gt  ;  One&lt  ;  /body&gt  ;  &lt  ;  /html&gt  ;  ]</body></html>>  assertEquals  (   "<html><head><style></style><meta  name  =  \ "foo\ "></head><body>One</body></html> "  ,  TextUtil  .  stripNewlines  (  doc  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_64_HtmlTreeBuilderState_2_2	1493	0	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1646	clearStackToContext( "tbody ",   "tfoot ",   "thead ",   "template ");  	[BUGGY]  clearStackToContext  (   "tbody "  ,   "tfoot "  ,   "thead "  )  ;  [FE]  AssertionFailedError  assertTrue  (  template  .  childNodes  (  )  .  size  (  )  >  1  )  ;  [METHOD]  clearStackToTableBodyContext  [TYPE]  void  [PARAMETER]  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  FormElement  formElement  [CONTEXT]  void  clearStackToTableBodyContext  (  )  {  [BUGGY]  clearStackToContext  (   "tbody "  ,   "tfoot "  ,   "thead "  )  ;  }  	Jsoup_65_HtmlTreeBuilder_2_1	360	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1647	clearStackToContext( "tr ",   "template ");  	[BUGGY]  clearStackToContext  (   "tr "  )  ;  [FE]  AssertionFailedError  assertTrue  (  template  .  childNodes  (  )  .  size  (  )  >  1  )  ;  [METHOD]  clearStackToTableRowContext  [TYPE]  void  [PARAMETER]  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  FormElement  formElement  [CONTEXT]  void  clearStackToTableRowContext  (  )  {  [BUGGY]  clearStackToContext  (   "tr "  )  ;  }  	Jsoup_65_HtmlTreeBuilder_2_2	364	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1648	if  (name.equals( "template "))  {  tb.insert(startTag);  }  else  if  (name.equals( "tr "))  {  	[BUGGY]  if  (  name  .  equals  (   "tr "  )  )  {  [FE]  AssertionFailedError  assertTrue  (  template  .  childNodes  (  )  .  size  (  )  >  1  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  13  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  EndTag  endTag  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  StartTag  startTag  [CONTEXT]  boolean  process  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  switch  (  t  .  type  )  {  case  StartTag:  Token  .  StartTag  startTag  =  t  .  asStartTag  (  )  ;  String  name  =  startTag  .  normalName  (  )  ;  [BUGGY]  if  (  name  .  equals  (   "tr "  )  )  {  tb  .  clearStackToTableBodyContext  (  )  ;  tb  .  insert  (  startTag  )  ;  tb  .  transition  (  InRow  )  ;  }  else  if  (  StringUtil  .  in  (  name  ,   "th "  ,   "td "  )  )  {  tb  .  error  (  this  )  ;  	Jsoup_65_HtmlTreeBuilderState_2_1	1036	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1649	if  (name.equals( "template "))  {  tb.insert(startTag);  }  else  if  (StringUtil.in(name,   "th ",   "td "))  {  	[BUGGY]  if  (  StringUtil  .  in  (  name  ,   "th "  ,   "td "  )  )  {  [FE]  AssertionFailedError  assertTrue  (  template  .  childNodes  (  )  .  size  (  )  >  1  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  14  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  EndTag  endTag  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  StartTag  startTag  [CONTEXT]  boolean  process  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  if  (  t  .  isStartTag  (  )  )  {  Token  .  StartTag  startTag  =  t  .  asStartTag  (  )  ;  String  name  =  startTag  .  normalName  (  )  ;  [BUGGY]  if  (  StringUtil  .  in  (  name  ,   "th "  ,   "td "  )  )  {  tb  .  clearStackToTableRowContext  (  )  ;  tb  .  insert  (  startTag  )  ;  tb  .  transition  (  InCell  )  ;  tb  .  insertMarkerToFormattingElements  (  )  ;  }  else  if  (  StringUtil  .  in  (  name  ,   "caption "  ,   "col "  ,   "colgroup "  ,   "tbody "  ,   "tfoot "  ,   "thead "  ,   "tr "  )  )  {  	Jsoup_65_HtmlTreeBuilderState_2_2	1096	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1650	childNodes  =  new  NodeList(this,  4);  	[BUGGY]  childNodes  =  new  NodeList  (  4  )  ;  [FE]  NullPointerException  assertEquals  (  cloneExpect  ,  cloneNextSibling  .  text  (  )  )  ;  [METHOD]  ensureChildNodes  [TYPE]  List  [PARAMETER]  [CLASS]  Element  [TYPE]  Pattern  classSplit  [TYPE]  boolean  false  true  [TYPE]  WeakReference  shadowChildrenRef  [TYPE]  Attributes  attributes  [TYPE]  List  EMPTY_NODES  childNodes  [TYPE]  Tag  tag  [TYPE]  String  baseUri  [CONTEXT]  protected  List<Node>  ensureChildNodes  (  )  {  if  (  childNodes  =  =  EMPTY_NODES  )  {  [BUGGY]  childNodes  =  new  NodeList  (  4  )  ;  }  return  childNodes  ;  }  	Jsoup_66_Element_4_1	89	1	src/main/java/org/jsoup/nodes/Element.java
1651	clone.childNodes  =  new  NodeList(clone,  childNodes.size());  	[BUGGY]  clone  .  childNodes  =  new  NodeList  (  childNodes  .  size  (  )  )  ;  [FE]  NullPointerException  assertEquals  (  cloneExpect  ,  cloneNextSibling  .  text  (  )  )  ;  [METHOD]  doClone  [TYPE]  Element  [PARAMETER]  Node  parent  [CLASS]  Element  [TYPE]  Pattern  classSplit  [TYPE]  boolean  false  true  [TYPE]  WeakReference  shadowChildrenRef  [TYPE]  Node  parent  [TYPE]  Element  clone  [TYPE]  Attributes  attributes  [TYPE]  List  EMPTY_NODES  childNodes  [TYPE]  Tag  tag  [TYPE]  String  baseUri  [CONTEXT]  protected  Element  doClone  (  Node  parent  )  {  Element  clone  =  (  Element  )  super  .  doClone  (  parent  )  ;  clone  .  attributes  =  attributes  !  =  null  ?  attributes  .  clone  (  )  :  null  ;  clone  .  baseUri  =  baseUri  ;  [BUGGY]  clone  .  childNodes  =  new  NodeList  (  childNodes  .  size  (  )  )  ;  clone  .  childNodes  .  addAll  (  childNodes  )  ;  return  clone  ;  }  	Jsoup_66_Element_4_2	1402	1	src/main/java/org/jsoup/nodes/Element.java
1652	private  static  final  class  NodeList  extends  ChangeNotifyingArrayList<Node>  {  private  final  Element  owner;    NodeList(Element  owner,  int  initialCapacity)  {  this.owner  =  owner;  	[BUGGY]  private  final  class  NodeList  extends  ChangeNotifyingArrayList<Node>  {  NodeList  (  int  initialCapacity  )  {  [FE]  NullPointerException  assertEquals  (  cloneExpect  ,  cloneNextSibling  .  text  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_66_Element_4_3	1408	2	src/main/java/org/jsoup/nodes/Element.java
1653	owner.nodelistChanged();  	[BUGGY]  nodelistChanged  (  )  ;  [FE]  NullPointerException  assertEquals  (  cloneExpect  ,  cloneNextSibling  .  text  (  )  )  ;  [METHOD]  onContentsChanged  [TYPE]  void  [PARAMETER]  [CLASS]  NodeList  [TYPE]  boolean  false  true  [CONTEXT]  public  void  onContentsChanged  (  )  {  [BUGGY]  nodelistChanged  (  )  ;  }  	Jsoup_66_Element_4_4	1414	1	src/main/java/org/jsoup/nodes/Element.java
1654	public  static  final  int  MaxScopeSearchDepth  =  100;    	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  System  .  currentTimeMillis  (  )  -  start  <  1000  )  ;  [CLASS]  [CONTEXT]  	Jsoup_67_HtmlTreeBuilder_2_1	42	0	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1655	if  (depth  >  MaxScopeSearchDepth)  {  depth  =  MaxScopeSearchDepth;  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  System  .  currentTimeMillis  (  )  -  start  <  1000  )  ;  [METHOD]  inSpecificScope  [TYPE]  boolean  [PARAMETER]  String[]  targetNames  String[]  baseTypes  String[]  extraTypes  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  el  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  baseTypes  extraTypes  specificScopeTarget  targetNames  [TYPE]  String  elName  [TYPE]  FormElement  formElement  [TYPE]  int  depth  pos  [CONTEXT]  private  boolean  inSpecificScope  (  String[]  targetNames  ,  String[]  baseTypes  ,  String[]  extraTypes  )  {  int  depth  =  stack  .  size  (  )  -1  ;  [BUGGY]  for  (  int  pos  =  depth  ;  pos  >  =  0  ;  pos--  )  {  Element  el  =  stack  .  get  (  pos  )  ;  String  elName  =  el  .  nodeName  (  )  ;  if  (  inSorted  (  elName  ,  targetNames  )  )  return  true  ;  if  (  inSorted  (  elName  ,  baseTypes  )  )  return  false  ;  if  (  extraTypes  !  =  null  &&  inSorted  (  elName  ,  extraTypes  )  )  return  false  ;  }  Validate  .  fail  (   "Should  not  be  reachable "  )  ;  return  false  ;  }  	Jsoup_67_HtmlTreeBuilder_2_2	468	0	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1656	final  int  bottom  =  stack.size()  -1;  	[BUGGY]  int  bottom  =  stack  .  size  (  )  -1  ;  if  (  bottom  >  MaxScopeSearchDepth  )  {  bottom  =  MaxScopeSearchDepth  ;  }  [FE]  StackOverflowError  assertEquals  (  1  ,  doc  .  select  (   "p "  )  .  size  (  )  )  ;  [METHOD]  inSpecificScope  [TYPE]  boolean  [PARAMETER]  String[]  targetNames  String[]  baseTypes  String[]  extraTypes  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  baseTypes  extraTypes  specificScopeTarget  targetNames  [TYPE]  String  elName  [TYPE]  int  MaxScopeSearchDepth  bottom  pos  top  [TYPE]  FormElement  formElement  [CONTEXT]  private  boolean  inSpecificScope  (  String[]  targetNames  ,  String[]  baseTypes  ,  String[]  extraTypes  )  {  [BUGGY]  int  bottom  =  stack  .  size  (  )  -1  ;  if  (  bottom  >  MaxScopeSearchDepth  )  {  bottom  =  MaxScopeSearchDepth  ;  }  final  int  top  =  bottom  >  MaxScopeSearchDepth  ?  bottom  -  MaxScopeSearchDepth  :  0  ;    for  (  int  pos  =  bottom  ;  pos  >  =  top  ;  pos--  )  {  final  String  elName  =  stack  .  get  (  pos  )  .  nodeName  (  )  ;  if  (  inSorted  (  elName  ,  targetNames  )  )  return  true  ;  if  (  inSorted  (  elName  ,  baseTypes  )  )  return  false  ;  if  (  extraTypes  !  =  null  &&  inSorted  (  elName  ,  extraTypes  )  )  return  false  ;  }  return  false  ;  }  	Jsoup_68_HtmlTreeBuilder_1_1	468	4	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1657	@Override  protected  void  removeChild(Node  out)  {  super.removeChild(out);  elements.remove(out);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<2>  but  was:<3>  assertEquals  (  null  ,  doc  .  selectFirst  (   "input[name  =  pass] "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_69_FormElement_1_1	49	0	src/main/java/org/jsoup/nodes/FormElement.java
1658	int  i  =  0;  do  {  el  =  el.parent();  i++;  }  while  (i  <  6  &&  el  !=  null);  	[BUGGY]  else  return  el  .  parent  (  )  !  =  null  &&  el  .  parent  (  )  .  tag  .  preserveWhitespace  (  )  ;  [FE]  AssertionFailedError:  expected:<code[  assertEquals  (   "<pre><code><span><b>code\n\ncode</b></span></code></pre> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  preserveWhitespace  [TYPE]  boolean  [PARAMETER]  Node  node  [CLASS]  Element  [TYPE]  Pattern  classSplit  [TYPE]  boolean  false  true  [TYPE]  WeakReference  shadowChildrenRef  [TYPE]  Element  el  owner  [TYPE]  Node  node  [TYPE]  Attributes  attributes  [TYPE]  List  EMPTY_NODES  childNodes  [TYPE]  Tag  tag  [TYPE]  String  baseUri  [CONTEXT]  static  boolean  preserveWhitespace  (  Node  node  )  {  if  (  node  !  =  null  &&  node  instanceof  Element  )  {  Element  el  =  (  Element  )  node  ;  [BUGGY]  if  (  el  .  tag  .  preserveWhitespace  (  )  )  return  true  ;  else  return  el  .  parent  (  )  !  =  null  &&  el  .  parent  (  )  .  tag  .  preserveWhitespace  (  )  ;  }  return  false  ;  }  	Jsoup_70_Element_1_1	1091	2	src/main/java/org/jsoup/nodes/Element.java
1659	if  (_parsingContext.inRoot())  {  _verifyRootSpace(ch);  }  	[BUGGY]  [FE]  AssertionFailedError:  Should  have  gotten  an  exception  ;  instead  got  token:  VALUE_NUMBER_INT  [METHOD]  _parseNumber  [TYPE]  JsonToken  [PARAMETER]  int  ch  [CLASS]  ReaderBasedJsonParser  [TYPE]  boolean  _tokenIncomplete  false  negative  true  [TYPE]  Reader  _reader  [TYPE]  int[]  _icLatin1  _icWS  [TYPE]  ObjectCodec  _objectCodec  [TYPE]  CharsToNameCanonicalizer  _symbols  [TYPE]  int  _hashSeed  ch  expLen  fractLen  inputLen  intLen  len  ptr  startPtr  [TYPE]  char[]  _inputBuffer  [CONTEXT]  }  ch  =  (  int  )  _inputBuffer[ptr++]  ;  if  (  ch  =  =  INT_MINUS  ||  ch  =  =  INT_PLUS  )  {  //  yup  ,  skip  for  now  if  (  ptr  >  =  inputLen  )  {  break  dummy_loop  ;  }  ch  =  (  int  )  _inputBuffer[ptr++]  ;  }  while  (  ch  <  =  INT_9  &&  ch  >  =  INT_0  )  {  ++expLen  ;  if  (  ptr  >  =  inputLen  )  {  break  dummy_loop  ;  }  ch  =  (  int  )  _inputBuffer[ptr++]  ;  }  if  (  expLen  =  =  0  )  {  reportUnexpectedNumberChar  (  ch  ,   "Exponent  indicator  not  followed  by  a  digit "  )  ;  }  }  --ptr  ;  //  need  to  push  back  following  separator  _inputPtr  =  ptr  ;  [BUGGY]  int  len  =  ptr-startPtr  ;  _textBuffer  .  resetWithShared  (  _inputBuffer  ,  startPtr  ,  len  )  ;  return  reset  (  negative  ,  intLen  ,  fractLen  ,  expLen  )  ;  }  while  (  false  )  ;  _inputPtr  =  negative  ?  (  startPtr+1  )  :  startPtr  ;  	JacksonCore_2_ReaderBasedJsonParser_3_1	952	0	src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java
1660	if  (count  <  1)  return   " ";  	[BUGGY]  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  -1  assertTrue  (  r  .  isEmpty  (  )  )  ;  [METHOD]  cacheString  [TYPE]  String  [PARAMETER]  final  char[]  charBuf  String[]  stringCache  final  int  start  final  int  count  [CLASS]  CharacterReader  [TYPE]  boolean  false  true  [TYPE]  char  EOF  [TYPE]  Reader  reader  [TYPE]  String[]  stringCache  [TYPE]  String  cached  [TYPE]  int  bufLength  bufMark  bufPos  bufSplitPoint  count  hash  i  index  maxBufferLen  maxStringCacheLen  offset  readAheadLimit  readerPos  start  [TYPE]  char[]  charBuf  [CONTEXT]  private  static  String  cacheString  (  final  char[]  charBuf  ,  final  String[]  stringCache  ,  final  int  start  ,  final  int  count  )  {  if  (  count  >  maxStringCacheLen  )  return  new  String  (  charBuf  ,  start  ,  count  )  ;  [BUGGY]  int  hash  =  0  ;  int  offset  =  start  ;  for  (  int  i  =  0  ;  i  <  count  ;  i++  )  {  hash  =  31  *  hash  +  charBuf[offset++]  ;  }  final  int  index  =  hash  &  stringCache  .  length  -  1  ;  String  cached  =  stringCache[index]  ;  if  (  cached  =  =  null  )  {  //  miss  ,  add  cached  =  new  String  (  charBuf  ,  start  ,  count  )  ;  stringCache[index]  =  cached  ;  }  else  {  //  hashcode  hit  ,  check  equality  if  (  rangeEquals  (  charBuf  ,  start  ,  count  ,  cached  )  )  {  //  hit  return  cached  ;  }  else  {  //  hashcode  conflict  cached  =  new  String  (  charBuf  ,  start  ,  count  )  ;  stringCache[index]  =  cached  ;  //  update  the  cache  ,  as  recently  used  strings  are  more  likely  to  show  up  again  }  }  return  cached  ;  }  	Jsoup_72_CharacterReader_1_1	427	0	src/main/java/org/jsoup/parser/CharacterReader.java
1661		[BUGGY]  [FE]  AssertionFailedError:  expected:<http://[wwww3org/1999/xhtml]>  but  was:<http://[examplecom/clip]>  assertEquals  (   "img "  ,  img  .  getNodeName  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_73_W3CDom_7_1	22	0	src/main/java/org/jsoup/helper/W3CDom.java
1662	private  final  Stack<HashMap<String,  String>>  namespacesStack  =  new  Stack<>();    	[BUGGY]  private  final  HashMap<String  ,  String>  namespaces  =  new  HashMap<>  (  )  ;  [FE]  AssertionFailedError:  expected:<http://[wwww3org/1999/xhtml]>  but  was:<http://[examplecom/clip]>  assertEquals  (   "img "  ,  img  .  getNodeName  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_73_W3CDom_7_2	73	1	src/main/java/org/jsoup/helper/W3CDom.java
1663	this.namespacesStack.push(new  HashMap<String,  String>());  	[BUGGY]  [FE]  AssertionFailedError:  expected:<http://[wwww3org/1999/xhtml]>  but  was:<http://[examplecom/clip]>  assertEquals  (   "img "  ,  img  .  getNodeName  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_73_W3CDom_7_3	78	0	src/main/java/org/jsoup/helper/W3CDom.java
1664	namespacesStack.push(new  HashMap<>(namespacesStack.peek()));    	[BUGGY]  [FE]  AssertionFailedError:  expected:<http://[wwww3org/1999/xhtml]>  but  was:<http://[examplecom/clip]>  assertEquals  (   "img "  ,  img  .  getNodeName  (  )  )  ;  [METHOD]  head  [TYPE]  void  [PARAMETER]  Node  source  int  depth  [CLASS]  W3CBuilder  [TYPE]  Comment  comment  sourceComment  [TYPE]  boolean  false  true  [TYPE]  HashMap  namespaces  [TYPE]  DataNode  sourceData  [TYPE]  Element  dest  el  sourceEl  [TYPE]  Node  source  [TYPE]  TextNode  sourceText  [TYPE]  Text  node  text  [TYPE]  String  namespace  prefix  xmlnsKey  xmlnsPrefix  [TYPE]  Document  doc  [TYPE]  int  depth  [CONTEXT]  public  void  head  (  org  .  jsoup  .  nodes  .  Node  source  ,  int  depth  )  {  [BUGGY]  if  (  source  instanceof  org  .  jsoup  .  nodes  .  Element  )  {  org  .  jsoup  .  nodes  .  Element  sourceEl  =  (  org  .  jsoup  .  nodes  .  Element  )  source  ;  String  prefix  =  updateNamespaces  (  sourceEl  )  ;  String  namespace  =  namespaces  .  get  (  prefix  )  ;  	Jsoup_73_W3CDom_7_4	81	0	src/main/java/org/jsoup/helper/W3CDom.java
1665	String  namespace  =  namespacesStack.peek().get(prefix);  	[BUGGY]  String  namespace  =  namespaces  .  get  (  prefix  )  ;  [FE]  AssertionFailedError:  expected:<http://[wwww3org/1999/xhtml]>  but  was:<http://[examplecom/clip]>  assertEquals  (   "img "  ,  img  .  getNodeName  (  )  )  ;  [METHOD]  head  [TYPE]  void  [PARAMETER]  Node  source  int  depth  [CLASS]  W3CBuilder  [TYPE]  Comment  comment  sourceComment  [TYPE]  boolean  false  true  [TYPE]  HashMap  namespaces  [TYPE]  DataNode  sourceData  [TYPE]  Element  dest  el  sourceEl  [TYPE]  Node  source  [TYPE]  TextNode  sourceText  [TYPE]  Text  node  text  [TYPE]  String  namespace  prefix  xmlnsKey  xmlnsPrefix  [TYPE]  Document  doc  [TYPE]  int  depth  [CONTEXT]  public  void  head  (  org  .  jsoup  .  nodes  .  Node  source  ,  int  depth  )  {  if  (  source  instanceof  org  .  jsoup  .  nodes  .  Element  )  {  org  .  jsoup  .  nodes  .  Element  sourceEl  =  (  org  .  jsoup  .  nodes  .  Element  )  source  ;  String  prefix  =  updateNamespaces  (  sourceEl  )  ;  [BUGGY]  String  namespace  =  namespaces  .  get  (  prefix  )  ;  Element  el  =  doc  .  createElementNS  (  namespace  ,  sourceEl  .  tagName  (  )  )  ;  copyAttributes  (  sourceEl  ,  el  )  ;  if  (  dest  =  =  null  )  {  //  sets  up  the  root  doc  .  appendChild  (  el  )  ;  	Jsoup_73_W3CDom_7_5	85	1	src/main/java/org/jsoup/helper/W3CDom.java
1666	namespacesStack.pop();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<http://[wwww3org/1999/xhtml]>  but  was:<http://[examplecom/clip]>  assertEquals  (   "img "  ,  img  .  getNodeName  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_73_W3CDom_7_6	116	0	src/main/java/org/jsoup/helper/W3CDom.java
1667	namespacesStack.peek().put(prefix,  attr.getValue());  	[BUGGY]  namespaces  .  put  (  prefix  ,  attr  .  getValue  (  )  )  ;  [FE]  AssertionFailedError:  expected:<http://[wwww3org/1999/xhtml]>  but  was:<http://[examplecom/clip]>  assertEquals  (   "img "  ,  img  .  getNodeName  (  )  )  ;  [METHOD]  updateNamespaces  [TYPE]  String  [PARAMETER]  Element  el  [CLASS]  W3CBuilder  [TYPE]  boolean  false  true  [TYPE]  HashMap  namespaces  [TYPE]  Attribute  attr  [TYPE]  Element  dest  el  [TYPE]  Attributes  attributes  [TYPE]  String  key  prefix  xmlnsKey  xmlnsPrefix  [TYPE]  Document  doc  [TYPE]  int  pos  [CONTEXT]  private  String  updateNamespaces  (  org  .  jsoup  .  nodes  .  Element  el  )  {    Attributes  attributes  =  el  .  attributes  (  )  ;  for  (  Attribute  attr  :  attributes  )  {  String  key  =  attr  .  getKey  (  )  ;  String  prefix  ;  if  (  key  .  equals  (  xmlnsKey  )  )  {  prefix  =   " "  ;  }  else  if  (  key  .  startsWith  (  xmlnsPrefix  )  )  {  prefix  =  key  .  substring  (  xmlnsPrefix  .  length  (  )  )  ;  }  else  {  continue  ;  }  [BUGGY]  namespaces  .  put  (  prefix  ,  attr  .  getValue  (  )  )  ;  }  int  pos  =  el  .  tagName  (  )  .  indexOf  (   ": "  )  ;  return  pos  >  0  ?  el  .  tagName  (  )  .  substring  (  0  ,  pos  )  :   " "  ;  }  	Jsoup_73_W3CDom_7_7	144	1	src/main/java/org/jsoup/helper/W3CDom.java
1668	public  static  boolean  isInvisibleChar(int  c)  {  return  Character.getType(c)  ==  16  &&  (c  ==  8203  ||  c  ==  8204  ||  c  ==  8205  ||  c  ==  173);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<This[isonelong]word>  but  was:<This[  assertTrue  (  matched  .  is  (   ":containsOwn  (  Thisisonelongword  )   "  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_74_StringUtil_2_1	131	0	src/main/java/org/jsoup/helper/StringUtil.java
1669	else  if  (!isInvisibleChar(c))  {  	[BUGGY]  else  {  [FE]  AssertionFailedError:  expected:<This[isonelong]word>  but  was:<This[  assertTrue  (  matched  .  is  (   ":containsOwn  (  Thisisonelongword  )   "  )  )  ;  [METHOD]  appendNormalisedWhitespace  [TYPE]  void  [PARAMETER]  StringBuilder  accum  String  string  boolean  stripLeading  [CLASS]  StringUtil  [TYPE]  String[]  padding  [TYPE]  String  string  [TYPE]  boolean  false  lastWasWhite  reachedNonWhite  stripLeading  true  [TYPE]  StringBuilder  accum  [TYPE]  ThreadLocal  stringLocal  [TYPE]  int  MaxCachedBuilderSize  c  i  len  [CONTEXT]  public  static  void  appendNormalisedWhitespace  (  StringBuilder  accum  ,  String  string  ,  boolean  stripLeading  )  {  boolean  lastWasWhite  =  false  ;  boolean  reachedNonWhite  =  false  ;  int  len  =  string  .  length  (  )  ;  int  c  ;  for  (  int  i  =  0  ;  i  <  len  ;  i+  =  Character  .  charCount  (  c  )  )  {  c  =  string  .  codePointAt  (  i  )  ;  if  (  isActuallyWhitespace  (  c  )  )  {  if  (  (  stripLeading  &&  !reachedNonWhite  )  ||  lastWasWhite  )  continue  ;  accum  .  append  (  '  '  )  ;  lastWasWhite  =  true  ;  }  [BUGGY]  else  {  accum  .  appendCodePoint  (  c  )  ;  lastWasWhite  =  false  ;  reachedNonWhite  =  true  ;  }  }  }  	Jsoup_74_StringUtil_2_2	165	1	src/main/java/org/jsoup/helper/StringUtil.java
1670	if  (!Attribute.shouldCollapseAttribute(key,  val,  out))  {  	[BUGGY]  if  (  !  (  out  .  syntax  (  )  =  =  Document  .  OutputSettings  .  Syntax  .  html  &&  (  val  =  =  null  ||  val  .  equals  (  key  )  &&  Attribute  .  isBooleanAttribute  (  key  )  )  )  )  {  [FE]  AssertionFailedError:  expected:<mg  src  =   "foo "  noshade[]  nohref  async  autofo>  but  was:<mg  src  =   "foo "  noshade[  =   " "]  nohref  async  autofo>  assertEquals  (   "<img  src  =  \ "foo\ "  noshade  nohref  async  autofocus  =  \ "false\ "> "  ,  img  .  outerHtml  (  )  )  ;  [METHOD]  html  [TYPE]  void  [PARAMETER]  Appendable  accum  OutputSettings  out  [CLASS]  Attributes  [TYPE]  boolean  false  true  [TYPE]  OutputSettings  out  [TYPE]  Attribute  attr  [TYPE]  Appendable  accum  [TYPE]  Attributes  attributes  [TYPE]  Iterator  attrIter  [TYPE]  String  EmptyString  dataPrefix  key  val  [TYPE]  String[]  Empty  keys  vals  [TYPE]  int  GrowthFactor  InitialCapacity  NotFound  i  size  sz  [CONTEXT]  final  void  html  (  final  Appendable  accum  ,  final  Document  .  OutputSettings  out  )  throws  IOException  {  final  int  sz  =  size  ;  for  (  int  i  =  0  ;  i  <  sz  ;  i++  )  {  final  String  key  =  keys[i]  ;  final  String  val  =  vals[i]  ;  accum  .  append  (  '  '  )  .  append  (  key  )  ;    [BUGGY]  if  (  !  (  out  .  syntax  (  )  =  =  Document  .  OutputSettings  .  Syntax  .  html  &&  (  val  =  =  null  ||  val  .  equals  (  key  )  &&  Attribute  .  isBooleanAttribute  (  key  )  )  )  )  {  accum  .  append  (   "  =  \ " "  )  ;  Entities  .  escape  (  accum  ,  val  =  =  null  ?  EmptyString  :  val  ,  out  ,  true  ,  false  ,  false  )  ;  accum  .  append  (  ' "'  )  ;  }  }  }  	Jsoup_75_Attributes_1_1	319	2	src/main/java/org/jsoup/nodes/Attributes.java
1671	tb.reader.matchConsume( "\\n ");    	[BUGGY]  [FE]  AssertionFailedError:  expected:<  assertEquals  (   "\nOne\nTwo\n "  ,  pre  .  wholeText  (  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  return  false  ;  //  ignore  frameset  }  else  {  Element  second  =  stack  .  get  (  1  )  ;  if  (  second  .  parent  (  )  !  =  null  )  second  .  remove  (  )  ;  while  (  stack  .  size  (  )  >  1  )  stack  .  remove  (  stack  .  size  (  )  -1  )  ;  tb  .  insert  (  startTag  )  ;  tb  .  transition  (  InFrameset  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  Headings  )  )  {  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  if  (  StringUtil  .  inSorted  (  tb  .  currentElement  (  )  .  nodeName  (  )  ,  Constants  .  Headings  )  )  {  tb  .  error  (  this  )  ;  tb  .  pop  (  )  ;  }  tb  .  insert  (  startTag  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartPreListing  )  )  {  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  tb  .  insert  (  startTag  )  ;  [BUGGY]  tb  .  framesetOk  (  false  )  ;  }  else  if  (  name  .  equals  (   "form "  )  )  {  if  (  tb  .  getFormElement  (  )  !  =  null  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  	Jsoup_76_HtmlTreeBuilderState_1_1	382	0	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1672	String  elName  =  endTag.normalName();  	[BUGGY]  String  elName  =  endTag  .  name  (  )  ;  [FE]  AssertionFailedError:  expected:<<div>  assertEquals  (   "<div>\n  test\n</div>\n<p></p> "  ,  document  .  html  (  )  )  ;  [METHOD]  popStackToClose  [TYPE]  void  [PARAMETER]  EndTag  endTag  [CLASS]  XmlTreeBuilder  [TYPE]  boolean  false  true  [TYPE]  EndTag  endTag  [TYPE]  Element  firstFound  next  [TYPE]  String  elName  [TYPE]  int  pos  [CONTEXT]  private  void  popStackToClose  (  Token  .  EndTag  endTag  )  {  [BUGGY]  String  elName  =  endTag  .  name  (  )  ;  Element  firstFound  =  null  ;  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  next  =  stack  .  get  (  pos  )  ;  if  (  next  .  nodeName  (  )  .  equals  (  elName  )  )  {  firstFound  =  next  ;  break  ;  }  }  if  (  firstFound  =  =  null  )  return  ;  //  not  found  ,  skip  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  next  =  stack  .  get  (  pos  )  ;  stack  .  remove  (  pos  )  ;  if  (  next  =  =  firstFound  )  break  ;  }  }  	Jsoup_77_XmlTreeBuilder_1_1	117	1	src/main/java/org/jsoup/parser/XmlTreeBuilder.java
1673		[BUGGY]  [FE]  UncheckedIOException:  javaioIOException:  Underlying  input  stream  returned  zero  bytes  assertEquals  (  true  ,  threw  )  ;  [CLASS]  [CONTEXT]  	Jsoup_78_DataUtil_2_1	3	0	src/main/java/org/jsoup/helper/DataUtil.java
1674	try  {  }  catch  (UncheckedIOException  e)  {  throw  e.ioException();  }  	[BUGGY]  [FE]  UncheckedIOException:  javaioIOException:  Underlying  input  stream  returned  zero  bytes  assertEquals  (  true  ,  threw  )  ;  [METHOD]  parseInputStream  [TYPE]  Document  [PARAMETER]  InputStream  input  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  InputStream  input  [TYPE]  Element  meta  [TYPE]  String  baseUri  charset  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  Elements  metaElements  [TYPE]  ByteBuffer  firstBytes  [TYPE]  BomCharset  bomCharset  [TYPE]  int  boundaryLength  bufferSize  firstReadBufferSize  offset  [TYPE]  char[]  mimeBoundaryChars  [TYPE]  Parser  parser  [TYPE]  boolean  false  fullyRead  true  [TYPE]  BufferedReader  reader  [TYPE]  XmlDeclaration  prolog  [CONTEXT]  if  (  foundCharset  !  =  null  )  break  ;  }  if  (  foundCharset  =  =  null  &&  doc  .  childNodeSize  (  )  >  0  &&  doc  .  childNode  (  0  )  instanceof  XmlDeclaration  )  {  XmlDeclaration  prolog  =  (  XmlDeclaration  )  doc  .  childNode  (  0  )  ;  if  (  prolog  .  name  (  )  .  equals  (   "xml "  )  )  foundCharset  =  prolog  .  attr  (   "encoding "  )  ;  }  foundCharset  =  validateCharset  (  foundCharset  )  ;  if  (  foundCharset  !  =  null  &&  !foundCharset  .  equalsIgnoreCase  (  defaultCharset  )  )  {  //  need  to  re-decode  .    (  case  insensitive  check  here  to  match  how  validate  works  )  foundCharset  =  foundCharset  .  trim  (  )  .  replaceAll  (   "[\ "'] "  ,   " "  )  ;  charsetName  =  foundCharset  ;  doc  =  null  ;  }  else  if  (  !fullyRead  )  {  doc  =  null  ;  }  }  else  {  //  specified  by  content  type  header  (  or  by  user  on  file  load  )  Validate  .  notEmpty  (  charsetName  ,   "Must  set  charset  arg  to  character  set  of  file  to  parse  .  Set  to  null  to  attempt  to  detect  from  HTML "  )  ;  }  if  (  doc  =  =  null  )  {  if  (  charsetName  =  =  null  )  charsetName  =  defaultCharset  ;  BufferedReader  reader  =  new  BufferedReader  (  new  InputStreamReader  (  input  ,  charsetName  )  ,  bufferSize  )  ;  [BUGGY]  doc  =  parser  .  parseInput  (  reader  ,  baseUri  )  ;  doc  .  outputSettings  (  )  .  charset  (  charsetName  )  ;  }  input  .  close  (  )  ;  return  doc  ;  	Jsoup_78_DataUtil_2_2	151	0	src/main/java/org/jsoup/helper/DataUtil.java
1675		[BUGGY]  [FE]  UnsupportedOperationException:  Leaf  Nodes  do  not  have  child  nodes  assertEquals  (  0  ,  nodes  .  size  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_79_LeafNode_3_1	5	0	src/main/java/org/jsoup/nodes/LeafNode.java
1676	private  static  final  List<Node>  EmptyNodes  =  Collections.emptyList();  	[BUGGY]  [FE]  UnsupportedOperationException:  Leaf  Nodes  do  not  have  child  nodes  assertEquals  (  0  ,  nodes  .  size  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_79_LeafNode_3_2	8	0	src/main/java/org/jsoup/nodes/LeafNode.java
1677	return  EmptyNodes;  	[BUGGY]  throw  new  UnsupportedOperationException  (   "Leaf  Nodes  do  not  have  child  nodes  .   "  )  ;  [FE]  UnsupportedOperationException:  Leaf  Nodes  do  not  have  child  nodes  assertEquals  (  0  ,  nodes  .  size  (  )  )  ;  [METHOD]  ensureChildNodes  [TYPE]  List  [PARAMETER]  [CLASS]  LeafNode  [TYPE]  Object  value  [TYPE]  boolean  false  true  [CONTEXT]  protected  List<Node>  ensureChildNodes  (  )  {  [BUGGY]  throw  new  UnsupportedOperationException  (   "Leaf  Nodes  do  not  have  child  nodes  .   "  )  ;  }  	Jsoup_79_LeafNode_3_3	94	1	src/main/java/org/jsoup/nodes/LeafNode.java
1678	if  (doc.childNodeSize()  >  0)  {  	[BUGGY]  [FE]  IndexOutOfBoundsException:  Index:  0  ,  Size:  0  assertEquals  (   "One "  ,  doc  .  select  (   "val "  )  .  text  (  )  )  ;  [METHOD]  insert  [TYPE]  void  [PARAMETER]  Comment  commentToken  [CLASS]  XmlTreeBuilder  [TYPE]  Comment  comment  commentToken  [TYPE]  boolean  false  true  [TYPE]  Node  insert  [TYPE]  Element  el  [TYPE]  String  data  [TYPE]  Document  doc  [CONTEXT]  void  insert  (  Token  .  Comment  commentToken  )  {  Comment  comment  =  new  Comment  (  commentToken  .  getData  (  )  )  ;  Node  insert  =  comment  ;  if  (  commentToken  .  bogus  )  {  //  xml  declarations  are  emitted  as  bogus  comments  (  which  is  right  for  html  ,  but  not  xml  )    String  data  =  comment  .  getData  (  )  ;  if  (  data  .  length  (  )  >  1  &&  (  data  .  startsWith  (   "! "  )  ||  data  .  startsWith  (   "? "  )  )  )  {  Document  doc  =  Jsoup  .  parse  (   "< "  +  data  .  substring  (  1  ,  data  .  length  (  )  -1  )  +   "> "  ,  baseUri  ,  Parser  .  xmlParser  (  )  )  ;  [BUGGY]  Element  el  =  doc  .  child  (  0  )  ;  insert  =  new  XmlDeclaration  (  settings  .  normalizeTag  (  el  .  tagName  (  )  )  ,  data  .  startsWith  (   "! "  )  )  ;  insert  .  attributes  (  )  .  addAll  (  el  .  attributes  (  )  )  ;  }  }  insertNode  (  insert  )  ;  }  	Jsoup_80_XmlTreeBuilder_1_1	91	0	src/main/java/org/jsoup/parser/XmlTreeBuilder.java
1680		[BUGGY]  [FE]  AssertionFailedError:  expected:<Hell[  assertEquals  (   "Hell  Wrld! "  ,  doc  .  body  (  )  .  text  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_81_DataUtil_2_1	5	0	src/main/java/org/jsoup/helper/DataUtil.java
1681	else  if  (first  instanceof  Comment)  {  Comment  comment  =  (Comment)  first;  if  (comment.isXmlDeclaration())  decl  =  comment.asXmlDeclaration();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<Hell[  assertEquals  (   "Hell  Wrld! "  ,  doc  .  body  (  )  .  text  (  )  )  ;  [METHOD]  parseInputStream  [TYPE]  Document  [PARAMETER]  InputStream  input  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  InputStream  input  [TYPE]  Element  meta  [TYPE]  Node  first  [TYPE]  UncheckedIOException  e  [TYPE]  String  baseUri  charset  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  Elements  metaElements  [TYPE]  ByteBuffer  firstBytes  [TYPE]  BomCharset  bomCharset  [TYPE]  int  boundaryLength  bufferSize  firstReadBufferSize  [TYPE]  char[]  mimeBoundaryChars  [TYPE]  Parser  parser  [TYPE]  boolean  false  fullyRead  offset  true  [TYPE]  BufferedReader  reader  [TYPE]  XmlDeclaration  decl  [CONTEXT]  if  (  bomCharset  !  =  null  )  charsetName  =  bomCharset  .  charset  ;  if  (  charsetName  =  =  null  )  {  //  determine  from  meta  .  safe  first  parse  as  UTF-8  String  docData  =  Charset  .  forName  (  defaultCharset  )  .  decode  (  firstBytes  )  .  toString  (  )  ;  doc  =  parser  .  parseInput  (  docData  ,  baseUri  )  ;    Elements  metaElements  =  doc  .  select  (   "meta[http-equiv  =  content-type]  ,  meta[charset] "  )  ;  String  foundCharset  =  null  ;  //  if  not  found  ,  will  keep  utf-8  as  best  attempt  for  (  Element  meta  :  metaElements  )  {  if  (  meta  .  hasAttr  (   "http-equiv "  )  )  foundCharset  =  getCharsetFromContentType  (  meta  .  attr  (   "content "  )  )  ;  if  (  foundCharset  =  =  null  &&  meta  .  hasAttr  (   "charset "  )  )  foundCharset  =  meta  .  attr  (   "charset "  )  ;  if  (  foundCharset  !  =  null  )  break  ;  }  if  (  foundCharset  =  =  null  &&  doc  .  childNodeSize  (  )  >  0  )  {  Node  first  =  doc  .  childNode  (  0  )  ;  XmlDeclaration  decl  =  null  ;  if  (  first  instanceof  XmlDeclaration  )  decl  =  (  XmlDeclaration  )  first  ;  [BUGGY]  if  (  decl  !  =  null  )  {  if  (  decl  .  name  (  )  .  equalsIgnoreCase  (   "xml "  )  )  foundCharset  =  decl  .  attr  (   "encoding "  )  ;  }  }  foundCharset  =  validateCharset  (  foundCharset  )  ;  	Jsoup_81_DataUtil_2_2	136	0	src/main/java/org/jsoup/helper/DataUtil.java
1682	if  (!charset.canEncode())  {  doc.charset(Charset.forName(defaultCharset));  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[UTF-8]>  but  was:<[ISO-2022-CN]>  assertEquals  (   "<html><head><meta  charset  =  \ "UTF-8\ "></head><body>One</body></html> "  ,  TextUtil  .  stripNewlines  (  html  )  )  ;  [METHOD]  parseInputStream  [TYPE]  Document  [PARAMETER]  InputStream  input  String  charsetName  String  baseUri  Parser  parser  [CLASS]  DataUtil  [TYPE]  Pattern  charsetPattern  [TYPE]  Comment  comment  [TYPE]  InputStream  input  [TYPE]  Element  meta  [TYPE]  Node  first  [TYPE]  Charset  charset  [TYPE]  UncheckedIOException  e  [TYPE]  String  baseUri  charset  charsetName  defaultCharset  docData  foundCharset  [TYPE]  Document  doc  [TYPE]  Elements  metaElements  [TYPE]  ByteBuffer  firstBytes  [TYPE]  BomCharset  bomCharset  [TYPE]  int  boundaryLength  bufferSize  firstReadBufferSize  [TYPE]  char[]  mimeBoundaryChars  [TYPE]  Parser  parser  [TYPE]  boolean  false  fullyRead  offset  true  [TYPE]  BufferedReader  reader  [TYPE]  XmlDeclaration  decl  [CONTEXT]  foundCharset  =  validateCharset  (  foundCharset  )  ;  if  (  foundCharset  !  =  null  &&  !foundCharset  .  equalsIgnoreCase  (  defaultCharset  )  )  {  //  need  to  re-decode  .    (  case  insensitive  check  here  to  match  how  validate  works  )  foundCharset  =  foundCharset  .  trim  (  )  .  replaceAll  (   "[\ "'] "  ,   " "  )  ;  charsetName  =  foundCharset  ;  doc  =  null  ;  }  else  if  (  !fullyRead  )  {  doc  =  null  ;  }  }  else  {  //  specified  by  content  type  header  (  or  by  user  on  file  load  )  Validate  .  notEmpty  (  charsetName  ,   "Must  set  charset  arg  to  character  set  of  file  to  parse  .  Set  to  null  to  attempt  to  detect  from  HTML "  )  ;  }  if  (  doc  =  =  null  )  {  if  (  charsetName  =  =  null  )  charsetName  =  defaultCharset  ;  BufferedReader  reader  =  new  BufferedReader  (  new  InputStreamReader  (  input  ,  charsetName  )  ,  bufferSize  )  ;  if  (  bomCharset  !  =  null  &&  bomCharset  .  offset  )  //  creating  the  buffered  reader  ignores  the  input  pos  ,  so  must  skip  here  reader  .  skip  (  1  )  ;  try  {  doc  =  parser  .  parseInput  (  reader  ,  baseUri  )  ;  }  catch  (  UncheckedIOException  e  )  {  throw  e  .  ioException  (  )  ;  }  Charset  charset  =  Charset  .  forName  (  charsetName  )  ;  doc  .  outputSettings  (  )  .  charset  (  charset  )  ;  [BUGGY]  }  input  .  close  (  )  ;  return  doc  ;  }  	Jsoup_82_DataUtil_1_1	171	0	src/main/java/org/jsoup/helper/DataUtil.java
1683		[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  =  a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>>  but  was:<<p  =  a>One<a[  <p>Something</a></p><a  <p]>Else</a>>  assertEquals  (   "<p  .  .  .  .  .  ></p> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  consumeTagName  [TYPE]  String  [PARAMETER]  [CLASS]  CharacterReader  [TYPE]  char  EOF  c  [TYPE]  Reader  reader  [TYPE]  String[]  stringCache  [TYPE]  boolean  false  true  [TYPE]  int  bufLength  bufMark  bufPos  bufSplitPoint  maxBufferLen  maxStringCacheLen  readAheadLimit  readerPos  remaining  start  [TYPE]  char[]  charBuf  val  [CONTEXT]  String  consumeTagName  (  )  {    bufferUp  (  )  ;  final  int  start  =  bufPos  ;  final  int  remaining  =  bufLength  ;  final  char[]  val  =  charBuf  ;  while  (  bufPos  <  remaining  )  {  final  char  c  =  val[bufPos]  ;  [BUGGY]  if  (  c  =  =  '\t'||  c  =  =  '\n'||  c  =  =  '\r'||  c  =  =  '\f'||  c  =  =  '  '||  c  =  =  '/'||  c  =  =  '>'||  c  =  =  TokeniserState  .  nullChar  )  break  ;  bufPos++  ;  }  return  bufPos  >  start  ?  cacheString  (  charBuf  ,  stringCache  ,  start  ,  bufPos  -start  )  :   " "  ;  }  	Jsoup_83_CharacterReader_1_1	254	0	src/main/java/org/jsoup/parser/CharacterReader.java
1684	r.unconsume();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  =  a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>>  but  was:<<p  =  a>One<a[  <p>Something</a></p><a  <p]>Else</a>>  assertEquals  (   "<p  .  .  .  .  .  ></p> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  read  [TYPE]  void  [PARAMETER]  Tokeniser  t  CharacterReader  r  [CLASS]  10  [TYPE]  CharacterReader  r  [TYPE]  boolean  false  true  [TYPE]  char  c  [TYPE]  Tokeniser  t  [TYPE]  String  tagName  [CONTEXT]  void  read  (  Tokeniser  t  ,  CharacterReader  r  )  {    String  tagName  =  r  .  consumeTagName  (  )  ;  t  .  tagPending  .  appendTagName  (  tagName  )  ;  char  c  =  r  .  consume  (  )  ;  switch  (  c  )  {  case  '\t':  case  '\n':  case  '\r':  case  '\f':  case  '  ':  t  .  transition  (  BeforeAttributeName  )  ;  break  ;  case  '/':  t  .  transition  (  SelfClosingStartTag  )  ;  break  ;  [BUGGY]  case  '>':  t  .  emitTagPending  (  )  ;  t  .  transition  (  Data  )  ;  break  ;  case  nullChar:  //  replacement  	Jsoup_83_TokeniserState_3_1	161	0	src/main/java/org/jsoup/parser/TokeniserState.java
1685	r.unconsume();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  =  a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>>  but  was:<<p  =  a>One<a[  <p>Something</a></p><a  <p]>Else</a>>  assertEquals  (   "<p  .  .  .  .  .  ></p> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  read  [TYPE]  void  [PARAMETER]  Tokeniser  t  CharacterReader  r  [CLASS]  34  [TYPE]  CharacterReader  r  [TYPE]  boolean  false  true  [TYPE]  char  c  [TYPE]  Tokeniser  t  [CONTEXT]  void  read  (  Tokeniser  t  ,  CharacterReader  r  )  {  char  c  =  r  .  consume  (  )  ;  switch  (  c  )  {  case  '\t':  case  '\n':  case  '\r':  case  '\f':  case  '  ':  break  ;  //  ignore  whitespace  case  '/':  t  .  transition  (  SelfClosingStartTag  )  ;  break  ;  [BUGGY]  case  '>':  t  .  emitTagPending  (  )  ;  t  .  transition  (  Data  )  ;  break  ;  case  nullChar:  	Jsoup_83_TokeniserState_3_2	564	0	src/main/java/org/jsoup/parser/TokeniserState.java
1686		[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  =  a>One<a[></a></p><p><a>Something</a></p><a]>Else</a>>  but  was:<<p  =  a>One<a[  <p>Something</a></p><a  <p]>Else</a>>  assertEquals  (   "<p  .  .  .  .  .  ></p> "  ,  doc  .  body  (  )  .  html  (  )  )  ;  [METHOD]  read  [TYPE]  void  [PARAMETER]  Tokeniser  t  CharacterReader  r  [CLASS]  34  [TYPE]  CharacterReader  r  [TYPE]  boolean  false  true  [TYPE]  char  c  [TYPE]  Tokeniser  t  [CONTEXT]  case  '\n':  case  '\r':  case  '\f':  case  '  ':  break  ;  //  ignore  whitespace  case  '/':  t  .  transition  (  SelfClosingStartTag  )  ;  break  ;  case  '>':  t  .  emitTagPending  (  )  ;  t  .  transition  (  Data  )  ;  break  ;  case  nullChar:  t  .  error  (  this  )  ;  t  .  tagPending  .  newAttribute  (  )  ;  r  .  unconsume  (  )  ;  t  .  transition  (  AttributeName  )  ;  break  ;  case  eof:  t  .  eofError  (  this  )  ;  t  .  transition  (  Data  )  ;  break  ;  case  ' "':  case  '\'':  [BUGGY]  case  '<':  case  '  =  ':  t  .  error  (  this  )  ;  t  .  tagPending  .  newAttribute  (  )  ;  t  .  tagPending  .  appendAttributeName  (  c  )  ;  t  .  transition  (  AttributeName  )  ;  	Jsoup_83_TokeniserState_3_3	581	0	src/main/java/org/jsoup/parser/TokeniserState.java
1687	Element  el  =  namespace  ==  null  &&  tagName.contains( ": ")  ?  doc.createElementNS( " ",  tagName)  :    	[BUGGY]  Element  el  =  [FE]  domDOMException:  NAMESPACE_ERR:  An  attempt  is  made  to  create  or  change  an  object  in  a  way  which  is  incorrect  with  regard  to  namespaces  assertEquals  (   "fb:like "  ,  fb  .  getNodeName  (  )  )  ;  [METHOD]  head  [TYPE]  void  [PARAMETER]  Node  source  int  depth  [CLASS]  W3CBuilder  [TYPE]  Comment  comment  sourceComment  [TYPE]  boolean  false  true  [TYPE]  DataNode  sourceData  [TYPE]  Element  dest  el  sourceEl  [TYPE]  Node  source  [TYPE]  TextNode  sourceText  [TYPE]  Text  node  text  [TYPE]  String  namespace  prefix  tagName  xmlnsKey  xmlnsPrefix  [TYPE]  Document  doc  [TYPE]  int  depth  [TYPE]  Stack  namespacesStack  [CONTEXT]  public  void  head  (  org  .  jsoup  .  nodes  .  Node  source  ,  int  depth  )  {  namespacesStack  .  push  (  new  HashMap<>  (  namespacesStack  .  peek  (  )  )  )  ;  //  inherit  from  above  on  the  stack  if  (  source  instanceof  org  .  jsoup  .  nodes  .  Element  )  {  org  .  jsoup  .  nodes  .  Element  sourceEl  =  (  org  .  jsoup  .  nodes  .  Element  )  source  ;  String  prefix  =  updateNamespaces  (  sourceEl  )  ;  String  namespace  =  namespacesStack  .  peek  (  )  .  get  (  prefix  )  ;  String  tagName  =  sourceEl  .  tagName  (  )  ;  [BUGGY]  Element  el  =  doc  .  createElementNS  (  namespace  ,  tagName  )  ;  copyAttributes  (  sourceEl  ,  el  )  ;  if  (  dest  =  =  null  )  {  //  sets  up  the  root  doc  .  appendChild  (  el  )  ;  }  else  {  	Jsoup_84_W3CDom_1_1	91	1	src/main/java/org/jsoup/helper/W3CDom.java
1688	key  =  key.trim();  this.key  =  key;  	[BUGGY]  this  .  key  =  key  .  trim  (  )  ;  [FE]  AssertionFailedError:  Expected  exception:  javalangIllegalArgumentException  [CLASS]  [CONTEXT]  	Jsoup_85_Attribute_1_1	44	1	src/main/java/org/jsoup/nodes/Attribute.java
1689	if  (doc.children().size()  >  0)  {  	[BUGGY]  if  (  doc  .  childNodeSize  (  )  >  0  )  {  [FE]  IndexOutOfBoundsException:  Index:  0  ,  Size:  0  assertEquals  (   "<script>  var  a  =  \ "\n  <!--?\ "  ;  var  b  =  \ "?-->\ "  ;  </script> "  ,  doc  .  html  (  )  )  ;  //  converted  from  pseudo  xmldecl  to  comment  [METHOD]  asXmlDeclaration  [TYPE]  XmlDeclaration  [PARAMETER]  [CLASS]  Comment  [TYPE]  XmlDeclaration  decl  [TYPE]  String  COMMENT_KEY  data  [TYPE]  boolean  false  true  [TYPE]  Document  doc  [TYPE]  Element  el  [CONTEXT]  public  XmlDeclaration  asXmlDeclaration  (  )  {  String  data  =  getData  (  )  ;  Document  doc  =  Jsoup  .  parse  (   "< "  +  data  .  substring  (  1  ,  data  .  length  (  )  -1  )  +   "> "  ,  baseUri  (  )  ,  Parser  .  xmlParser  (  )  )  ;  XmlDeclaration  decl  =  null  ;  [BUGGY]  if  (  doc  .  childNodeSize  (  )  >  0  )  {  Element  el  =  doc  .  child  (  0  )  ;  decl  =  new  XmlDeclaration  (  NodeUtils  .  parser  (  doc  )  .  settings  (  )  .  normalizeTag  (  el  .  tagName  (  )  )  ,  data  .  startsWith  (   "! "  )  )  ;  decl  .  attributes  (  )  .  addAll  (  el  .  attributes  (  )  )  ;  }  return  decl  ;  }  	Jsoup_86_Comment_1_1	78	1	src/main/java/org/jsoup/nodes/Comment.java
1690	public  String  normalName()  {  return  tag.normalName();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_87_Element_1_1	140	0	src/main/java/org/jsoup/nodes/Element.java
1691	if  (next.normalName().equals(elName))  {  	[BUGGY]  if  (  next  .  nodeName  (  )  .  equals  (  elName  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  getFromStack  [TYPE]  Element  [PARAMETER]  String  elName  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  next  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  String  elName  [TYPE]  int  MaxScopeSearchDepth  pos  [TYPE]  FormElement  formElement  [CONTEXT]  Element  getFromStack  (  String  elName  )  {  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  next  =  stack  .  get  (  pos  )  ;  [BUGGY]  if  (  next  .  nodeName  (  )  .  equals  (  elName  )  )  {  return  next  ;  }  }  return  null  ;  }  	Jsoup_87_HtmlTreeBuilder_13_1	315	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1692	if  (next.normalName().equals(elName))  	[BUGGY]  if  (  next  .  nodeName  (  )  .  equals  (  elName  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  popStackToClose  [TYPE]  void  [PARAMETER]  String  elName  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  next  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  String  elName  [TYPE]  int  MaxScopeSearchDepth  pos  [TYPE]  FormElement  formElement  [CONTEXT]  void  popStackToClose  (  String  elName  )  {  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  next  =  stack  .  get  (  pos  )  ;  stack  .  remove  (  pos  )  ;  [BUGGY]  if  (  next  .  nodeName  (  )  .  equals  (  elName  )  )  break  ;  }  }  	Jsoup_87_HtmlTreeBuilder_13_2	337	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1693	if  (inSorted(next.normalName(),  elNames))  	[BUGGY]  if  (  inSorted  (  next  .  nodeName  (  )  ,  elNames  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  popStackToClose  [TYPE]  void  [PARAMETER]  elNames  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  next  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  elNames  specificScopeTarget  [TYPE]  int  MaxScopeSearchDepth  pos  [TYPE]  FormElement  formElement  [CONTEXT]  void  popStackToClose  (  String  .  .  .  elNames  )  {  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  next  =  stack  .  get  (  pos  )  ;  stack  .  remove  (  pos  )  ;  [BUGGY]  if  (  inSorted  (  next  .  nodeName  (  )  ,  elNames  )  )  break  ;  }  }  	Jsoup_87_HtmlTreeBuilder_13_3	347	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1694	if  (next.normalName().equals(elName))  {  	[BUGGY]  if  (  next  .  nodeName  (  )  .  equals  (  elName  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  popStackToBefore  [TYPE]  void  [PARAMETER]  String  elName  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  next  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  String  elName  [TYPE]  int  MaxScopeSearchDepth  pos  [TYPE]  FormElement  formElement  [CONTEXT]  void  popStackToBefore  (  String  elName  )  {  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  next  =  stack  .  get  (  pos  )  ;  [BUGGY]  if  (  next  .  nodeName  (  )  .  equals  (  elName  )  )  {  break  ;  }  else  {  stack  .  remove  (  pos  )  ;  }  }  }  	Jsoup_87_HtmlTreeBuilder_13_4	355	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1695	if  (StringUtil.in(next.normalName(),  nodeNames)  ||  next.normalName().equals( "html "))  	[BUGGY]  if  (  StringUtil  .  in  (  next  .  nodeName  (  )  ,  nodeNames  )  ||  next  .  nodeName  (  )  .  equals  (   "html "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  clearStackToContext  [TYPE]  void  [PARAMETER]  nodeNames  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  next  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  nodeNames  specificScopeTarget  [TYPE]  int  MaxScopeSearchDepth  pos  [TYPE]  FormElement  formElement  [CONTEXT]  private  void  clearStackToContext  (  String  .  .  .  nodeNames  )  {  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  next  =  stack  .  get  (  pos  )  ;  [BUGGY]  if  (  StringUtil  .  in  (  next  .  nodeName  (  )  ,  nodeNames  )  ||  next  .  nodeName  (  )  .  equals  (   "html "  )  )  break  ;  else  stack  .  remove  (  pos  )  ;  }  }  	Jsoup_87_HtmlTreeBuilder_13_5	378	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1696	String  name  =  node.normalName();  	[BUGGY]  String  name  =  node  .  nodeName  (  )  ;  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  resetInsertionMode  [TYPE]  void  [PARAMETER]  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  last  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  node  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  String  name  [TYPE]  int  MaxScopeSearchDepth  pos  [TYPE]  FormElement  formElement  [CONTEXT]  void  resetInsertionMode  (  )  {  boolean  last  =  false  ;  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  node  =  stack  .  get  (  pos  )  ;  if  (  pos  =  =  0  )  {  last  =  true  ;  node  =  contextElement  ;  }  [BUGGY]  String  name  =  node  .  nodeName  (  )  ;  if  (   "select "  .  equals  (  name  )  )  {  transition  (  HtmlTreeBuilderState  .  InSelect  )  ;  break  ;  //  frag  }  else  if  (  (   "td "  .  equals  (  name  )  ||   "th "  .  equals  (  name  )  &&  !last  )  )  {  transition  (  HtmlTreeBuilderState  .  InCell  )  ;  	Jsoup_87_HtmlTreeBuilder_13_6	420	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1697	final  String  elName  =  stack.get(pos).normalName();  	[BUGGY]  final  String  elName  =  stack  .  get  (  pos  )  .  nodeName  (  )  ;  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  inSpecificScope  [TYPE]  boolean  [PARAMETER]  String[]  targetNames  String[]  baseTypes  String[]  extraTypes  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  baseTypes  extraTypes  specificScopeTarget  targetNames  [TYPE]  String  elName  [TYPE]  int  MaxScopeSearchDepth  bottom  pos  top  [TYPE]  FormElement  formElement  [CONTEXT]  private  boolean  inSpecificScope  (  String[]  targetNames  ,  String[]  baseTypes  ,  String[]  extraTypes  )  {  final  int  bottom  =  stack  .  size  (  )  -1  ;  final  int  top  =  bottom  >  MaxScopeSearchDepth  ?  bottom  -  MaxScopeSearchDepth  :  0  ;    for  (  int  pos  =  bottom  ;  pos  >  =  top  ;  pos--  )  {  [BUGGY]  final  String  elName  =  stack  .  get  (  pos  )  .  nodeName  (  )  ;  if  (  inSorted  (  elName  ,  targetNames  )  )  return  true  ;  if  (  inSorted  (  elName  ,  baseTypes  )  )  return  false  ;  if  (  extraTypes  !  =  null  &&  inSorted  (  elName  ,  extraTypes  )  )  return  false  ;  }  return  false  ;  }  	Jsoup_87_HtmlTreeBuilder_13_7	476	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1698	String  elName  =  el.normalName();  	[BUGGY]  String  elName  =  el  .  nodeName  (  )  ;  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  inSelectScope  [TYPE]  boolean  [PARAMETER]  String  targetName  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  el  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  String  elName  targetName  [TYPE]  int  MaxScopeSearchDepth  pos  [TYPE]  FormElement  formElement  [CONTEXT]  boolean  inSelectScope  (  String  targetName  )  {  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  el  =  stack  .  get  (  pos  )  ;  [BUGGY]  String  elName  =  el  .  nodeName  (  )  ;  if  (  elName  .  equals  (  targetName  )  )  return  true  ;  if  (  !inSorted  (  elName  ,  TagSearchSelectScope  )  )  //  all  elements  except  return  false  ;  }  Validate  .  fail  (   "Should  not  be  reachable "  )  ;  return  false  ;  }  	Jsoup_87_HtmlTreeBuilder_13_8	517	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1699	while  ((excludeTag  !=  null  &&  !currentElement().normalName().equals(excludeTag))  &&  inSorted(currentElement().normalName(),  TagSearchEndTags))  	[BUGGY]  while  (  (  excludeTag  !  =  null  &&  !currentElement  (  )  .  nodeName  (  )  .  equals  (  excludeTag  )  )  &&  inSorted  (  currentElement  (  )  .  nodeName  (  )  ,  TagSearchEndTags  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  generateImpliedEndTags  [TYPE]  void  [PARAMETER]  String  excludeTag  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  String  excludeTag  [TYPE]  int  MaxScopeSearchDepth  [TYPE]  FormElement  formElement  [CONTEXT]  void  generateImpliedEndTags  (  String  excludeTag  )  {  [BUGGY]  while  (  (  excludeTag  !  =  null  &&  !currentElement  (  )  .  nodeName  (  )  .  equals  (  excludeTag  )  )  &&  inSorted  (  currentElement  (  )  .  nodeName  (  )  ,  TagSearchEndTags  )  )  pop  (  )  ;  }  	Jsoup_87_HtmlTreeBuilder_13_9	569	2	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1700	String  name  =  el.normalName();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  isSpecial  [TYPE]  boolean  [PARAMETER]  Element  el  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  el  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  String  name  [TYPE]  int  MaxScopeSearchDepth  [TYPE]  FormElement  formElement  [CONTEXT]  boolean  isSpecial  (  Element  el  )  {    [BUGGY]  String  name  =  el  .  nodeName  (  )  ;  return  inSorted  (  name  ,  TagSearchSpecial  )  ;  }  	Jsoup_87_HtmlTreeBuilder_13_10	581	0	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1701	return  a.normalName().equals(b.normalName())  &&  	[BUGGY]  return  a  .  nodeName  (  )  .  equals  (  b  .  nodeName  (  )  )  &&  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  isSameFormattingElement  [TYPE]  boolean  [PARAMETER]  Element  a  Element  b  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  a  b  contextElement  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  int  MaxScopeSearchDepth  [TYPE]  FormElement  formElement  [CONTEXT]  private  boolean  isSameFormattingElement  (  Element  a  ,  Element  b  )  {  [BUGGY]  return  a  .  nodeName  (  )  .  equals  (  b  .  nodeName  (  )  )  &&  a  .  attributes  (  )  .  equals  (  b  .  attributes  (  )  )  ;  }  	Jsoup_87_HtmlTreeBuilder_13_11	618	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1702	Element  newEl  =  insertStartTag(entry.normalName());    	[BUGGY]  Element  newEl  =  insertStartTag  (  entry  .  nodeName  (  )  )  ;  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  reconstructFormattingElements  [TYPE]  void  [PARAMETER]  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  skip  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  entry  headElement  last  newEl  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  int  MaxScopeSearchDepth  pos  size  [TYPE]  FormElement  formElement  [CONTEXT]  void  reconstructFormattingElements  (  )  {  Element  last  =  lastFormattingElement  (  )  ;  if  (  last  =  =  null  ||  onStack  (  last  )  )  return  ;  Element  entry  =  last  ;  int  size  =  formattingElements  .  size  (  )  ;  int  pos  =  size  -  1  ;  boolean  skip  =  false  ;  while  (  true  )  {  if  (  pos  =  =  0  )  {  //  step  4  .  if  none  before  ,  skip  to  8  skip  =  true  ;  break  ;  }  entry  =  formattingElements  .  get  (  --pos  )  ;  //  step  5  .  one  earlier  than  entry  if  (  entry  =  =  null  ||  onStack  (  entry  )  )  //  step  6  -  neither  marker  nor  on  stack  break  ;  //  jump  to  8  ,  else  continue  back  to  4  }  while  (  true  )  {  if  (  !skip  )  //  step  7:  on  later  than  entry  entry  =  formattingElements  .  get  (  ++pos  )  ;  Validate  .  notNull  (  entry  )  ;  //  should  not  occur  ,  as  we  break  at  last  element  skip  =  false  ;  //  can  only  skip  increment  from  4  .  [BUGGY]  Element  newEl  =  insertStartTag  (  entry  .  nodeName  (  )  )  ;  newEl  .  attributes  (  )  .  addAll  (  entry  .  attributes  (  )  )  ;    formattingElements  .  set  (  pos  ,  newEl  )  ;  	Jsoup_87_HtmlTreeBuilder_13_12	649	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1703	else  if  (next.normalName().equals(nodeName))  	[BUGGY]  else  if  (  next  .  nodeName  (  )  .  equals  (  nodeName  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  getActiveFormattingElement  [TYPE]  Element  [PARAMETER]  String  nodeName  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  headElement  next  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  String  nodeName  [TYPE]  int  MaxScopeSearchDepth  pos  [TYPE]  FormElement  formElement  [CONTEXT]  Element  getActiveFormattingElement  (  String  nodeName  )  {  for  (  int  pos  =  formattingElements  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  next  =  formattingElements  .  get  (  pos  )  ;  if  (  next  =  =  null  )  //  scope  marker  break  ;  [BUGGY]  else  if  (  next  .  nodeName  (  )  .  equals  (  nodeName  )  )  return  next  ;  }  return  null  ;  }  	Jsoup_87_HtmlTreeBuilder_13_13	689	1	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1704	if  (el.normalName().equals( "li "))  {  	[BUGGY]  if  (  el  .  nodeName  (  )  .  equals  (   "li "  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  removeFromActiveFormattingElements  (  remainingA  )  ;  tb  .  removeFromStack  (  remainingA  )  ;  }  }  tb  .  reconstructFormattingElements  (  )  ;  Element  a  =  tb  .  insert  (  startTag  )  ;  tb  .  pushActiveFormattingElements  (  a  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartEmptyFormatters  )  )  {  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insertEmpty  (  startTag  )  ;  tb  .  framesetOk  (  false  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartPClosers  )  )  {  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  tb  .  insert  (  startTag  )  ;  }  else  if  (  name  .  equals  (   "span "  )  )  {  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  startTag  )  ;  }  else  if  (  name  .  equals  (   "li "  )  )  {  tb  .  framesetOk  (  false  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  for  (  int  i  =  stack  .  size  (  )  -  1  ;  i  >  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  [BUGGY]  if  (  el  .  nodeName  (  )  .  equals  (   "li "  )  )  {  tb  .  processEndTag  (   "li "  )  ;  break  ;  }  if  (  tb  .  isSpecial  (  el  )  &&  !StringUtil  .  inSorted  (  el  .  nodeName  (  )  ,  Constants  .  InBodyStartLiBreakers  )  )  break  ;  	Jsoup_87_HtmlTreeBuilderState_36_1	315	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1705	if  (tb.isSpecial(el)  &&  !StringUtil.inSorted(el.normalName(),  Constants.InBodyStartLiBreakers))  	[BUGGY]  if  (  tb  .  isSpecial  (  el  )  &&  !StringUtil  .  inSorted  (  el  .  nodeName  (  )  ,  Constants  .  InBodyStartLiBreakers  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  reconstructFormattingElements  (  )  ;  Element  a  =  tb  .  insert  (  startTag  )  ;  tb  .  pushActiveFormattingElements  (  a  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartEmptyFormatters  )  )  {  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insertEmpty  (  startTag  )  ;  tb  .  framesetOk  (  false  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartPClosers  )  )  {  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  tb  .  insert  (  startTag  )  ;  }  else  if  (  name  .  equals  (   "span "  )  )  {  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  startTag  )  ;  }  else  if  (  name  .  equals  (   "li "  )  )  {  tb  .  framesetOk  (  false  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  for  (  int  i  =  stack  .  size  (  )  -  1  ;  i  >  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  if  (  el  .  nodeName  (  )  .  equals  (   "li "  )  )  {  tb  .  processEndTag  (   "li "  )  ;  break  ;  }  [BUGGY]  if  (  tb  .  isSpecial  (  el  )  &&  !StringUtil  .  inSorted  (  el  .  nodeName  (  )  ,  Constants  .  InBodyStartLiBreakers  )  )  break  ;  }  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_2	319	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1706	if  (stack.size()  ==  1  ||  (stack.size()  >  2  &&  !stack.get(1).normalName().equals( "body ")))  {  	[BUGGY]  if  (  stack  .  size  (  )  =  =  1  ||  (  stack  .  size  (  )  >  2  &&  !stack  .  get  (  1  )  .  nodeName  (  )  .  equals  (   "body "  )  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  Element  el  =  stack  .  get  (  i  )  ;  if  (  el  .  nodeName  (  )  .  equals  (   "li "  )  )  {  tb  .  processEndTag  (   "li "  )  ;  break  ;  }  if  (  tb  .  isSpecial  (  el  )  &&  !StringUtil  .  inSorted  (  el  .  nodeName  (  )  ,  Constants  .  InBodyStartLiBreakers  )  )  break  ;  }  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  tb  .  insert  (  startTag  )  ;  }  else  if  (  name  .  equals  (   "html "  )  )  {  tb  .  error  (  this  )  ;  Element  html  =  tb  .  getStack  (  )  .  get  (  0  )  ;  for  (  Attribute  attribute  :  startTag  .  getAttributes  (  )  )  {  if  (  !html  .  hasAttr  (  attribute  .  getKey  (  )  )  )  html  .  attributes  (  )  .  put  (  attribute  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartToHead  )  )  {  return  tb  .  process  (  t  ,  InHead  )  ;  }  else  if  (  name  .  equals  (   "body "  )  )  {  tb  .  error  (  this  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  [BUGGY]  if  (  stack  .  size  (  )  =  =  1  ||  (  stack  .  size  (  )  >  2  &&  !stack  .  get  (  1  )  .  nodeName  (  )  .  equals  (   "body "  )  )  )  {  return  false  ;  //  ignore  }  else  {  tb  .  framesetOk  (  false  )  ;  Element  body  =  stack  .  get  (  1  )  ;  	Jsoup_87_HtmlTreeBuilderState_36_3	339	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1707	if  (stack.size()  ==  1  ||  (stack.size()  >  2  &&  !stack.get(1).normalName().equals( "body ")))  {  	[BUGGY]  if  (  stack  .  size  (  )  =  =  1  ||  (  stack  .  size  (  )  >  2  &&  !stack  .  get  (  1  )  .  nodeName  (  )  .  equals  (   "body "  )  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  Element  html  =  tb  .  getStack  (  )  .  get  (  0  )  ;  for  (  Attribute  attribute  :  startTag  .  getAttributes  (  )  )  {  if  (  !html  .  hasAttr  (  attribute  .  getKey  (  )  )  )  html  .  attributes  (  )  .  put  (  attribute  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartToHead  )  )  {  return  tb  .  process  (  t  ,  InHead  )  ;  }  else  if  (  name  .  equals  (   "body "  )  )  {  tb  .  error  (  this  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  if  (  stack  .  size  (  )  =  =  1  ||  (  stack  .  size  (  )  >  2  &&  !stack  .  get  (  1  )  .  nodeName  (  )  .  equals  (   "body "  )  )  )  {  return  false  ;  //  ignore  }  else  {  tb  .  framesetOk  (  false  )  ;  Element  body  =  stack  .  get  (  1  )  ;  for  (  Attribute  attribute  :  startTag  .  getAttributes  (  )  )  {  if  (  !body  .  hasAttr  (  attribute  .  getKey  (  )  )  )  body  .  attributes  (  )  .  put  (  attribute  )  ;  }  }  }  else  if  (  name  .  equals  (   "frameset "  )  )  {  tb  .  error  (  this  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  [BUGGY]  if  (  stack  .  size  (  )  =  =  1  ||  (  stack  .  size  (  )  >  2  &&  !stack  .  get  (  1  )  .  nodeName  (  )  .  equals  (   "body "  )  )  )  {  return  false  ;  //  ignore  }  else  if  (  !tb  .  framesetOk  (  )  )  {  return  false  ;  //  ignore  frameset  }  else  {  	Jsoup_87_HtmlTreeBuilderState_36_4	353	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1708	if  (StringUtil.inSorted(tb.currentElement().normalName(),  Constants.Headings))  {  	[BUGGY]  if  (  StringUtil  .  inSorted  (  tb  .  currentElement  (  )  .  nodeName  (  )  ,  Constants  .  Headings  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  body  .  attributes  (  )  .  put  (  attribute  )  ;  }  }  }  else  if  (  name  .  equals  (   "frameset "  )  )  {  tb  .  error  (  this  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  if  (  stack  .  size  (  )  =  =  1  ||  (  stack  .  size  (  )  >  2  &&  !stack  .  get  (  1  )  .  nodeName  (  )  .  equals  (   "body "  )  )  )  {  return  false  ;  //  ignore  }  else  if  (  !tb  .  framesetOk  (  )  )  {  return  false  ;  //  ignore  frameset  }  else  {  Element  second  =  stack  .  get  (  1  )  ;  if  (  second  .  parent  (  )  !  =  null  )  second  .  remove  (  )  ;  while  (  stack  .  size  (  )  >  1  )  stack  .  remove  (  stack  .  size  (  )  -1  )  ;  tb  .  insert  (  startTag  )  ;  tb  .  transition  (  InFrameset  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  Headings  )  )  {  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  [BUGGY]  if  (  StringUtil  .  inSorted  (  tb  .  currentElement  (  )  .  nodeName  (  )  ,  Constants  .  Headings  )  )  {  tb  .  error  (  this  )  ;  tb  .  pop  (  )  ;  }  tb  .  insert  (  startTag  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartPreListing  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_5	372	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1709	if  (StringUtil.inSorted(el.normalName(),  Constants.DdDt))  {  tb.processEndTag(el.normalName());  if  (tb.isSpecial(el)  &&  !StringUtil.inSorted(el.normalName(),  Constants.InBodyStartLiBreakers))  	[BUGGY]  if  (  StringUtil  .  inSorted  (  el  .  nodeName  (  )  ,  Constants  .  DdDt  )  )  {  tb  .  processEndTag  (  el  .  nodeName  (  )  )  ;  if  (  tb  .  isSpecial  (  el  )  &&  !StringUtil  .  inSorted  (  el  .  nodeName  (  )  ,  Constants  .  InBodyStartLiBreakers  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  error  (  this  )  ;  tb  .  pop  (  )  ;  }  tb  .  insert  (  startTag  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartPreListing  )  )  {  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  tb  .  insert  (  startTag  )  ;  tb  .  reader  .  matchConsume  (   "\n "  )  ;  //  ignore  LF  if  next  token  tb  .  framesetOk  (  false  )  ;  }  else  if  (  name  .  equals  (   "form "  )  )  {  if  (  tb  .  getFormElement  (  )  !  =  null  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  tb  .  insertForm  (  startTag  ,  true  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  DdDt  )  )  {  tb  .  framesetOk  (  false  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  for  (  int  i  =  stack  .  size  (  )  -  1  ;  i  >  0  ;  i--  )  {  Element  el  =  stack  .  get  (  i  )  ;  [BUGGY]  if  (  StringUtil  .  inSorted  (  el  .  nodeName  (  )  ,  Constants  .  DdDt  )  )  {  tb  .  processEndTag  (  el  .  nodeName  (  )  )  ;  break  ;  }  if  (  tb  .  isSpecial  (  el  )  &&  !StringUtil  .  inSorted  (  el  .  nodeName  (  )  ,  Constants  .  InBodyStartLiBreakers  )  )  break  ;  	Jsoup_87_HtmlTreeBuilderState_36_6	398	3	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1710	if  (tb.currentElement().normalName().equals( "option "))  	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  transition  (  Text  )  ;  }  else  if  (  name  .  equals  (   "xmp "  )  )  {  if  (  tb  .  inButtonScope  (   "p "  )  )  {  tb  .  processEndTag  (   "p "  )  ;  }  tb  .  reconstructFormattingElements  (  )  ;  tb  .  framesetOk  (  false  )  ;  handleRawtext  (  startTag  ,  tb  )  ;  }  else  if  (  name  .  equals  (   "iframe "  )  )  {  tb  .  framesetOk  (  false  )  ;  handleRawtext  (  startTag  ,  tb  )  ;  }  else  if  (  name  .  equals  (   "noembed "  )  )  {  handleRawtext  (  startTag  ,  tb  )  ;  }  else  if  (  name  .  equals  (   "select "  )  )  {  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  startTag  )  ;  tb  .  framesetOk  (  false  )  ;  HtmlTreeBuilderState  state  =  tb  .  state  (  )  ;  if  (  state  .  equals  (  InTable  )  ||  state  .  equals  (  InCaption  )  ||  state  .  equals  (  InTableBody  )  ||  state  .  equals  (  InRow  )  ||  state  .  equals  (  InCell  )  )  tb  .  transition  (  InSelectInTable  )  ;  else  tb  .  transition  (  InSelect  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartOptions  )  )  {  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  processEndTag  (   "option "  )  ;  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  startTag  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartRuby  )  )  {  if  (  tb  .  inScope  (   "ruby "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_7	531	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1711	if  (!tb.currentElement().normalName().equals( "ruby "))  {  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "ruby "  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  handleRawtext  (  startTag  ,  tb  )  ;  }  else  if  (  name  .  equals  (   "iframe "  )  )  {  tb  .  framesetOk  (  false  )  ;  handleRawtext  (  startTag  ,  tb  )  ;  }  else  if  (  name  .  equals  (   "noembed "  )  )  {  handleRawtext  (  startTag  ,  tb  )  ;  }  else  if  (  name  .  equals  (   "select "  )  )  {  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  startTag  )  ;  tb  .  framesetOk  (  false  )  ;  HtmlTreeBuilderState  state  =  tb  .  state  (  )  ;  if  (  state  .  equals  (  InTable  )  ||  state  .  equals  (  InCaption  )  ||  state  .  equals  (  InTableBody  )  ||  state  .  equals  (  InRow  )  ||  state  .  equals  (  InCell  )  )  tb  .  transition  (  InSelectInTable  )  ;  else  tb  .  transition  (  InSelect  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartOptions  )  )  {  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  processEndTag  (   "option "  )  ;  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  startTag  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartRuby  )  )  {  if  (  tb  .  inScope  (   "ruby "  )  )  {  tb  .  generateImpliedEndTags  (  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "ruby "  )  )  {  tb  .  error  (  this  )  ;  tb  .  popStackToBefore  (   "ruby "  )  ;  //  i  .  e  .  close  up  to  but  not  include  name  }  tb  .  insert  (  startTag  )  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_8	538	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1712	}  else  if  (!tb.inScope(formatEl.normalName()))  {  	[BUGGY]  }  else  if  (  !tb  .  inScope  (  formatEl  .  nodeName  (  )  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  startTag  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartDrop  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  reconstructFormattingElements  (  )  ;  tb  .  insert  (  startTag  )  ;  }  break  ;  case  EndTag:  Token  .  EndTag  endTag  =  t  .  asEndTag  (  )  ;  name  =  endTag  .  normalName  (  )  ;  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyEndAdoptionFormatters  )  )  {  for  (  int  i  =  0  ;  i  <  8  ;  i++  )  {  Element  formatEl  =  tb  .  getActiveFormattingElement  (  name  )  ;  if  (  formatEl  =  =  null  )  return  anyOtherEndTag  (  t  ,  tb  )  ;  else  if  (  !tb  .  onStack  (  formatEl  )  )  {  tb  .  error  (  this  )  ;  tb  .  removeFromActiveFormattingElements  (  formatEl  )  ;  return  true  ;  [BUGGY]  }  else  if  (  !tb  .  inScope  (  formatEl  .  nodeName  (  )  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  if  (  tb  .  currentElement  (  )  !  =  formatEl  )  tb  .  error  (  this  )  ;  	Jsoup_87_HtmlTreeBuilderState_36_9	574	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1713	tb.popStackToClose(formatEl.normalName());  	[BUGGY]  tb  .  popStackToClose  (  formatEl  .  nodeName  (  )  )  ;  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  return  true  ;  }  else  if  (  !tb  .  inScope  (  formatEl  .  nodeName  (  )  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  if  (  tb  .  currentElement  (  )  !  =  formatEl  )  tb  .  error  (  this  )  ;  Element  furthestBlock  =  null  ;  Element  commonAncestor  =  null  ;  boolean  seenFormattingElement  =  false  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;    final  int  stackSize  =  stack  .  size  (  )  ;  for  (  int  si  =  0  ;  si  <  stackSize  &&  si  <  64  ;  si++  )  {  Element  el  =  stack  .  get  (  si  )  ;  if  (  el  =  =  formatEl  )  {  commonAncestor  =  stack  .  get  (  si  -  1  )  ;  seenFormattingElement  =  true  ;  }  else  if  (  seenFormattingElement  &&  tb  .  isSpecial  (  el  )  )  {  furthestBlock  =  el  ;  break  ;  }  }  if  (  furthestBlock  =  =  null  )  {  [BUGGY]  tb  .  popStackToClose  (  formatEl  .  nodeName  (  )  )  ;  tb  .  removeFromActiveFormattingElements  (  formatEl  )  ;  return  true  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_10	598	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1714	if  (StringUtil.inSorted(commonAncestor.normalName(),  Constants.InBodyEndTableFosters))  {  	[BUGGY]  if  (  StringUtil  .  inSorted  (  commonAncestor  .  nodeName  (  )  ,  Constants  .  InBodyEndTableFosters  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  if  (  tb  .  onStack  (  node  )  )  node  =  tb  .  aboveOnStack  (  node  )  ;  if  (  !tb  .  isInActiveFormattingElements  (  node  )  )  {  //  note  no  bookmark  check  tb  .  removeFromStack  (  node  )  ;  continue  ;  }  else  if  (  node  =  =  formatEl  )  break  ;  Element  replacement  =  new  Element  (  Tag  .  valueOf  (  node  .  nodeName  (  )  ,  ParseSettings  .  preserveCase  )  ,  tb  .  getBaseUri  (  )  )  ;  tb  .  replaceActiveFormattingElement  (  node  ,  replacement  )  ;  tb  .  replaceOnStack  (  node  ,  replacement  )  ;  node  =  replacement  ;  if  (  lastNode  =  =  furthestBlock  )  {    }  if  (  lastNode  .  parent  (  )  !  =  null  )  lastNode  .  remove  (  )  ;  node  .  appendChild  (  lastNode  )  ;  lastNode  =  node  ;  }  [BUGGY]  if  (  StringUtil  .  inSorted  (  commonAncestor  .  nodeName  (  )  ,  Constants  .  InBodyEndTableFosters  )  )  {  if  (  lastNode  .  parent  (  )  !  =  null  )  lastNode  .  remove  (  )  ;  tb  .  insertInFosterParent  (  lastNode  )  ;  }  else  {  if  (  lastNode  .  parent  (  )  !  =  null  )  	Jsoup_87_HtmlTreeBuilderState_36_11	633	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1715	if  (!tb.currentElement().normalName().equals(name))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  }  else  {  if  (  lastNode  .  parent  (  )  !  =  null  )  lastNode  .  remove  (  )  ;  commonAncestor  .  appendChild  (  lastNode  )  ;  }  Element  adopter  =  new  Element  (  formatEl  .  tag  (  )  ,  tb  .  getBaseUri  (  )  )  ;  adopter  .  attributes  (  )  .  addAll  (  formatEl  .  attributes  (  )  )  ;  Node[]  childNodes  =  furthestBlock  .  childNodes  (  )  .  toArray  (  new  Node[furthestBlock  .  childNodeSize  (  )  ]  )  ;  for  (  Node  childNode  :  childNodes  )  {  adopter  .  appendChild  (  childNode  )  ;  //  append  will  reparent  .  thus  the  clone  to  avoid  concurrent  mod  .  }  furthestBlock  .  appendChild  (  adopter  )  ;  tb  .  removeFromActiveFormattingElements  (  formatEl  )  ;  tb  .  removeFromStack  (  formatEl  )  ;  tb  .  insertOnStackAfter  (  furthestBlock  ,  adopter  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyEndClosers  )  )  {  if  (  !tb  .  inScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  name  .  equals  (   "span "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_12	662	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1716	if  (!tb.currentElement().normalName().equals(name))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  removeFromActiveFormattingElements  (  formatEl  )  ;  tb  .  removeFromStack  (  formatEl  )  ;  tb  .  insertOnStackAfter  (  furthestBlock  ,  adopter  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyEndClosers  )  )  {  if  (  !tb  .  inScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  name  .  equals  (   "span "  )  )  {  return  anyOtherEndTag  (  t  ,  tb  )  ;  }  else  if  (  name  .  equals  (   "li "  )  )  {  if  (  !tb  .  inListItemScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  name  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  name  .  equals  (   "body "  )  )  {  if  (  !tb  .  inScope  (   "body "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_13	675	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1717	if  (!tb.currentElement().normalName().equals(name))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  name  .  equals  (   "body "  )  )  {  if  (  !tb  .  inScope  (   "body "  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  transition  (  AfterBody  )  ;  }  }  else  if  (  name  .  equals  (   "html "  )  )  {  boolean  notIgnored  =  tb  .  processEndTag  (   "body "  )  ;  if  (  notIgnored  )  return  tb  .  process  (  endTag  )  ;  }  else  if  (  name  .  equals  (   "form "  )  )  {  Element  currentForm  =  tb  .  getFormElement  (  )  ;  tb  .  setFormElement  (  null  )  ;  if  (  currentForm  =  =  null  ||  !tb  .  inScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  removeFromStack  (  currentForm  )  ;  }  }  else  if  (  name  .  equals  (   "p "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_14	699	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1718	if  (!tb.currentElement().normalName().equals(name))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  }  }  else  if  (  name  .  equals  (   "html "  )  )  {  boolean  notIgnored  =  tb  .  processEndTag  (   "body "  )  ;  if  (  notIgnored  )  return  tb  .  process  (  endTag  )  ;  }  else  if  (  name  .  equals  (   "form "  )  )  {  Element  currentForm  =  tb  .  getFormElement  (  )  ;  tb  .  setFormElement  (  null  )  ;  if  (  currentForm  =  =  null  ||  !tb  .  inScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  removeFromStack  (  currentForm  )  ;  }  }  else  if  (  name  .  equals  (   "p "  )  )  {  if  (  !tb  .  inButtonScope  (  name  )  )  {  tb  .  error  (  this  )  ;  tb  .  processStartTag  (  name  )  ;  //  if  no  p  to  close  ,  creates  an  empty  <p></p>  return  tb  .  process  (  endTag  )  ;  }  else  {  tb  .  generateImpliedEndTags  (  name  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  DdDt  )  )  {  if  (  !tb  .  inScope  (  name  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_15	711	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1719	if  (!tb.currentElement().normalName().equals(name))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  removeFromStack  (  currentForm  )  ;  }  }  else  if  (  name  .  equals  (   "p "  )  )  {  if  (  !tb  .  inButtonScope  (  name  )  )  {  tb  .  error  (  this  )  ;  tb  .  processStartTag  (  name  )  ;  //  if  no  p  to  close  ,  creates  an  empty  <p></p>  return  tb  .  process  (  endTag  )  ;  }  else  {  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  DdDt  )  )  {  if  (  !tb  .  inScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  name  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  Headings  )  )  {  if  (  !tb  .  inScope  (  Constants  .  Headings  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_16	721	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1720	if  (!tb.currentElement().normalName().equals(name))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  error  (  this  )  ;  tb  .  processStartTag  (  name  )  ;  //  if  no  p  to  close  ,  creates  an  empty  <p></p>  return  tb  .  process  (  endTag  )  ;  }  else  {  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  DdDt  )  )  {  if  (  !tb  .  inScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  Headings  )  )  {  if  (  !tb  .  inScope  (  Constants  .  Headings  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  name  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  Constants  .  Headings  )  ;  }  }  else  if  (  name  .  equals  (   "sarcasm "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_17	731	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1721	if  (!tb.currentElement().normalName().equals(name))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  Node[]  childNodes  [TYPE]  Character  c  [TYPE]  EndTag  endTag  [TYPE]  Attribute  attr  attribute  [TYPE]  Element  a  adopter  body  commonAncestor  currentForm  el  form  formatEl  furthestBlock  html  lastNode  node  remainingA  replacement  second  [TYPE]  Node  childNode  [TYPE]  ArrayList  stack  [TYPE]  Attributes  inputAttribs  [TYPE]  Token  t  [TYPE]  String  name  prompt  [TYPE]  StartTag  startTag  [TYPE]  int  i  j  si  stackSize  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  HtmlTreeBuilderState  state  [TYPE]  boolean  false  notIgnored  seenFormattingElement  true  [CONTEXT]  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  }  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  Headings  )  )  {  if  (  !tb  .  inScope  (  Constants  .  Headings  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  Constants  .  Headings  )  ;  }  }  else  if  (  name  .  equals  (   "sarcasm "  )  )  {  return  anyOtherEndTag  (  t  ,  tb  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InBodyStartApplets  )  )  {  if  (  !tb  .  inScope  (   "name "  )  )  {  if  (  !tb  .  inScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  tb  .  generateImpliedEndTags  (  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  tb  .  clearFormattingElementsToLastMarker  (  )  ;  }  }  else  if  (  name  .  equals  (   "br "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_18	745	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1722	String  name  =  t.asEndTag().normalName;    	[BUGGY]  String  name  =  tb  .  settings  .  normalizeTag  (  t  .  asEndTag  (  )  .  name  (  )  )  ;  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  anyOtherEndTag  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Element  node  [TYPE]  ArrayList  stack  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  int  pos  [CONTEXT]  boolean  anyOtherEndTag  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  [BUGGY]  String  name  =  tb  .  settings  .  normalizeTag  (  t  .  asEndTag  (  )  .  name  (  )  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  node  =  stack  .  get  (  pos  )  ;  if  (  node  .  nodeName  (  )  .  equals  (  name  )  )  {  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !name  .  equals  (  tb  .  currentElement  (  )  .  nodeName  (  )  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  break  ;  }  else  {  if  (  tb  .  isSpecial  (  node  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  }  }  return  true  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_19	768	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1723	if  (node.normalName().equals(name))  {  if  (!name.equals(tb.currentElement().normalName()))  	[BUGGY]  if  (  node  .  nodeName  (  )  .  equals  (  name  )  )  {  if  (  !name  .  equals  (  tb  .  currentElement  (  )  .  nodeName  (  )  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  anyOtherEndTag  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  7  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Element  node  [TYPE]  ArrayList  stack  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  int  pos  [CONTEXT]  boolean  anyOtherEndTag  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  String  name  =  tb  .  settings  .  normalizeTag  (  t  .  asEndTag  (  )  .  name  (  )  )  ;  ArrayList<Element>  stack  =  tb  .  getStack  (  )  ;  for  (  int  pos  =  stack  .  size  (  )  -1  ;  pos  >  =  0  ;  pos--  )  {  Element  node  =  stack  .  get  (  pos  )  ;  [BUGGY]  if  (  node  .  nodeName  (  )  .  equals  (  name  )  )  {  tb  .  generateImpliedEndTags  (  name  )  ;  if  (  !name  .  equals  (  tb  .  currentElement  (  )  .  nodeName  (  )  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  break  ;  }  else  {  if  (  tb  .  isSpecial  (  node  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  }  }  return  true  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_20	772	2	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1724	if  (tb.currentElement().normalName().equals( "html "))  	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  9  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  processed  true  [TYPE]  EndTag  endTag  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  StartTag  startTag  [CONTEXT]  }  else  {  return  anythingElse  (  t  ,  tb  )  ;  }  return  true  ;  //  todo:  check  if  should  return  processed  http://www  .  whatwg  .  org/specs/web-apps/current-work/multipage/tree-construction  .  html#parsing-main-intable  }  else  if  (  t  .  isEndTag  (  )  )  {  Token  .  EndTag  endTag  =  t  .  asEndTag  (  )  ;  String  name  =  endTag  .  normalName  (  )  ;  if  (  name  .  equals  (   "table "  )  )  {  if  (  !tb  .  inTableScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  popStackToClose  (   "table "  )  ;  }  tb  .  resetInsertionMode  (  )  ;  }  else  if  (  StringUtil  .  in  (  name  ,   "body "  ,   "caption "  ,   "col "  ,   "colgroup "  ,   "html "  ,   "tbody "  ,   "td "  ,   "tfoot "  ,   "th "  ,   "thead "  ,   "tr "  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  return  anythingElse  (  t  ,  tb  )  ;  }  return  true  ;  //  todo:  as  above  todo  }  else  if  (  t  .  isEOF  (  )  )  {  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  tb  .  error  (  this  )  ;  return  true  ;  //  stops  parsing  }  return  anythingElse  (  t  ,  tb  )  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_21	887	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1725	if  (StringUtil.in(tb.currentElement().normalName(),   "table ",   "tbody ",   "tfoot ",   "thead ",   "tr "))  {  	[BUGGY]  if  (  StringUtil  .  in  (  tb  .  currentElement  (  )  .  nodeName  (  )  ,   "table "  ,   "tbody "  ,   "tfoot "  ,   "thead "  ,   "tr "  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  anythingElse  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  9  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  processed  true  [TYPE]  Token  t  [CONTEXT]  boolean  anythingElse  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  tb  .  error  (  this  )  ;  boolean  processed  ;  [BUGGY]  if  (  StringUtil  .  in  (  tb  .  currentElement  (  )  .  nodeName  (  )  ,   "table "  ,   "tbody "  ,   "tfoot "  ,   "thead "  ,   "tr "  )  )  {  tb  .  setFosterInserts  (  true  )  ;  processed  =  tb  .  process  (  t  ,  InBody  )  ;  tb  .  setFosterInserts  (  false  )  ;  }  else  {  processed  =  tb  .  process  (  t  ,  InBody  )  ;  }  return  processed  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_22	897	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1726	if  (StringUtil.in(tb.currentElement().normalName(),   "table ",   "tbody ",   "tfoot ",   "thead ",   "tr "))  {  	[BUGGY]  if  (  StringUtil  .  in  (  tb  .  currentElement  (  )  .  nodeName  (  )  ,   "table "  ,   "tbody "  ,   "tfoot "  ,   "thead "  ,   "tr "  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  10  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Character  c  [TYPE]  Token  t  [TYPE]  String  character  [CONTEXT]  boolean  process  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  switch  (  t  .  type  )  {  case  Character:  Token  .  Character  c  =  t  .  asCharacter  (  )  ;  if  (  c  .  getData  (  )  .  equals  (  nullString  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  getPendingTableCharacters  (  )  .  add  (  c  .  getData  (  )  )  ;  }  break  ;  default:  if  (  tb  .  getPendingTableCharacters  (  )  .  size  (  )  >  0  )  {  for  (  String  character  :  tb  .  getPendingTableCharacters  (  )  )  {  if  (  !isWhitespace  (  character  )  )  {  tb  .  error  (  this  )  ;  [BUGGY]  if  (  StringUtil  .  in  (  tb  .  currentElement  (  )  .  nodeName  (  )  ,   "table "  ,   "tbody "  ,   "tfoot "  ,   "thead "  ,   "tr "  )  )  {  tb  .  setFosterInserts  (  true  )  ;  tb  .  process  (  new  Token  .  Character  (  )  .  data  (  character  )  ,  InBody  )  ;  tb  .  setFosterInserts  (  false  )  ;  }  else  {  tb  .  process  (  new  Token  .  Character  (  )  .  data  (  character  )  ,  InBody  )  ;  	Jsoup_87_HtmlTreeBuilderState_36_23	926	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1727	if  (!tb.currentElement().normalName().equals( "caption "))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "caption "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  11  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  processed  true  [TYPE]  EndTag  endTag  [TYPE]  Token  t  [TYPE]  String  name  [CONTEXT]  boolean  process  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  if  (  t  .  isEndTag  (  )  &&  t  .  asEndTag  (  )  .  normalName  (  )  .  equals  (   "caption "  )  )  {  Token  .  EndTag  endTag  =  t  .  asEndTag  (  )  ;  String  name  =  endTag  .  normalName  (  )  ;  if  (  !tb  .  inTableScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  generateImpliedEndTags  (  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "caption "  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (   "caption "  )  ;  tb  .  clearFormattingElementsToLastMarker  (  )  ;  tb  .  transition  (  InTable  )  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_24	954	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1728	if  (tb.currentElement().normalName().equals( "html "))  {    	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  12  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  EndTag  endTag  [TYPE]  Token  t  [TYPE]  StartTag  startTag  [CONTEXT]  tb  .  insert  (  t  .  asCharacter  (  )  )  ;  return  true  ;  }  switch  (  t  .  type  )  {  case  Comment:  tb  .  insert  (  t  .  asComment  (  )  )  ;  break  ;  case  Doctype:  tb  .  error  (  this  )  ;  break  ;  case  StartTag:  Token  .  StartTag  startTag  =  t  .  asStartTag  (  )  ;  switch  (  startTag  .  normalName  (  )  )  {  case   "html ":  return  tb  .  process  (  t  ,  InBody  )  ;  case   "col ":  tb  .  insertEmpty  (  startTag  )  ;  break  ;  default:  return  anythingElse  (  t  ,  tb  )  ;  }  break  ;  case  EndTag:  Token  .  EndTag  endTag  =  t  .  asEndTag  (  )  ;  if  (  endTag  .  normalName  .  equals  (   "colgroup "  )  )  {  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  pop  (  )  ;  tb  .  transition  (  InTable  )  ;  	Jsoup_87_HtmlTreeBuilderState_36_25	1007	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1729	if  (tb.currentElement().normalName().equals( "html "))  	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  12  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  EndTag  endTag  [TYPE]  Token  t  [TYPE]  StartTag  startTag  [CONTEXT]  Token  .  StartTag  startTag  =  t  .  asStartTag  (  )  ;  switch  (  startTag  .  normalName  (  )  )  {  case   "html ":  return  tb  .  process  (  t  ,  InBody  )  ;  case   "col ":  tb  .  insertEmpty  (  startTag  )  ;  break  ;  default:  return  anythingElse  (  t  ,  tb  )  ;  }  break  ;  case  EndTag:  Token  .  EndTag  endTag  =  t  .  asEndTag  (  )  ;  if  (  endTag  .  normalName  .  equals  (   "colgroup "  )  )  {  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  pop  (  )  ;  tb  .  transition  (  InTable  )  ;  }  }  else  return  anythingElse  (  t  ,  tb  )  ;  break  ;  case  EOF:  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  return  true  ;  //  stop  parsing  ;  frag  case  else  return  anythingElse  (  t  ,  tb  )  ;  default:  return  anythingElse  (  t  ,  tb  )  ;  	Jsoup_87_HtmlTreeBuilderState_36_26	1018	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1730	tb.processEndTag(tb.currentElement().normalName());    	[BUGGY]  tb  .  processEndTag  (  tb  .  currentElement  (  )  .  nodeName  (  )  )  ;  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  exitTableBody  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  13  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Token  t  [CONTEXT]  private  boolean  exitTableBody  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  if  (  !  (  tb  .  inTableScope  (   "tbody "  )  ||  tb  .  inTableScope  (   "thead "  )  ||  tb  .  inScope  (   "tfoot "  )  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  tb  .  clearStackToTableBodyContext  (  )  ;  [BUGGY]  tb  .  processEndTag  (  tb  .  currentElement  (  )  .  nodeName  (  )  )  ;  return  tb  .  process  (  t  )  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_27	1089	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1731	if  (!tb.currentElement().normalName().equals(name))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  15  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  EndTag  endTag  [TYPE]  Token  t  [TYPE]  String  name  [CONTEXT]  boolean  process  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  if  (  t  .  isEndTag  (  )  )  {  Token  .  EndTag  endTag  =  t  .  asEndTag  (  )  ;  String  name  =  endTag  .  normalName  (  )  ;  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InCellNames  )  )  {  if  (  !tb  .  inTableScope  (  name  )  )  {  tb  .  error  (  this  )  ;  tb  .  transition  (  InRow  )  ;  //  might  not  be  in  scope  if  empty:  <td  />  and  processing  fake  end  tag  return  false  ;  }  tb  .  generateImpliedEndTags  (  )  ;  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (  name  )  )  tb  .  error  (  this  )  ;  tb  .  popStackToClose  (  name  )  ;  tb  .  clearFormattingElementsToLastMarker  (  )  ;  tb  .  transition  (  InRow  )  ;  }  else  if  (  StringUtil  .  inSorted  (  name  ,  Constants  .  InCellBody  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_28	1173	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1732	if  (tb.currentElement().normalName().equals( "option "))  	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  16  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Character  c  [TYPE]  EndTag  end  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  StartTag  start  [CONTEXT]  boolean  process  (  Token  t  ,  HtmlTreeBuilder  tb  )  {  switch  (  t  .  type  )  {  case  Character:  Token  .  Character  c  =  t  .  asCharacter  (  )  ;  if  (  c  .  getData  (  )  .  equals  (  nullString  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  insert  (  c  )  ;  }  break  ;  case  Comment:  tb  .  insert  (  t  .  asComment  (  )  )  ;  break  ;  case  Doctype:  tb  .  error  (  this  )  ;  return  false  ;  case  StartTag:  Token  .  StartTag  start  =  t  .  asStartTag  (  )  ;  String  name  =  start  .  normalName  (  )  ;  if  (  name  .  equals  (   "html "  )  )  return  tb  .  process  (  start  ,  InBody  )  ;  else  if  (  name  .  equals  (   "option "  )  )  {  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  processEndTag  (   "option "  )  ;  tb  .  insert  (  start  )  ;  }  else  if  (  name  .  equals  (   "optgroup "  )  )  {  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  processEndTag  (   "option "  )  ;  	Jsoup_87_HtmlTreeBuilderState_36_29	1240	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1733	if  (tb.currentElement().normalName().equals( "option "))  else  if  (tb.currentElement().normalName().equals( "optgroup "))  	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  else  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  16  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Character  c  [TYPE]  EndTag  end  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  StartTag  start  [CONTEXT]  case  Character:  Token  .  Character  c  =  t  .  asCharacter  (  )  ;  if  (  c  .  getData  (  )  .  equals  (  nullString  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  insert  (  c  )  ;  }  break  ;  case  Comment:  tb  .  insert  (  t  .  asComment  (  )  )  ;  break  ;  case  Doctype:  tb  .  error  (  this  )  ;  return  false  ;  case  StartTag:  Token  .  StartTag  start  =  t  .  asStartTag  (  )  ;  String  name  =  start  .  normalName  (  )  ;  if  (  name  .  equals  (   "html "  )  )  return  tb  .  process  (  start  ,  InBody  )  ;  else  if  (  name  .  equals  (   "option "  )  )  {  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  processEndTag  (   "option "  )  ;  tb  .  insert  (  start  )  ;  }  else  if  (  name  .  equals  (   "optgroup "  )  )  {  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  processEndTag  (   "option "  )  ;  else  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  tb  .  processEndTag  (   "optgroup "  )  ;  tb  .  insert  (  start  )  ;  }  else  if  (  name  .  equals  (   "select "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_30	1244	2	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1734	if  (tb.currentElement().normalName().equals( "option ")  &&  tb.aboveOnStack(tb.currentElement())  !=  null  &&  tb.aboveOnStack(tb.currentElement()).normalName().equals( "optgroup "))  if  (tb.currentElement().normalName().equals( "optgroup "))  	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  &&  tb  .  aboveOnStack  (  tb  .  currentElement  (  )  )  !  =  null  &&  tb  .  aboveOnStack  (  tb  .  currentElement  (  )  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  16  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Character  c  [TYPE]  EndTag  end  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  StartTag  start  [CONTEXT]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  processEndTag  (   "option "  )  ;  else  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  tb  .  processEndTag  (   "optgroup "  )  ;  tb  .  insert  (  start  )  ;  }  else  if  (  name  .  equals  (   "select "  )  )  {  tb  .  error  (  this  )  ;  return  tb  .  processEndTag  (   "select "  )  ;  }  else  if  (  StringUtil  .  in  (  name  ,   "input "  ,   "keygen "  ,   "textarea "  )  )  {  tb  .  error  (  this  )  ;  if  (  !tb  .  inSelectScope  (   "select "  )  )  return  false  ;  //  frag  tb  .  processEndTag  (   "select "  )  ;  return  tb  .  process  (  start  )  ;  }  else  if  (  name  .  equals  (   "script "  )  )  {  return  tb  .  process  (  t  ,  InHead  )  ;  }  else  {  return  anythingElse  (  t  ,  tb  )  ;  }  break  ;  case  EndTag:  Token  .  EndTag  end  =  t  .  asEndTag  (  )  ;  name  =  end  .  normalName  (  )  ;  switch  (  name  )  {  case   "optgroup ":  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  &&  tb  .  aboveOnStack  (  tb  .  currentElement  (  )  )  !  =  null  &&  tb  .  aboveOnStack  (  tb  .  currentElement  (  )  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  tb  .  processEndTag  (   "option "  )  ;  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  tb  .  pop  (  )  ;  else  tb  .  error  (  this  )  ;  	Jsoup_87_HtmlTreeBuilderState_36_31	1269	2	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1735	if  (tb.currentElement().normalName().equals( "option "))  	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  16  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Character  c  [TYPE]  EndTag  end  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  StartTag  start  [CONTEXT]  }  else  if  (  StringUtil  .  in  (  name  ,   "input "  ,   "keygen "  ,   "textarea "  )  )  {  tb  .  error  (  this  )  ;  if  (  !tb  .  inSelectScope  (   "select "  )  )  return  false  ;  //  frag  tb  .  processEndTag  (   "select "  )  ;  return  tb  .  process  (  start  )  ;  }  else  if  (  name  .  equals  (   "script "  )  )  {  return  tb  .  process  (  t  ,  InHead  )  ;  }  else  {  return  anythingElse  (  t  ,  tb  )  ;  }  break  ;  case  EndTag:  Token  .  EndTag  end  =  t  .  asEndTag  (  )  ;  name  =  end  .  normalName  (  )  ;  switch  (  name  )  {  case   "optgroup ":  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  &&  tb  .  aboveOnStack  (  tb  .  currentElement  (  )  )  !  =  null  &&  tb  .  aboveOnStack  (  tb  .  currentElement  (  )  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  tb  .  processEndTag  (   "option "  )  ;  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  tb  .  pop  (  )  ;  else  tb  .  error  (  this  )  ;  break  ;  case   "option ":  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  pop  (  )  ;  else  tb  .  error  (  this  )  ;  break  ;  case   "select ":  	Jsoup_87_HtmlTreeBuilderState_36_32	1277	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1736	if  (!tb.currentElement().normalName().equals( "html "))  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  16  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Character  c  [TYPE]  EndTag  end  [TYPE]  Token  t  [TYPE]  String  name  [TYPE]  StartTag  start  [CONTEXT]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "optgroup "  )  )  tb  .  pop  (  )  ;  else  tb  .  error  (  this  )  ;  break  ;  case   "option ":  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "option "  )  )  tb  .  pop  (  )  ;  else  tb  .  error  (  this  )  ;  break  ;  case   "select ":  if  (  !tb  .  inSelectScope  (  name  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  popStackToClose  (  name  )  ;  tb  .  resetInsertionMode  (  )  ;  }  break  ;  default:  return  anythingElse  (  t  ,  tb  )  ;  }  break  ;  case  EOF:  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  tb  .  error  (  this  )  ;  break  ;  default:  return  anythingElse  (  t  ,  tb  )  ;  }  	Jsoup_87_HtmlTreeBuilderState_36_33	1296	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1737	if  (tb.currentElement().normalName().equals( "html "))  {    	[BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  19  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Token  t  [TYPE]  StartTag  start  [CONTEXT]  if  (  isWhitespace  (  t  )  )  {  tb  .  insert  (  t  .  asCharacter  (  )  )  ;  }  else  if  (  t  .  isComment  (  )  )  {  tb  .  insert  (  t  .  asComment  (  )  )  ;  }  else  if  (  t  .  isDoctype  (  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  if  (  t  .  isStartTag  (  )  )  {  Token  .  StartTag  start  =  t  .  asStartTag  (  )  ;  switch  (  start  .  normalName  (  )  )  {  case   "html ":  return  tb  .  process  (  start  ,  InBody  )  ;  case   "frameset ":  tb  .  insert  (  start  )  ;  break  ;  case   "frame ":  tb  .  insertEmpty  (  start  )  ;  break  ;  case   "noframes ":  return  tb  .  process  (  start  ,  InHead  )  ;  default:  tb  .  error  (  this  )  ;  return  false  ;  }  }  else  if  (  t  .  isEndTag  (  )  &&  t  .  asEndTag  (  )  .  normalName  (  )  .  equals  (   "frameset "  )  )  {  [BUGGY]  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  pop  (  )  ;  if  (  !tb  .  isFragmentParsing  (  )  &&  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "frameset "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_34	1383	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1738	if  (!tb.isFragmentParsing()  &&  !tb.currentElement().normalName().equals( "frameset "))  {  	[BUGGY]  if  (  !tb  .  isFragmentParsing  (  )  &&  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "frameset "  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  19  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Token  t  [TYPE]  StartTag  start  [CONTEXT]  tb  .  error  (  this  )  ;  return  false  ;  }  else  if  (  t  .  isStartTag  (  )  )  {  Token  .  StartTag  start  =  t  .  asStartTag  (  )  ;  switch  (  start  .  normalName  (  )  )  {  case   "html ":  return  tb  .  process  (  start  ,  InBody  )  ;  case   "frameset ":  tb  .  insert  (  start  )  ;  break  ;  case   "frame ":  tb  .  insertEmpty  (  start  )  ;  break  ;  case   "noframes ":  return  tb  .  process  (  start  ,  InHead  )  ;  default:  tb  .  error  (  this  )  ;  return  false  ;  }  }  else  if  (  t  .  isEndTag  (  )  &&  t  .  asEndTag  (  )  .  normalName  (  )  .  equals  (   "frameset "  )  )  {  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  pop  (  )  ;  [BUGGY]  if  (  !tb  .  isFragmentParsing  (  )  &&  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "frameset "  )  )  {  tb  .  transition  (  AfterFrameset  )  ;  }  }  }  else  if  (  t  .  isEOF  (  )  )  {  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  	Jsoup_87_HtmlTreeBuilderState_36_35	1388	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1739	if  (!tb.currentElement().normalName().equals( "html "))  {  	[BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [METHOD]  process  [TYPE]  boolean  [PARAMETER]  Token  t  HtmlTreeBuilder  tb  [CLASS]  19  [TYPE]  HtmlTreeBuilder  tb  [TYPE]  boolean  false  true  [TYPE]  Token  t  [TYPE]  StartTag  start  [CONTEXT]  case   "html ":  return  tb  .  process  (  start  ,  InBody  )  ;  case   "frameset ":  tb  .  insert  (  start  )  ;  break  ;  case   "frame ":  tb  .  insertEmpty  (  start  )  ;  break  ;  case   "noframes ":  return  tb  .  process  (  start  ,  InHead  )  ;  default:  tb  .  error  (  this  )  ;  return  false  ;  }  }  else  if  (  t  .  isEndTag  (  )  &&  t  .  asEndTag  (  )  .  normalName  (  )  .  equals  (   "frameset "  )  )  {  if  (  tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  tb  .  error  (  this  )  ;  return  false  ;  }  else  {  tb  .  pop  (  )  ;  if  (  !tb  .  isFragmentParsing  (  )  &&  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "frameset "  )  )  {  tb  .  transition  (  AfterFrameset  )  ;  }  }  }  else  if  (  t  .  isEOF  (  )  )  {  [BUGGY]  if  (  !tb  .  currentElement  (  )  .  nodeName  (  )  .  equals  (   "html "  )  )  {  tb  .  error  (  this  )  ;  return  true  ;  }  }  else  {  tb  .  error  (  this  )  ;  	Jsoup_87_HtmlTreeBuilderState_36_36	1393	1	src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java
1740		[BUGGY]  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_87_Tag_4_1	4	0	src/main/java/org/jsoup/parser/Tag.java
1741	private  String  normalName;    	[BUGGY]  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_87_Tag_4_2	17	0	src/main/java/org/jsoup/parser/Tag.java
1742	normalName  =  Normalizer.lowerCase(tagName);  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_87_Tag_4_3	28	0	src/main/java/org/jsoup/parser/Tag.java
1743	public  String  normalName()  {  return  normalName;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<A>  ONE  <[/A>  <A>  Two]  </A>>  but  was:<<A>  ONE  <[A>  Two  </A>]  </A>>  assertEquals  (   "<A>  ONE  </A>  <A>  Two  </A> "  ,  StringUtil  .  normaliseWhitespace  (  doc  .  body  (  )  .  html  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_87_Tag_4_4	43	0	src/main/java/org/jsoup/parser/Tag.java
1744	return  Attributes.checkNotNull(val);  	[BUGGY]  return  val  ;  [FE]  AssertionFailedError:  expected:<>  but  was:<null>  assertEquals  (   " "  ,  first  .  getValue  (  )  )  ;  [METHOD]  getValue  [TYPE]  String  [PARAMETER]  [CLASS]  Attribute  [TYPE]  Attributes  parent  [TYPE]  String[]  booleanAttributes  [TYPE]  String  key  val  [TYPE]  boolean  false  true  [CONTEXT]  public  String  getValue  (  )  {  [BUGGY]  return  val  ;  }  	Jsoup_88_Attribute_1_1	80	1	src/main/java/org/jsoup/nodes/Attribute.java
1745	String  oldVal  =  this.val;  oldVal  =  parent.get(this.key);    	[BUGGY]  String  oldVal  =  parent  .  get  (  this  .  key  )  ;  [FE]  NullPointerException  assertEquals  (  null  ,  attr  .  parent  )  ;  [METHOD]  setValue  [TYPE]  String  [PARAMETER]  String  val  [CLASS]  Attribute  [TYPE]  Attributes  parent  [TYPE]  String[]  booleanAttributes  [TYPE]  String  key  oldVal  val  [TYPE]  boolean  false  true  [TYPE]  int  i  [CONTEXT]  public  String  setValue  (  String  val  )  {  [BUGGY]  String  oldVal  =  parent  .  get  (  this  .  key  )  ;  if  (  parent  !  =  null  )  {  int  i  =  parent  .  indexOfKey  (  this  .  key  )  ;  if  (  i  !  =  Attributes  .  NotFound  )  parent  .  vals[i]  =  val  ;  }  this  .  val  =  val  ;  return  Attributes  .  checkNotNull  (  oldVal  )  ;  }  	Jsoup_89_Attribute_1_1	88	1	src/main/java/org/jsoup/nodes/Attribute.java
1746	if  (end  >=  input.length)  return  false;  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  1  [METHOD]  looksLikeUtf8  [TYPE]  boolean  [PARAMETER]  byte[]  input  [CLASS]  Base  [TYPE]  byte[]  input  [TYPE]  Method  method  [TYPE]  boolean  false  true  [TYPE]  Map  cookies  headers  [TYPE]  URL  url  [TYPE]  int  end  i  j  o  [CONTEXT]  int  i  =  0  ;  if  (  input  .  length  >  =  3  &&  (  input[0]  &  0xFF  )  =  =  0xEF  &&  (  input[1]  &  0xFF  )  =  =  0xBB  &  (  input[2]  &  0xFF  )  =  =  0xBF  )  {  i  =  3  ;  }  int  end  ;  for  (  int  j  =  input  .  length  ;  i  <  j  ;  ++i  )  {  int  o  =  input[i]  ;  if  (  (  o  &  0x80  )  =  =  0  )  {  continue  ;  //  ASCII  }  if  (  (  o  &  0xE0  )  =  =  0xC0  )  {  end  =  i  +  1  ;  }  else  if  (  (  o  &  0xF0  )  =  =  0xE0  )  {  end  =  i  +  2  ;  }  else  if  (  (  o  &  0xF8  )  =  =  0xF0  )  {  end  =  i  +  3  ;  }  else  {  return  false  ;  }  [BUGGY]  while  (  i  <  end  )  {  i++  ;  o  =  input[i]  ;  if  (  (  o  &  0xC0  )  !  =  0x80  )  {  return  false  ;  	Jsoup_90_HttpConnection_1_1	424	0	src/main/java/org/jsoup/helper/HttpConnection.java
1747	public  UncheckedIOException(String  message)  {  super(new  IOException(message));  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  threw  )  ;  [CLASS]  [CONTEXT]  	Jsoup_91_UncheckedIOException_1_1	10	0	src/main/java/org/jsoup/UncheckedIOException.java
1748	if  (isBinary())  {  throw  new  UncheckedIOException( "Input  is  binary  and  unsupported ");  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  threw  )  ;  [CLASS]  [CONTEXT]  	Jsoup_91_CharacterReader_3_1	37	0	src/main/java/org/jsoup/parser/CharacterReader.java
1749	private  static  final  int  numNullsConsideredBinary  =  10;    	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  threw  )  ;  [CLASS]  [CONTEXT]  	Jsoup_91_CharacterReader_3_2	452	0	src/main/java/org/jsoup/parser/CharacterReader.java
1750	boolean  isBinary()  {  int  nullsSeen  =  0;  for  (int  i  =  bufPos;  i  <  bufLength;  i++)  {\n',   "+                        if  (charBuf[i]  ==  '\\0')\n ",  '+                                nullsSeen++;  }  return  nullsSeen  >=  numNullsConsideredBinary;  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  threw  )  ;  [CLASS]  [CONTEXT]  	Jsoup_91_CharacterReader_3_3	457	0	src/main/java/org/jsoup/parser/CharacterReader.java
1751		[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_92_Attributes_5_1	6	0	src/main/java/org/jsoup/nodes/Attributes.java
1752	public  Attributes  add(String  key,  String  value)  {  	[BUGGY]  private  void  add  (  String  key  ,  String  value  )  {  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_92_Attributes_5_2	118	1	src/main/java/org/jsoup/nodes/Attributes.java
1753	return  this;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_92_Attributes_5_3	123	0	src/main/java/org/jsoup/nodes/Attributes.java
1754	public  boolean  isEmpty()  {  return  size  ==  0;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_92_Attributes_5_4	239	0	src/main/java/org/jsoup/nodes/Attributes.java
1755	public  int  deduplicate(ParseSettings  settings)  {  if  (isEmpty())  return  0;  boolean  preserve  =  settings.preserveAttributeCase();  int  dupes  =  0;  OUTER:  for  (int  i  =  0;  i  <  keys.length;  i++)  {  for  (int  j  =  i  +  1;  j  <  keys.length;  j++)  {  if  (keys[j]  ==  null)\n',   "+                                        continue  OUTER;    dupes++;  remove(j);  j--;  }  }  }  return  dupes;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_92_Attributes_5_5	397	0	src/main/java/org/jsoup/nodes/Attributes.java
1756	if  (!startTag.attributes.isEmpty())  {  int  dupes  =  startTag.attributes.deduplicate(settings);  if  (dupes  >  0)  {  error( "Duplicate  attribute ");  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [METHOD]  insert  [TYPE]  Element  [PARAMETER]  StartTag  startTag  [CLASS]  HtmlTreeBuilder  [TYPE]  HtmlTreeBuilderState  originalState  state  [TYPE]  boolean  baseUriSetFromDoc  false  fosterInserts  fragmentParsing  framesetOk  true  [TYPE]  EndTag  emptyEnd  [TYPE]  Element  contextElement  el  headElement  [TYPE]  ArrayList  formattingElements  [TYPE]  List  pendingTableCharacters  [TYPE]  String[]  TagSearchButton  TagSearchEndTags  TagSearchList  TagSearchSelectScope  TagSearchSpecial  TagSearchTableScope  TagsSearchInScope  specificScopeTarget  [TYPE]  int  MaxScopeSearchDepth  [TYPE]  FormElement  formElement  [TYPE]  StartTag  startTag  [CONTEXT]  Element  insert  (  final  Token  .  StartTag  startTag  )  {  [BUGGY]    if  (  startTag  .  isSelfClosing  (  )  )  {  Element  el  =  insertEmpty  (  startTag  )  ;  stack  .  add  (  el  )  ;  tokeniser  .  transition  (  TokeniserState  .  Data  )  ;  //  handles  <script  />  ,  otherwise  needs  breakout  steps  from  script  data  tokeniser  .  emit  (  emptyEnd  .  reset  (  )  .  name  (  el  .  tagName  (  )  )  )  ;  //  ensure  we  get  out  of  whatever  state  we  are  in  .  emitted  for  yielded  processing  return  el  ;  }  Element  el  =  new  Element  (  Tag  .  valueOf  (  startTag  .  name  (  )  ,  settings  )  ,  baseUri  ,  settings  .  normalizeAttributes  (  startTag  .  attributes  )  )  ;  insert  (  el  )  ;  return  el  ;  }  	Jsoup_92_HtmlTreeBuilder_1_1	199	0	src/main/java/org/jsoup/parser/HtmlTreeBuilder.java
1757	public  boolean  preserveAttributeCase()  {  return  preserveAttributeCase;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [CLASS]  [CONTEXT]  	Jsoup_92_ParseSettings_1_1	38	0	src/main/java/org/jsoup/parser/ParseSettings.java
1758	attributes.add(pendingAttributeName,  value);  	[BUGGY]  attributes  .  put  (  pendingAttributeName  ,  value  )  ;  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [METHOD]  newAttribute  [TYPE]  void  [PARAMETER]  [CLASS]  Tag  [TYPE]  Attributes  attributes  [TYPE]  boolean  false  hasEmptyAttributeValue  hasPendingAttributeValue  selfClosing  true  [TYPE]  String  normalName  pendingAttributeName  pendingAttributeValueS  tagName  value  [TYPE]  StringBuilder  pendingAttributeValue  [CONTEXT]  final  void  newAttribute  (  )  {  if  (  attributes  =  =  null  )  attributes  =  new  Attributes  (  )  ;  if  (  pendingAttributeName  !  =  null  )  {  pendingAttributeName  =  pendingAttributeName  .  trim  (  )  ;  if  (  pendingAttributeName  .  length  (  )  >  0  )  {  String  value  ;  if  (  hasPendingAttributeValue  )  value  =  pendingAttributeValue  .  length  (  )  >  0  ?  pendingAttributeValue  .  toString  (  )  :  pendingAttributeValueS  ;  else  if  (  hasEmptyAttributeValue  )  value  =   " "  ;  else  value  =  null  ;  [BUGGY]  attributes  .  put  (  pendingAttributeName  ,  value  )  ;  }  }  pendingAttributeName  =  null  ;  hasEmptyAttributeValue  =  false  ;  hasPendingAttributeValue  =  false  ;  reset  (  pendingAttributeValue  )  ;  pendingAttributeValueS  =  null  ;  }  	Jsoup_92_Token_1_1	116	1	src/main/java/org/jsoup/parser/Token.java
1759		[BUGGY]  [FE]  AssertionFailedError:  expected:<<p  One  =   "[One "  one  =   "Three "  two  =   "Four] "  Two  =   "Six ">Text</p>>  but  was:<<p  One  =   "[Two "  one  =   "Three "  two  =   "Five] "  Two  =   "Six ">Text</p>>  assertEquals  (   "<p  One  =  \ "One\ "  one  =  \ "Three\ "  two  =  \ "Four\ "  Two  =  \ "Six\ ">Text</p> "  ,  doc  .  selectFirst  (   "p "  )  .  outerHtml  (  )  )  ;  [METHOD]  insert  [TYPE]  Element  [PARAMETER]  StartTag  startTag  [CLASS]  XmlTreeBuilder  [TYPE]  boolean  false  true  [TYPE]  Element  el  [TYPE]  Tag  tag  [TYPE]  StartTag  startTag  [CONTEXT]  Element  insert  (  Token  .  StartTag  startTag  )  {  Tag  tag  =  Tag  .  valueOf  (  startTag  .  name  (  )  ,  settings  )  ;  [BUGGY]  Element  el  =  new  Element  (  tag  ,  baseUri  ,  settings  .  normalizeAttributes  (  startTag  .  attributes  )  )  ;  insertNode  (  el  )  ;  if  (  startTag  .  isSelfClosing  (  )  )  {  if  (  !tag  .  isKnownTag  (  )  )  //  unknown  tag  ,  remember  this  is  self  closing  for  output  .  see  above  .  tag  .  setSelfClosing  (  )  ;  }  else  {  stack  .  add  (  el  )  ;  }  return  el  ;  }  	Jsoup_92_XmlTreeBuilder_1_1	78	0	src/main/java/org/jsoup/parser/XmlTreeBuilder.java
1760	if  (type.equalsIgnoreCase( "button "))  continue;    	[BUGGY]  [FE]  AssertionFailedError:  expected:<6>  but  was:<7>  assertEquals  (   "eight  =  on "  ,  data  .  get  (  5  )  .  toString  (  )  )  ;  //  default  [METHOD]  formData  [TYPE]  List  [PARAMETER]  [CLASS]  FormElement  [TYPE]  ArrayList  data  [TYPE]  String  name  type  val  [TYPE]  boolean  false  set  true  [TYPE]  Elements  elements  options  [TYPE]  Element  el  option  [CONTEXT]  public  List<Connection  .  KeyVal>  formData  (  )  {  ArrayList<Connection  .  KeyVal>  data  =  new  ArrayList<>  (  )  ;    for  (  Element  el:  elements  )  {  if  (  !el  .  tag  (  )  .  isFormSubmittable  (  )  )  continue  ;  //  contents  are  form  listable  ,  superset  of  submitable  if  (  el  .  hasAttr  (   "disabled "  )  )  continue  ;  //  skip  disabled  form  inputs  String  name  =  el  .  attr  (   "name "  )  ;  if  (  name  .  length  (  )  =  =  0  )  continue  ;  String  type  =  el  .  attr  (   "type "  )  ;  [BUGGY]  if  (   "select "  .  equals  (  el  .  normalName  (  )  )  )  {  Elements  options  =  el  .  select  (   "option[selected] "  )  ;  boolean  set  =  false  ;  for  (  Element  option:  options  )  {  data  .  add  (  HttpConnection  .  KeyVal  .  create  (  name  ,  option  .  val  (  )  )  )  ;  	Jsoup_93_FormElement_1_1	89	0	src/main/java/org/jsoup/nodes/FormElement.java
1761		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  value  iterator  <test:nodeSet  (  )  >  expected:<[Nested:  Name  1  ,  Nested:  Name  2]>  but  was:<[[/beans[1]  ,  /beans[2]]]>  assertXPathValueAndPointer  (  [CLASS]  [CONTEXT]  	JxPath_2_Expression_4_1	19	0	src/java/org/apache/commons/jxpath/ri/compiler/Expression.java
1762	if  (result  instanceof  NodeSet)  {  return  new  ValueIterator(((NodeSet)  result).getPointers().iterator());  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  value  iterator  <test:nodeSet  (  )  >  expected:<[Nested:  Name  1  ,  Nested:  Name  2]>  but  was:<[[/beans[1]  ,  /beans[2]]]>  assertXPathValueAndPointer  (  [METHOD]  iterate  [TYPE]  Iterator  [PARAMETER]  EvalContext  context  [CLASS]  Expression  [TYPE]  Locale  locale  [TYPE]  boolean  contextDependencyKnown  contextDependent  false  true  [TYPE]  QName  qname  [TYPE]  Iterator  iterator  [TYPE]  EvalContext  context  [TYPE]  Object  result  [TYPE]  Double  NOT_A_NUMBER  ONE  ZERO  [CONTEXT]  public  Iterator  iterate  (  EvalContext  context  )  {  Object  result  =  compute  (  context  )  ;  if  (  result  instanceof  EvalContext  )  {  return  new  ValueIterator  (  (  EvalContext  )  result  )  ;  }  [BUGGY]  return  ValueUtils  .  iterate  (  result  )  ;  }  	JxPath_2_Expression_4_2	77	0	src/java/org/apache/commons/jxpath/ri/compiler/Expression.java
1763	if  (result  instanceof  NodeSet)  {  return  new  PointerIterator(((NodeSet)  result).getPointers().iterator(),  new  QName(null,   "value "),  context.getRootContext().getCurrentNodePointer().getLocale());  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  value  iterator  <test:nodeSet  (  )  >  expected:<[Nested:  Name  1  ,  Nested:  Name  2]>  but  was:<[[/beans[1]  ,  /beans[2]]]>  assertXPathValueAndPointer  (  [METHOD]  iteratePointers  [TYPE]  Iterator  [PARAMETER]  EvalContext  context  [CLASS]  Expression  [TYPE]  Locale  locale  [TYPE]  boolean  contextDependencyKnown  contextDependent  false  true  [TYPE]  QName  qname  [TYPE]  Iterator  iterator  [TYPE]  EvalContext  context  [TYPE]  Object  result  [TYPE]  Double  NOT_A_NUMBER  ONE  ZERO  [CONTEXT]  public  Iterator  iteratePointers  (  EvalContext  context  )  {  Object  result  =  compute  (  context  )  ;  if  (  result  =  =  null  )  {  return  Collections  .  EMPTY_LIST  .  iterator  (  )  ;  }  if  (  result  instanceof  EvalContext  )  {  return  (  EvalContext  )  result  ;  }  [BUGGY]  return  new  PointerIterator  (  ValueUtils  .  iterate  (  result  )  ,  new  QName  (  null  ,   "value "  )  ,  context  .  getRootContext  (  )  .  getCurrentNodePointer  (  )  .  getLocale  (  )  )  ;  }  	JxPath_2_Expression_4_3	88	0	src/java/org/apache/commons/jxpath/ri/compiler/Expression.java
1764	}  	[BUGGY]  }  [FE]  AssertionFailedError:  Evaluating  value  iterator  <test:nodeSet  (  )  >  expected:<[Nested:  Name  1  ,  Nested:  Name  2]>  but  was:<[[/beans[1]  ,  /beans[2]]]>  assertXPathValueAndPointer  (  [CLASS]  [CONTEXT]  	JxPath_2_Expression_4_4	145	1	src/java/org/apache/commons/jxpath/ri/compiler/Expression.java
1765		[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  e  .  getCause  (  )  instanceof  JXPathAbstractFactoryException  )  ;  [CLASS]  [CONTEXT]  	JxPath_3_NullPropertyPointer_4_1	19	0	src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java
1766	if  (parent  instanceof  NullPointer  &&  parent.equals(newParent))  {  throw  createBadFactoryException(context.getFactory());  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  e  .  getCause  (  )  instanceof  JXPathAbstractFactoryException  )  ;  [METHOD]  createPath  [TYPE]  NodePointer  [PARAMETER]  JXPathContext  context  [CLASS]  NullPropertyPointer  [TYPE]  boolean  byNameAttribute  false  true  [TYPE]  String  propertyName  [TYPE]  NodePointer  newParent  [TYPE]  JXPathContext  context  [TYPE]  PropertyOwnerPointer  pop  [CONTEXT]  public  NodePointer  createPath  (  JXPathContext  context  )  {  NodePointer  newParent  =  parent  .  createPath  (  context  )  ;  if  (  isAttribute  (  )  )  {  return  newParent  .  createAttribute  (  context  ,  getName  (  )  )  ;  }  else  {  [BUGGY]              if  (  newParent  instanceof  PropertyOwnerPointer  )  {  PropertyOwnerPointer  pop  =  (  PropertyOwnerPointer  )  newParent  ;  newParent  =  pop  .  getPropertyPointer  (  )  ;  }  return  newParent  .  createChild  (  context  ,  getName  (  )  ,  getIndex  (  )  )  ;  }  }  	JxPath_3_NullPropertyPointer_4_2	109	0	src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java
1767	if  (parent  instanceof  NullPointer  &&  parent.equals(newParent))  {  throw  createBadFactoryException(context.getFactory());  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  e  .  getCause  (  )  instanceof  JXPathAbstractFactoryException  )  ;  [METHOD]  createPath  [TYPE]  NodePointer  [PARAMETER]  JXPathContext  context  Object  value  [CLASS]  NullPropertyPointer  [TYPE]  Object  value  [TYPE]  boolean  byNameAttribute  false  true  [TYPE]  String  propertyName  [TYPE]  NodePointer  newParent  pointer  [TYPE]  JXPathContext  context  [TYPE]  PropertyOwnerPointer  pop  [CONTEXT]  public  NodePointer  createPath  (  JXPathContext  context  ,  Object  value  )  {  NodePointer  newParent  =  parent  .  createPath  (  context  )  ;  if  (  isAttribute  (  )  )  {  NodePointer  pointer  =  newParent  .  createAttribute  (  context  ,  getName  (  )  )  ;  pointer  .  setValue  (  value  )  ;  return  pointer  ;  }  else  {  [BUGGY]  if  (  newParent  instanceof  PropertyOwnerPointer  )  {  PropertyOwnerPointer  pop  =  (  PropertyOwnerPointer  )  newParent  ;  newParent  =  pop  .  getPropertyPointer  (  )  ;  }  return  newParent  .  createChild  (  context  ,  getName  (  )  ,  index  ,  value  )  ;  }  }  	JxPath_3_NullPropertyPointer_4_3	138	0	src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java
1768	  private  JXPathAbstractFactoryException  createBadFactoryException(AbstractFactory  factory)  {  return  new  JXPathAbstractFactoryException( "Factory   "  +  factory  +   "  reported  success  creating  object  for  path:   "  +  asPath()  +   "  but  object  was  null.    Terminating  to  avoid  stack  recursion. ");  }  }  	[BUGGY]  }  [FE]  AssertionFailedError  assertTrue  (  e  .  getCause  (  )  instanceof  JXPathAbstractFactoryException  )  ;  [CLASS]  [CONTEXT]  	JxPath_3_NullPropertyPointer_4_4	224	1	src/java/org/apache/commons/jxpath/ri/model/beans/NullPropertyPointer.java
1769	protected  static  String  findEnclosingAttribute(Node  n,  String  attrName)  {  	[BUGGY]  protected  String  getLanguage  (  )  {  Node  n  =  node  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [CLASS]  [CONTEXT]  	JxPath_4_DOMNodePointer_7_1	296	2	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1770	String  attr  =  e.getAttribute(attrName);  	[BUGGY]  String  attr  =  e  .  getAttribute  (   "xml:lang "  )  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  getLanguage  [TYPE]  String  [PARAMETER]  [CLASS]  DOMNodePointer  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  attr  defaultNamespace  id  [TYPE]  boolean  false  true  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  Node  n  node  [TYPE]  Element  e  [CONTEXT]  protected  String  getLanguage  (  )  {  Node  n  =  node  ;  while  (  n  !  =  null  )  {  if  (  n  .  getNodeType  (  )  =  =  Node  .  ELEMENT_NODE  )  {  Element  e  =  (  Element  )  n  ;  [BUGGY]  String  attr  =  e  .  getAttribute  (   "xml:lang "  )  ;  if  (  attr  !  =  null  &&  !attr  .  equals  (   " "  )  )  {  return  attr  ;  }  }  n  =  n  .  getParentNode  (  )  ;  }  return  null  ;  }  	JxPath_4_DOMNodePointer_7_2	301	1	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1771	protected  String  getLanguage()  {  return  findEnclosingAttribute(node,   "xml:lang ");  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [CLASS]  [CONTEXT]  	JxPath_4_DOMNodePointer_7_3	311	0	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1772	if  (node.getNodeType()  ==  Node.COMMENT_NODE)  {  String  text  =  ((Comment)  node).getData();  return  text  ==  null  ?   " "  :  text.trim();  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  getValue  [TYPE]  Object  [PARAMETER]  [CLASS]  DOMNodePointer  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  [TYPE]  boolean  false  true  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  Node  node  [CONTEXT]  public  Object  getValue  (  )  {  [BUGGY]  return  stringValue  (  node  )  ;  }  	JxPath_4_DOMNodePointer_7_4	632	0	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1773	return   " ";  boolean  trim  =  ! "preserve ".equals(findEnclosingAttribute(node,   "xml:space "));  return  text  ==  null  ?   " "  :  trim  ?  text.trim()  :  text;  	[BUGGY]  String  text  =  (  (  Comment  )  node  )  .  getData  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  stringValue  [TYPE]  String  [PARAMETER]  Node  node  [CLASS]  DOMNodePointer  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Node  child  node  [TYPE]  NodeList  list  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  text  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  int  i  nodeType  [CONTEXT]  private  String  stringValue  (  Node  node  )  {  int  nodeType  =  node  .  getNodeType  (  )  ;  if  (  nodeType  =  =  Node  .  COMMENT_NODE  )  {  [BUGGY]  String  text  =  (  (  Comment  )  node  )  .  getData  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  if  (  nodeType  =  =  Node  .  TEXT_NODE  ||  nodeType  =  =  Node  .  CDATA_SECTION_NODE  )  {  String  text  =  node  .  getNodeValue  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  if  (  nodeType  =  =  Node  .  PROCESSING_INSTRUCTION_NODE  )  {  String  text  =  (  (  ProcessingInstruction  )  node  )  .  getData  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  NodeList  list  =  node  .  getChildNodes  (  )  ;  StringBuffer  buf  =  new  StringBuffer  (  16  )  ;  for  (  int  i  =  0  ;  i  <  list  .  getLength  (  )  ;  i++  )  {  Node  child  =  list  .  item  (  i  )  ;  if  (  child  .  getNodeType  (  )  =  =  Node  .  TEXT_NODE  )  {  buf  .  append  (  child  .  getNodeValue  (  )  )  ;  }  else  {  buf  .  append  (  stringValue  (  child  )  )  ;  }  }  return  buf  .  toString  (  )  .  trim  (  )  ;  }  	JxPath_4_DOMNodePointer_7_5	638	3	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1774	return  text  ==  null  ?   " "  :  trim  ?  text.trim()  :  text;  	[BUGGY]  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  stringValue  [TYPE]  String  [PARAMETER]  Node  node  [CLASS]  DOMNodePointer  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Node  child  node  [TYPE]  NodeList  list  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  text  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  int  i  nodeType  [CONTEXT]  private  String  stringValue  (  Node  node  )  {  int  nodeType  =  node  .  getNodeType  (  )  ;  if  (  nodeType  =  =  Node  .  COMMENT_NODE  )  {  String  text  =  (  (  Comment  )  node  )  .  getData  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  if  (  nodeType  =  =  Node  .  TEXT_NODE  ||  nodeType  =  =  Node  .  CDATA_SECTION_NODE  )  {  String  text  =  node  .  getNodeValue  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  if  (  nodeType  =  =  Node  .  PROCESSING_INSTRUCTION_NODE  )  {  String  text  =  (  (  ProcessingInstruction  )  node  )  .  getData  (  )  ;  [BUGGY]  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  NodeList  list  =  node  .  getChildNodes  (  )  ;  StringBuffer  buf  =  new  StringBuffer  (  16  )  ;  for  (  int  i  =  0  ;  i  <  list  .  getLength  (  )  ;  i++  )  {  Node  child  =  list  .  item  (  i  )  ;  if  (  child  .  getNodeType  (  )  =  =  Node  .  TEXT_NODE  )  {  buf  .  append  (  child  .  getNodeValue  (  )  )  ;  }  else  {  buf  .  append  (  stringValue  (  child  )  )  ;  }  }  return  buf  .  toString  (  )  .  trim  (  )  ;  }  	JxPath_4_DOMNodePointer_7_6	647	1	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1775	return  buf.toString();  	[BUGGY]  if  (  child  .  getNodeType  (  )  =  =  Node  .  TEXT_NODE  )  {  buf  .  append  (  child  .  getNodeValue  (  )  )  ;  }  else  {  }  return  buf  .  toString  (  )  .  trim  (  )  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  stringValue  [TYPE]  String  [PARAMETER]  Node  node  [CLASS]  DOMNodePointer  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  Node  child  node  [TYPE]  NodeList  list  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  text  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  int  i  nodeType  [CONTEXT]  private  String  stringValue  (  Node  node  )  {  int  nodeType  =  node  .  getNodeType  (  )  ;  if  (  nodeType  =  =  Node  .  COMMENT_NODE  )  {  String  text  =  (  (  Comment  )  node  )  .  getData  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  if  (  nodeType  =  =  Node  .  TEXT_NODE  ||  nodeType  =  =  Node  .  CDATA_SECTION_NODE  )  {  String  text  =  node  .  getNodeValue  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  if  (  nodeType  =  =  Node  .  PROCESSING_INSTRUCTION_NODE  )  {  String  text  =  (  (  ProcessingInstruction  )  node  )  .  getData  (  )  ;  return  text  =  =  null  ?   " "  :  text  .  trim  (  )  ;  }  NodeList  list  =  node  .  getChildNodes  (  )  ;  StringBuffer  buf  =  new  StringBuffer  (  16  )  ;  for  (  int  i  =  0  ;  i  <  list  .  getLength  (  )  ;  i++  )  {  Node  child  =  list  .  item  (  i  )  ;  [BUGGY]  if  (  child  .  getNodeType  (  )  =  =  Node  .  TEXT_NODE  )  {  buf  .  append  (  child  .  getNodeValue  (  )  )  ;  }  else  {  buf  .  append  (  stringValue  (  child  )  )  ;  }  }  return  buf  .  toString  (  )  .  trim  (  )  ;  }  	JxPath_4_DOMNodePointer_7_7	653	6	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1776	StringBuffer  buf  =  new  StringBuffer();  for  (NodeIterator  children  =  childIterator(null,  false,  null);  children.setPosition(children.getPosition()  +  1);)  {  NodePointer  ptr  =  children.getNodePointer();  if  (ptr.getImmediateNode()  instanceof  Element  ||  ptr.getImmediateNode()  instanceof  Text)  {  buf.append(ptr.getValue());  }  }  return  buf.toString();  	[BUGGY]  return  (  (  Element  )  node  )  .  getTextTrim  (  )  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  getValue  [TYPE]  Object  [PARAMETER]  [CLASS]  JDOMNodePointer  [TYPE]  Object  node  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  id  text  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [CONTEXT]  public  Object  getValue  (  )  {  if  (  node  instanceof  Element  )  {  [BUGGY]  return  (  (  Element  )  node  )  .  getTextTrim  (  )  ;  }  if  (  node  instanceof  Comment  )  {  String  text  =  (  (  Comment  )  node  )  .  getText  (  )  ;  if  (  text  !  =  null  )  {  text  =  text  .  trim  (  )  ;  }  return  text  ;  }  if  (  node  instanceof  Text  )  {  return  (  (  Text  )  node  )  .  getTextTrim  (  )  ;  }  if  (  node  instanceof  CDATA  )  {  return  (  (  CDATA  )  node  )  .  getTextTrim  (  )  ;  }  if  (  node  instanceof  ProcessingInstruction  )  {  String  text  =  (  (  ProcessingInstruction  )  node  )  .  getData  (  )  ;  if  (  text  !  =  null  )  {  text  =  text  .  trim  (  )  ;  }  return  text  ;  }  return  null  ;  }  	JxPath_4_JDOMNodePointer_5_1	240	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java
1777	String  result  =  null;  result  =  ((Text)  node).getText();  result  =  ((ProcessingInstruction)  node).getData();  boolean  trim  =  ! "preserve ".equals(findEnclosingAttribute(node,   "space ",  Namespace.XML_NAMESPACE));  return  result  !=  null  &&  trim  ?  result.trim()  :  result;  	[BUGGY]  return  (  (  Text  )  node  )  .  getTextTrim  (  )  ;  }  if  (  node  instanceof  CDATA  )  {  return  (  (  CDATA  )  node  )  .  getTextTrim  (  )  ;  String  text  =  (  (  ProcessingInstruction  )  node  )  .  getData  (  )  ;  if  (  text  !  =  null  )  {  text  =  text  .  trim  (  )  ;  }  return  text  ;  return  null  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  getValue  [TYPE]  Object  [PARAMETER]  [CLASS]  JDOMNodePointer  [TYPE]  Object  node  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  id  text  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [CONTEXT]  public  Object  getValue  (  )  {  if  (  node  instanceof  Element  )  {  return  (  (  Element  )  node  )  .  getTextTrim  (  )  ;  }  if  (  node  instanceof  Comment  )  {  String  text  =  (  (  Comment  )  node  )  .  getText  (  )  ;  if  (  text  !  =  null  )  {  text  =  text  .  trim  (  )  ;  }  return  text  ;  }  [BUGGY]  if  (  node  instanceof  Text  )  {  return  (  (  Text  )  node  )  .  getTextTrim  (  )  ;  }  if  (  node  instanceof  CDATA  )  {  return  (  (  CDATA  )  node  )  .  getTextTrim  (  )  ;  }  if  (  node  instanceof  ProcessingInstruction  )  {  String  text  =  (  (  ProcessingInstruction  )  node  )  .  getData  (  )  ;  if  (  text  !  =  null  )  {  text  =  text  .  trim  (  )  ;  }  return  text  ;  }  return  null  ;  }  	JxPath_4_JDOMNodePointer_5_2	249	10	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java
1778	return  findEnclosingAttribute(node,   "lang ",  Namespace.XML_NAMESPACE);  }    protected  static  String  findEnclosingAttribute(Object  n,  String  attrName,  Namespace  ns)  {  	[BUGGY]  Object  n  =  node  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  getLanguage  [TYPE]  String  [PARAMETER]  [CLASS]  JDOMNodePointer  [TYPE]  Object  n  node  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  attr  id  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  Element  e  [CONTEXT]  protected  String  getLanguage  (  )  {  [BUGGY]  Object  n  =  node  ;  while  (  n  !  =  null  )  {  if  (  n  instanceof  Element  )  {  Element  e  =  (  Element  )  n  ;  String  attr  =  e  .  getAttributeValue  (   "lang "  ,  Namespace  .  XML_NAMESPACE  )  ;  if  (  attr  !  =  null  &&  !attr  .  equals  (   " "  )  )  {  return  attr  ;  }  }  n  =  nodeParent  (  n  )  ;  }  return  null  ;  }  	JxPath_4_JDOMNodePointer_5_3	436	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java
1779	String  attr  =  e.getAttributeValue(attrName,  ns);  	[BUGGY]  String  attr  =  e  .  getAttributeValue  (   "lang "  ,  Namespace  .  XML_NAMESPACE  )  ;  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [METHOD]  getLanguage  [TYPE]  String  [PARAMETER]  [CLASS]  JDOMNodePointer  [TYPE]  Object  n  node  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  attr  id  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  Element  e  [CONTEXT]  protected  String  getLanguage  (  )  {  Object  n  =  node  ;  while  (  n  !  =  null  )  {  if  (  n  instanceof  Element  )  {  Element  e  =  (  Element  )  n  ;  [BUGGY]  String  attr  =  e  .  getAttributeValue  (   "lang "  ,  Namespace  .  XML_NAMESPACE  )  ;  if  (  attr  !  =  null  &&  !attr  .  equals  (   " "  )  )  {  return  attr  ;  }  }  n  =  nodeParent  (  n  )  ;  }  return  null  ;  }  	JxPath_4_JDOMNodePointer_5_4	440	2	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java
1780	}  	[BUGGY]  }  [FE]  AssertionFailedError:  expected:<foo>  but  was:<  foo  >  [CLASS]  [CONTEXT]  	JxPath_4_JDOMNodePointer_5_5	756	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java
1781	return  0;  	[BUGGY]  throw  new  JXPathException  (   "Cannot  compare  pointers  that  do  not  belong  to  the  same  tree:  \' "  +  p1  +   "\'  and  \' "  +  p2  +   "\' "  )  ;  [FE]  commonsjxpathJXPathException:  Cannot  compare  pointers  that  do  not  belong  to  the  same  tree:  ''  and  '$var'  assertEquals  (  3  ,  sz  )  ;  [METHOD]  compareNodePointers  [TYPE]  int  [PARAMETER]  NodePointer  p1  int  depth1  NodePointer  p2  int  depth2  [CLASS]  NodePointer  [TYPE]  Locale  locale  [TYPE]  boolean  attribute  false  true  [TYPE]  NamespaceResolver  namespaceResolver  [TYPE]  Object  rootNode  [TYPE]  String  UNKNOWN_NAMESPACE  [TYPE]  NodePointer  p1  p2  parent  [TYPE]  int  WHOLE_COLLECTION  depth1  depth2  index  r  [CONTEXT]  private  int  compareNodePointers  (  NodePointer  p1  ,  int  depth1  ,  NodePointer  p2  ,  int  depth2  )  {  if  (  depth1  <  depth2  )  {  int  r  =  compareNodePointers  (  p1  ,  depth1  ,  p2  .  parent  ,  depth2  -  1  )  ;  return  r  =  =  0  ?  -1  :  r  ;  }  if  (  depth1  >  depth2  )  {  int  r  =  compareNodePointers  (  p1  .  parent  ,  depth1  -  1  ,  p2  ,  depth2  )  ;  return  r  =  =  0  ?  1  :  r  ;  }  if  (  p1  =  =  null  &&  p2  =  =  null  )  {  return  0  ;  }  if  (  p1  !  =  null  &&  p1  .  equals  (  p2  )  )  {  return  0  ;  }  if  (  depth1  =  =  1  )  {  [BUGGY]  throw  new  JXPathException  (   "Cannot  compare  pointers  that  do  not  belong  to  the  same  tree:  ' "  +  p1  +   "'  and  ' "  +  p2  +   "' "  )  ;  }  int  r  =  compareNodePointers  (  p1  .  parent  ,  depth1  -  1  ,  p2  .  parent  ,  depth2  -  1  )  ;  if  (  r  !  =  0  )  {  	JxPath_5_NodePointer_1_1	665	3	src/java/org/apache/commons/jxpath/ri/model/NodePointer.java
1782	if  (l  instanceof  InitialContext)  {  ((EvalContext)  l).reset();  }    if  (l  instanceof  SelfContext)  {  	[BUGGY]  if  (  l  instanceof  InitialContext  ||  l  instanceof  SelfContext  )  {  [FE]  AssertionFailedError:  Evaluating  <$d  =  'a'>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$d  =  'b' "  ,  Boolean  .  TRUE  )  ;  [METHOD]  equal  [TYPE]  boolean  [PARAMETER]  EvalContext  context  Expression  left  Expression  right  [CLASS]  CoreOperationCompare  [TYPE]  boolean  false  true  [TYPE]  Expression  left  right  [TYPE]  EvalContext  context  [TYPE]  Object  l  r  [CONTEXT]  protected  boolean  equal  (  EvalContext  context  ,  Expression  left  ,  Expression  right  )  {  Object  l  =  left  .  compute  (  context  )  ;  Object  r  =  right  .  compute  (  context  )  ;      [BUGGY]  if  (  l  instanceof  InitialContext  ||  l  instanceof  SelfContext  )  {  l  =  (  (  EvalContext  )  l  )  .  getSingleNodePointer  (  )  ;  }  if  (  r  instanceof  InitialContext  ||  r  instanceof  SelfContext  )  {  r  =  (  (  EvalContext  )  r  )  .  getSingleNodePointer  (  )  ;  	JxPath_6_CoreOperationCompare_2_1	57	1	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java
1783	if  (r  instanceof  InitialContext)  {  ((EvalContext)  r).reset();  }    if  (r  instanceof  SelfContext)  {  	[BUGGY]  if  (  r  instanceof  InitialContext  ||  r  instanceof  SelfContext  )  {  [FE]  AssertionFailedError:  Evaluating  <$d  =  'a'>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$d  =  'b' "  ,  Boolean  .  TRUE  )  ;  [METHOD]  equal  [TYPE]  boolean  [PARAMETER]  EvalContext  context  Expression  left  Expression  right  [CLASS]  CoreOperationCompare  [TYPE]  boolean  false  true  [TYPE]  Expression  left  right  [TYPE]  EvalContext  context  [TYPE]  Object  l  r  [CONTEXT]  protected  boolean  equal  (  EvalContext  context  ,  Expression  left  ,  Expression  right  )  {  Object  l  =  left  .  compute  (  context  )  ;  Object  r  =  right  .  compute  (  context  )  ;      if  (  l  instanceof  InitialContext  ||  l  instanceof  SelfContext  )  {  l  =  (  (  EvalContext  )  l  )  .  getSingleNodePointer  (  )  ;  }  [BUGGY]  if  (  r  instanceof  InitialContext  ||  r  instanceof  SelfContext  )  {  r  =  (  (  EvalContext  )  r  )  .  getSingleNodePointer  (  )  ;  }  if  (  l  instanceof  Collection  )  {  l  =  (  (  Collection  )  l  )  .  iterator  (  )  ;  	JxPath_6_CoreOperationCompare_2_2	61	1	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java
1784		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationGreaterThan_2_1	19	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java
1785	protected  boolean  evaluateCompare(int  compare)  {  return  compare  >  0;  	[BUGGY]  public  Object  computeValue  (  EvalContext  context  )  {  double  l  =  InfoSetUtil  .  doubleValue  (  args[0]  .  computeValue  (  context  )  )  ;  double  r  =  InfoSetUtil  .  doubleValue  (  args[1]  .  computeValue  (  context  )  )  ;  return  l  >  r  ?  Boolean  .  TRUE  :  Boolean  .  FALSE  ;  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationGreaterThan_2_2	33	4	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThan.java
1786		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationGreaterThanOrEqual_2_1	19	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java
1787	protected  boolean  evaluateCompare(int  compare)  {  return  compare  >=  0;  	[BUGGY]  public  Object  computeValue  (  EvalContext  context  )  {  double  l  =  InfoSetUtil  .  doubleValue  (  args[0]  .  computeValue  (  context  )  )  ;  double  r  =  InfoSetUtil  .  doubleValue  (  args[1]  .  computeValue  (  context  )  )  ;  return  l  >  =  r  ?  Boolean  .  TRUE  :  Boolean  .  FALSE  ;  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationGreaterThanOrEqual_2_2	34	4	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationGreaterThanOrEqual.java
1788		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationLessThan_2_1	19	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java
1789	protected  boolean  evaluateCompare(int  compare)  {  return  compare  <  0;  	[BUGGY]  public  Object  computeValue  (  EvalContext  context  )  {  double  l  =  InfoSetUtil  .  doubleValue  (  args[0]  .  computeValue  (  context  )  )  ;  double  r  =  InfoSetUtil  .  doubleValue  (  args[1]  .  computeValue  (  context  )  )  ;  return  l  <  r  ?  Boolean  .  TRUE  :  Boolean  .  FALSE  ;  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationLessThan_2_2	33	4	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThan.java
1790		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationLessThanOrEqual_2_1	19	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java
1791	protected  boolean  evaluateCompare(int  compare)  {  return  compare  <=  0;  	[BUGGY]  public  Object  computeValue  (  EvalContext  context  )  {  double  l  =  InfoSetUtil  .  doubleValue  (  args[0]  .  computeValue  (  context  )  )  ;  double  r  =  InfoSetUtil  .  doubleValue  (  args[1]  .  computeValue  (  context  )  )  ;  return  l  <  =  r  ?  Boolean  .  TRUE  :  Boolean  .  FALSE  ;  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationLessThanOrEqual_2_2	34	4	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationLessThanOrEqual.java
1792	    	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationRelationalExpression_3_1	19	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java
1793	public  final  Object  computeValue(EvalContext  context)  {  return  compute(args[0].computeValue(context),  args[1]  .computeValue(context))  ?  Boolean.TRUE  :  Boolean.FALSE;  }    	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationRelationalExpression_3_2	31	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java
1794	protected  abstract  boolean  evaluateCompare(int  compare);    private  boolean  compute(Object  left,  Object  right)  {  left  =  reduce(left);  right  =  reduce(right);    if  (left  instanceof  InitialContext)  {  ((InitialContext)  left).reset();  }  if  (right  instanceof  InitialContext)  {  ((InitialContext)  right).reset();  }  if  (left  instanceof  Iterator  &&  right  instanceof  Iterator)  {  return  findMatch((Iterator)  left,  (Iterator)  right);  }  if  (left  instanceof  Iterator)  {  return  containsMatch((Iterator)  left,  right);  }  if  (right  instanceof  Iterator)  {  return  containsMatch((Iterator)  right,  left);  }  return  evaluateCompare(compare(left,  right));  }    private  Object  reduce(Object  o)  {  if  (o  instanceof  SelfContext)  {  o  =  ((EvalContext)  o).getSingleNodePointer();  }  if  (o  instanceof  Collection)  {  o  =  ((Collection)  o).iterator();  }  return  o;  }    private  boolean  containsMatch(Iterator  it,  Object  value)  {  while  (it.hasNext())  {  Object  element  =  it.next();  if  (evaluateCompare(compare(element,  value)))  {  return  true;  }  }  return  false;  }    private  boolean  findMatch(Iterator  lit,  Iterator  rit)  {  HashSet  left  =  new  HashSet();  while  (lit.hasNext())  {  left.add(lit.next());  }  while  (rit.hasNext())  {  if  (containsMatch(left.iterator(),  rit.next()))  {  return  true;  }  }  return  false;  }    private  int  compare(Object  l,  Object  r)  {  double  ld  =  InfoSetUtil.doubleValue(l);  double  rd  =  InfoSetUtil.doubleValue(r);  return  ld  ==  rd  ?  0  :  ld  <  rd  ?  -1  :  1;  }    	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$array  >  0>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$array  <  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_7_CoreOperationRelationalExpression_3_3	39	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java
1795	if  (Double.isNaN(ld))  {  return  false;  }  if  (Double.isNaN(rd))  {  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$nan  >  $nan>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$nan  =  1 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [METHOD]  compute  [TYPE]  boolean  [PARAMETER]  Object  left  Object  right  [CLASS]  CoreOperationRelationalExpression  [TYPE]  boolean  false  true  [TYPE]  double  ld  rd  [TYPE]  Object  left  right  [CONTEXT]  private  boolean  compute  (  Object  left  ,  Object  right  )  {  left  =  reduce  (  left  )  ;  right  =  reduce  (  right  )  ;  if  (  left  instanceof  InitialContext  )  {  (  (  InitialContext  )  left  )  .  reset  (  )  ;  }  if  (  right  instanceof  InitialContext  )  {  (  (  InitialContext  )  right  )  .  reset  (  )  ;  }  if  (  left  instanceof  Iterator  &&  right  instanceof  Iterator  )  {  return  findMatch  (  (  Iterator  )  left  ,  (  Iterator  )  right  )  ;  }  if  (  left  instanceof  Iterator  )  {  return  containsMatch  (  (  Iterator  )  left  ,  right  )  ;  }  if  (  right  instanceof  Iterator  )  {  return  containsMatch  (  (  Iterator  )  right  ,  left  )  ;  }  double  ld  =  InfoSetUtil  .  doubleValue  (  left  )  ;  [BUGGY]  double  rd  =  InfoSetUtil  .  doubleValue  (  right  )  ;  return  evaluateCompare  (  ld  =  =  rd  ?  0  :  ld  <  rd  ?  -1  :  1  )  ;  }  	JxPath_8_CoreOperationRelationalExpression_1_1	76	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java
1796	private  boolean  invert;  this(arg1,  arg2,  false);  }    protected  CoreOperationCompare(Expression  arg1,  Expression  arg2,  boolean  invert)  {  this.invert  =  invert;  }    public  Object  computeValue(EvalContext  context)  {  return  equal(context,  args[0],  args[1])  ?  Boolean.TRUE  :  Boolean.FALSE;  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$nan  =  $nan>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$nan  !  =  1 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_9_CoreOperationCompare_3_1	37	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java
1797		[BUGGY]  if  (  l  instanceof  Pointer  &&  r  instanceof  Pointer  )  {  if  (  l  .  equals  (  r  )  )  {  return  true  ;  }  }  [FE]  AssertionFailedError:  Evaluating  <$nan  =  $nan>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$nan  !  =  1 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [METHOD]  equal  [TYPE]  boolean  [PARAMETER]  Object  l  Object  r  [CLASS]  CoreOperationCompare  [TYPE]  boolean  false  true  [TYPE]  Object  l  r  [CONTEXT]  protected  boolean  equal  (  Object  l  ,  Object  r  )  {  [BUGGY]  if  (  l  instanceof  Pointer  &&  r  instanceof  Pointer  )  {  if  (  l  .  equals  (  r  )  )  {  return  true  ;  }  }  if  (  l  instanceof  Pointer  )  {  l  =  (  (  Pointer  )  l  )  .  getValue  (  )  ;  }  if  (  r  instanceof  Pointer  )  {  r  =  (  (  Pointer  )  r  )  .  getValue  (  )  ;  }  if  (  l  =  =  r  )  {  return  true  ;  }  if  (  l  instanceof  Boolean  ||  r  instanceof  Boolean  )  {  return  (  InfoSetUtil  .  booleanValue  (  l  )  =  =  InfoSetUtil  .  booleanValue  (  r  )  )  ;  }  if  (  l  instanceof  Number  ||  r  instanceof  Number  )  {  return  (  InfoSetUtil  .  doubleValue  (  l  )  =  =  InfoSetUtil  .  doubleValue  (  r  )  )  ;  }  if  (  l  instanceof  String  ||  r  instanceof  String  )  {  return  (  InfoSetUtil  .  stringValue  (  l  )  .  equals  (  InfoSetUtil  .  stringValue  (  r  )  )  )  ;  }  return  l  !  =  null  &&  l  .  equals  (  r  )  ;  }  	JxPath_9_CoreOperationCompare_3_2	121	5	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java
1798	boolean  result;  result  =  l  ==  r  ||  InfoSetUtil.booleanValue(l)  ==  InfoSetUtil.booleanValue(r);  }  else  if  (l  instanceof  Number  ||  r  instanceof  Number)  {  double  ld  =  InfoSetUtil.doubleValue(l);  if  (Double.isNaN(ld))  {  return  false;  double  rd  =  InfoSetUtil.doubleValue(r);  if  (Double.isNaN(rd))  {  return  false;  }  result  =  ld  ==  rd;  }  else  {  l  =  InfoSetUtil.stringValue(l);  r  =  InfoSetUtil.stringValue(r);  }  result  =  l  ==  r  ||  l  !=  null  &&  l.equals(r);  return  result  ^  invert;  	[BUGGY]  if  (  l  =  =  r  )  {  return  true  ;  }  return  (  InfoSetUtil  .  booleanValue  (  l  )  =  =  InfoSetUtil  .  booleanValue  (  r  )  )  ;  }  if  (  l  instanceof  Number  ||  r  instanceof  Number  )  {  return  (  InfoSetUtil  .  doubleValue  (  l  )  =  =  InfoSetUtil  .  doubleValue  (  r  )  )  ;  return  (  InfoSetUtil  .  stringValue  (  l  )  .  equals  (  InfoSetUtil  .  stringValue  (  r  )  )  )  ;  return  l  !  =  null  &&  l  .  equals  (  r  )  ;  [FE]  AssertionFailedError:  Evaluating  <$nan  =  $nan>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$nan  !  =  1 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [METHOD]  equal  [TYPE]  boolean  [PARAMETER]  Object  l  Object  r  [CLASS]  CoreOperationCompare  [TYPE]  boolean  false  true  [TYPE]  Object  l  r  [CONTEXT]  protected  boolean  equal  (  Object  l  ,  Object  r  )  {  if  (  l  instanceof  Pointer  &&  r  instanceof  Pointer  )  {  if  (  l  .  equals  (  r  )  )  {  return  true  ;  }  }  if  (  l  instanceof  Pointer  )  {  l  =  (  (  Pointer  )  l  )  .  getValue  (  )  ;  }  if  (  r  instanceof  Pointer  )  {  r  =  (  (  Pointer  )  r  )  .  getValue  (  )  ;  }  [BUGGY]  if  (  l  =  =  r  )  {  return  true  ;  }  if  (  l  instanceof  Boolean  ||  r  instanceof  Boolean  )  {  return  (  InfoSetUtil  .  booleanValue  (  l  )  =  =  InfoSetUtil  .  booleanValue  (  r  )  )  ;  }  if  (  l  instanceof  Number  ||  r  instanceof  Number  )  {  return  (  InfoSetUtil  .  doubleValue  (  l  )  =  =  InfoSetUtil  .  doubleValue  (  r  )  )  ;  }  if  (  l  instanceof  String  ||  r  instanceof  String  )  {  return  (  InfoSetUtil  .  stringValue  (  l  )  .  equals  (  InfoSetUtil  .  stringValue  (  r  )  )  )  ;  }  return  l  !  =  null  &&  l  .  equals  (  r  )  ;  }  	JxPath_9_CoreOperationCompare_3_3	134	10	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java
1799		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$nan  =  $nan>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$nan  !  =  1 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_9_CoreOperationEqual_2_1	19	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java
1800		[BUGGY]  public  Object  computeValue  (  EvalContext  context  )  {  return  equal  (  context  ,  args[0]  ,  args[1]  )  ?  Boolean  .  TRUE  :  Boolean  .  FALSE  ;  }  [FE]  AssertionFailedError:  Evaluating  <$nan  =  $nan>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$nan  !  =  1 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_9_CoreOperationEqual_2_2	32	3	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationEqual.java
1801		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$nan  =  $nan>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$nan  !  =  1 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_9_CoreOperationNotEqual_2_1	19	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java
1802	super(arg1,  arg2,  true);  	[BUGGY]  super  (  arg1  ,  arg2  )  ;  public  Object  computeValue  (  EvalContext  context  )  {  return  equal  (  context  ,  args[0]  ,  args[1]  )  ?  Boolean  .  FALSE  :  Boolean  .  TRUE  ;  }  [FE]  AssertionFailedError:  Evaluating  <$nan  =  $nan>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$nan  !  =  1 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [CLASS]  [CONTEXT]  	JxPath_9_CoreOperationNotEqual_2_2	29	4	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationNotEqual.java
1803	return  compute(args[0].compute(context),  args[1].compute(context))  	[BUGGY]  return  compute  (  args[0]  .  computeValue  (  context  )  ,  args[1]  .  computeValue  (  context  )  )  [FE]  AssertionFailedError:  Evaluating  </idonotexist  >  =  0>  expected:<false>  but  was:<true>  assertXPathValue  (  context  ,   "$array[position  (  )  <  1]  <  =  0 "  ,  Boolean  .  FALSE  ,  Boolean  .  class  )  ;  [METHOD]  computeValue  [TYPE]  Object  [PARAMETER]  EvalContext  context  [CLASS]  CoreOperationRelationalExpression  [TYPE]  boolean  false  true  [TYPE]  EvalContext  context  [CONTEXT]  public  final  Object  computeValue  (  EvalContext  context  )  {  [BUGGY]  return  compute  (  args[0]  .  computeValue  (  context  )  ,  args[1]  .  computeValue  (  context  )  )  ?  Boolean  .  TRUE  :  Boolean  .  FALSE  ;  }  	JxPath_10_CoreOperationRelationalExpression_1_1	42	1	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java
1804		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <vendor[1]/product[1]/rate:amount[1]/@rate:discount>  expected:<10%>  but  was:<20%>  [CLASS]  [CONTEXT]  	JxPath_11_DOMAttributeIterator_2_1	22	0	src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java
1805	NamespaceResolver  nsr  =  parent.getNamespaceResolver();  testNS  =  nsr  ==  null  ?  null  :  nsr.getNamespaceURI(testPrefix);  testNS  =  testNS  ==  null  ?  parent.getNamespaceURI(testPrefix)  :  testNS;  	[BUGGY]  testNS  =  parent  .  getNamespaceURI  (  testPrefix  )  ;  [FE]  AssertionFailedError:  Evaluating  <vendor[1]/product[1]/rate:amount[1]/@rate:discount>  expected:<10%>  but  was:<20%>  [METHOD]  getAttribute  [TYPE]  Attr  [PARAMETER]  Element  element  QName  name  [CLASS]  DOMAttributeIterator  [TYPE]  NamedNodeMap  nnm  [TYPE]  boolean  false  true  [TYPE]  QName  name  [TYPE]  Element  element  [TYPE]  List  attributes  [TYPE]  NodePointer  parent  [TYPE]  String  testNS  testPrefix  [TYPE]  int  i  position  [TYPE]  Attr  attr  [CONTEXT]  private  Attr  getAttribute  (  Element  element  ,  QName  name  )  {  String  testPrefix  =  name  .  getPrefix  (  )  ;  String  testNS  =  null  ;  if  (  testPrefix  !  =  null  )  {  [BUGGY]  testNS  =  parent  .  getNamespaceURI  (  testPrefix  )  ;  }  if  (  testNS  !  =  null  )  {  Attr  attr  =  element  .  getAttributeNodeNS  (  testNS  ,  name  .  getName  (  )  )  ;  if  (  attr  !  =  null  )  {  return  attr  ;  }    NamedNodeMap  nnm  =  element  .  getAttributes  (  )  ;  for  (  int  i  =  0  ;  i  <  nnm  .  getLength  (  )  ;  i++  )  {  attr  =  (  Attr  )  nnm  .  item  (  i  )  ;  if  (  testAttr  (  attr  ,  name  )  )  {  return  attr  ;  }  }  return  null  ;  }  return  element  .  getAttributeNode  (  name  .  getName  (  )  )  ;  }  	JxPath_11_DOMAttributeIterator_2_2	111	1	src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java
1806		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <vendor[1]/product[1]/rate:amount[1]/@rate:discount>  expected:<10%>  but  was:<20%>  [CLASS]  [CONTEXT]  	JxPath_11_JDOMAttributeIterator_4_1	23	0	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java
1807	NamespaceResolver  nsr  =  parent.getNamespaceResolver();  if  (nsr  !=  null)  {  String  uri  =  nsr.getNamespaceURI(prefix);  if  (uri  !=  null)  {  ns  =  Namespace.getNamespace(prefix,  uri);  }  }  if  (ns  ==  null)  {  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <vendor[1]/product[1]/rate:amount[1]/@rate:discount>  expected:<10%>  but  was:<20%>  [CLASS]  [CONTEXT]  	JxPath_11_JDOMAttributeIterator_4_2	52	0	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java
1808	}  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <vendor[1]/product[1]/rate:amount[1]/@rate:discount>  expected:<10%>  but  was:<20%>  [CLASS]  [CONTEXT]  	JxPath_11_JDOMAttributeIterator_4_3	58	0	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java
1809	}  	[BUGGY]  }  [FE]  AssertionFailedError:  Evaluating  <vendor[1]/product[1]/rate:amount[1]/@rate:discount>  expected:<10%>  but  was:<20%>  [CLASS]  [CONTEXT]  	JxPath_11_JDOMAttributeIterator_4_4	114	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java
1810	return  equalStrings(namespaceURI,  nodeNS)  ||  nodeNS  ==  null  &&  equalStrings(testPrefix,  getPrefix(node));  	[BUGGY]  return  equalStrings  (  namespaceURI  ,  nodeNS  )  ;  [FE]  commonsjxpathJXPathNotFoundException:  No  value  for  xpath:  /ElementA/B:ElementB  [METHOD]  testNode  [TYPE]  boolean  [PARAMETER]  Node  node  NodeTest  test  [CLASS]  DOMNodePointer  [TYPE]  boolean  false  true  wildcard  [TYPE]  NodeNameTest  nodeNameTest  [TYPE]  QName  testName  [TYPE]  Node  node  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  namespaceURI  nodeNS  nodePI  testPI  testPrefix  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  NodeTest  test  [TYPE]  int  nodeType  [CONTEXT]  public  static  boolean  testNode  (  Node  node  ,  NodeTest  test  )  {  if  (  test  =  =  null  )  {  return  true  ;  }  if  (  test  instanceof  NodeNameTest  )  {  if  (  node  .  getNodeType  (  )  !  =  Node  .  ELEMENT_NODE  )  {  return  false  ;  }  NodeNameTest  nodeNameTest  =  (  NodeNameTest  )  test  ;  QName  testName  =  nodeNameTest  .  getNodeName  (  )  ;  String  namespaceURI  =  nodeNameTest  .  getNamespaceURI  (  )  ;  boolean  wildcard  =  nodeNameTest  .  isWildcard  (  )  ;  String  testPrefix  =  testName  .  getPrefix  (  )  ;  if  (  wildcard  &&  testPrefix  =  =  null  )  {  return  true  ;  }  if  (  wildcard  ||  testName  .  getName  (  )    .  equals  (  DOMNodePointer  .  getLocalName  (  node  )  )  )  {  String  nodeNS  =  DOMNodePointer  .  getNamespaceURI  (  node  )  ;  [BUGGY]  return  equalStrings  (  namespaceURI  ,  nodeNS  )  ;  }  return  false  ;  }  if  (  test  instanceof  NodeTypeTest  )  {  int  nodeType  =  node  .  getNodeType  (  )  ;  	JxPath_12_DOMNodePointer_1_1	108	1	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1811	protected  static  String  getPrefix(NodePointer  pointer,  String  namespaceURI)  {  NodePointer  currentPointer  =  pointer;  while  (currentPointer  !=  null)  {  NodeIterator  ni  =  currentPointer.namespaceIterator();  for  (int  position  =  1;  ni  !=  null  &&  ni.setPosition(position);  position++)  {  NodePointer  nsPointer  =  ni.getNodePointer();  String  uri  =  nsPointer.getNamespaceURI();  if  (uri.equals(namespaceURI))  {  String  prefix  =  nsPointer.getName().getName();  if  (! " ".equals(prefix))  {  return  prefix;  }  }  }  currentPointer  =  pointer.getParent();  }  return  null;  }  	[BUGGY]  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [CLASS]  [CONTEXT]  	JxPath_13_NamespaceResolver_7_1	47	0	src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java
1812	String  uri  =  getExternallyRegisteredNamespaceURI(prefix);  return  uri  ==  null  &&  pointer  !=  null  ?  pointer.getNamespaceURI(prefix)  :  uri;  }  	[BUGGY]  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [METHOD]  getNamespaceURI  [TYPE]  String  [PARAMETER]  String  prefix  [CLASS]  NamespaceResolver  [TYPE]  NamespaceResolver  parent  [TYPE]  boolean  false  sealed  true  [TYPE]  NodePointer  pointer  [TYPE]  String  prefix  uri  [TYPE]  HashMap  namespaceMap  reverseMap  [CONTEXT]  public  synchronized  String  getNamespaceURI  (  String  prefix  )  {  [BUGGY]        String  uri  =  (  String  )  namespaceMap  .  get  (  prefix  )  ;  if  (  uri  =  =  null  &&  pointer  !  =  null  )  {  uri  =  pointer  .  getNamespaceURI  (  prefix  )  ;  }  if  (  uri  =  =  null  &&  parent  !  =  null  )  {  return  parent  .  getNamespaceURI  (  prefix  )  ;  }  return  uri  ;  }  	JxPath_13_NamespaceResolver_7_2	108	0	src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java
1813	protected  synchronized  String  getExternallyRegisteredNamespaceURI(  String  prefix)  {  return  uri  ==  null  &&  parent  !=  null  ?  parent  .getExternallyRegisteredNamespaceURI(prefix)  :  uri;  	[BUGGY]  if  (  uri  =  =  null  &&  pointer  !  =  null  )  {  uri  =  pointer  .  getNamespaceURI  (  prefix  )  ;  }  if  (  uri  =  =  null  &&  parent  !  =  null  )  {  return  parent  .  getNamespaceURI  (  prefix  )  ;  }  return  uri  ;  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [METHOD]  getNamespaceURI  [TYPE]  String  [PARAMETER]  String  prefix  [CLASS]  NamespaceResolver  [TYPE]  NamespaceResolver  parent  [TYPE]  boolean  false  sealed  true  [TYPE]  NodePointer  pointer  [TYPE]  String  prefix  uri  [TYPE]  HashMap  namespaceMap  reverseMap  [CONTEXT]  public  synchronized  String  getNamespaceURI  (  String  prefix  )  {        [BUGGY]  String  uri  =  (  String  )  namespaceMap  .  get  (  prefix  )  ;  if  (  uri  =  =  null  &&  pointer  !  =  null  )  {  uri  =  pointer  .  getNamespaceURI  (  prefix  )  ;  }  if  (  uri  =  =  null  &&  parent  !  =  null  )  {  return  parent  .  getNamespaceURI  (  prefix  )  ;  }  return  uri  ;  }  	JxPath_13_NamespaceResolver_7_3	116	7	src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java
1814	String  prefix  =  getExternallyRegisteredPrefix(namespaceURI);  return  prefix  ==  null  &&  pointer  !=  null  ?  getPrefix(pointer,  namespaceURI)  :  prefix;  }  	[BUGGY]  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [METHOD]  getPrefix  [TYPE]  String  [PARAMETER]  String  namespaceURI  [CLASS]  NamespaceResolver  [TYPE]  NodeIterator  ni  [TYPE]  Entry  entry  [TYPE]  boolean  false  sealed  true  [TYPE]  HashMap  namespaceMap  reverseMap  [TYPE]  Iterator  it  [TYPE]  NamespaceResolver  parent  [TYPE]  NodePointer  nsPointer  pointer  [TYPE]  String  namespaceURI  prefix  uri  [TYPE]  int  position  [CONTEXT]  public  synchronized  String  getPrefix  (  String  namespaceURI  )  {  [BUGGY]      	JxPath_13_NamespaceResolver_7_4	132	0	src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java
1815	protected  synchronized  String  getExternallyRegisteredPrefix(String  namespaceURI)  {  	[BUGGY]  NodeIterator  ni  =  pointer  .  namespaceIterator  (  )  ;  if  (  ni  !  =  null  )  {  for  (  int  position  =  1  ;  ni  .  setPosition  (  position  )  ;  position++  )  {  NodePointer  nsPointer  =  ni  .  getNodePointer  (  )  ;  String  uri  =  nsPointer  .  getNamespaceURI  (  )  ;  String  prefix  =  nsPointer  .  getName  (  )  .  getName  (  )  ;  if  (  ! " "  .  equals  (  prefix  )  )  {  reverseMap  .  put  (  uri  ,  prefix  )  ;  }  }  }  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [METHOD]  getPrefix  [TYPE]  String  [PARAMETER]  String  namespaceURI  [CLASS]  NamespaceResolver  [TYPE]  NodeIterator  ni  [TYPE]  Entry  entry  [TYPE]  boolean  false  sealed  true  [TYPE]  HashMap  namespaceMap  reverseMap  [TYPE]  Iterator  it  [TYPE]  NamespaceResolver  parent  [TYPE]  NodePointer  nsPointer  pointer  [TYPE]  String  namespaceURI  prefix  uri  [TYPE]  int  position  [CONTEXT]  public  synchronized  String  getPrefix  (  String  namespaceURI  )  {        [BUGGY]  if  (  reverseMap  =  =  null  )  {  reverseMap  =  new  HashMap  (  )  ;  NodeIterator  ni  =  pointer  .  namespaceIterator  (  )  ;  if  (  ni  !  =  null  )  {  for  (  int  position  =  1  ;  ni  .  setPosition  (  position  )  ;  position++  )  {  NodePointer  nsPointer  =  ni  .  getNodePointer  (  )  ;  	JxPath_13_NamespaceResolver_7_5	139	11	src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java
1816	return  prefix  ==  null  &&  parent  !=  null  ?  parent  .getExternallyRegisteredPrefix(namespaceURI)  :  prefix;  	[BUGGY]  if  (  prefix  =  =  null  &&  parent  !  =  null  )  {  return  parent  .  getPrefix  (  namespaceURI  )  ;  }  return  prefix  ;  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [METHOD]  getPrefix  [TYPE]  String  [PARAMETER]  String  namespaceURI  [CLASS]  NamespaceResolver  [TYPE]  NodeIterator  ni  [TYPE]  Entry  entry  [TYPE]  boolean  false  sealed  true  [TYPE]  HashMap  namespaceMap  reverseMap  [TYPE]  Iterator  it  [TYPE]  NamespaceResolver  parent  [TYPE]  NodePointer  nsPointer  pointer  [TYPE]  String  namespaceURI  prefix  uri  [TYPE]  int  position  [CONTEXT]      if  (  reverseMap  =  =  null  )  {  reverseMap  =  new  HashMap  (  )  ;  NodeIterator  ni  =  pointer  .  namespaceIterator  (  )  ;  if  (  ni  !  =  null  )  {  for  (  int  position  =  1  ;  ni  .  setPosition  (  position  )  ;  position++  )  {  NodePointer  nsPointer  =  ni  .  getNodePointer  (  )  ;  String  uri  =  nsPointer  .  getNamespaceURI  (  )  ;  String  prefix  =  nsPointer  .  getName  (  )  .  getName  (  )  ;  if  (  ! " "  .  equals  (  prefix  )  )  {  reverseMap  .  put  (  uri  ,  prefix  )  ;  }  }  }  Iterator  it  =  namespaceMap  .  entrySet  (  )  .  iterator  (  )  ;  while  (  it  .  hasNext  (  )  )  {  Map  .  Entry  entry  =  (  Map  .  Entry  )  it  .  next  (  )  ;  reverseMap  .  put  (  entry  .  getValue  (  )  ,  entry  .  getKey  (  )  )  ;  }  }  String  prefix  =  (  String  )  reverseMap  .  get  (  namespaceURI  )  ;  [BUGGY]  if  (  prefix  =  =  null  &&  parent  !  =  null  )  {  return  parent  .  getPrefix  (  namespaceURI  )  ;  }  return  prefix  ;  }  	JxPath_13_NamespaceResolver_7_6	159	4	src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java
1817	}  	[BUGGY]  }  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [CLASS]  [CONTEXT]  	JxPath_13_NamespaceResolver_7_7	200	1	src/java/org/apache/commons/jxpath/ri/NamespaceResolver.java
1818		[BUGGY]  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [CLASS]  [CONTEXT]  	JxPath_13_DOMNodePointer_4_1	29	0	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1819	private  NamespaceResolver  localNamespaceResolver;  	[BUGGY]  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [CLASS]  [CONTEXT]  	JxPath_13_DOMNodePointer_4_2	61	0	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1820	public  synchronized  NamespaceResolver  getNamespaceResolver()  {  if  (localNamespaceResolver  ==  null)  {  localNamespaceResolver  =  new  NamespaceResolver(super.getNamespaceResolver());  localNamespaceResolver.setNamespaceContextPointer(this);  }  return  localNamespaceResolver;  }  	[BUGGY]  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [CLASS]  [CONTEXT]  	JxPath_13_DOMNodePointer_4_3	189	0	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1821	String  ns  =  null;  NamespaceResolver  nsr  =  getNamespaceResolver();  if  (nsr  !=  null)  {  ns  =  nsr.getNamespaceURI(prefix);  }  	[BUGGY]  String  ns  =  getNamespaceURI  (  prefix  )  ;  [FE]  commonsjxpathJXPathException:  Unknown  namespace  prefix:  A  [METHOD]  createAttribute  [TYPE]  NodePointer  [PARAMETER]  JXPathContext  context  QName  name  [CLASS]  DOMNodePointer  [TYPE]  NodeIterator  it  [TYPE]  boolean  false  true  [TYPE]  JXPathContext  context  [TYPE]  QName  name  [TYPE]  Node  node  [TYPE]  Element  element  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  ns  prefix  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [CONTEXT]  public  NodePointer  createAttribute  (  JXPathContext  context  ,  QName  name  )  {  if  (  !  (  node  instanceof  Element  )  )  {  return  super  .  createAttribute  (  context  ,  name  )  ;  }  Element  element  =  (  Element  )  node  ;  String  prefix  =  name  .  getPrefix  (  )  ;  if  (  prefix  !  =  null  )  {  [BUGGY]  String  ns  =  getNamespaceURI  (  prefix  )  ;  if  (  ns  =  =  null  )  {  throw  new  JXPathException  (   "Unknown  namespace  prefix:   "  +  prefix  )  ;  }  element  .  setAttributeNS  (  ns  ,  name  .  toString  (  )  ,   " "  )  ;  }  else  {  if  (  !element  .  hasAttribute  (  name  .  getName  (  )  )  )  {  element  .  setAttribute  (  name  .  getName  (  )  ,   " "  )  ;  }  }  NodeIterator  it  =  attributeIterator  (  name  )  ;  it  .  setPosition  (  1  )  ;  return  it  .  getNodePointer  (  )  ;  }  	JxPath_13_DOMNodePointer_4_4	415	1	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1822	if  (Double.isNaN(v)  ||  Double.isInfinite(v))  {  \treturn  new  Double(v);  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <round  (  'NaN'  )  >  expected:<NaN>  but  was:<00>  assertXPathValue  (  context  ,   "round  (  2  div  0  )   "  ,  new  Double  (  Double  .  POSITIVE_INFINITY  )  )  ;  [METHOD]  functionFloor  [TYPE]  Object  [PARAMETER]  EvalContext  context  [CLASS]  CoreFunction  [TYPE]  EvalContext  context  [TYPE]  boolean  false  true  [TYPE]  Double  ZERO  [TYPE]  int  functionCode  [TYPE]  double  v  [CONTEXT]  protected  Object  functionFloor  (  EvalContext  context  )  {  assertArgCount  (  1  )  ;  double  v  =  InfoSetUtil  .  doubleValue  (  getArg1  (  )  .  computeValue  (  context  )  )  ;  [BUGGY]  return  new  Double  (  Math  .  floor  (  v  )  )  ;  }  	JxPath_14_CoreFunction_3_1	656	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java
1823	if  (Double.isNaN(v)  ||  Double.isInfinite(v))  {  \treturn  new  Double(v);  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <round  (  'NaN'  )  >  expected:<NaN>  but  was:<00>  assertXPathValue  (  context  ,   "round  (  2  div  0  )   "  ,  new  Double  (  Double  .  POSITIVE_INFINITY  )  )  ;  [METHOD]  functionCeiling  [TYPE]  Object  [PARAMETER]  EvalContext  context  [CLASS]  CoreFunction  [TYPE]  EvalContext  context  [TYPE]  boolean  false  true  [TYPE]  Double  ZERO  [TYPE]  int  functionCode  [TYPE]  double  v  [CONTEXT]  protected  Object  functionCeiling  (  EvalContext  context  )  {  assertArgCount  (  1  )  ;  double  v  =  InfoSetUtil  .  doubleValue  (  getArg1  (  )  .  computeValue  (  context  )  )  ;  [BUGGY]  return  new  Double  (  Math  .  ceil  (  v  )  )  ;  }  	JxPath_14_CoreFunction_3_2	662	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java
1824	if  (Double.isNaN(v)  ||  Double.isInfinite(v))  {  \treturn  new  Double(v);  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <round  (  'NaN'  )  >  expected:<NaN>  but  was:<00>  assertXPathValue  (  context  ,   "round  (  2  div  0  )   "  ,  new  Double  (  Double  .  POSITIVE_INFINITY  )  )  ;  [METHOD]  functionRound  [TYPE]  Object  [PARAMETER]  EvalContext  context  [CLASS]  CoreFunction  [TYPE]  EvalContext  context  [TYPE]  boolean  false  true  [TYPE]  Double  ZERO  [TYPE]  int  functionCode  [TYPE]  double  v  [CONTEXT]  protected  Object  functionRound  (  EvalContext  context  )  {  assertArgCount  (  1  )  ;  double  v  =  InfoSetUtil  .  doubleValue  (  getArg1  (  )  .  computeValue  (  context  )  )  ;  [BUGGY]  return  new  Double  (  Math  .  round  (  v  )  )  ;  }  	JxPath_14_CoreFunction_3_3	668	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreFunction.java
1825		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  </vendor[1]/contact[4]  |  /vendor[1]/contact[1]>  expected:<John>  but  was:<Jack  Black>  [CLASS]  [CONTEXT]  	JxPath_15_UnionContext_4_1	20	0	src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java
1826		[BUGGY]  nodeSet  .  add  (  ptr  )  ;  [FE]  AssertionFailedError:  Evaluating  </vendor[1]/contact[4]  |  /vendor[1]/contact[1]>  expected:<John>  but  was:<Jack  Black>  [METHOD]  setPosition  [TYPE]  boolean  [PARAMETER]  int  position  [CLASS]  UnionContext  [TYPE]  boolean  false  prepared  true  [TYPE]  ArrayList  pointers  [TYPE]  EvalContext  ctx  [TYPE]  BasicNodeSet  nodeSet  [TYPE]  NodePointer  ptr  [TYPE]  EvalContext[]  contexts  [TYPE]  int  i  position  [CONTEXT]  public  boolean  setPosition  (  int  position  )  {  if  (  !prepared  )  {  prepared  =  true  ;  BasicNodeSet  nodeSet  =  (  BasicNodeSet  )  getNodeSet  (  )  ;  ArrayList  pointers  =  new  ArrayList  (  )  ;  for  (  int  i  =  0  ;  i  <  contexts  .  length  ;  i++  )  {  EvalContext  ctx  =  (  EvalContext  )  contexts[i]  ;  while  (  ctx  .  nextSet  (  )  )  {  while  (  ctx  .  nextNode  (  )  )  {  NodePointer  ptr  =  ctx  .  getCurrentNodePointer  (  )  ;  if  (  !pointers  .  contains  (  ptr  )  )  {  [BUGGY]  nodeSet  .  add  (  ptr  )  ;  pointers  .  add  (  ptr  )  ;  }  }  }  }  }  return  super  .  setPosition  (  position  )  ;  }  	JxPath_15_UnionContext_4_2	56	1	src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java
1827	sortPointers(pointers);    for  (Iterator  it  =  pointers.iterator();  it.hasNext();)  {  nodeSet.add((Pointer)  it.next());  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  </vendor[1]/contact[4]  |  /vendor[1]/contact[1]>  expected:<John>  but  was:<Jack  Black>  [METHOD]  setPosition  [TYPE]  boolean  [PARAMETER]  int  position  [CLASS]  UnionContext  [TYPE]  boolean  false  prepared  true  [TYPE]  ArrayList  pointers  [TYPE]  EvalContext  ctx  [TYPE]  BasicNodeSet  nodeSet  [TYPE]  NodePointer  ptr  [TYPE]  EvalContext[]  contexts  [TYPE]  int  i  position  [CONTEXT]  public  boolean  setPosition  (  int  position  )  {  if  (  !prepared  )  {  prepared  =  true  ;  BasicNodeSet  nodeSet  =  (  BasicNodeSet  )  getNodeSet  (  )  ;  ArrayList  pointers  =  new  ArrayList  (  )  ;  for  (  int  i  =  0  ;  i  <  contexts  .  length  ;  i++  )  {  EvalContext  ctx  =  (  EvalContext  )  contexts[i]  ;  while  (  ctx  .  nextSet  (  )  )  {  while  (  ctx  .  nextNode  (  )  )  {  NodePointer  ptr  =  ctx  .  getCurrentNodePointer  (  )  ;  if  (  !pointers  .  contains  (  ptr  )  )  {  nodeSet  .  add  (  ptr  )  ;  pointers  .  add  (  ptr  )  ;  }  }  }  }  [BUGGY]  }  return  super  .  setPosition  (  position  )  ;  }  	JxPath_15_UnionContext_4_3	62	0	src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java
1828	}  	[BUGGY]  }  [FE]  AssertionFailedError:  Evaluating  </vendor[1]/contact[4]  |  /vendor[1]/contact[1]>  expected:<John>  but  was:<Jack  Black>  [CLASS]  [CONTEXT]  	JxPath_15_UnionContext_4_4	65	1	src/java/org/apache/commons/jxpath/ri/axes/UnionContext.java
1829	return  true;  	[BUGGY]  return  nodeType  =  =  Node  .  ELEMENT_NODE  ||  nodeType  =  =  Node  .  DOCUMENT_NODE  ;  [FE]  ComparisonFailure:  Evaluating  pointer  <//location[2]/following::node  (  )  [2]>  expected:<vendor[1]/product[1][]>  but  was:<vendor[1]/product[1][/product:name[1]]>  [METHOD]  testNode  [TYPE]  boolean  [PARAMETER]  Node  node  NodeTest  test  [CLASS]  DOMNodePointer  [TYPE]  boolean  false  true  wildcard  [TYPE]  NodeNameTest  nodeNameTest  [TYPE]  QName  testName  [TYPE]  Node  node  [TYPE]  NamespaceResolver  localNamespaceResolver  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  namespaceURI  nodeNS  nodePI  testPI  testPrefix  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  NodeTest  test  [TYPE]  int  nodeType  [CONTEXT]  if  (  node  .  getNodeType  (  )  !  =  Node  .  ELEMENT_NODE  )  {  return  false  ;  }  NodeNameTest  nodeNameTest  =  (  NodeNameTest  )  test  ;  QName  testName  =  nodeNameTest  .  getNodeName  (  )  ;  String  namespaceURI  =  nodeNameTest  .  getNamespaceURI  (  )  ;  boolean  wildcard  =  nodeNameTest  .  isWildcard  (  )  ;  String  testPrefix  =  testName  .  getPrefix  (  )  ;  if  (  wildcard  &&  testPrefix  =  =  null  )  {  return  true  ;  }  if  (  wildcard  ||  testName  .  getName  (  )    .  equals  (  DOMNodePointer  .  getLocalName  (  node  )  )  )  {  String  nodeNS  =  DOMNodePointer  .  getNamespaceURI  (  node  )  ;  return  equalStrings  (  namespaceURI  ,  nodeNS  )  ||  nodeNS  =  =  null  &&  equalStrings  (  testPrefix  ,  getPrefix  (  node  )  )  ;  }  return  false  ;  }  if  (  test  instanceof  NodeTypeTest  )  {  int  nodeType  =  node  .  getNodeType  (  )  ;  switch  (  (  (  NodeTypeTest  )  test  )  .  getNodeType  (  )  )  {  case  Compiler  .  NODE_TYPE_NODE  :  [BUGGY]  return  nodeType  =  =  Node  .  ELEMENT_NODE  ||  nodeType  =  =  Node  .  DOCUMENT_NODE  ;  case  Compiler  .  NODE_TYPE_TEXT  :  return  nodeType  =  =  Node  .  CDATA_SECTION_NODE  ||  nodeType  =  =  Node  .  TEXT_NODE  ;  case  Compiler  .  NODE_TYPE_COMMENT  :  	JxPath_16_DOMNodePointer_1_1	147	2	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1830	return  true;  	[BUGGY]  return  (  node  instanceof  Element  )  ||  (  node  instanceof  Document  )  ;  [FE]  ComparisonFailure:  Evaluating  pointer  <//location[2]/following::node  (  )  [2]>  expected:<vendor[1]/product[1][]>  but  was:<vendor[1]/product[1][/product:name[1]]>  [METHOD]  testNode  [TYPE]  boolean  [PARAMETER]  NodePointer  pointer  Object  node  NodeTest  test  [CLASS]  JDOMNodePointer  [TYPE]  boolean  false  true  wildcard  [TYPE]  NodeNameTest  nodeNameTest  [TYPE]  QName  testName  [TYPE]  NamespaceResolver  localNamespaceResolver  [TYPE]  Object  node  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  id  namespaceURI  nodeNS  nodePI  testPI  testPrefix  [TYPE]  NodePointer  pointer  [TYPE]  long  serialVersionUID  [TYPE]  NodeTest  test  [CONTEXT]  if  (  test  instanceof  NodeNameTest  )  {  if  (  !  (  node  instanceof  Element  )  )  {  return  false  ;  }  NodeNameTest  nodeNameTest  =  (  NodeNameTest  )  test  ;  QName  testName  =  nodeNameTest  .  getNodeName  (  )  ;  String  namespaceURI  =  nodeNameTest  .  getNamespaceURI  (  )  ;  boolean  wildcard  =  nodeNameTest  .  isWildcard  (  )  ;  String  testPrefix  =  testName  .  getPrefix  (  )  ;  if  (  wildcard  &&  testPrefix  =  =  null  )  {  return  true  ;  }  if  (  wildcard  ||  testName  .  getName  (  )    .  equals  (  JDOMNodePointer  .  getLocalName  (  node  )  )  )  {  String  nodeNS  =  JDOMNodePointer  .  getNamespaceURI  (  node  )  ;  return  equalStrings  (  namespaceURI  ,  nodeNS  )  ||  nodeNS  =  =  null  &&  equalStrings  (  testPrefix  ,  getPrefix  (  node  )  )  ;  }  return  false  ;  }  if  (  test  instanceof  NodeTypeTest  )  {  switch  (  (  (  NodeTypeTest  )  test  )  .  getNodeType  (  )  )  {  case  Compiler  .  NODE_TYPE_NODE  :  [BUGGY]  return  (  node  instanceof  Element  )  ||  (  node  instanceof  Document  )  ;  case  Compiler  .  NODE_TYPE_TEXT  :  return  (  node  instanceof  Text  )  ||  (  node  instanceof  CDATA  )  ;  case  Compiler  .  NODE_TYPE_COMMENT  :  return  node  instanceof  Comment  ;  case  Compiler  .  NODE_TYPE_PI  :  	JxPath_16_JDOMNodePointer_1_1	391	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java
1831	if  (testPrefix  ==  null  ||  equalStrings(testPrefix,  nodePrefix))  {  if  (nodePrefix  ==  null)  {  return  false;  return  equalStrings(parent.getNamespaceURI(testPrefix),  parent  .getNamespaceURI(nodePrefix));  	[BUGGY]  if  (  equalStrings  (  testPrefix  ,  nodePrefix  )  )  {  String  testNS  =  null  ;  if  (  testPrefix  !  =  null  )  {  testNS  =  parent  .  getNamespaceURI  (  testPrefix  )  ;  String  nodeNS  =  null  ;  if  (  nodePrefix  !  =  null  )  {  nodeNS  =  parent  .  getNamespaceURI  (  nodePrefix  )  ;  }  return  equalStrings  (  testNS  ,  nodeNS  )  ;  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/@*>  expected:<[10%  ,  20%]>  but  was:<[20%]>  [METHOD]  testAttr  [TYPE]  boolean  [PARAMETER]  Attr  attr  [CLASS]  DOMAttributeIterator  [TYPE]  boolean  false  true  [TYPE]  QName  name  [TYPE]  List  attributes  [TYPE]  NodePointer  parent  [TYPE]  String  nodeLocalName  nodeNS  nodePrefix  testLocalName  testNS  testPrefix  [TYPE]  int  position  [TYPE]  Attr  attr  [CONTEXT]  private  boolean  testAttr  (  Attr  attr  )  {  String  nodePrefix  =  DOMNodePointer  .  getPrefix  (  attr  )  ;  String  nodeLocalName  =  DOMNodePointer  .  getLocalName  (  attr  )  ;  if  (  nodePrefix  !  =  null  &&  nodePrefix  .  equals  (   "xmlns "  )  )  {  return  false  ;  }  if  (  nodePrefix  =  =  null  &&  nodeLocalName  .  equals  (   "xmlns "  )  )  {  return  false  ;  }  String  testLocalName  =  name  .  getName  (  )  ;  if  (  testLocalName  .  equals  (   "* "  )  ||  testLocalName  .  equals  (  nodeLocalName  )  )  {  String  testPrefix  =  name  .  getPrefix  (  )  ;  [BUGGY]  if  (  equalStrings  (  testPrefix  ,  nodePrefix  )  )  {  return  true  ;  }  String  testNS  =  null  ;  if  (  testPrefix  !  =  null  )  {  testNS  =  parent  .  getNamespaceURI  (  testPrefix  )  ;  	JxPath_17_DOMAttributeIterator_2_1	84	9	src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java
1832	}  	[BUGGY]  }  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/@*>  expected:<[10%  ,  20%]>  but  was:<[20%]>  [CLASS]  [CONTEXT]  	JxPath_17_DOMAttributeIterator_2_2	155	1	src/java/org/apache/commons/jxpath/ri/model/dom/DOMAttributeIterator.java
1833		[BUGGY]  if  (  ns  !  =  null  )  {  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/@*>  expected:<[10%  ,  20%]>  but  was:<[20%]>  [CLASS]  [CONTEXT]  	JxPath_17_JDOMAttributeIterator_4_1	70	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java
1834		[BUGGY]  }  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/@*>  expected:<[10%  ,  20%]>  but  was:<[20%]>  [CLASS]  [CONTEXT]  	JxPath_17_JDOMAttributeIterator_4_2	74	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java
1835	if  (ns  ==  Namespace.NO_NAMESPACE  ||  attr.getNamespace().equals(ns))  {  	[BUGGY]  if  (  attr  .  getNamespace  (  )  .  equals  (  ns  )  )  {  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/@*>  expected:<[10%  ,  20%]>  but  was:<[20%]>  [CLASS]  [CONTEXT]  	JxPath_17_JDOMAttributeIterator_4_3	82	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java
1836	}  	[BUGGY]  }  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/@*>  expected:<[10%  ,  20%]>  but  was:<[20%]>  [CLASS]  [CONTEXT]  	JxPath_17_JDOMAttributeIterator_4_4	117	1	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMAttributeIterator.java
1837		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/attribute::node  (  )  >  expected:<[10%  ,  20%]>  but  was:<[]>  [CLASS]  [CONTEXT]  	JxPath_18_AttributeContext_5_1	19	0	src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java
1838		[BUGGY]  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/attribute::node  (  )  >  expected:<[10%  ,  20%]>  but  was:<[]>  [CLASS]  [CONTEXT]  	JxPath_18_AttributeContext_5_2	23	0	src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java
1839	private  static  final  NodeNameTest  WILDCARD_TEST  =  new  NodeNameTest(new  QName(null,   "* "));  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/attribute::node  (  )  >  expected:<[10%  ,  20%]>  but  was:<[]>  [CLASS]  [CONTEXT]  	JxPath_18_AttributeContext_5_3	33	0	src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java
1840	NodeNameTest  nodeNameTest  =  null;  if  (nodeTest  instanceof  NodeTypeTest)  {  if  (((NodeTypeTest)  nodeTest).getNodeType()  ==  Compiler.NODE_TYPE_NODE)  {  nodeNameTest  =  WILDCARD_TEST;  }  }  else  if  (nodeTest  instanceof  NodeNameTest)  {  nodeNameTest  =  (NodeNameTest)  nodeTest;  }  if  (nodeNameTest  ==  null)  {  iterator  =  parentContext.getCurrentNodePointer().attributeIterator(  nodeNameTest.getNodeName());  	[BUGGY]  if  (  !  (  nodeTest  instanceof  NodeNameTest  )  )  {  QName  name  =  (  (  NodeNameTest  )  nodeTest  )  .  getNodeName  (  )  ;  iterator  =  parentContext  .  getCurrentNodePointer  (  )  .  attributeIterator  (  name  )  ;  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/attribute::node  (  )  >  expected:<[10%  ,  20%]>  but  was:<[]>  [METHOD]  nextNode  [TYPE]  boolean  [PARAMETER]  [CLASS]  AttributeContext  [TYPE]  NodeIterator  iterator  [TYPE]  boolean  false  setStarted  true  [TYPE]  NodePointer  currentNodePointer  [TYPE]  NodeTest  nodeTest  [TYPE]  QName  name  [CONTEXT]  public  boolean  nextNode  (  )  {  super  .  setPosition  (  getCurrentPosition  (  )  +  1  )  ;  if  (  !setStarted  )  {  setStarted  =  true  ;  [BUGGY]  if  (  !  (  nodeTest  instanceof  NodeNameTest  )  )  {  return  false  ;  }  QName  name  =  (  (  NodeNameTest  )  nodeTest  )  .  getNodeName  (  )  ;  iterator  =  parentContext  .  getCurrentNodePointer  (  )  .  attributeIterator  (  name  )  ;  }  if  (  iterator  =  =  null  )  {  return  false  ;  }  if  (  !iterator  .  setPosition  (  iterator  .  getPosition  (  )  +  1  )  )  {  return  false  ;  }  currentNodePointer  =  iterator  .  getNodePointer  (  )  ;  return  true  ;  }  	JxPath_18_AttributeContext_5_4	75	4	src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java
1841	}  	[BUGGY]  }  [FE]  AssertionFailedError:  Evaluating  value  iterator  <vendor/product/price:amount/attribute::node  (  )  >  expected:<[10%  ,  20%]>  but  was:<[]>  [CLASS]  [CONTEXT]  	JxPath_18_AttributeContext_5_5	91	1	src/java/org/apache/commons/jxpath/ri/axes/AttributeContext.java
1842	if  (n.getNodeType()  ==  Node.ELEMENT_NODE  &&  matchesQName(n))  {  	[BUGGY]  if  (  n  .  getNodeType  (  )  =  =  Node  .  ELEMENT_NODE  )  {  String  nm  =  n  .  getNodeName  (  )  ;  if  (  nm  .  equals  (  node  .  getNodeName  (  )  )  )  {  }  [FE]  AssertionFailedError:  Evaluating  pointer  iterator  </a:doc/a:elem>  expected:<[/a:doc[1]/a:elem[1]  ,  /a:doc[1]/a:elem[2]]>  but  was:<[/a:doc[1]/a:elem[1]  ,  /a:doc[1]/a:elem[1]]>  [METHOD]  getRelativePositionByQName  [TYPE]  int  [PARAMETER]  [CLASS]  DOMNodePointer  [TYPE]  boolean  false  true  [TYPE]  Node  n  node  [TYPE]  NamespaceResolver  localNamespaceResolver  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  nm  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  int  count  [CONTEXT]  private  int  getRelativePositionByQName  (  )  {  int  count  =  1  ;  Node  n  =  node  .  getPreviousSibling  (  )  ;  while  (  n  !  =  null  )  {  [BUGGY]  if  (  n  .  getNodeType  (  )  =  =  Node  .  ELEMENT_NODE  )  {  String  nm  =  n  .  getNodeName  (  )  ;  if  (  nm  .  equals  (  node  .  getNodeName  (  )  )  )  {  count++  ;  }  }  n  =  n  .  getPreviousSibling  (  )  ;  }  return  count  ;  }  	JxPath_19_DOMNodePointer_2_1	560	4	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1843	private  boolean  matchesQName(Node  n)  {  if  (getNamespaceURI()  !=  null)  {  return  equalStrings(getNamespaceURI(n),  getNamespaceURI())  &&  equalStrings(node.getLocalName(),  n.getLocalName());  }  return  equalStrings(node.getNodeName(),  n.getNodeName());  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  pointer  iterator  </a:doc/a:elem>  expected:<[/a:doc[1]/a:elem[1]  ,  /a:doc[1]/a:elem[2]]>  but  was:<[/a:doc[1]/a:elem[1]  ,  /a:doc[1]/a:elem[1]]>  [CLASS]  [CONTEXT]  	JxPath_19_DOMNodePointer_2_2	571	0	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1844	if  (child  instanceof  Element  &&  matchesQName(((Element)  child)))  {  	[BUGGY]  if  (  (  child  instanceof  Element  )  &&  (  (  Element  )  child  )  .  getQualifiedName  (  )  .  equals  (  name  )  )  {  [FE]  AssertionFailedError:  Evaluating  pointer  iterator  </a:doc/a:elem>  expected:<[/a:doc[1]/a:elem[1]  ,  /a:doc[1]/a:elem[2]]>  but  was:<[/a:doc[1]/a:elem[1]  ,  /a:doc[1]/a:elem[1]]>  [METHOD]  getRelativePositionByQName  [TYPE]  int  [PARAMETER]  [CLASS]  JDOMNodePointer  [TYPE]  boolean  false  true  [TYPE]  NamespaceResolver  localNamespaceResolver  [TYPE]  Object  child  node  parent  [TYPE]  List  children  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  id  name  [TYPE]  long  serialVersionUID  [TYPE]  int  count  i  [CONTEXT]  private  int  getRelativePositionByQName  (  )  {  if  (  node  instanceof  Element  )  {  Object  parent  =  (  (  Element  )  node  )  .  getParent  (  )  ;  if  (  !  (  parent  instanceof  Element  )  )  {  return  1  ;  }  List  children  =  (  (  Element  )  parent  )  .  getContent  (  )  ;  int  count  =  0  ;  String  name  =  (  (  Element  )  node  )  .  getQualifiedName  (  )  ;  for  (  int  i  =  0  ;  i  <  children  .  size  (  )  ;  i++  )  {  Object  child  =  children  .  get  (  i  )  ;  [BUGGY]  if  (  (  child  instanceof  Element  )  &&  (  (  Element  )  child  )  .  getQualifiedName  (  )  .  equals  (  name  )  )  {  count++  ;  }  if  (  child  =  =  node  )  {  break  ;  }  }  return  count  ;  }  return  1  ;  }  	JxPath_19_JDOMNodePointer_2_1	696	2	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java
1845	private  boolean  matchesQName(Element  element)  {  if  (getNamespaceURI()  !=  null)  {  String  ns  =  getNamespaceURI(element);  if  (ns  ==  null  ||  !ns.equals(getNamespaceURI()))  {  return  false;  }  }  return  element.getName().equals(((Element)  node).getName());  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  pointer  iterator  </a:doc/a:elem>  expected:<[/a:doc[1]/a:elem[1]  ,  /a:doc[1]/a:elem[2]]>  but  was:<[/a:doc[1]/a:elem[1]  ,  /a:doc[1]/a:elem[1]]>  [CLASS]  [CONTEXT]  	JxPath_19_JDOMNodePointer_2_2	709	0	src/java/org/apache/commons/jxpath/ri/model/jdom/JDOMNodePointer.java
1846	return  containsMatch(left,  (Iterator)  right);  	[BUGGY]  return  containsMatch  (  (  Iterator  )  right  ,  left  )  ;  [FE]  AssertionFailedError:  Evaluating  <$a  +  $b  <  =  $c>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$a  +  $b  <  =  $c "  ,  Boolean  .  TRUE  )  ;  [METHOD]  compute  [TYPE]  boolean  [PARAMETER]  Object  left  Object  right  [CLASS]  CoreOperationRelationalExpression  [TYPE]  boolean  false  true  [TYPE]  double  ld  rd  [TYPE]  Object  left  right  [CONTEXT]  private  boolean  compute  (  Object  left  ,  Object  right  )  {  left  =  reduce  (  left  )  ;  right  =  reduce  (  right  )  ;  if  (  left  instanceof  InitialContext  )  {  (  (  InitialContext  )  left  )  .  reset  (  )  ;  }  if  (  right  instanceof  InitialContext  )  {  (  (  InitialContext  )  right  )  .  reset  (  )  ;  }  if  (  left  instanceof  Iterator  &&  right  instanceof  Iterator  )  {  return  findMatch  (  (  Iterator  )  left  ,  (  Iterator  )  right  )  ;  }  if  (  left  instanceof  Iterator  )  {  return  containsMatch  (  (  Iterator  )  left  ,  right  )  ;  }  if  (  right  instanceof  Iterator  )  {  [BUGGY]  return  containsMatch  (  (  Iterator  )  right  ,  left  )  ;  }  double  ld  =  InfoSetUtil  .  doubleValue  (  left  )  ;  if  (  Double  .  isNaN  (  ld  )  )  {  return  false  ;  }  double  rd  =  InfoSetUtil  .  doubleValue  (  right  )  ;  if  (  Double  .  isNaN  (  rd  )  )  {  return  false  ;  }  return  evaluateCompare  (  ld  =  =  rd  ?  0  :  ld  <  rd  ?  -1  :  1  )  ;  }  	JxPath_20_CoreOperationRelationalExpression_2_1	88	1	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java
1847	private  boolean  containsMatch(Object  value,  Iterator  it)  {  while  (it.hasNext())  {  Object  element  =  it.next();  if  (compute(value,  element))  {  return  true;  }  }  return  false;  }  	[BUGGY]  [FE]  AssertionFailedError:  Evaluating  <$a  +  $b  <  =  $c>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "$a  +  $b  <  =  $c "  ,  Boolean  .  TRUE  )  ;  [CLASS]  [CONTEXT]  	JxPath_20_CoreOperationRelationalExpression_2_2	138	0	src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java
1848	Object  baseValue  =  getBaseValue();  return  baseValue  ==  null  ?  1  :  ValueUtils.getLength(baseValue);  	[BUGGY]  return  ValueUtils  .  getLength  (  getBaseValue  (  )  )  ;  [FE]  AssertionFailedError:  Evaluating  <map/b  !  =  map/a>  expected:<true>  but  was:<false>  assertXPathValue  (  context  ,   "not  (  map[@name  =  'a']  =  map[@name  =  'c']  )   "  ,  Boolean  .  FALSE  )  ;  [METHOD]  getLength  [TYPE]  int  [PARAMETER]  [CLASS]  PropertyPointer  [TYPE]  Object  UNINITIALIZED  bean  value  [TYPE]  int  UNSPECIFIED_PROPERTY  propertyIndex  [TYPE]  boolean  false  true  [CONTEXT]  public  int  getLength  (  )  {  [BUGGY]  return  ValueUtils  .  getLength  (  getBaseValue  (  )  )  ;  }  	JxPath_21_PropertyPointer_1_1	152	1	src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java
1849	uri  =  attr.getValue();  break;  	[BUGGY]  return  attr  .  getValue  (  )  ;  [FE]  ComparisonFailure:  expected:</b:foo[1]/[test[1]]>  but  was:</b:foo[1]/[node  (  )  [2]]>  [METHOD]  getNamespaceURI  [TYPE]  String  [PARAMETER]  Node  node  [CLASS]  DOMNodePointer  [TYPE]  boolean  false  true  [TYPE]  Node  aNode  node  [TYPE]  Element  element  [TYPE]  NamespaceResolver  localNamespaceResolver  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  prefix  qname  uri  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  Attr  attr  [CONTEXT]  public  static  String  getNamespaceURI  (  Node  node  )  {  if  (  node  instanceof  Document  )  {  node  =  (  (  Document  )  node  )  .  getDocumentElement  (  )  ;  }  Element  element  =  (  Element  )  node  ;  String  uri  =  element  .  getNamespaceURI  (  )  ;  if  (  uri  =  =  null  )  {  String  prefix  =  getPrefix  (  node  )  ;  String  qname  =  prefix  =  =  null  ?   "xmlns "  :   "xmlns: "  +  prefix  ;  Node  aNode  =  node  ;  while  (  aNode  !  =  null  )  {  if  (  aNode  .  getNodeType  (  )  =  =  Node  .  ELEMENT_NODE  )  {  Attr  attr  =  (  (  Element  )  aNode  )  .  getAttributeNode  (  qname  )  ;  if  (  attr  !  =  null  )  {  [BUGGY]  return  attr  .  getValue  (  )  ;  }  }  aNode  =  aNode  .  getParentNode  (  )  ;  }  return  null  ;  }  return  uri  ;  }  	JxPath_22_DOMNodePointer_2_1	689	1	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1850	return   " ".equals(uri)  ?  null  :  uri;  	[BUGGY]  return  null  ;  return  uri  ;  [FE]  ComparisonFailure:  expected:</b:foo[1]/[test[1]]>  but  was:</b:foo[1]/[node  (  )  [2]]>  [METHOD]  getNamespaceURI  [TYPE]  String  [PARAMETER]  Node  node  [CLASS]  DOMNodePointer  [TYPE]  boolean  false  true  [TYPE]  Node  aNode  node  [TYPE]  Element  element  [TYPE]  NamespaceResolver  localNamespaceResolver  [TYPE]  String  XMLNS_NAMESPACE_URI  XML_NAMESPACE_URI  defaultNamespace  id  prefix  qname  uri  [TYPE]  Map  namespaces  [TYPE]  long  serialVersionUID  [TYPE]  Attr  attr  [CONTEXT]  public  static  String  getNamespaceURI  (  Node  node  )  {  if  (  node  instanceof  Document  )  {  node  =  (  (  Document  )  node  )  .  getDocumentElement  (  )  ;  }  Element  element  =  (  Element  )  node  ;  String  uri  =  element  .  getNamespaceURI  (  )  ;  if  (  uri  =  =  null  )  {  String  prefix  =  getPrefix  (  node  )  ;  String  qname  =  prefix  =  =  null  ?   "xmlns "  :   "xmlns: "  +  prefix  ;  Node  aNode  =  node  ;  while  (  aNode  !  =  null  )  {  if  (  aNode  .  getNodeType  (  )  =  =  Node  .  ELEMENT_NODE  )  {  Attr  attr  =  (  (  Element  )  aNode  )  .  getAttributeNode  (  qname  )  ;  if  (  attr  !  =  null  )  {  return  attr  .  getValue  (  )  ;  }  }  aNode  =  aNode  .  getParentNode  (  )  ;  }  [BUGGY]  return  null  ;  }  return  uri  ;  }  	JxPath_22_DOMNodePointer_2_2	694	2	src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java
1851	for  (int  position  =  0;  position  <  indexOfVararg;  position++)  {  Matcher  m  =  matchers.get(position);  if  (m  instanceof  CapturesArguments)  {  ((CapturesArguments)  m).captureFrom(invocation.getArgumentAt(position,  Object.class));  }  }  for  (int  position  =  indexOfVararg;  position  <  matchers.size();  position++)  {  Matcher  m  =  matchers.get(position);  if  (m  instanceof  CapturesArguments)  {  ((CapturesArguments)  m).captureFrom(invocation.getRawArguments()[position  -  indexOfVararg]);  }  }  	[BUGGY]  throw  new  UnsupportedOperationException  (  )  ;  [FE]  UnsupportedOperationException  [METHOD]  captureArgumentsFrom  [TYPE]  void  [PARAMETER]  Invocation  invocation  [CLASS]  InvocationMatcher  [TYPE]  List  matchers  [TYPE]  boolean  false  true  [TYPE]  Invocation  invocation  [TYPE]  Matcher  m  [TYPE]  long  serialVersionUID  [TYPE]  int  indexOfVararg  position  [CONTEXT]  public  void  captureArgumentsFrom  (  Invocation  invocation  )  {  if  (  invocation  .  getMethod  (  )  .  isVarArgs  (  )  )  {  int  indexOfVararg  =  invocation  .  getRawArguments  (  )  .  length  -  1  ;  [BUGGY]  throw  new  UnsupportedOperationException  (  )  ;  }  else  {  for  (  int  position  =  0  ;  position  <  matchers  .  size  (  )  ;  position++  )  {  Matcher  m  =  matchers  .  get  (  position  )  ;  if  (  m  instanceof  CapturesArguments  )  {  	Mockito_1_InvocationMatcher_1_1	123	1	src/org/mockito/internal/invocation/InvocationMatcher.java
1852		[BUGGY]  [FE]  AssertionFailedError:  It  is  forbidden  to  create  timer  with  negative  value  of  timer's  duration  Assert  .  assertTrue  (  true  )  ;  [CLASS]  [CONTEXT]  	Mockito_2_Timer_3_1	3	0	src/org/mockito/internal/util/Timer.java
1853	validateInput(durationMillis);  	[BUGGY]  [FE]  AssertionFailedError:  It  is  forbidden  to  create  timer  with  negative  value  of  timer's  duration  Assert  .  assertTrue  (  true  )  ;  [CLASS]  [CONTEXT]  	Mockito_2_Timer_3_2	10	0	src/org/mockito/internal/util/Timer.java
1854	private  void  validateInput(long  durationMillis)  {  if  (durationMillis  <  0)  {  new  Reporter().cannotCreateTimerWithNegativeDurationTime(durationMillis);  }  }  	[BUGGY]  [FE]  AssertionFailedError:  It  is  forbidden  to  create  timer  with  negative  value  of  timer's  duration  Assert  .  assertTrue  (  true  )  ;  [CLASS]  [CONTEXT]  	Mockito_2_Timer_3_3	28	0	src/org/mockito/internal/util/Timer.java
1855	for  (Matcher  m  :  uniqueMatcherSet(indexOfVararg))  {  Object  rawArgument  =  invocation.getRawArguments()[indexOfVararg];  for  (int  i  =  0;  i  <  Array.getLength(rawArgument);  i++)  {  ((CapturesArguments)  m).captureFrom(Array.get(rawArgument,  i));  }  	[BUGGY]  for  (  int  position  =  indexOfVararg  ;  position  <  matchers  .  size  (  )  ;  position++  )  {  Matcher  m  =  matchers  .  get  (  position  )  ;  (  (  CapturesArguments  )  m  )  .  captureFrom  (  invocation  .  getRawArguments  (  )  [position  -  indexOfVararg]  )  ;  [FE]  AssertionFailedError:  expected:<[['a'  ,  'b']]>  but  was:<[[1]]>  Assertions  .  assertThat  (  m  .  getAllValues  (  )  )  .  containsExactly  (   "a "  ,   "b "  )  ;  [METHOD]  captureArgumentsFrom  [TYPE]  void  [PARAMETER]  Invocation  invocation  [CLASS]  InvocationMatcher  [TYPE]  List  matchers  [TYPE]  boolean  false  true  [TYPE]  Invocation  invocation  [TYPE]  Matcher  m  [TYPE]  long  serialVersionUID  [TYPE]  int  indexOfVararg  position  [CONTEXT]  public  void  captureArgumentsFrom  (  Invocation  invocation  )  {  if  (  invocation  .  getMethod  (  )  .  isVarArgs  (  )  )  {  int  indexOfVararg  =  invocation  .  getRawArguments  (  )  .  length  -  1  ;  for  (  int  position  =  0  ;  position  <  indexOfVararg  ;  position++  )  {  Matcher  m  =  matchers  .  get  (  position  )  ;  if  (  m  instanceof  CapturesArguments  )  {  (  (  CapturesArguments  )  m  )  .  captureFrom  (  invocation  .  getArgumentAt  (  position  ,  Object  .  class  )  )  ;  }  }  [BUGGY]  for  (  int  position  =  indexOfVararg  ;  position  <  matchers  .  size  (  )  ;  position++  )  {  Matcher  m  =  matchers  .  get  (  position  )  ;  if  (  m  instanceof  CapturesArguments  )  {  (  (  CapturesArguments  )  m  )  .  captureFrom  (  invocation  .  getRawArguments  (  )  [position  -  indexOfVararg]  )  ;  }  }  }  else  {  for  (  int  position  =  0  ;  position  <  matchers  .  size  (  )  ;  position++  )  {  Matcher  m  =  matchers  .  get  (  position  )  ;  if  (  m  instanceof  CapturesArguments  )  {  (  (  CapturesArguments  )  m  )  .  captureFrom  (  invocation  .  getArgumentAt  (  position  ,  Object  .  class  )  )  ;  }  }  }  }  	Mockito_3_InvocationMatcher_2_1	127	3	src/org/mockito/internal/invocation/InvocationMatcher.java
1856	private  Set<Matcher>  uniqueMatcherSet(int  indexOfVararg)  {  HashSet<Matcher>  set  =  new  HashSet<Matcher>();  for  (int  position  =  indexOfVararg;  position  <  matchers.size();  position++)  {  Matcher  matcher  =  matchers.get(position);  if(matcher  instanceof  MatcherDecorator)  {  set.add(((MatcherDecorator)  matcher).getActualMatcher());  }  else  {  set.add(matcher);  }  }  return  set;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<[['a'  ,  'b']]>  but  was:<[[1]]>  Assertions  .  assertThat  (  m  .  getAllValues  (  )  )  .  containsExactly  (   "a "  ,   "b "  )  ;  [CLASS]  [CONTEXT]  	Mockito_3_InvocationMatcher_2_2	143	0	src/org/mockito/internal/invocation/InvocationMatcher.java
1857	 "But  found  this  interaction  on  mock  \' "  +  safelyGetMockName(undesired.getMock())  +   "\': ",  	[BUGGY]   "But  found  this  interaction  on  mock  \' "  +  undesired  .  getMock  (  )  +   "\': "  ,  [FE]  Exception:  Unexpected  exception  ,  expected<orgmockitoexceptionsverificationVerificationInOrderFailure>  but  was<javalangClassCastException>  [METHOD]  noMoreInteractionsWanted  [TYPE]  void  [PARAMETER]  Invocation  undesired  VerificationAwareInvocation>  invocations  [CLASS]  Reporter  [TYPE]  boolean  false  true  [TYPE]  Invocation  undesired  [TYPE]  List  invocations  [TYPE]  String  scenario  [TYPE]  ScenarioPrinter  scenarioPrinter  [CONTEXT]  public  void  noMoreInteractionsWanted  (  Invocation  undesired  ,  List<VerificationAwareInvocation>  invocations  )  {  ScenarioPrinter  scenarioPrinter  =  new  ScenarioPrinter  (  )  ;  String  scenario  =  scenarioPrinter  .  print  (  invocations  )  ;  throw  new  NoInteractionsWanted  (  join  (   "No  interactions  wanted  here: "  ,  new  LocationImpl  (  )  ,  [BUGGY]   "But  found  this  interaction  on  mock  ' "  +  undesired  .  getMock  (  )  +   "': "  ,  undesired  .  getLocation  (  )  ,  scenario  )  )  ;  }  	Mockito_4_Reporter_3_1	424	1	src/org/mockito/exceptions/Reporter.java
1858	 "But  found  this  interaction  on  mock  \' "  +  safelyGetMockName(undesired.getMock())  +   "\': ",  	[BUGGY]   "But  found  this  interaction  on  mock  \' "  +  undesired  .  getMock  (  )  +   "\': "  ,  [FE]  Exception:  Unexpected  exception  ,  expected<orgmockitoexceptionsverificationVerificationInOrderFailure>  but  was<javalangClassCastException>  [METHOD]  noMoreInteractionsWantedInOrder  [TYPE]  void  [PARAMETER]  Invocation  undesired  [CLASS]  Reporter  [TYPE]  boolean  false  true  [TYPE]  Invocation  undesired  [CONTEXT]  public  void  noMoreInteractionsWantedInOrder  (  Invocation  undesired  )  {  throw  new  VerificationInOrderFailure  (  join  (   "No  interactions  wanted  here: "  ,  new  LocationImpl  (  )  ,  [BUGGY]   "But  found  this  interaction  on  mock  ' "  +  undesired  .  getMock  (  )  +   "': "  ,  undesired  .  getLocation  (  )    )  )  ;  }  	Mockito_4_Reporter_3_2	434	1	src/org/mockito/exceptions/Reporter.java
1859	if  (details.getCause()  ==  null)  {  return  details.getMessage();  }  	[BUGGY]  [FE]  Exception:  Unexpected  exception  ,  expected<orgmockitoexceptionsverificationVerificationInOrderFailure>  but  was<javalangClassCastException>  [METHOD]  exceptionCauseMessageIfAvailable  [TYPE]  String  [PARAMETER]  Exception  details  [CLASS]  Reporter  [TYPE]  boolean  false  true  [TYPE]  Exception  details  [CONTEXT]  private  String  exceptionCauseMessageIfAvailable  (  Exception  details  )  {  [BUGGY]  return  details  .  getCause  (  )  .  getMessage  (  )  ;  }  	Mockito_4_Reporter_3_3	677	0	src/org/mockito/exceptions/Reporter.java
1860	catch  (AssertionError  e)  {  	[BUGGY]  catch  (  org  .  mockito  .  exceptions  .  verification  .  junit  .  ArgumentsAreDifferent  e  )  {  [FE]  AssertionFailedError:  'orgmockitointernalverificationVerificationOverTimeImpl'  has  some  dependency  to  JUnit  [METHOD]  verify  [TYPE]  void  [PARAMETER]  VerificationData  data  [CLASS]  VerificationOverTimeImpl  [TYPE]  boolean  false  returnOnSuccess  true  [TYPE]  MockitoAssertionError  e  [TYPE]  Timer  timer  [TYPE]  org  .  mockito  .  exceptions  e  [TYPE]  AssertionError  error  [TYPE]  long  durationMillis  pollingPeriodMillis  [TYPE]  VerificationMode  delegate  [TYPE]  VerificationData  data  [CONTEXT]  public  void  verify  (  VerificationData  data  )  {  AssertionError  error  =  null  ;  timer  .  start  (  )  ;  while  (  timer  .  isCounting  (  )  )  {  try  {  delegate  .  verify  (  data  )  ;  if  (  returnOnSuccess  )  {  return  ;  }  else  {  error  =  null  ;  }  }  catch  (  MockitoAssertionError  e  )  {  error  =  handleVerifyException  (  e  )  ;  }  [BUGGY]  catch  (  org  .  mockito  .  exceptions  .  verification  .  junit  .  ArgumentsAreDifferent  e  )  {  error  =  handleVerifyException  (  e  )  ;  }  }  if  (  error  !  =  null  )  {  throw  error  ;  }  }  	Mockito_5_VerificationOverTimeImpl_1_1	91	1	src/org/mockito/internal/verification/VerificationOverTimeImpl.java
1861	return  reportMatcher(new  InstanceOf(Boolean.class)).returnFalse();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnFalse  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyBoolean  [TYPE]  boolean  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  boolean  anyBoolean  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnFalse  (  )  ;  }  	Mockito_6_Matchers_20_1	122	1	src/org/mockito/Matchers.java
1862	return  reportMatcher(new  InstanceOf(Byte.class)).returnZero();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyByte  [TYPE]  byte  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  byte  anyByte  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  }  	Mockito_6_Matchers_20_2	137	1	src/org/mockito/Matchers.java
1863	return  reportMatcher(new  InstanceOf(Character.class)).returnChar();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnChar  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyChar  [TYPE]  char  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  char  anyChar  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnChar  (  )  ;  }  	Mockito_6_Matchers_20_3	152	1	src/org/mockito/Matchers.java
1864	return  reportMatcher(new  InstanceOf(Integer.class)).returnZero();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyInt  [TYPE]  int  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  int  anyInt  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  }  	Mockito_6_Matchers_20_4	167	1	src/org/mockito/Matchers.java
1865	return  reportMatcher(new  InstanceOf(Long.class)).returnZero();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyLong  [TYPE]  long  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  long  anyLong  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  }  	Mockito_6_Matchers_20_5	182	1	src/org/mockito/Matchers.java
1866	return  reportMatcher(new  InstanceOf(Float.class)).returnZero();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyFloat  [TYPE]  float  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  float  anyFloat  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  }  	Mockito_6_Matchers_20_6	197	1	src/org/mockito/Matchers.java
1867	return  reportMatcher(new  InstanceOf(Double.class)).returnZero();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyDouble  [TYPE]  double  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  double  anyDouble  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  }  	Mockito_6_Matchers_20_7	212	1	src/org/mockito/Matchers.java
1868	return  reportMatcher(new  InstanceOf(Short.class)).returnZero();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyShort  [TYPE]  short  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  short  anyShort  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnZero  (  )  ;  }  	Mockito_6_Matchers_20_8	227	1	src/org/mockito/Matchers.java
1869	return  (T)  reportMatcher(new  InstanceOf(Object.class)).returnNull();  	[BUGGY]  return  (  T  )  reportMatcher  (  Any  .  ANY  )  .  returnNull  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyObject  [TYPE]  <T>  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  T  anyObject  (  )  {  [BUGGY]  return  (  T  )  reportMatcher  (  Any  .  ANY  )  .  returnNull  (  )  ;  }  	Mockito_6_Matchers_20_9	244	1	src/org/mockito/Matchers.java
1870	return  (T)  reportMatcher(new  InstanceOf(clazz)).returnFor(clazz);  	[BUGGY]  return  (  T  )  reportMatcher  (  Any  .  ANY  )  .  returnFor  (  clazz  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  any  [TYPE]  <T>  [PARAMETER]  Class<T>  clazz  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  Class  clazz  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  T  any  (  Class<T>  clazz  )  {  [BUGGY]  return  (  T  )  reportMatcher  (  Any  .  ANY  )  .  returnFor  (  clazz  )  ;  }  	Mockito_6_Matchers_20_10	292	1	src/org/mockito/Matchers.java
1871	return  (T)  reportMatcher(Any.ANY).returnNull();  	[BUGGY]  return  (  T  )  anyObject  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  any  [TYPE]  <T>  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  T  any  (  )  {  [BUGGY]  return  (  T  )  anyObject  (  )  ;  }  	Mockito_6_Matchers_20_11	309	1	src/org/mockito/Matchers.java
1872	return  reportMatcher(new  InstanceOf(String.class)).returnString();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnString  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyString  [TYPE]  String  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  String  anyString  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnString  (  )  ;  }  	Mockito_6_Matchers_20_12	324	1	src/org/mockito/Matchers.java
1873	return  reportMatcher(new  InstanceOf(List.class)).returnList();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnList  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyList  [TYPE]  List  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  List  anyList  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnList  (  )  ;  }  	Mockito_6_Matchers_20_13	339	1	src/org/mockito/Matchers.java
1874	return  anyList();  	[BUGGY]  return  (  List  )  reportMatcher  (  Any  .  ANY  )  .  returnList  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyListOf  [TYPE]  <T>  [PARAMETER]  Class<T>  clazz  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  Class  clazz  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  List<T>  anyListOf  (  Class<T>  clazz  )  {  [BUGGY]  return  (  List  )  reportMatcher  (  Any  .  ANY  )  .  returnList  (  )  ;  }  	Mockito_6_Matchers_20_14	358	1	src/org/mockito/Matchers.java
1875	return  reportMatcher(new  InstanceOf(Set.class)).returnSet();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnSet  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anySet  [TYPE]  Set  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  Set  anySet  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnSet  (  )  ;  }  	Mockito_6_Matchers_20_15	373	1	src/org/mockito/Matchers.java
1876	return  anySet();  	[BUGGY]  return  (  Set  )  reportMatcher  (  Any  .  ANY  )  .  returnSet  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anySetOf  [TYPE]  <T>  [PARAMETER]  Class<T>  clazz  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  Class  clazz  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  Set<T>  anySetOf  (  Class<T>  clazz  )  {  [BUGGY]  return  (  Set  )  reportMatcher  (  Any  .  ANY  )  .  returnSet  (  )  ;  }  	Mockito_6_Matchers_20_16	392	1	src/org/mockito/Matchers.java
1877	return  reportMatcher(new  InstanceOf(Map.class)).returnMap();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnMap  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyMap  [TYPE]  Map  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  Map  anyMap  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnMap  (  )  ;  }  	Mockito_6_Matchers_20_17	407	1	src/org/mockito/Matchers.java
1878	return  anyMap();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnMap  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyMapOf  [TYPE]  <K  ,  V>  [PARAMETER]  Class<K>  keyClazz  Class<V>  valueClazz  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  Class  keyClazz  valueClazz  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <K  ,  V>Map<K  ,  V>  anyMapOf  (  Class<K>  keyClazz  ,  Class<V>  valueClazz  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnMap  (  )  ;  }  	Mockito_6_Matchers_20_18	427	1	src/org/mockito/Matchers.java
1879	return  reportMatcher(new  InstanceOf(Collection.class)).returnList();  	[BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnList  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyCollection  [TYPE]  Collection  [PARAMETER]  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  boolean  false  true  [CONTEXT]  public  static  Collection  anyCollection  (  )  {  [BUGGY]  return  reportMatcher  (  Any  .  ANY  )  .  returnList  (  )  ;  }  	Mockito_6_Matchers_20_19	442	1	src/org/mockito/Matchers.java
1880	return  anyCollection();  	[BUGGY]  return  (  Collection  )  reportMatcher  (  Any  .  ANY  )  .  returnList  (  )  ;  [FE]  ComparisonFailure:  expected:<null>  but  was:<0>  assertEquals  (  null  ,  mock  .  forDouble  (  null  )  )  ;  [METHOD]  anyCollectionOf  [TYPE]  <T>  [PARAMETER]  Class<T>  clazz  [CLASS]  Matchers  [TYPE]  MockingProgress  MOCKING_PROGRESS  [TYPE]  Class  clazz  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  Collection<T>  anyCollectionOf  (  Class<T>  clazz  )  {  [BUGGY]  return  (  Collection  )  reportMatcher  (  Any  .  ANY  )  .  returnList  (  )  ;  }  	Mockito_6_Matchers_20_20	461	1	src/org/mockito/Matchers.java
1881	registerTypeParametersOn(new  TypeVariable[]  {  typeVariable  });  	[BUGGY]  [FE]  exceptionsbaseMockitoException:  Raw  extraction  not  supported  for  :  'null'  [METHOD]  readTypeVariables  [TYPE]  void  [PARAMETER]  [CLASS]  TypeVariableReturnType  [TYPE]  Class  rawType  [TYPE]  Type  type  [TYPE]  TypeVariable[]  typeParameters  [TYPE]  boolean  false  true  [TYPE]  TypeVariable  typeVariable  [CONTEXT]  private  void  readTypeVariables  (  )  {  for  (  Type  type  :  typeVariable  .  getBounds  (  )  )  {  registerTypeVariablesOn  (  type  )  ;  }  [BUGGY]  registerTypeVariablesOn  (  getActualTypeArgumentFor  (  typeVariable  )  )  ;  }  	Mockito_7_GenericMetadataSupport_1_1	379	0	src/org/mockito/internal/util/reflection/GenericMetadataSupport.java
1882	}  else  if  (typeParameter  !=  actualTypeArgument)  {  	[BUGGY]  }  else  {  [FE]  StackOverflowError  assertThat  (  genericMetadata  .  rawType  (  )  )  .  isEqualTo  (  GenericsSelfReference  .  class  )  ;  [METHOD]  registerTypeVariablesOn  [TYPE]  void  [PARAMETER]  Type  classType  [CLASS]  GenericMetadataSupport  [TYPE]  ParameterizedType  parameterizedType  [TYPE]  WildcardType  wildcard  [TYPE]  Type  actualTypeArgument  classType  [TYPE]  boolean  false  true  [TYPE]  TypeVariable  typeParameter  typeVariable  [TYPE]  Type[]  actualTypeArguments  [TYPE]  Class  clazz  rawType  returnType  [TYPE]  TypeVariable[]  typeParameters  [TYPE]  Map  contextualActualTypeParameters  [TYPE]  int  i  [CONTEXT]  protected  void  registerTypeVariablesOn  (  Type  classType  )  {  if  (  !  (  classType  instanceof  ParameterizedType  )  )  {  return  ;  }  ParameterizedType  parameterizedType  =  (  ParameterizedType  )  classType  ;  TypeVariable[]  typeParameters  =  (  (  Class<?>  )  parameterizedType  .  getRawType  (  )  )  .  getTypeParameters  (  )  ;  Type[]  actualTypeArguments  =  parameterizedType  .  getActualTypeArguments  (  )  ;  for  (  int  i  =  0  ;  i  <  actualTypeArguments  .  length  ;  i++  )  {  TypeVariable  typeParameter  =  typeParameters[i]  ;  Type  actualTypeArgument  =  actualTypeArguments[i]  ;  if  (  actualTypeArgument  instanceof  WildcardType  )  {  contextualActualTypeParameters  .  put  (  typeParameter  ,  boundsOf  (  (  WildcardType  )  actualTypeArgument  )  )  ;  [BUGGY]  }  else  {  contextualActualTypeParameters  .  put  (  typeParameter  ,  actualTypeArgument  )  ;  }  }  }  	Mockito_8_GenericMetadataSupport_1_1	79	1	src/org/mockito/internal/util/reflection/GenericMetadataSupport.java
1883		[BUGGY]  [FE]  exceptionsbaseMockitoException:  assertEquals  (   "abstract  me "  ,  thing  .  fullName  (  )  )  ;  [CLASS]  [CONTEXT]  	Mockito_9_CallsRealMethods_2_1	8	0	src/org/mockito/internal/stubbing/answers/CallsRealMethods.java
1884	\tif  (Modifier.isAbstract(invocation.getMethod().getModifiers()))  {  \t\treturn  new  GloballyConfiguredAnswer().answer(invocation);  \t}  	[BUGGY]  [FE]  exceptionsbaseMockitoException:  assertEquals  (   "abstract  me "  ,  thing  .  fullName  (  )  )  ;  [METHOD]  answer  [TYPE]  Object  [PARAMETER]  InvocationOnMock  invocation  [CLASS]  CallsRealMethods  [TYPE]  long  serialVersionUID  [TYPE]  InvocationOnMock  invocation  [TYPE]  boolean  false  true  [CONTEXT]  public  Object  answer  (  InvocationOnMock  invocation  )  throws  Throwable  {  [BUGGY]  return  invocation  .  callRealMethod  (  )  ;  }  	Mockito_9_CallsRealMethods_2_2	36	0	src/org/mockito/internal/stubbing/answers/CallsRealMethods.java
1885		[BUGGY]  [FE]  exceptionsbaseMockitoException:  assertThat  (  the_deep_stub  )  .  isNotNull  (  )  ;  [CLASS]  [CONTEXT]  	Mockito_10_ReturnsDeepStubs_6_1	17	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1886	newDeepStubMock(returnTypeGenericMetadata,  invocation.getMock()),  	[BUGGY]  newDeepStubMock  (  returnTypeGenericMetadata  )  ,  [FE]  exceptionsbaseMockitoException:  assertThat  (  the_deep_stub  )  .  isNotNull  (  )  ;  [METHOD]  deepStub  [TYPE]  Object  [PARAMETER]  InvocationOnMock  invocation  GenericMetadataSupport  returnTypeGenericMetadata  [CLASS]  ReturnsDeepStubs  [TYPE]  boolean  false  true  [TYPE]  InvocationContainerImpl  container  [TYPE]  StubbedInvocationMatcher  stubbedInvocationMatcher  [TYPE]  InvocationOnMock  invocation  [TYPE]  ReturnsEmptyValues  DELEGATE  [TYPE]  Object  mock  [TYPE]  MockitoCore  MOCKITO_CORE  [TYPE]  GenericMetadataSupport  returnTypeGenericMetadata  [TYPE]  long  serialVersionUID  [TYPE]  InternalMockHandler  handler  [CONTEXT]  private  Object  deepStub  (  InvocationOnMock  invocation  ,  GenericMetadataSupport  returnTypeGenericMetadata  )  throws  Throwable  {  InternalMockHandler<Object>  handler  =  new  MockUtil  (  )  .  getMockHandler  (  invocation  .  getMock  (  )  )  ;  InvocationContainerImpl  container  =  (  InvocationContainerImpl  )  handler  .  getInvocationContainer  (  )  ;    for  (  StubbedInvocationMatcher  stubbedInvocationMatcher  :  container  .  getStubbedInvocations  (  )  )  {  if  (  container  .  getInvocationForStubbing  (  )  .  matches  (  stubbedInvocationMatcher  .  getInvocation  (  )  )  )  {  return  stubbedInvocationMatcher  .  answer  (  invocation  )  ;  }  }  return  recordDeepStubAnswer  (  [BUGGY]  newDeepStubMock  (  returnTypeGenericMetadata  )  ,  container  )  ;  }  	Mockito_10_ReturnsDeepStubs_6_2	71	1	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1887	private  Object  newDeepStubMock(GenericMetadataSupport  returnTypeGenericMetadata,  Object  parentMock)  {  MockCreationSettings  parentMockSettings  =  new  MockUtil().getMockSettings(parentMock);  withSettingsUsing(returnTypeGenericMetadata,  parentMockSettings)  	[BUGGY]  private  Object  newDeepStubMock  (  GenericMetadataSupport  returnTypeGenericMetadata  )  {  withSettingsUsing  (  returnTypeGenericMetadata  )  [FE]  exceptionsbaseMockitoException:  assertThat  (  the_deep_stub  )  .  isNotNull  (  )  ;  [CLASS]  [CONTEXT]  	Mockito_10_ReturnsDeepStubs_6_3	87	2	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1888	private  MockSettings  withSettingsUsing(GenericMetadataSupport  returnTypeGenericMetadata,  MockCreationSettings  parentMockSettings)  {  	[BUGGY]  private  MockSettings  withSettingsUsing  (  GenericMetadataSupport  returnTypeGenericMetadata  )  {  [FE]  exceptionsbaseMockitoException:  assertThat  (  the_deep_stub  )  .  isNotNull  (  )  ;  [CLASS]  [CONTEXT]  	Mockito_10_ReturnsDeepStubs_6_4	94	1	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1889	return  propagateSerializationSettings(mockSettings,  parentMockSettings)  	[BUGGY]  return  mockSettings  .  serializable  (  )  [FE]  exceptionsbaseMockitoException:  assertThat  (  the_deep_stub  )  .  isNotNull  (  )  ;  [METHOD]  withSettingsUsing  [TYPE]  MockSettings  [PARAMETER]  GenericMetadataSupport  returnTypeGenericMetadata  [CLASS]  ReturnsDeepStubs  [TYPE]  boolean  false  true  [TYPE]  ReturnsEmptyValues  DELEGATE  [TYPE]  Object  mock  [TYPE]  MockitoCore  MOCKITO_CORE  [TYPE]  MockSettings  mockSettings  [TYPE]  GenericMetadataSupport  returnTypeGenericMetadata  [TYPE]  long  serialVersionUID  [CONTEXT]  private  MockSettings  withSettingsUsing  (  GenericMetadataSupport  returnTypeGenericMetadata  )  {  MockSettings  mockSettings  =  returnTypeGenericMetadata  .  hasRawExtraInterfaces  (  )  ?  withSettings  (  )  .  extraInterfaces  (  returnTypeGenericMetadata  .  rawExtraInterfaces  (  )  )  :  withSettings  (  )  ;  [BUGGY]  return  mockSettings  .  serializable  (  )    .  defaultAnswer  (  returnsDeepStubsAnswerUsing  (  returnTypeGenericMetadata  )  )  ;  }  	Mockito_10_ReturnsDeepStubs_6_5	99	1	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1890	private  MockSettings  propagateSerializationSettings(MockSettings  mockSettings,  MockCreationSettings  parentMockSettings)  {  return  mockSettings.serializable(parentMockSettings.getSerializableMode());  }  	[BUGGY]  [FE]  exceptionsbaseMockitoException:  assertThat  (  the_deep_stub  )  .  isNotNull  (  )  ;  [CLASS]  [CONTEXT]  	Mockito_10_ReturnsDeepStubs_6_6	103	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1891	if  (this  ==  o)  {  return  true;  }  if  (o  instanceof  DelegatingMethod)  {  DelegatingMethod  that  =  (DelegatingMethod)  o;  return  method.equals(that.method);  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  delegatingMethod  .  equals  (  someMethod  )  )  ;  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  Object  o  [CLASS]  DelegatingMethod  [TYPE]  Object  o  [TYPE]  Method  method  [TYPE]  boolean  false  true  [CONTEXT]  public  boolean  equals  (  Object  o  )  {  [BUGGY]  return  method  .  equals  (  o  )  ;  }  	Mockito_11_DelegatingMethod_2_1	55	0	src/org/mockito/internal/creation/DelegatingMethod.java
1892	return  method.hashCode();  	[BUGGY]  return  1  ;  [FE]  AssertionFailedError  assertTrue  (  delegatingMethod  .  equals  (  someMethod  )  )  ;  [METHOD]  hashCode  [TYPE]  int  [PARAMETER]  [CLASS]  DelegatingMethod  [TYPE]  Method  method  [TYPE]  boolean  false  true  [CONTEXT]  public  int  hashCode  (  )  {  [BUGGY]  return  1  ;  }  	Mockito_11_DelegatingMethod_2_2	60	1	src/org/mockito/internal/creation/DelegatingMethod.java
1893	if  (actual  instanceof  Class)  {  }  else  if  (actual  instanceof  ParameterizedType)  {\n',   "                                    }  	[BUGGY]  [FE]  ClassCastException:  ObjectsParameterizedTypeImpl  cannot  be  cast  to  Class  assertEquals  (  Set  .  class  ,  m  .  getGenericType  (  field  (   "multiNested "  )  )  )  ;  [METHOD]  getGenericType  [TYPE]  Class  [PARAMETER]  Field  field  [CLASS]  GenericMaster  [TYPE]  Field  field  [TYPE]  Type  actual  generic  [TYPE]  boolean  false  true  [CONTEXT]  public  Class  getGenericType  (  Field  field  )  {  Type  generic  =  field  .  getGenericType  (  )  ;  if  (  generic  !  =  null  &&  generic  instanceof  ParameterizedType  )  {  Type  actual  =  (  (  ParameterizedType  )  generic  )  .  getActualTypeArguments  (  )  [0]  ;  [BUGGY]  return  (  Class  )  actual  ;  }  return  Object  .  class  ;  }  	Mockito_12_GenericMaster_1_1	20	0	src/org/mockito/internal/util/reflection/GenericMaster.java
1894	if  (((MockAwareVerificationMode)  verificationMode).getMock()  ==  invocation.getMock())  {  	[BUGGY]  if  (  verificationMode  instanceof  MockAwareVerificationMode  &&  (  (  MockAwareVerificationMode  )  verificationMode  )  .  getMock  (  )  =  =  invocation  .  getMock  (  )  )  {  [FE]  AssertionFailedError  [METHOD]  handle  [TYPE]  Object  [PARAMETER]  Invocation  invocation  [CLASS]  MockHandler  [TYPE]  VerificationDataImpl  data  [TYPE]  Invocation  invocation  [TYPE]  MatchersBinder  matchersBinder  [TYPE]  MockSettingsImpl  mockSettings  [TYPE]  InvocationMatcher  invocationMatcher  [TYPE]  MockingProgress  mockingProgress  [TYPE]  long  serialVersionUID  [TYPE]  VerificationMode  verificationMode  [TYPE]  boolean  false  true  [TYPE]  InvocationContainerImpl  invocationContainerImpl  [TYPE]  StubbedInvocationMatcher  stubbedInvocation  [TYPE]  OngoingStubbingImpl  ongoingStubbing  [TYPE]  Object  ret  [CONTEXT]  public  Object  handle  (  Invocation  invocation  )  throws  Throwable  {  if  (  invocationContainerImpl  .  hasAnswersForStubbing  (  )  )  {  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  invocationContainerImpl  .  setMethodForStubbing  (  invocationMatcher  )  ;  return  null  ;  }  VerificationMode  verificationMode  =  mockingProgress  .  pullVerificationMode  (  )  ;  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  mockingProgress  .  validateState  (  )  ;    if  (  verificationMode  !  =  null  )  {    [BUGGY]  if  (  verificationMode  instanceof  MockAwareVerificationMode  &&  (  (  MockAwareVerificationMode  )  verificationMode  )  .  getMock  (  )  =  =  invocation  .  getMock  (  )  )  {  VerificationDataImpl  data  =  new  VerificationDataImpl  (  invocationContainerImpl  ,  invocationMatcher  )  ;  verificationMode  .  verify  (  data  )  ;  return  null  ;    	Mockito_13_MockHandler_2_1	77	1	src/org/mockito/internal/MockHandler.java
1895	}  else  {  mockingProgress.verificationStarted(verificationMode);  	[BUGGY]  [FE]  AssertionFailedError  [METHOD]  handle  [TYPE]  Object  [PARAMETER]  Invocation  invocation  [CLASS]  MockHandler  [TYPE]  VerificationDataImpl  data  [TYPE]  Invocation  invocation  [TYPE]  MatchersBinder  matchersBinder  [TYPE]  MockSettingsImpl  mockSettings  [TYPE]  InvocationMatcher  invocationMatcher  [TYPE]  MockingProgress  mockingProgress  [TYPE]  long  serialVersionUID  [TYPE]  VerificationMode  verificationMode  [TYPE]  boolean  false  true  [TYPE]  InvocationContainerImpl  invocationContainerImpl  [TYPE]  StubbedInvocationMatcher  stubbedInvocation  [TYPE]  OngoingStubbingImpl  ongoingStubbing  [TYPE]  Object  ret  [CONTEXT]  public  Object  handle  (  Invocation  invocation  )  throws  Throwable  {  if  (  invocationContainerImpl  .  hasAnswersForStubbing  (  )  )  {  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  invocationContainerImpl  .  setMethodForStubbing  (  invocationMatcher  )  ;  return  null  ;  }  VerificationMode  verificationMode  =  mockingProgress  .  pullVerificationMode  (  )  ;  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  mockingProgress  .  validateState  (  )  ;    if  (  verificationMode  !  =  null  )  {    if  (  verificationMode  instanceof  MockAwareVerificationMode  &&  (  (  MockAwareVerificationMode  )  verificationMode  )  .  getMock  (  )  =  =  invocation  .  getMock  (  )  )  {  VerificationDataImpl  data  =  new  VerificationDataImpl  (  invocationContainerImpl  ,  invocationMatcher  )  ;  verificationMode  .  verify  (  data  )  ;  return  null  ;  [BUGGY]    }  }  invocationContainerImpl  .  setInvocationForPotentialStubbing  (  invocationMatcher  )  ;  	Mockito_13_MockHandler_2_2	81	0	src/org/mockito/internal/MockHandler.java
1896		[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Mockito_14_MockHandler_3_1	20	0	src/org/mockito/internal/MockHandler.java
1897	if  (verificationMode  instanceof  MockAwareVerificationMode  &&  ((MockAwareVerificationMode)  verificationMode).getMock()  ==  invocation.getMock())  {  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  handle  [TYPE]  Object  [PARAMETER]  Invocation  invocation  [CLASS]  MockHandler  [TYPE]  VerificationDataImpl  data  [TYPE]  Invocation  invocation  [TYPE]  MatchersBinder  matchersBinder  [TYPE]  MockSettingsImpl  mockSettings  [TYPE]  InvocationMatcher  invocationMatcher  [TYPE]  MockingProgress  mockingProgress  [TYPE]  long  serialVersionUID  [TYPE]  VerificationMode  verificationMode  [TYPE]  boolean  false  true  [TYPE]  InvocationContainerImpl  invocationContainerImpl  [TYPE]  StubbedInvocationMatcher  stubbedInvocation  [TYPE]  OngoingStubbingImpl  ongoingStubbing  [TYPE]  Object  ret  [CONTEXT]  public  Object  handle  (  Invocation  invocation  )  throws  Throwable  {  if  (  invocationContainerImpl  .  hasAnswersForStubbing  (  )  )  {  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  invocationContainerImpl  .  setMethodForStubbing  (  invocationMatcher  )  ;  return  null  ;  }  VerificationMode  verificationMode  =  mockingProgress  .  pullVerificationMode  (  )  ;  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  mockingProgress  .  validateState  (  )  ;    if  (  verificationMode  !  =  null  )  {    [BUGGY]  VerificationDataImpl  data  =  new  VerificationDataImpl  (  invocationContainerImpl  .  getInvocations  (  )  ,  invocationMatcher  )  ;  verificationMode  .  verify  (  data  )  ;  return  null  ;  }  invocationContainerImpl  .  setInvocationForPotentialStubbing  (  invocationMatcher  )  ;  	Mockito_14_MockHandler_3_2	76	0	src/org/mockito/internal/MockHandler.java
1898	}  	[BUGGY]  [FE]  AssertionFailedError:  [METHOD]  handle  [TYPE]  Object  [PARAMETER]  Invocation  invocation  [CLASS]  MockHandler  [TYPE]  VerificationDataImpl  data  [TYPE]  Invocation  invocation  [TYPE]  MatchersBinder  matchersBinder  [TYPE]  MockSettingsImpl  mockSettings  [TYPE]  InvocationMatcher  invocationMatcher  [TYPE]  MockingProgress  mockingProgress  [TYPE]  long  serialVersionUID  [TYPE]  VerificationMode  verificationMode  [TYPE]  boolean  false  true  [TYPE]  InvocationContainerImpl  invocationContainerImpl  [TYPE]  StubbedInvocationMatcher  stubbedInvocation  [TYPE]  OngoingStubbingImpl  ongoingStubbing  [TYPE]  Object  ret  [CONTEXT]  public  Object  handle  (  Invocation  invocation  )  throws  Throwable  {  if  (  invocationContainerImpl  .  hasAnswersForStubbing  (  )  )  {  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  invocationContainerImpl  .  setMethodForStubbing  (  invocationMatcher  )  ;  return  null  ;  }  VerificationMode  verificationMode  =  mockingProgress  .  pullVerificationMode  (  )  ;  InvocationMatcher  invocationMatcher  =  matchersBinder  .  bindMatchers  (  mockingProgress  .  getArgumentMatcherStorage  (  )  ,  invocation  )  ;  mockingProgress  .  validateState  (  )  ;    if  (  verificationMode  !  =  null  )  {    VerificationDataImpl  data  =  new  VerificationDataImpl  (  invocationContainerImpl  .  getInvocations  (  )  ,  invocationMatcher  )  ;  verificationMode  .  verify  (  data  )  ;  return  null  ;  [BUGGY]  }  invocationContainerImpl  .  setInvocationForPotentialStubbing  (  invocationMatcher  )  ;  OngoingStubbingImpl<T>  ongoingStubbing  =  new  OngoingStubbingImpl<T>  (  invocationContainerImpl  )  ;  mockingProgress  .  reportOngoingStubbing  (  ongoingStubbing  )  ;  	Mockito_14_MockHandler_3_3	79	0	src/org/mockito/internal/MockHandler.java
1899		[BUGGY]  [FE]  AssertionFailedError:  [CLASS]  [CONTEXT]  	Mockito_14_MockitoCore_2_1	23	0	src/org/mockito/internal/MockitoCore.java
1900	mockingProgress.verificationStarted(new  MockAwareVerificationMode(mock,  mode));  	[BUGGY]  mockingProgress  .  verificationStarted  (  mode  )  ;  [FE]  AssertionFailedError:  [METHOD]  verify  [TYPE]  <T>  [PARAMETER]  T  mock  VerificationMode  mode  [CLASS]  MockitoCore  [TYPE]  boolean  false  true  [TYPE]  T  mock  [TYPE]  MockingProgress  mockingProgress  [TYPE]  MockUtil  mockUtil  [TYPE]  VerificationMode  mode  [TYPE]  Reporter  reporter  [CONTEXT]  public  <T>  T  verify  (  T  mock  ,  VerificationMode  mode  )  {  if  (  mock  =  =  null  )  {  reporter  .  nullPassedToVerify  (  )  ;  }  else  if  (  !mockUtil  .  isMock  (  mock  )  )  {  reporter  .  notAMockPassedToVerify  (  )  ;  }  [BUGGY]  mockingProgress  .  verificationStarted  (  mode  )  ;  return  mock  ;  }  	Mockito_14_MockitoCore_2_2	73	1	src/org/mockito/internal/MockitoCore.java
1901		[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  awaitingInjection  .  propertySetterUsed  )  ;  [CLASS]  [CONTEXT]  	Mockito_15_FinalMockCandidateFilter_2_1	4	0	src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java
1902	if  (!new  BeanPropertySetter(fieldInstance,  field).set(matchingMock))  {  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  awaitingInjection  .  propertySetterUsed  )  ;  [METHOD]  thenInject  [TYPE]  boolean  [PARAMETER]  [CLASS]  1  [TYPE]  boolean  false  true  [TYPE]  Exception  e  [CONTEXT]  public  boolean  thenInject  (  )  {  try  {  [BUGGY]  new  FieldSetter  (  fieldInstance  ,  field  )  .  set  (  matchingMock  )  ;  }  catch  (  Exception  e  )  {  throw  new  MockitoException  (   "Problems  injecting  dependency  in   "  +  field  .  getName  (  )  ,  e  )  ;  }  return  true  ;  }  	Mockito_15_FinalMockCandidateFilter_2_2	25	0	src/org/mockito/internal/configuration/injection/FinalMockCandidateFilter.java
1903	public  <T>  T  mock(Class<T>  classToMock,  MockSettings  mockSettings,  boolean  shouldResetOngoingStubbing)  {  if  (shouldResetOngoingStubbing)  {  }  	[BUGGY]  public  <T>  T  mock  (  Class<T>  classToMock  ,  MockSettings  mockSettings  ,  boolean  shouldResetOngoingStubbing  )  {  return  mock  (  classToMock  ,  mockSettings  )  ;  }  public  <T>  T  mock  (  Class<T>  classToMock  ,  MockSettings  mockSettings  )  {  [FE]  exceptionsmisusingMissingMethodInvocationException:  [CLASS]  [CONTEXT]  	Mockito_16_MockitoCore_1_1	32	2	src/org/mockito/internal/MockitoCore.java
1904	return  MOCKITO_CORE.mock(classToMock,  mockSettings,  true);  	[BUGGY]  return  MOCKITO_CORE  .  mock  (  classToMock  ,  mockSettings  )  ;  [FE]  exceptionsmisusingMissingMethodInvocationException:  [METHOD]  mock  [TYPE]  <T>  [PARAMETER]  Class<T>  classToMock  MockSettings  mockSettings  [CLASS]  Mockito  [TYPE]  Answer  CALLS_REAL_METHODS  RETURNS_DEFAULTS  RETURNS_MOCKS  RETURNS_SMART_NULLS  [TYPE]  MockitoCore  MOCKITO_CORE  [TYPE]  Class  classToMock  [TYPE]  MockSettings  mockSettings  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  T  mock  (  Class<T>  classToMock  ,  MockSettings  mockSettings  )  {  [BUGGY]  return  MOCKITO_CORE  .  mock  (  classToMock  ,  mockSettings  )  ;  }  	Mockito_16_Mockito_2_1	827	1	src/org/mockito/Mockito.java
1905	.defaultAnswer(CALLS_REAL_METHODS),  true);  	[BUGGY]  .  defaultAnswer  (  CALLS_REAL_METHODS  )  )  ;  [FE]  exceptionsmisusingMissingMethodInvocationException:  [METHOD]  spy  [TYPE]  <T>  [PARAMETER]  T  object  [CLASS]  Mockito  [TYPE]  Answer  CALLS_REAL_METHODS  RETURNS_DEFAULTS  RETURNS_MOCKS  RETURNS_SMART_NULLS  [TYPE]  MockitoCore  MOCKITO_CORE  [TYPE]  boolean  false  true  [TYPE]  T  object  [CONTEXT]  public  static  <T>  T  spy  (  T  object  )  {  return  MOCKITO_CORE  .  mock  (  (  Class<T>  )  object  .  getClass  (  )  ,  withSettings  (  )    .  spiedInstance  (  object  )  [BUGGY]  .  defaultAnswer  (  CALLS_REAL_METHODS  )  )  ;  }  	Mockito_16_Mockito_2_2	899	1	src/org/mockito/Mockito.java
1906	private  boolean  serializable;  this.serializable  =  true;  return  this;  	[BUGGY]  return  this  .  extraInterfaces  (  java  .  io  .  Serializable  .  class  )  ;  [FE]  NotSerializableException:  orgmockitousageIMethods$$EnhancerByMockitoWithCGLIB$$a155cf16  [CLASS]  [CONTEXT]  	Mockito_17_MockSettingsImpl_2_1	20	1	src/org/mockito/internal/creation/MockSettingsImpl.java
1907	return  serializable;  	[BUGGY]  return  extraInterfaces  !  =  null  &&  java  .  util  .  Arrays  .  asList  (  extraInterfaces  )  .  contains  (  java  .  io  .  Serializable  .  class  )  ;  [FE]  NotSerializableException:  orgmockitousageIMethods$$EnhancerByMockitoWithCGLIB$$a155cf16  [METHOD]  isSerializable  [TYPE]  boolean  [PARAMETER]  [CLASS]  MockSettingsImpl  [TYPE]  Answer  defaultAnswer  [TYPE]  Class[]  extraInterfaces  [TYPE]  MockName  mockName  [TYPE]  boolean  false  true  [TYPE]  Object  spiedInstance  [TYPE]  String  name  [TYPE]  long  serialVersionUID  [CONTEXT]  public  boolean  isSerializable  (  )  {  [BUGGY]  return  extraInterfaces  !  =  null  &&  java  .  util  .  Arrays  .  asList  (  extraInterfaces  )  .  contains  (  java  .  io  .  Serializable  .  class  )  ;  }  	Mockito_17_MockSettingsImpl_2_2	74	1	src/org/mockito/internal/creation/MockSettingsImpl.java
1908		[BUGGY]  [FE]  NotSerializableException:  orgmockitousageIMethods$$EnhancerByMockitoWithCGLIB$$a155cf16  [CLASS]  [CONTEXT]  	Mockito_17_MockUtil_2_1	19	0	src/org/mockito/internal/util/MockUtil.java
1909	if  (settings.isSerializable())  {  ancillaryTypes  =  interfaces  ==  null  ?  new  Class<?>[]  {Serializable.class}  :  new  ArrayUtils().concat(interfaces,  Serializable.class);  }  else  {  }  	[BUGGY]  [FE]  NotSerializableException:  orgmockitousageIMethods$$EnhancerByMockitoWithCGLIB$$a155cf16  [METHOD]  createMock  [TYPE]  <T>  [PARAMETER]  Class<T>  classToMock  MockSettingsImpl  settings  [CLASS]  MockUtil  [TYPE]  Class[]  ancillaryTypes  interfaces  [TYPE]  boolean  false  true  [TYPE]  T  mock  [TYPE]  MockSettingsImpl  settings  [TYPE]  CreationValidator  creationValidator  [TYPE]  Class  classToMock  [TYPE]  MockHandler  mockHandler  [TYPE]  Object  spiedInstance  [TYPE]  MethodInterceptorFilter  filter  [CONTEXT]  public  <T>  T  createMock  (  Class<T>  classToMock  ,  MockSettingsImpl  settings  )  {  creationValidator  .  validateType  (  classToMock  )  ;  creationValidator  .  validateExtraInterfaces  (  classToMock  ,  settings  .  getExtraInterfaces  (  )  )  ;  creationValidator  .  validateMockedType  (  classToMock  ,  settings  .  getSpiedInstance  (  )  )  ;  settings  .  initiateMockName  (  classToMock  )  ;  MockHandler<T>  mockHandler  =  new  MockHandler<T>  (  settings  )  ;  MethodInterceptorFilter  filter  =  new  MethodInterceptorFilter  (  mockHandler  ,  settings  )  ;  Class<?>[]  interfaces  =  settings  .  getExtraInterfaces  (  )  ;  Class<?>[]  ancillaryTypes  ;  [BUGGY]  ancillaryTypes  =  interfaces  =  =  null  ?  new  Class<?>[0]  :  interfaces  ;  Object  spiedInstance  =  settings  .  getSpiedInstance  (  )  ;  T  mock  =  ClassImposterizer  .  INSTANCE  .  imposterise  (  filter  ,  classToMock  ,  ancillaryTypes  )  ;  if  (  spiedInstance  !  =  null  )  {  new  LenientCopyTool  (  )  .  copyToMock  (  spiedInstance  ,  mock  )  ;  }  return  mock  ;  }  	Mockito_17_MockUtil_2_2	45	0	src/org/mockito/internal/util/MockUtil.java
1910	}  else  if  (type  ==  Iterable.class)  {  return  new  ArrayList<Object>(0);  	[BUGGY]  [FE]  NullPointerException  assertFalse  (  (  (  Iterable  )  values  .  returnValueFor  (  Iterable  .  class  )  )  .  iterator  (  )  .  hasNext  (  )  )  ;  [METHOD]  returnValueFor  [TYPE]  Object  [PARAMETER]  Class<?>  type  [CLASS]  ReturnsEmptyValues  [TYPE]  ObjectMethodsGuru  methodsGuru  [TYPE]  Class  type  [TYPE]  boolean  false  true  [TYPE]  MockUtil  mockUtil  [TYPE]  long  serialVersionUID  [CONTEXT]  Object  returnValueFor  (  Class<?>  type  )  {  if  (  Primitives  .  isPrimitiveOrWrapper  (  type  )  )  {  return  Primitives  .  defaultValueForPrimitiveOrWrapper  (  type  )  ;    [BUGGY]  }  else  if  (  type  =  =  Collection  .  class  )  {  return  new  LinkedList<Object>  (  )  ;  }  else  if  (  type  =  =  Set  .  class  )  {  return  new  HashSet<Object>  (  )  ;  }  else  if  (  type  =  =  HashSet  .  class  )  {  return  new  HashSet<Object>  (  )  ;  	Mockito_18_ReturnsEmptyValues_1_1	87	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
1911		[BUGGY]  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [CLASS]  [CONTEXT]  	Mockito_19_FinalMockCandidateFilter_2_1	13	0	src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java
1912	public  OngoingInjecter  filterCandidate(final  Collection<Object>  mocks,  final  Field  field,  List<Field>  fields,  final  Object  fieldInstance)  {  	[BUGGY]  public  OngoingInjecter  filterCandidate  (  final  Collection<Object>  mocks  ,  final  Field  field  ,  final  Object  fieldInstance  )  {  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [CLASS]  [CONTEXT]  	Mockito_19_FinalMockCandidateFilter_2_2	23	1	src/org/mockito/internal/configuration/injection/filter/FinalMockCandidateFilter.java
1913		[BUGGY]  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [CLASS]  [CONTEXT]  	Mockito_19_MockCandidateFilter_2_1	9	0	src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
1914	List<Field>  fields,  Object  instance  	[BUGGY]  Object  fieldInstance  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [CLASS]  [CONTEXT]  	Mockito_19_MockCandidateFilter_2_2	15	1	src/org/mockito/internal/configuration/injection/filter/MockCandidateFilter.java
1915	\t\t\tField  field,  List<Field>  fields,  Object  fieldInstance)  {  	[BUGGY]  \t\t\tField  field  ,  Object  fieldInstance  )  {  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [METHOD]  filterCandidate  [TYPE]  OngoingInjecter  [PARAMETER]  Object>  mocks  Field  field  Object  fieldInstance  [CLASS]  NameBasedCandidateFilter  [TYPE]  Field  field  [TYPE]  boolean  false  true  [TYPE]  MockCandidateFilter  next  [TYPE]  MockUtil  mockUtil  [TYPE]  Collection  mocks  [TYPE]  Object  fieldInstance  mock  [TYPE]  List  mockNameMatches  [CONTEXT]  public  OngoingInjecter  filterCandidate  (  Collection<Object>  mocks  ,  [BUGGY]  Field  field  ,  Object  fieldInstance  )  {  List<Object>  mockNameMatches  =  new  ArrayList<Object>  (  )  ;  if  (  mocks  .  size  (  )  >  1  )  {  for  (  Object  mock  :  mocks  )  {  if  (  field  .  getName  (  )  .  equals  (  mockUtil  .  getMockName  (  mock  )  .  toString  (  )  )  )  {  mockNameMatches  .  add  (  mock  )  ;  }  }  return  next  .  filterCandidate  (  mockNameMatches  ,  field  ,  fieldInstance  )  ;          }  return  next  .  filterCandidate  (  mocks  ,  field  ,  fieldInstance  )  ;  }  	Mockito_19_NameBasedCandidateFilter_3_1	23	1	src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
1916	\t\t\treturn  next.filterCandidate(mockNameMatches,  field,  fields,  	[BUGGY]  \t\t\treturn  next  .  filterCandidate  (  mockNameMatches  ,  field  ,  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [METHOD]  filterCandidate  [TYPE]  OngoingInjecter  [PARAMETER]  Object>  mocks  Field  field  Object  fieldInstance  [CLASS]  NameBasedCandidateFilter  [TYPE]  Field  field  [TYPE]  boolean  false  true  [TYPE]  MockCandidateFilter  next  [TYPE]  MockUtil  mockUtil  [TYPE]  Collection  mocks  [TYPE]  Object  fieldInstance  mock  [TYPE]  List  mockNameMatches  [CONTEXT]  public  OngoingInjecter  filterCandidate  (  Collection<Object>  mocks  ,  Field  field  ,  Object  fieldInstance  )  {  List<Object>  mockNameMatches  =  new  ArrayList<Object>  (  )  ;  if  (  mocks  .  size  (  )  >  1  )  {  for  (  Object  mock  :  mocks  )  {  if  (  field  .  getName  (  )  .  equals  (  mockUtil  .  getMockName  (  mock  )  .  toString  (  )  )  )  {  mockNameMatches  .  add  (  mock  )  ;  }  }  [BUGGY]  return  next  .  filterCandidate  (  mockNameMatches  ,  field  ,  fieldInstance  )  ;          }  return  next  .  filterCandidate  (  mocks  ,  field  ,  fieldInstance  )  ;  }  	Mockito_19_NameBasedCandidateFilter_3_2	31	1	src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
1917	\t\t}  else  if  (mocks.size()  ==  1)  {  \t\t\tString  mockName  =  mockUtil.getMockName(mocks.iterator().next())  \t\t\t\t\t.toString();    \t\t\tfor  (Field  otherField  :  fields)  {  \t\t\t\tif  (!otherField.equals(field)  \t\t\t\t\t\t&&  otherField.getType().equals(field.getType())  \t\t\t\t\t\t&&  otherField.getName().equals(mockName))  {    \t\t\t\t\treturn  new  OngoingInjecter()  {  \t\t\t\t\t\tpublic  Object  thenInject()  {  \t\t\t\t\t\t\treturn  null;  \t\t\t\t\t\t}  \t\t\t\t\t};  \t\t\t\t}  \t\t\t}  \t\treturn  next.filterCandidate(mocks,  field,  fields,  fieldInstance);  	[BUGGY]  \t\treturn  next  .  filterCandidate  (  mocks  ,  field  ,  fieldInstance  )  ;  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [METHOD]  filterCandidate  [TYPE]  OngoingInjecter  [PARAMETER]  Object>  mocks  Field  field  Object  fieldInstance  [CLASS]  NameBasedCandidateFilter  [TYPE]  Field  field  [TYPE]  boolean  false  true  [TYPE]  MockCandidateFilter  next  [TYPE]  MockUtil  mockUtil  [TYPE]  Collection  mocks  [TYPE]  Object  fieldInstance  mock  [TYPE]  List  mockNameMatches  [CONTEXT]  public  OngoingInjecter  filterCandidate  (  Collection<Object>  mocks  ,  Field  field  ,  Object  fieldInstance  )  {  List<Object>  mockNameMatches  =  new  ArrayList<Object>  (  )  ;  if  (  mocks  .  size  (  )  >  1  )  {  for  (  Object  mock  :  mocks  )  {  if  (  field  .  getName  (  )  .  equals  (  mockUtil  .  getMockName  (  mock  )  .  toString  (  )  )  )  {  mockNameMatches  .  add  (  mock  )  ;  }  }  return  next  .  filterCandidate  (  mockNameMatches  ,  field  ,  fieldInstance  )  ;          [BUGGY]  }  return  next  .  filterCandidate  (  mocks  ,  field  ,  fieldInstance  )  ;  }  	Mockito_19_NameBasedCandidateFilter_3_3	42	1	src/org/mockito/internal/configuration/injection/filter/NameBasedCandidateFilter.java
1918	public  OngoingInjecter  filterCandidate(Collection<Object>  mocks,  Field  field,  List<Field>  fields,  Object  fieldInstance)  {  	[BUGGY]  public  OngoingInjecter  filterCandidate  (  Collection<Object>  mocks  ,  Field  field  ,  Object  fieldInstance  )  {  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [CLASS]  [CONTEXT]  	Mockito_19_TypeBasedCandidateFilter_2_1	20	1	src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
1919	return  next.filterCandidate(mockTypeMatches,  field,  fields,  fieldInstance);  	[BUGGY]  return  next  .  filterCandidate  (  mockTypeMatches  ,  field  ,  fieldInstance  )  ;  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [METHOD]  filterCandidate  [TYPE]  OngoingInjecter  [PARAMETER]  Object>  mocks  Field  field  Object  fieldInstance  [CLASS]  TypeBasedCandidateFilter  [TYPE]  Collection  mocks  [TYPE]  Field  field  [TYPE]  Object  fieldInstance  mock  [TYPE]  List  mockTypeMatches  [TYPE]  boolean  false  true  [TYPE]  MockCandidateFilter  next  [CONTEXT]  public  OngoingInjecter  filterCandidate  (  Collection<Object>  mocks  ,  Field  field  ,  Object  fieldInstance  )  {  List<Object>  mockTypeMatches  =  new  ArrayList<Object>  (  )  ;  for  (  Object  mock  :  mocks  )  {  if  (  field  .  getType  (  )  .  isAssignableFrom  (  mock  .  getClass  (  )  )  )  {  mockTypeMatches  .  add  (  mock  )  ;  }  }  [BUGGY]  return  next  .  filterCandidate  (  mockTypeMatches  ,  field  ,  fieldInstance  )  ;  }  	Mockito_19_TypeBasedCandidateFilter_2_2	28	1	src/org/mockito/internal/configuration/injection/filter/TypeBasedCandidateFilter.java
1920	Object  injected  =  mockCandidateFilter.filterCandidate(mocks,  field,  orderedInstanceFields,  instance).thenInject();  	[BUGGY]  Object  injected  =  mockCandidateFilter  .  filterCandidate  (  mocks  ,  field  ,  instance  )  .  thenInject  (  )  ;  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  candidate2  assertNotNull  (  otherSuperUnderTesting  .  candidate2  )  ;  [METHOD]  injectMockCandidatesOnFields  [TYPE]  boolean  [PARAMETER]  Object>  mocks  Object  instance  boolean  injectionOccurred  Field>  orderedInstanceFields  [CLASS]  PropertyAndSetterInjection  [TYPE]  Field  field  [TYPE]  Set  mocks  [TYPE]  boolean  false  injectionOccurred  true  [TYPE]  Filter  notFinalOrStatic  [TYPE]  MockCandidateFilter  mockCandidateFilter  [TYPE]  Iterator  it  [TYPE]  Object  injected  instance  [TYPE]  List  orderedInstanceFields  [CONTEXT]  private  boolean  injectMockCandidatesOnFields  (  Set<Object>  mocks  ,  Object  instance  ,  boolean  injectionOccurred  ,  List<Field>  orderedInstanceFields  )  {  for  (  Iterator<Field>  it  =  orderedInstanceFields  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  {  Field  field  =  it  .  next  (  )  ;  [BUGGY]  Object  injected  =  mockCandidateFilter  .  filterCandidate  (  mocks  ,  field  ,  instance  )  .  thenInject  (  )  ;  if  (  injected  !  =  null  )  {  injectionOccurred  |  =  true  ;  mocks  .  remove  (  injected  )  ;  it  .  remove  (  )  ;  }  }  return  injectionOccurred  ;  }  	Mockito_19_PropertyAndSetterInjection_1_1	114	1	src/org/mockito/internal/configuration/injection/PropertyAndSetterInjection.java
1921	Instantiator  instantiator  =  new  InstantiatorProvider().getInstantiator(settings);  mockInstance  =  instantiator.newInstance(mockedProxyType);  	[BUGGY]  mockInstance  =  classInstantiator  .  instantiate  (  mockedProxyType  )  ;  [FE]  ComparisonFailure:  expected:<[inner]  strength>  but  was:<[null]  strength>  assertEquals  (   "inner  strength "  ,  outer  .  strength  .  fullStrength  (  )  )  ;  [METHOD]  createMock  [TYPE]  <T>  [PARAMETER]  MockCreationSettings<T>  settings  MockHandler  handler  [CLASS]  ByteBuddyMockMaker  [TYPE]  MockAccess  mockAccess  [TYPE]  org  .  mockito  .  internal  .  creation  .  instance  e  [TYPE]  boolean  false  true  [TYPE]  T  mockInstance  [TYPE]  ClassInstantiator  classInstantiator  [TYPE]  MockCreationSettings  settings  [TYPE]  ClassCastException  cce  [TYPE]  MockHandler  handler  [TYPE]  Class  mockedProxyType  [TYPE]  CachingMockBytecodeGenerator  cachingMockBytecodeGenerator  [CONTEXT]  public  <T>  T  createMock  (  MockCreationSettings<T>  settings  ,  MockHandler  handler  )  {  if  (  settings  .  getSerializableMode  (  )  =  =  SerializableMode  .  ACROSS_CLASSLOADERS  )  {  throw  new  MockitoException  (   "Serialization  across  classloaders  not  yet  supported  with  ByteBuddyMockMaker "  )  ;  }  Class<?  extends  T>  mockedProxyType  =  cachingMockBytecodeGenerator  .  get  (  settings  .  getTypeToMock  (  )  ,  settings  .  getExtraInterfaces  (  )    )  ;  [BUGGY]  T  mockInstance  =  null  ;  try  {  mockInstance  =  classInstantiator  .  instantiate  (  mockedProxyType  )  ;  MockMethodInterceptor  .  MockAccess  mockAccess  =  (  MockMethodInterceptor  .  MockAccess  )  mockInstance  ;  mockAccess  .  setMockitoInterceptor  (  new  MockMethodInterceptor  (  asInternalMockHandler  (  handler  )  ,  settings  )  )  ;  return  ensureMockIsAssignableToMockedType  (  settings  ,  mockInstance  )  ;  }  catch  (  ClassCastException  cce  )  {  throw  new  MockitoException  (  join  (   "ClassCastException  occurred  while  creating  the  mockito  mock  : "  ,   "class  to  mock  :   "  +  describeClass  (  mockedProxyType  )  ,   "created  class  :   "  +  describeClass  (  settings  .  getTypeToMock  (  )  )  ,   "proxy  instance  class  :   "  +  describeClass  (  mockInstance  )  ,   "instance  creation  by  :   "  +  classInstantiator  .  getClass  (  )  .  getSimpleName  (  )  ,   " "  ,   "You  might  experience  classloading  issues  ,  please  ask  the  mockito  mailing-list  .   "  ,   " "  )  ,  cce  )  ;  }  catch  (  org  .  mockito  .  internal  .  creation  .  instance  .  InstantiationException  e  )  {  throw  new  MockitoException  (   "Unable  to  create  mock  instance  of  type  ' "  +  mockedProxyType  .  getSuperclass  (  )  .  getSimpleName  (  )  +   "' "  ,  e  )  ;  }  }  	Mockito_20_ByteBuddyMockMaker_2_1	32	1	src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java
1922	 "    instance  creation  by  :   "  +  instantiator.getClass().getSimpleName(),  	[BUGGY]   "  instance  creation  by  :   "  +  classInstantiator  .  getClass  (  )  .  getSimpleName  (  )  ,  [FE]  ComparisonFailure:  expected:<[inner]  strength>  but  was:<[null]  strength>  assertEquals  (   "inner  strength "  ,  outer  .  strength  .  fullStrength  (  )  )  ;  [METHOD]  createMock  [TYPE]  <T>  [PARAMETER]  MockCreationSettings<T>  settings  MockHandler  handler  [CLASS]  ByteBuddyMockMaker  [TYPE]  MockAccess  mockAccess  [TYPE]  org  .  mockito  .  internal  .  creation  .  instance  e  [TYPE]  boolean  false  true  [TYPE]  T  mockInstance  [TYPE]  ClassInstantiator  classInstantiator  [TYPE]  MockCreationSettings  settings  [TYPE]  ClassCastException  cce  [TYPE]  MockHandler  handler  [TYPE]  Class  mockedProxyType  [TYPE]  CachingMockBytecodeGenerator  cachingMockBytecodeGenerator  [CONTEXT]  public  <T>  T  createMock  (  MockCreationSettings<T>  settings  ,  MockHandler  handler  )  {  if  (  settings  .  getSerializableMode  (  )  =  =  SerializableMode  .  ACROSS_CLASSLOADERS  )  {  throw  new  MockitoException  (   "Serialization  across  classloaders  not  yet  supported  with  ByteBuddyMockMaker "  )  ;  }  Class<?  extends  T>  mockedProxyType  =  cachingMockBytecodeGenerator  .  get  (  settings  .  getTypeToMock  (  )  ,  settings  .  getExtraInterfaces  (  )    )  ;  T  mockInstance  =  null  ;  try  {  mockInstance  =  classInstantiator  .  instantiate  (  mockedProxyType  )  ;  MockMethodInterceptor  .  MockAccess  mockAccess  =  (  MockMethodInterceptor  .  MockAccess  )  mockInstance  ;  mockAccess  .  setMockitoInterceptor  (  new  MockMethodInterceptor  (  asInternalMockHandler  (  handler  )  ,  settings  )  )  ;  return  ensureMockIsAssignableToMockedType  (  settings  ,  mockInstance  )  ;  }  catch  (  ClassCastException  cce  )  {  throw  new  MockitoException  (  join  (   "ClassCastException  occurred  while  creating  the  mockito  mock  : "  ,   "class  to  mock  :   "  +  describeClass  (  mockedProxyType  )  ,   "created  class  :   "  +  describeClass  (  settings  .  getTypeToMock  (  )  )  ,   "proxy  instance  class  :   "  +  describeClass  (  mockInstance  )  ,  [BUGGY]   "instance  creation  by  :   "  +  classInstantiator  .  getClass  (  )  .  getSimpleName  (  )  ,   " "  ,   "You  might  experience  classloading  issues  ,  please  ask  the  mockito  mailing-list  .   "  ,   " "  )  ,  cce  )  ;  }  catch  (  org  .  mockito  .  internal  .  creation  .  instance  .  InstantiationException  e  )  {  throw  new  MockitoException  (   "Unable  to  create  mock  instance  of  type  ' "  +  mockedProxyType  .  getSuperclass  (  )  .  getSimpleName  (  )  +   "' "  ,  e  )  ;  }  }  	Mockito_20_ByteBuddyMockMaker_2_2	45	1	src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java
1923	return  withParams(cls,  outerClassInstance);  private  static  <T>  T  withParams(Class<T>  cls,  Object...  params)  {  	[BUGGY]  return  withOuterClass  (  cls  )  ;  private  <T>  T  withOuterClass  (  Class<T>  cls  )  {  [FE]  internalcreationinstanceInstantationException:  Unable  to  create  mock  instance  of  'SomeInnerClass'  assertEquals  (  new  ConstructorInstantiator  (  new  ChildOfThis  (  )  )  .  newInstance  (  SomeInnerClass  .  class  )  .  getClass  (  )  ,  SomeInnerClass  .  class  )  ;  [METHOD]  newInstance  [TYPE]  <T>  [PARAMETER]  Class<T>  cls  [CLASS]  ConstructorInstantiator  [TYPE]  Object  outerClassInstance  [TYPE]  Class  cls  [TYPE]  boolean  false  true  [CONTEXT]  public  <T>  T  newInstance  (  Class<T>  cls  )  {  if  (  outerClassInstance  =  =  null  )  {  return  noArgConstructor  (  cls  )  ;  }  [BUGGY]  return  withOuterClass  (  cls  )  ;  }  	Mockito_21_ConstructorInstantiator_4_1	17	2	src/org/mockito/internal/creation/instance/ConstructorInstantiator.java
1924	for  (Constructor<?>  constructor  :  cls.getDeclaredConstructors())  {  Class<?>[]  types  =  constructor.getParameterTypes();  if  (paramsMatch(types,  params))  {  return  (T)  constructor.newInstance(params);  }  }  	[BUGGY]  Constructor<T>  c  =  cls  .  getDeclaredConstructor  (  outerClassInstance  .  getClass  (  )  )  ;  return  c  .  newInstance  (  outerClassInstance  )  ;  [FE]  internalcreationinstanceInstantationException:  Unable  to  create  mock  instance  of  'SomeInnerClass'  assertEquals  (  new  ConstructorInstantiator  (  new  ChildOfThis  (  )  )  .  newInstance  (  SomeInnerClass  .  class  )  .  getClass  (  )  ,  SomeInnerClass  .  class  )  ;  [METHOD]  withOuterClass  [TYPE]  <T>  [PARAMETER]  Class<T>  cls  [CLASS]  ConstructorInstantiator  [TYPE]  Object  outerClassInstance  [TYPE]  Class  cls  [TYPE]  boolean  false  true  [TYPE]  Constructor  c  [TYPE]  Exception  e  [CONTEXT]  private  <T>  T  withOuterClass  (  Class<T>  cls  )  {  try  {    [BUGGY]  Constructor<T>  c  =  cls  .  getDeclaredConstructor  (  outerClassInstance  .  getClass  (  )  )  ;  return  c  .  newInstance  (  outerClassInstance  )  ;  }  catch  (  Exception  e  )  {  throw  paramsException  (  cls  ,  e  )  ;  }  }  	Mockito_21_ConstructorInstantiator_4_2	24	2	src/org/mockito/internal/creation/instance/ConstructorInstantiator.java
1925	throw  paramsException(cls,  null);  	[BUGGY]  [FE]  internalcreationinstanceInstantationException:  Unable  to  create  mock  instance  of  'SomeInnerClass'  assertEquals  (  new  ConstructorInstantiator  (  new  ChildOfThis  (  )  )  .  newInstance  (  SomeInnerClass  .  class  )  .  getClass  (  )  ,  SomeInnerClass  .  class  )  ;  [CLASS]  [CONTEXT]  	Mockito_21_ConstructorInstantiator_4_3	29	0	src/org/mockito/internal/creation/instance/ConstructorInstantiator.java
1926	private  static  boolean  paramsMatch(Class<?>[]  types,  Object[]  params)  {  if  (params.length  !=  types.length)  {  return  false;  }  for  (int  i  =  0;  i  <  params.length;  i++)  {  if  (!types[i].isInstance(params[i]))  {  return  false;  }  }  return  true;  }  	[BUGGY]  [FE]  internalcreationinstanceInstantationException:  Unable  to  create  mock  instance  of  'SomeInnerClass'  assertEquals  (  new  ConstructorInstantiator  (  new  ChildOfThis  (  )  )  .  newInstance  (  SomeInnerClass  .  class  )  .  getClass  (  )  ,  SomeInnerClass  .  class  )  ;  [CLASS]  [CONTEXT]  	Mockito_21_ConstructorInstantiator_4_4	36	0	src/org/mockito/internal/creation/instance/ConstructorInstantiator.java
1927	if  (o1  ==  o2  )  {  return  true;  \t}  else  if  (o1  ==  null  ||  o2  ==  null)  {  	[BUGGY]  if  (  o1  =  =  null  ||  o2  =  =  null  )  {  [FE]  RuntimeException  assertFalse  (  areEqual  (  new  int[]  {1}  ,  new  double[]  {1  .  0}  )  )  ;  [METHOD]  areEqual  [TYPE]  boolean  [PARAMETER]  Object  o1  Object  o2  [CLASS]  Equality  [TYPE]  boolean  false  true  [TYPE]  Object  o1  o2  [CONTEXT]  public  static  boolean  areEqual  (  Object  o1  ,  Object  o2  )  {  [BUGGY]  if  (  o1  =  =  null  ||  o2  =  =  null  )  {  return  o1  =  =  null  &&  o2  =  =  null  ;  }  else  if  (  isArray  (  o1  )  )  {  return  isArray  (  o2  )  &&  areArraysEqual  (  o1  ,  o2  )  ;  }  else  {  return  o1  .  equals  (  o2  )  ;  }  }  	Mockito_22_Equality_1_1	13	1	src/org/mockito/internal/matchers/Equality.java
1928	private  transient  MockitoCore  mockitoCore;  private  transient  ReturnsEmptyValues  delegate;  	[BUGGY]  private  MockitoCore  mockitoCore  =  new  MockitoCore  (  )  ;  private  ReturnsEmptyValues  delegate  =  new  ReturnsEmptyValues  (  )  ;  [FE]  NotSerializableException:  orgmockitointernalstubbingdefaultanswersReturnsDeepStubs$2  assertThat  (  deserializedSample  .  getSample  (  )  .  getNumber  (  )  )  .  isEqualTo  (  STUBBED_INTEGER_VALUE  )  ;  [CLASS]  [CONTEXT]  	Mockito_23_ReturnsDeepStubs_6_1	44	2	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1929	instantiateMockitoCoreIfNeeded();  instantiateDelegateIfNeeded();  	[BUGGY]  [FE]  NotSerializableException:  orgmockitointernalstubbingdefaultanswersReturnsDeepStubs$2  assertThat  (  deserializedSample  .  getSample  (  )  .  getNumber  (  )  )  .  isEqualTo  (  STUBBED_INTEGER_VALUE  )  ;  [METHOD]  answer  [TYPE]  Object  [PARAMETER]  InvocationOnMock  invocation  [CLASS]  ReturnsDeepStubs  [TYPE]  boolean  false  true  [TYPE]  InvocationOnMock  invocation  [TYPE]  ReturnsEmptyValues  delegate  [TYPE]  MockitoCore  mockitoCore  [TYPE]  Class  rawType  [TYPE]  GenericMetadataSupport  returnTypeGenericMetadata  [TYPE]  long  serialVersionUID  [CONTEXT]  public  Object  answer  (  InvocationOnMock  invocation  )  throws  Throwable  {  GenericMetadataSupport  returnTypeGenericMetadata  =  actualParameterizedType  (  invocation  .  getMock  (  )  )  .  resolveGenericReturnType  (  invocation  .  getMethod  (  )  )  ;  Class<?>  rawType  =  returnTypeGenericMetadata  .  rawType  (  )  ;  [BUGGY]  if  (  !mockitoCore  .  isTypeMockable  (  rawType  )  )  {  return  delegate  .  returnValueFor  (  rawType  )  ;  }  return  getMock  (  invocation  ,  returnTypeGenericMetadata  )  ;  }  	Mockito_23_ReturnsDeepStubs_6_2	52	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1930	private  synchronized  void  instantiateMockitoCoreIfNeeded()  {  if  (mockitoCore  ==  null)  {  mockitoCore  =  new  MockitoCore();  }  }  private  synchronized  void  instantiateDelegateIfNeeded()  {  if  (delegate  ==  null)  {  delegate  =  new  ReturnsEmptyValues();  }  }  	[BUGGY]  [FE]  NotSerializableException:  orgmockitointernalstubbingdefaultanswersReturnsDeepStubs$2  assertThat  (  deserializedSample  .  getSample  (  )  .  getNumber  (  )  )  .  isEqualTo  (  STUBBED_INTEGER_VALUE  )  ;  [CLASS]  [CONTEXT]  	Mockito_23_ReturnsDeepStubs_6_3	59	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1931	\t\t                .serializable()  	[BUGGY]  [FE]  NotSerializableException:  orgmockitointernalstubbingdefaultanswersReturnsDeepStubs$2  assertThat  (  deserializedSample  .  getSample  (  )  .  getNumber  (  )  )  .  isEqualTo  (  STUBBED_INTEGER_VALUE  )  ;  [METHOD]  withSettingsUsing  [TYPE]  MockSettings  [PARAMETER]  GenericMetadataSupport  returnTypeGenericMetadata  [CLASS]  ReturnsDeepStubs  [TYPE]  MockitoCore  mockitoCore  [TYPE]  MockSettings  mockSettings  [TYPE]  boolean  false  true  [TYPE]  GenericMetadataSupport  returnTypeGenericMetadata  [TYPE]  long  serialVersionUID  [TYPE]  ReturnsEmptyValues  delegate  [CONTEXT]  private  MockSettings  withSettingsUsing  (  GenericMetadataSupport  returnTypeGenericMetadata  )  {  MockSettings  mockSettings  =  returnTypeGenericMetadata  .  rawExtraInterfaces  (  )  .  length  >  0  ?  withSettings  (  )  .  extraInterfaces  (  returnTypeGenericMetadata  .  rawExtraInterfaces  (  )  )  :  withSettings  (  )  ;  return  mockSettings  [BUGGY]  .  defaultAnswer  (  returnsDeepStubsAnswerUsing  (  returnTypeGenericMetadata  )  )  ;  }  	Mockito_23_ReturnsDeepStubs_6_4	100	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1932	container.addAnswer(new  SerializableAnswer()  {  	[BUGGY]  container  .  addAnswer  (  new  Answer<Object>  (  )  {  [FE]  NotSerializableException:  orgmockitointernalstubbingdefaultanswersReturnsDeepStubs$2  assertThat  (  deserializedSample  .  getSample  (  )  .  getNumber  (  )  )  .  isEqualTo  (  STUBBED_INTEGER_VALUE  )  ;  [METHOD]  recordDeepStubMock  [TYPE]  Object  [PARAMETER]  Object  mock  InvocationContainerImpl  container  [CLASS]  ReturnsDeepStubs  [TYPE]  boolean  false  true  [TYPE]  InvocationContainerImpl  container  [TYPE]  InvocationOnMock  invocation  [TYPE]  ReturnsEmptyValues  delegate  [TYPE]  MockitoCore  mockitoCore  [TYPE]  Object  mock  [TYPE]  long  serialVersionUID  [CONTEXT]  private  Object  recordDeepStubMock  (  final  Object  mock  ,  InvocationContainerImpl  container  )  throws  Throwable  {  [BUGGY]  container  .  addAnswer  (  new  Answer<Object>  (  )  {  public  Object  answer  (  InvocationOnMock  invocation  )  throws  Throwable  {  return  mock  ;  }  }  ,  false  )  ;  return  mock  ;  }  	Mockito_23_ReturnsDeepStubs_6_5	114	1	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1933	\tabstract  class  SerializableAnswer  implements  Answer<Object>,  Serializable  {  \t}  	[BUGGY]  [FE]  NotSerializableException:  orgmockitointernalstubbingdefaultanswersReturnsDeepStubs$2  assertThat  (  deserializedSample  .  getSample  (  )  .  getNumber  (  )  )  .  isEqualTo  (  STUBBED_INTEGER_VALUE  )  ;  [CLASS]  [CONTEXT]  	Mockito_23_ReturnsDeepStubs_6_6	123	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1934	return  invocation.getMock()  ==  invocation.getArguments()[0]  ?  0  :  1;  	[BUGGY]  return  1  ;  [FE]  AssertionFailedError:  expected:<0>  but  was:<1>  assertEquals  (  0  ,  result  )  ;  [METHOD]  answer  [TYPE]  Object  [PARAMETER]  InvocationOnMock  invocation  [CLASS]  ReturnsEmptyValues  [TYPE]  ObjectMethodsGuru  methodsGuru  [TYPE]  MockName  name  [TYPE]  boolean  false  true  [TYPE]  MockUtil  mockUtil  [TYPE]  InvocationOnMock  invocation  [TYPE]  Object  mock  [TYPE]  Class  returnType  [TYPE]  long  serialVersionUID  [CONTEXT]  public  Object  answer  (  InvocationOnMock  invocation  )  {  if  (  methodsGuru  .  isToString  (  invocation  .  getMethod  (  )  )  )  {  Object  mock  =  invocation  .  getMock  (  )  ;  MockName  name  =  mockUtil  .  getMockName  (  mock  )  ;  if  (  name  .  isDefault  (  )  )  {  return   "Mock  for   "  +  mockUtil  .  getMockSettings  (  mock  )  .  getTypeToMock  (  )  .  getSimpleName  (  )  +   "  ,  hashCode:   "  +  mock  .  hashCode  (  )  ;  }  else  {  return  name  .  toString  (  )  ;  }  }  else  if  (  methodsGuru  .  isCompareToMethod  (  invocation  .  getMethod  (  )  )  )  {    [BUGGY]  return  1  ;  }  Class<?>  returnType  =  invocation  .  getMethod  (  )  .  getReturnType  (  )  ;  return  returnValueFor  (  returnType  )  ;  }  	Mockito_24_ReturnsEmptyValues_1_1	76	1	src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java
1935		[BUGGY]  [FE]  ClassCastException:  orgmockitointernalcreationjmockClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$2f702d3d  cannot  be  cast  to  javalangString  assertThat  (  listOfInteger  .  get  (  25  )  )  .  isEqualTo  (  0  )  ;  [CLASS]  [CONTEXT]  	Mockito_25_ReturnsDeepStubs_5_1	7	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1936		[BUGGY]  [FE]  ClassCastException:  orgmockitointernalcreationjmockClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$2f702d3d  cannot  be  cast  to  javalangString  assertThat  (  listOfInteger  .  get  (  25  )  )  .  isEqualTo  (  0  )  ;  [CLASS]  [CONTEXT]  	Mockito_25_ReturnsDeepStubs_5_2	19	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1937	return  getMock(invocation,  returnTypeGenericMetadata);  private  Object  getMock(InvocationOnMock  invocation,  GenericMetadataSupport  returnTypeGenericMetadata)  throws  Throwable  {  	[BUGGY]  return  getMock  (  invocation  )  ;  private  Object  getMock  (  InvocationOnMock  invocation  )  throws  Throwable  {  [FE]  ClassCastException:  orgmockitointernalcreationjmockClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$2f702d3d  cannot  be  cast  to  javalangString  assertThat  (  listOfInteger  .  get  (  25  )  )  .  isEqualTo  (  0  )  ;  [METHOD]  answer  [TYPE]  Object  [PARAMETER]  InvocationOnMock  invocation  [CLASS]  ReturnsDeepStubs  [TYPE]  Class  rawType  [TYPE]  boolean  false  true  [TYPE]  GenericMetadataSupport  returnTypeGenericMetadata  [TYPE]  long  serialVersionUID  [TYPE]  InvocationOnMock  invocation  [TYPE]  ReturnsEmptyValues  delegate  [CONTEXT]  public  Object  answer  (  InvocationOnMock  invocation  )  throws  Throwable  {  GenericMetadataSupport  returnTypeGenericMetadata  =  actualParameterizedType  (  invocation  .  getMock  (  )  )  .  resolveGenericReturnType  (  invocation  .  getMethod  (  )  )  ;  Class<?>  rawType  =  returnTypeGenericMetadata  .  rawType  (  )  ;  if  (  !new  MockCreationValidator  (  )  .  isTypeMockable  (  rawType  )  )  {  return  delegate  .  returnValueFor  (  rawType  )  ;  }  [BUGGY]  return  getMock  (  invocation  )  ;  }  	Mockito_25_ReturnsDeepStubs_5_3	53	2	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1938	return  recordDeepStubMock(createNewDeepStubMock(returnTypeGenericMetadata),  container);  	[BUGGY]  return  recordDeepStubMock  (  invocation  ,  container  )  ;  [FE]  ClassCastException:  orgmockitointernalcreationjmockClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$2f702d3d  cannot  be  cast  to  javalangString  assertThat  (  listOfInteger  .  get  (  25  )  )  .  isEqualTo  (  0  )  ;  [METHOD]  getMock  [TYPE]  Object  [PARAMETER]  InvocationOnMock  invocation  [CLASS]  ReturnsDeepStubs  [TYPE]  boolean  false  true  [TYPE]  InvocationContainerImpl  container  [TYPE]  StubbedInvocationMatcher  stubbedInvocationMatcher  [TYPE]  InvocationOnMock  invocation  [TYPE]  ReturnsEmptyValues  delegate  [TYPE]  long  serialVersionUID  [TYPE]  InternalMockHandler  handler  [CONTEXT]  private  Object  getMock  (  InvocationOnMock  invocation  )  throws  Throwable  {  InternalMockHandler<Object>  handler  =  new  MockUtil  (  )  .  getMockHandler  (  invocation  .  getMock  (  )  )  ;  InvocationContainerImpl  container  =  (  InvocationContainerImpl  )  handler  .  getInvocationContainer  (  )  ;    for  (  StubbedInvocationMatcher  stubbedInvocationMatcher  :  container  .  getStubbedInvocations  (  )  )  {  if  (  container  .  getInvocationForStubbing  (  )  .  matches  (  stubbedInvocationMatcher  .  getInvocation  (  )  )  )  {  return  stubbedInvocationMatcher  .  answer  (  invocation  )  ;  }  }  [BUGGY]  return  recordDeepStubMock  (  invocation  ,  container  )  ;  }  	Mockito_25_ReturnsDeepStubs_5_4	68	1	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1939	private  Object  createNewDeepStubMock(GenericMetadataSupport  returnTypeGenericMetadata)  {  return  mock(  returnTypeGenericMetadata.rawType(),  withSettingsUsing(returnTypeGenericMetadata)  );  }  private  MockSettings  withSettingsUsing(GenericMetadataSupport  returnTypeGenericMetadata)  {  MockSettings  mockSettings  =  returnTypeGenericMetadata.rawExtraInterfaces().length  >  0  ?  withSettings().extraInterfaces(returnTypeGenericMetadata.rawExtraInterfaces())  :  withSettings();  return  mockSettings  .defaultAnswer(returnsDeepStubsAnswerUsing(returnTypeGenericMetadata));  }  private  ReturnsDeepStubs  returnsDeepStubsAnswerUsing(final  GenericMetadataSupport  returnTypeGenericMetadata)  {  return  new  ReturnsDeepStubs()  {  @Override  protected  GenericMetadataSupport  actualParameterizedType(Object  mock)  {  return  returnTypeGenericMetadata;  }  };  }  private  Object  recordDeepStubMock(final  Object  mock,  InvocationContainerImpl  container)  throws  Throwable  {  	[BUGGY]  private  Object  recordDeepStubMock  (  InvocationOnMock  invocation  ,  InvocationContainerImpl  container  )  {  Class<?>  clz  =  invocation  .  getMethod  (  )  .  getReturnType  (  )  ;  final  Object  mock  =  org  .  mockito  .  Mockito  .  mock  (  clz  ,  this  )  ;  [FE]  ClassCastException:  orgmockitointernalcreationjmockClassImposterizer$ClassWithSuperclassToWorkAroundCglibBug$$EnhancerByMockitoWithCGLIB$$2f702d3d  cannot  be  cast  to  javalangString  assertThat  (  listOfInteger  .  get  (  25  )  )  .  isEqualTo  (  0  )  ;  [CLASS]  [CONTEXT]  	Mockito_25_ReturnsDeepStubs_5_5	77	3	src/org/mockito/internal/stubbing/defaultanswers/ReturnsDeepStubs.java
1940	primitiveValues.put(double.class,  0D);  	[BUGGY]  primitiveValues  .  put  (  double  .  class  ,  0  )  ;  [FE]  ClassCastException:  javalangInteger  cannot  be  cast  to  javalangDouble  assertThat  (  h  .  returnFor  (  double  .  class  )  )  .  isEqualTo  (  0  .  0D  )  ;  [CLASS]  [CONTEXT]  	Mockito_26_Primitives_1_1	66	1	src/org/mockito/internal/util/Primitives.java
1941	MethodInterceptorFilter  newFilter  =  newMethodInterceptorFilter(oldMockHandler.getMockSettings());  	[BUGGY]  MockHandler<T>  newMockHandler  =  new  MockHandler<T>  (  oldMockHandler  )  ;  MethodInterceptorFilter  newFilter  =  new  MethodInterceptorFilter  (  newMockHandler  ,  (  MockSettingsImpl  )  org  .  mockito  .  Mockito  .  withSettings  (  )  .  defaultAnswer  (  org  .  mockito  .  Mockito  .  RETURNS_DEFAULTS  )  )  ;  [FE]  AssertionFailedError:  [METHOD]  resetMock  [TYPE]  <T>  [PARAMETER]  T  mock  [CLASS]  MockUtil  [TYPE]  MockHandler  newMockHandler  [TYPE]  boolean  false  true  [TYPE]  T  mock  [TYPE]  MockHandlerInterface  oldMockHandler  [TYPE]  MockCreationValidator  creationValidator  [TYPE]  MethodInterceptorFilter  newFilter  [CONTEXT]  public  <T>  void  resetMock  (  T  mock  )  {  MockHandlerInterface<T>  oldMockHandler  =  getMockHandler  (  mock  )  ;  [BUGGY]  MockHandler<T>  newMockHandler  =  new  MockHandler<T>  (  oldMockHandler  )  ;  MethodInterceptorFilter  newFilter  =  new  MethodInterceptorFilter  (  newMockHandler  ,  (  MockSettingsImpl  )  org  .  mockito  .  Mockito  .  withSettings  (  )  .  defaultAnswer  (  org  .  mockito  .  Mockito  .  RETURNS_DEFAULTS  )  )  ;  (  (  Factory  )  mock  )  .  setCallback  (  0  ,  newFilter  )  ;  }  	Mockito_27_MockUtil_1_1	64	2	src/org/mockito/internal/util/MockUtil.java
1942	Object  injected  =  mockCandidateFilter.filterCandidate(mocks,  field,  fieldInstance).thenInject();  mocks.remove(injected);  	[BUGGY]  mockCandidateFilter  .  filterCandidate  (  mocks  ,  field  ,  fieldInstance  )  .  thenInject  (  )  ;  [FE]  AssertionFailedError:  expected  same:<javalangObject@1a6aecec>  was  not:<mockedBean>  assertSame  (  mockedBean  ,  illegalInjectionExample  .  mockShouldGoInHere  )  ;  [METHOD]  injectMockCandidate  [TYPE]  void  [PARAMETER]  Class<?>  awaitingInjectionClazz  Object>  mocks  Object  fieldInstance  [CLASS]  DefaultInjectionEngine  [TYPE]  Field  field  [TYPE]  Set  mocks  [TYPE]  boolean  false  true  [TYPE]  MockCandidateFilter  mockCandidateFilter  [TYPE]  Class  awaitingInjectionClazz  [TYPE]  Object  fieldInstance  [TYPE]  Comparator  supertypesLast  [CONTEXT]  private  void  injectMockCandidate  (  Class<?>  awaitingInjectionClazz  ,  Set<Object>  mocks  ,  Object  fieldInstance  )  {  for  (  Field  field  :  orderedInstanceFieldsFrom  (  awaitingInjectionClazz  )  )  {  [BUGGY]  mockCandidateFilter  .  filterCandidate  (  mocks  ,  field  ,  fieldInstance  )  .  thenInject  (  )  ;  }  }  	Mockito_28_DefaultInjectionEngine_1_1	93	1	src/org/mockito/internal/configuration/DefaultInjectionEngine.java
1943	description.appendText(wanted  ==  null  ?   "null "  :  wanted.toString());  	[BUGGY]  description  .  appendText  (  wanted  .  toString  (  )  )  ;  [FE]  Exception:  Unexpected  exception  ,  expected AssertionError  but  was NullPointerException  [METHOD]  describeTo  [TYPE]  void  [PARAMETER]  Description  description  [CLASS]  Same  [TYPE]  Object  wanted  [TYPE]  Description  description  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [CONTEXT]  public  void  describeTo  (  Description  description  )  {  description  .  appendText  (   "same  (   "  )  ;  appendQuoting  (  description  )  ;  [BUGGY]  description  .  appendText  (  wanted  .  toString  (  )  )  ;  appendQuoting  (  description  )  ;  description  .  appendText  (   "  )   "  )  ;  }  	Mockito_29_Same_1_1	29	1	src/org/mockito/internal/matchers/Same.java
1944	public  void  smartNullPointerException(Object  obj,  Location  location)  {  	[BUGGY]  public  void  smartNullPointerException  (  Location  location  )  {  [FE]  AssertionFailedError:  Exception  message  should  include  oompa  and  lumpa  ,  but  was:  assertTrue  (   "Exception  message  should  include  oompa  and  lumpa  ,  but  was:   "  +  message  ,  [CLASS]  [CONTEXT]  	Mockito_30_Reporter_2_1	438	1	src/org/mockito/exceptions/Reporter.java
1945	obj,  	[BUGGY]  [FE]  AssertionFailedError:  Exception  message  should  include  oompa  and  lumpa  ,  but  was:  assertTrue  (   "Exception  message  should  include  oompa  and  lumpa  ,  but  was:   "  +  message  ,  [METHOD]  smartNullPointerException  [TYPE]  void  [PARAMETER]  Location  location  [CLASS]  Reporter  [TYPE]  boolean  false  true  [TYPE]  Location  location  [CONTEXT]  public  void  smartNullPointerException  (  Location  location  )  {  throw  new  SmartNullPointerException  (  join  (   "You  have  a  NullPointerException  here: "  ,  new  Location  (  )  ,  [BUGGY]   "Because  this  method  was  *not*  stubbed  correctly: "  ,  location  ,   " "  )  )  ;  }  	Mockito_30_Reporter_2_2	442	0	src/org/mockito/exceptions/Reporter.java
1946	new  Reporter().smartNullPointerException(obj,  location);  	[BUGGY]  new  Reporter  (  )  .  smartNullPointerException  (  location  )  ;  [FE]  AssertionFailedError:  Exception  message  should  include  oompa  and  lumpa  ,  but  was:  assertTrue  (   "Exception  message  should  include  oompa  and  lumpa  ,  but  was:   "  +  message  ,  [METHOD]  intercept  [TYPE]  Object  [PARAMETER]  Object  obj  Method  method  Object[]  args  MethodProxy  proxy  [CLASS]  ThrowingInterceptor  [TYPE]  boolean  false  true  [TYPE]  InvocationOnMock  invocation  [TYPE]  MethodProxy  proxy  [TYPE]  Object  obj  [TYPE]  Method  method  [TYPE]  Object[]  args  [TYPE]  Location  location  [CONTEXT]  public  Object  intercept  (  Object  obj  ,  Method  method  ,  Object[]  args  ,  MethodProxy  proxy  )  throws  Throwable  {  if  (  new  ObjectMethodsGuru  (  )  .  isToString  (  method  )  )  {  return   "SmartNull  returned  by  unstubbed   "  +  formatMethodCall  (  )  +   "  method  on  mock "  ;  }  [BUGGY]  new  Reporter  (  )  .  smartNullPointerException  (  location  )  ;  return  null  ;  }  	Mockito_30_ReturnsSmartNulls_1_1	56	1	src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
1947		[BUGGY]  [FE]  ComparisonFailure:  expected:<  unstubbed  withArgs  (  [oompa  ,  lumpa]  )  method  on  mock>  but  was:<  unstubbed  withArgs  (  []  )  method  on  mock>  assertEquals  (   "SmartNull  returned  by  unstubbed  withArgs  (  oompa  ,  lumpa  )  method  on  mock "  ,  smartNull  +   " "  )  ;  [CLASS]  [CONTEXT]  	Mockito_31_ReturnsSmartNulls_2_1	9	0	src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
1948	\t\t\tString  args  =  Arrays.toString(invocation.getArguments());  \t\t\treturn  invocation.getMethod().getName()  +   "( "  +  args.substring(1,  args.length()  -  1)  +\t ") ";  	[BUGGY]  \t\t\treturn  invocation  .  getMethod  (  )  .  getName  (  )  +   "  (  )   "  ;  [FE]  ComparisonFailure:  expected:<  unstubbed  withArgs  (  [oompa  ,  lumpa]  )  method  on  mock>  but  was:<  unstubbed  withArgs  (  []  )  method  on  mock>  assertEquals  (   "SmartNull  returned  by  unstubbed  withArgs  (  oompa  ,  lumpa  )  method  on  mock "  ,  smartNull  +   " "  )  ;  [METHOD]  formatMethodCall  [TYPE]  String  [PARAMETER]  [CLASS]  ThrowingInterceptor  [TYPE]  InvocationOnMock  invocation  [TYPE]  Location  location  [TYPE]  boolean  false  true  [CONTEXT]  private  String  formatMethodCall  (  )  {  [BUGGY]  return  invocation  .  getMethod  (  )  .  getName  (  )  +   "  (  )   "  ;  }  	Mockito_31_ReturnsSmartNulls_2_2	60	1	src/org/mockito/internal/stubbing/defaultanswers/ReturnsSmartNulls.java
1949		[BUGGY]  [FE]  AssertionFailedError:  <'  Assertions  .  assertThat  (  e  .  getMessage  (  )  )  .  contains  (   "veryCoolSpy "  )  ;  [CLASS]  [CONTEXT]  	Mockito_32_SpyAnnotationEngine_2_1	19	0	src/org/mockito/internal/configuration/SpyAnnotationEngine.java
1950	field.set(testClass,  Mockito.mock(instance.getClass(),  withSettings()  .spiedInstance(instance)  .defaultAnswer(Mockito.CALLS_REAL_METHODS)  .name(field.getName())));  	[BUGGY]  field  .  set  (  testClass  ,  Mockito  .  spy  (  instance  )  )  ;  [FE]  AssertionFailedError:  <'  Assertions  .  assertThat  (  e  .  getMessage  (  )  )  .  contains  (   "veryCoolSpy "  )  ;  [METHOD]  process  [TYPE]  void  [PARAMETER]  Class<?>  context  Object  testClass  [CLASS]  SpyAnnotationEngine  [TYPE]  Field  field  [TYPE]  boolean  false  true  wasAccessible  [TYPE]  Class  context  [TYPE]  Object  instance  testClass  [TYPE]  Field[]  fields  [TYPE]  IllegalAccessException  e  [CONTEXT]  public  void  process  (  Class<?>  context  ,  Object  testClass  )  {  Field[]  fields  =  context  .  getDeclaredFields  (  )  ;  for  (  Field  field  :  fields  )  {  if  (  field  .  isAnnotationPresent  (  Spy  .  class  )  )  {  assertNoAnnotations  (  Spy  .  class  ,  field  ,  Mock  .  class  ,  org  .  mockito  .  MockitoAnnotations  .  Mock  .  class  ,  Captor  .  class  )  ;  boolean  wasAccessible  =  field  .  isAccessible  (  )  ;  field  .  setAccessible  (  true  )  ;  try  {  Object  instance  =  field  .  get  (  testClass  )  ;  if  (  instance  =  =  null  )  {  throw  new  MockitoException  (   "Cannot  create  a  @Spy  for  ' "  +  field  .  getName  (  )  +   "'  field  because  the  *instance*  is  missing\n "  +   "The  instance  must  be  created  *before*  initMocks  (  )  ;  \n "  +   "Example  of  correct  usage  of  @Spy:\n "  +   "  @Spy  List  mock  =  new  LinkedList  (  )  ;  \n "  +   "  //also  ,  don't  forget  about  MockitoAnnotations  .  initMocks  (  )  ;   "  )  ;  }  if  (  new  MockUtil  (  )  .  isMock  (  instance  )  )  {  Mockito  .  reset  (  instance  )  ;  }  else  {  [BUGGY]  field  .  set  (  testClass  ,  Mockito  .  spy  (  instance  )  )  ;  }  }  catch  (  IllegalAccessException  e  )  {  throw  new  MockitoException  (   "Problems  initiating  spied  field   "  +  field  .  getName  (  )  ,  e  )  ;  }  finally  {  field  .  setAccessible  (  wasAccessible  )  ;  	Mockito_32_SpyAnnotationEngine_2_2	49	1	src/org/mockito/internal/configuration/SpyAnnotationEngine.java
1951	if  (m1.getName()  !=  null  &&  m1.getName().equals(m2.getName()))  {  \tClass[]  params1  =  m1.getParameterTypes();  \tClass[]  params2  =  m2.getParameterTypes();  \tif  (params1.length  ==  params2.length)  {  \t        for  (int  i  =  0;  i  <  params1.length;  i++)  {  \t\tif  (params1[i]  !=  params2[i])  \t\t        return  false;  \t        }  \t        return  true;  \t}  }  return  false;  	[BUGGY]  return  m1  .  equals  (  m2  )  ;  [FE]  AssertionFailedError  Assert  .  assertNotNull  (  iterable  .  iterator  (  )  )  ;  [METHOD]  hasSameMethod  [TYPE]  boolean  [PARAMETER]  Invocation  candidate  [CLASS]  InvocationMatcher  [TYPE]  List  matchers  [TYPE]  Method  m1  m2  [TYPE]  boolean  false  true  [TYPE]  Invocation  candidate  invocation  [TYPE]  long  serialVersionUID  [CONTEXT]  public  boolean  hasSameMethod  (  Invocation  candidate  )  {    Method  m1  =  invocation  .  getMethod  (  )  ;  Method  m2  =  candidate  .  getMethod  (  )  ;  [BUGGY]  return  m1  .  equals  (  m2  )  ;  }  	Mockito_33_InvocationMatcher_1_1	98	1	src/org/mockito/internal/invocation/InvocationMatcher.java
1952	if  (m  instanceof  CapturesArguments  &&  i.getArguments().length  >  k)  {  	[BUGGY]  if  (  m  instanceof  CapturesArguments  )  {  [FE]  ArrayIndexOutOfBoundsException:  0  [METHOD]  captureArgumentsFrom  [TYPE]  void  [PARAMETER]  Invocation  i  [CLASS]  InvocationMatcher  [TYPE]  List  matchers  [TYPE]  boolean  false  true  [TYPE]  Invocation  i  invocation  [TYPE]  Matcher  m  [TYPE]  long  serialVersionUID  [TYPE]  int  k  [CONTEXT]  public  void  captureArgumentsFrom  (  Invocation  i  )  {  int  k  =  0  ;  for  (  Matcher  m  :  matchers  )  {  [BUGGY]  if  (  m  instanceof  CapturesArguments  )  {  (  (  CapturesArguments  )  m  )  .  captureFrom  (  i  .  getArguments  (  )  [k]  )  ;  }  k++  ;  }  }  	Mockito_34_InvocationMatcher_1_1	106	1	src/org/mockito/internal/invocation/InvocationMatcher.java
1953	return  reportMatcher(new  InstanceOf(clazz)).<T>returnFor(clazz);  	[BUGGY]  return  reportMatcher  (  new  InstanceOf  (  clazz  )  )  .  <T>returnNull  (  )  ;  [FE]  NullPointerException  [METHOD]  isA  [TYPE]  <T>  [PARAMETER]  Class<T>  clazz  [CLASS]  Matchers  [TYPE]  MockingProgress  mockingProgress  [TYPE]  Class  clazz  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  T  isA  (  Class<T>  clazz  )  {  [BUGGY]  return  reportMatcher  (  new  InstanceOf  (  clazz  )  )  .  <T>returnNull  (  )  ;  }  	Mockito_35_Matchers_3_1	362	1	src/org/mockito/Matchers.java
1954	return  (T)  reportMatcher(new  Equals(value)).<T>returnFor((Class)  value.getClass());  	[BUGGY]  return  reportMatcher  (  new  Equals  (  value  )  )  .  <T>returnNull  (  )  ;  [FE]  NullPointerException  [METHOD]  eq  [TYPE]  <T>  [PARAMETER]  T  value  [CLASS]  Matchers  [TYPE]  T  value  [TYPE]  MockingProgress  mockingProgress  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  T  eq  (  T  value  )  {  [BUGGY]  return  reportMatcher  (  new  Equals  (  value  )  )  .  <T>returnNull  (  )  ;  }  	Mockito_35_Matchers_3_2	479	1	src/org/mockito/Matchers.java
1955	return  (T)  reportMatcher(new  Same(value)).<T>returnFor((Class)  value.getClass());  	[BUGGY]  return  reportMatcher  (  new  Same  (  value  )  )  .  <T>returnNull  (  )  ;  [FE]  NullPointerException  [METHOD]  same  [TYPE]  <T>  [PARAMETER]  T  value  [CLASS]  Matchers  [TYPE]  T  value  [TYPE]  MockingProgress  mockingProgress  [TYPE]  boolean  false  true  [CONTEXT]  public  static  <T>  T  same  (  T  value  )  {  [BUGGY]  return  reportMatcher  (  new  Same  (  value  )  )  .  <T>returnNull  (  )  ;  }  	Mockito_35_Matchers_3_3	516	1	src/org/mockito/Matchers.java
1956		[BUGGY]  [FE]  NullPointerException  [CLASS]  [CONTEXT]  	Mockito_36_Invocation_2_1	11	0	src/org/mockito/internal/invocation/Invocation.java
1957	if  (this.getMethod().getDeclaringClass().isInterface())  {  new  Reporter().cannotCallRealMethodOnInterface();  }  	[BUGGY]  [FE]  NullPointerException  [METHOD]  callRealMethod  [TYPE]  Object  [PARAMETER]  [CLASS]  Invocation  [TYPE]  MockitoMethod  method  [TYPE]  boolean  false  true  verified  verifiedInOrder  [TYPE]  Object  mock  [TYPE]  RealMethod  realMethod  [TYPE]  long  serialVersionUID  [TYPE]  int  MAX_LINE_LENGTH  sequenceNumber  [TYPE]  Object[]  arguments  rawArguments  [TYPE]  Location  location  [CONTEXT]  public  Object  callRealMethod  (  )  throws  Throwable  {  [BUGGY]  return  realMethod  .  invoke  (  mock  ,  rawArguments  )  ;  }  	Mockito_36_Invocation_2_2	202	0	src/org/mockito/internal/invocation/Invocation.java
1958	if  (answer  instanceof  CallsRealMethods)  {  validateMockingConcreteClass((CallsRealMethods)  answer,  invocation);  }  private  void  validateMockingConcreteClass(CallsRealMethods  answer,  Invocation  invocation)  {  if  (invocation.getMethod().getDeclaringClass().isInterface())  {  reporter.cannotCallRealMethodOnInterface();  }  }  	[BUGGY]  [FE]  AssertionFailedError  [CLASS]  [CONTEXT]  	Mockito_37_AnswersValidator_1_1	28	0	src/org/mockito/internal/stubbing/answers/AnswersValidator.java
1959		[BUGGY]  if  (  durationField  .  isSupported  (  )  )  {  return  1  ;  }  [FE]  AssertionFailedError  assertMessageContains  (  ex  ,   "must  be  in  order "  ,   "largest-smallest "  )  ;  [METHOD]  compareTo  [TYPE]  int  [PARAMETER]  DurationField  durationField  [CLASS]  UnsupportedDurationField  [TYPE]  boolean  false  true  [TYPE]  HashMap  cCache  [TYPE]  DurationField  durationField  [TYPE]  long  serialVersionUID  [TYPE]  DurationFieldType  iType  [CONTEXT]  public  int  compareTo  (  DurationField  durationField  )  {  [BUGGY]  if  (  durationField  .  isSupported  (  )  )  {  return  1  ;  }  return  0  ;  }  	Time_1_UnsupportedDurationField_1_1	227	3	src/main/java/org/joda/time/field/UnsupportedDurationField.java
1960	if  (loopUnitField.isSupported()  ==  false)  {  if  (lastUnitField.isSupported())  {  throw  new  IllegalArgumentException( "Types  array  must  be  in  order  largest-smallest:   "  +  types[i  -  1].getName()  +   "  <   "  +  loopType.getName());  }  else  {  throw  new  IllegalArgumentException( "Types  array  must  not  contain  duplicate  unsupported:   "  +  types[i  -  1].getName()  +   "  and   "  +  loopType.getName());  }  }  	[BUGGY]  [FE]  AssertionFailedError  assertMessageContains  (  ex  ,   "must  be  in  order "  ,   "largest-smallest "  )  ;  [CLASS]  [CONTEXT]  	Time_1_Partial_2_1	217	0	src/main/java/org/joda/time/Partial.java
1961	}  else  if  (compare  ==  0  &&  lastUnitField.equals(loopUnitField))  {  	[BUGGY]  }  else  if  (  compare  =  =  0  )  {  [FE]  AssertionFailedError  assertMessageContains  (  ex  ,   "must  be  in  order "  ,   "largest-smallest "  )  ;  [CLASS]  [CONTEXT]  	Time_1_Partial_2_2	221	1	src/main/java/org/joda/time/Partial.java
1962	if  (durationField.isSupported())  {  return  1;  }  	[BUGGY]  [FE]  IllegalArgumentException:  Types  array  must  not  contain  duplicate:  era  and  year  assertEquals  (  1  ,  result  .  indexOf  (  DateTimeFieldType  .  year  (  )  )  )  ;  [METHOD]  compareTo  [TYPE]  int  [PARAMETER]  DurationField  durationField  [CLASS]  UnsupportedDurationField  [TYPE]  boolean  false  true  [TYPE]  HashMap  cCache  [TYPE]  DurationField  durationField  [TYPE]  long  serialVersionUID  [TYPE]  DurationFieldType  iType  [CONTEXT]  public  int  compareTo  (  DurationField  durationField  )  {  [BUGGY]  return  0  ;  }  	Time_2_UnsupportedDurationField_1_1	227	0	src/main/java/org/joda/time/field/UnsupportedDurationField.java
1963	if  (compare  <  0)  {  	[BUGGY]  if  (  compare  <  0  ||  (  compare  !  =  0  &&  loopUnitField  .  isSupported  (  )  =  =  false  )  )  {  [FE]  IllegalArgumentException:  Types  array  must  not  contain  duplicate:  era  and  year  assertEquals  (  1  ,  result  .  indexOf  (  DateTimeFieldType  .  year  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Time_2_Partial_2_1	218	1	src/main/java/org/joda/time/Partial.java
1964	if  (fieldType.getRangeDurationType()  ==  null)  {  break;  }  	[BUGGY]  [FE]  IllegalArgumentException:  Types  array  must  not  contain  duplicate:  era  and  year  assertEquals  (  1  ,  result  .  indexOf  (  DateTimeFieldType  .  year  (  )  )  )  ;  [METHOD]  with  [TYPE]  Partial  [PARAMETER]  DateTimeFieldType  fieldType  int  value  [CLASS]  Partial  [TYPE]  boolean  false  true  [TYPE]  DateTimeFieldType[]  iTypes  newTypes  [TYPE]  Partial  iPartial  newPartial  [TYPE]  DateTimeFieldType  fieldType  loopType  [TYPE]  int[]  iValues  newValues  [TYPE]  Chronology  iChronology  [TYPE]  DurationField  loopRangeField  loopUnitField  rangeField  unitField  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeFormatter[]  iFormatter  [TYPE]  int  compare  i  iFieldIndex  index  value  [CONTEXT]  public  Partial  with  (  DateTimeFieldType  fieldType  ,  int  value  )  {  if  (  fieldType  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  field  type  must  not  be  null "  )  ;  }  int  index  =  indexOf  (  fieldType  )  ;  if  (  index  =  =  -1  )  {  DateTimeFieldType[]  newTypes  =  new  DateTimeFieldType[iTypes  .  length  +  1]  ;  int[]  newValues  =  new  int[newTypes  .  length]  ;    int  i  =  0  ;  DurationField  unitField  =  fieldType  .  getDurationType  (  )  .  getField  (  iChronology  )  ;  if  (  unitField  .  isSupported  (  )  )  {  for  (  ;  i  <  iTypes  .  length  ;  i++  )  {  DateTimeFieldType  loopType  =  iTypes[i]  ;  DurationField  loopUnitField  =  loopType  .  getDurationType  (  )  .  getField  (  iChronology  )  ;  if  (  loopUnitField  .  isSupported  (  )  )  {  int  compare  =  unitField  .  compareTo  (  loopUnitField  )  ;  if  (  compare  >  0  )  {  break  ;  }  else  if  (  compare  =  =  0  )  {  [BUGGY]  DurationField  rangeField  =  fieldType  .  getRangeDurationType  (  )  .  getField  (  iChronology  )  ;  DurationField  loopRangeField  =  loopType  .  getRangeDurationType  (  )  .  getField  (  iChronology  )  ;  if  (  rangeField  .  compareTo  (  loopRangeField  )  >  0  )  {  break  ;  }  }  	Time_2_Partial_2_2	449	0	src/main/java/org/joda/time/Partial.java
1965	if  (amount  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  add  [TYPE]  void  [PARAMETER]  DurationFieldType  type  int  amount  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  amount  iRoundingMode  [TYPE]  DurationFieldType  type  [CONTEXT]  public  void  add  (  DurationFieldType  type  ,  int  amount  )  {  if  (  type  =  =  null  )  {  throw  new  IllegalArgumentException  (   "Field  must  not  be  null "  )  ;  }  [BUGGY]  setMillis  (  type  .  getField  (  getChronology  (  )  )  .  add  (  getMillis  (  )  ,  amount  )  )  ;  }  	Time_3_MutableDateTime_10_1	639	0	src/main/java/org/joda/time/MutableDateTime.java
1966	if  (years  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addYears  [TYPE]  void  [PARAMETER]  final  int  years  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  iRoundingMode  years  [CONTEXT]  public  void  addYears  (  final  int  years  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  years  (  )  .  add  (  getMillis  (  )  ,  years  )  )  ;  }  	Time_3_MutableDateTime_10_2	660	0	src/main/java/org/joda/time/MutableDateTime.java
1967	if  (weekyears  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addWeekyears  [TYPE]  void  [PARAMETER]  final  int  weekyears  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  iRoundingMode  weekyears  [CONTEXT]  public  void  addWeekyears  (  final  int  weekyears  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  weekyears  (  )  .  add  (  getMillis  (  )  ,  weekyears  )  )  ;  }  	Time_3_MutableDateTime_10_3	681	0	src/main/java/org/joda/time/MutableDateTime.java
1968	if  (months  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addMonths  [TYPE]  void  [PARAMETER]  final  int  months  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  iRoundingMode  months  [CONTEXT]  public  void  addMonths  (  final  int  months  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  months  (  )  .  add  (  getMillis  (  )  ,  months  )  )  ;  }  	Time_3_MutableDateTime_10_4	702	0	src/main/java/org/joda/time/MutableDateTime.java
1969	if  (weeks  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addWeeks  [TYPE]  void  [PARAMETER]  final  int  weeks  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  iRoundingMode  weeks  [CONTEXT]  public  void  addWeeks  (  final  int  weeks  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  weeks  (  )  .  add  (  getMillis  (  )  ,  weeks  )  )  ;  }  	Time_3_MutableDateTime_10_5	723	0	src/main/java/org/joda/time/MutableDateTime.java
1970	if  (days  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addDays  [TYPE]  void  [PARAMETER]  final  int  days  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  days  iRoundingMode  [CONTEXT]  public  void  addDays  (  final  int  days  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  days  (  )  .  add  (  getMillis  (  )  ,  days  )  )  ;  }  	Time_3_MutableDateTime_10_6	764	0	src/main/java/org/joda/time/MutableDateTime.java
1971	if  (hours  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addHours  [TYPE]  void  [PARAMETER]  final  int  hours  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  hours  iRoundingMode  [CONTEXT]  public  void  addHours  (  final  int  hours  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  hours  (  )  .  add  (  getMillis  (  )  ,  hours  )  )  ;  }  	Time_3_MutableDateTime_10_7	785	0	src/main/java/org/joda/time/MutableDateTime.java
1972	if  (minutes  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addMinutes  [TYPE]  void  [PARAMETER]  final  int  minutes  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  iRoundingMode  minutes  [CONTEXT]  public  void  addMinutes  (  final  int  minutes  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  minutes  (  )  .  add  (  getMillis  (  )  ,  minutes  )  )  ;  }  	Time_3_MutableDateTime_10_8	816	0	src/main/java/org/joda/time/MutableDateTime.java
1973	if  (seconds  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addSeconds  [TYPE]  void  [PARAMETER]  final  int  seconds  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  iRoundingMode  seconds  [CONTEXT]  public  void  addSeconds  (  final  int  seconds  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  seconds  (  )  .  add  (  getMillis  (  )  ,  seconds  )  )  ;  }  	Time_3_MutableDateTime_10_9	847	0	src/main/java/org/joda/time/MutableDateTime.java
1974	if  (millis  !=  0)  {  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-30T02:30:00000+0[1]:00>  but  was:<10-30T02:30:00000+0[2]:00>  assertEquals  (   "2011-10-30T02:30:00  .  000+01:00 "  ,  test  .  toString  (  )  )  ;  [METHOD]  addMillis  [TYPE]  void  [PARAMETER]  final  int  millis  [CLASS]  MutableDateTime  [TYPE]  MutableDateTime  iInstant  [TYPE]  DateTimeField  iField  iRoundingField  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  ROUND_CEILING  ROUND_FLOOR  ROUND_HALF_CEILING  ROUND_HALF_EVEN  ROUND_HALF_FLOOR  ROUND_NONE  iRoundingMode  millis  [CONTEXT]  public  void  addMillis  (  final  int  millis  )  {  [BUGGY]  setMillis  (  getChronology  (  )  .  millis  (  )  .  add  (  getMillis  (  )  ,  millis  )  )  ;  }  	Time_3_MutableDateTime_10_10	880	0	src/main/java/org/joda/time/MutableDateTime.java
1975	Partial  newPartial  =  new  Partial(newTypes,  newValues,  iChronology);  	[BUGGY] Partial newPartial = new Partial(iChronology, newTypes, newValues); [FE]  AssertionFailedError  assertEquals  (  1  ,  result  .  indexOf  (  DateTimeFieldType  .  halfdayOfDay  (  )  )  )  ;  [METHOD]  with  [TYPE]  Partial  [PARAMETER]  DateTimeFieldType  fieldType  int  value  [CLASS]  Partial  [TYPE]  boolean  false  true  [TYPE]  DateTimeFieldType[]  iTypes  newTypes  [TYPE]  Partial  iPartial  newPartial  [TYPE]  DateTimeFieldType  fieldType  loopType  [TYPE]  int[]  iValues  newValues  [TYPE]  Chronology  iChronology  [TYPE]  DurationField  loopRangeField  loopUnitField  rangeField  unitField  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeFormatter[]  iFormatter  [TYPE]  int  compare  i  iFieldIndex  index  value  [CONTEXT]  for  (  ;  i  <  iTypes  .  length  ;  i++  )  {  DateTimeFieldType  loopType  =  iTypes[i]  ;  DurationField  loopUnitField  =  loopType  .  getDurationType  (  )  .  getField  (  iChronology  )  ;  if  (  loopUnitField  .  isSupported  (  )  )  {  int  compare  =  unitField  .  compareTo  (  loopUnitField  )  ;  if  (  compare  >  0  )  {  break  ;  }  else  if  (  compare  =  =  0  )  {  DurationField  rangeField  =  fieldType  .  getRangeDurationType  (  )  .  getField  (  iChronology  )  ;  DurationField  loopRangeField  =  loopType  .  getRangeDurationType  (  )  .  getField  (  iChronology  )  ;  if  (  rangeField  .  compareTo  (  loopRangeField  )  >  0  )  {  break  ;  }  }  }  }  }  System  .  arraycopy  (  iTypes  ,  0  ,  newTypes  ,  0  ,  i  )  ;  System  .  arraycopy  (  iValues  ,  0  ,  newValues  ,  0  ,  i  )  ;  newTypes[i]  =  fieldType  ;  newValues[i]  =  value  ;  System  .  arraycopy  (  iTypes  ,  i  ,  newTypes  ,  i  +  1  ,  newTypes  .  length  -  i  -  1  )  ;  System  .  arraycopy  (  iValues  ,  i  ,  newValues  ,  i  +  1  ,  newValues  .  length  -  i  -  1  )  ;    [BUGGY]  Partial  newPartial  =  new  Partial  (  iChronology  ,  newTypes  ,  newValues  )  ;  iChronology  .  validate  (  newPartial  ,  newValues  )  ;  return  newPartial  ;  }  if  (  value  =  =  getValue  (  index  )  )  {  return  this  ;  	Time_4_Partial_1_1	464	1	src/main/java/org/joda/time/Partial.java
1976	long  totalMonths  =  years  *  12L  +  months;  if  (type.isSupported(DurationFieldType.YEARS_TYPE))  {  int  normalizedYears  =  FieldUtils.safeToInt(totalMonths  /  12);  result  =  result.withYears(normalizedYears);  totalMonths  =  totalMonths  -  (normalizedYears  *  12);  if  (type.isSupported(DurationFieldType.MONTHS_TYPE))  {  int  normalizedMonths  =  FieldUtils.safeToInt(totalMonths);  result  =  result.withMonths(normalizedMonths);  totalMonths  =  totalMonths  -  normalizedMonths;  }  if  (totalMonths  !=  0)  {  throw  new  UnsupportedOperationException( "Unable  to  normalize  as  PeriodType  is  missing  either  years  or  months  but  period  has  a  month/year  amount:   "  +  toString());  	[BUGGY]  years  =  FieldUtils  .  safeAdd  (  years  ,  months  /  12  )  ;  months  =  months  %  12  ;  if  (  years  !  =  0  )  {  result  =  result  .  withYears  (  years  )  ;  if  (  months  !  =  0  )  {  result  =  result  .  withMonths  (  months  )  ;  [FE]  UnsupportedOperationException:  Field  is  not  supported  assertEquals  (  new  Period  (  0  ,  27  ,  0  ,  0  ,  0  ,  0  ,  0  ,  0  ,  PeriodType  .  months  (  )  )  ,  result  )  ;  [METHOD]  normalizedStandard  [TYPE]  Period  [PARAMETER]  PeriodType  type  [CLASS]  Period  [TYPE]  Period  ZERO  result  [TYPE]  PeriodType  type  [TYPE]  boolean  false  true  [TYPE]  long  millis  serialVersionUID  [TYPE]  int  months  years  [CONTEXT]  public  Period  normalizedStandard  (  PeriodType  type  )  {  type  =  DateTimeUtils  .  getPeriodType  (  type  )  ;  long  millis  =  getMillis  (  )  ;  //  no  overflow  can  happen  ,  even  with  Integer  .  MAX_VALUEs  millis  +  =  (  (  (  long  )  getSeconds  (  )  )  *  (  (  long  )  DateTimeConstants  .  MILLIS_PER_SECOND  )  )  ;  millis  +  =  (  (  (  long  )  getMinutes  (  )  )  *  (  (  long  )  DateTimeConstants  .  MILLIS_PER_MINUTE  )  )  ;  millis  +  =  (  (  (  long  )  getHours  (  )  )  *  (  (  long  )  DateTimeConstants  .  MILLIS_PER_HOUR  )  )  ;  millis  +  =  (  (  (  long  )  getDays  (  )  )  *  (  (  long  )  DateTimeConstants  .  MILLIS_PER_DAY  )  )  ;  millis  +  =  (  (  (  long  )  getWeeks  (  )  )  *  (  (  long  )  DateTimeConstants  .  MILLIS_PER_WEEK  )  )  ;  Period  result  =  new  Period  (  millis  ,  type  ,  ISOChronology  .  getInstanceUTC  (  )  )  ;  int  years  =  getYears  (  )  ;  int  months  =  getMonths  (  )  ;  if  (  years  !  =  0  ||  months  !  =  0  )  {  [BUGGY]  years  =  FieldUtils  .  safeAdd  (  years  ,  months  /  12  )  ;  months  =  months  %  12  ;  if  (  years  !  =  0  )  {  result  =  result  .  withYears  (  years  )  ;  }  if  (  months  !  =  0  )  {  result  =  result  .  withMonths  (  months  )  ;  }  }  return  result  ;  }  	Time_5_Period_1_1	1628	6	src/main/java/org/joda/time/Period.java
1977	LocalDate  cutoverDate  =  new  LocalDate(cutoverInstant.getMillis(),  GregorianChronology.getInstance(zone));  if  (cutoverDate.getYear()  <=  0)  {  throw  new  IllegalArgumentException( "Cutover  too  early.  Must  be  on  or  after  0001-01-01. ");  }  	[BUGGY]  [FE]  AssertionFailedError  [METHOD]  getInstance  [TYPE]  GJChronology  [PARAMETER]  DateTimeZone  zone  ReadableInstant  gregorianCutover  int  minDaysInFirstWeek  [CLASS]  GJChronology  [TYPE]  ReadableInstant  gregorianCutover  [TYPE]  Instant  DEFAULT_CUTOVER  cutoverInstant  iCutoverInstant  [TYPE]  ArrayList  chronos  [TYPE]  ImpreciseCutoverField  iField  [TYPE]  DateTimeField  iGregorianField  iJulianField  [TYPE]  long  iCutover  iCutoverMillis  iGapDuration  serialVersionUID  [TYPE]  DateTimeZone  zone  [TYPE]  int  i  minDaysInFirstWeek  [TYPE]  boolean  false  iConvertByWeekyear  true  [TYPE]  JulianChronology  iJulianChronology  [TYPE]  GregorianChronology  iGregorianChronology  [TYPE]  GJChronology  chrono  [TYPE]  Map  cCache  [TYPE]  DurationField  iDurationField  iRangeDurationField  [CONTEXT]  public  static  synchronized  GJChronology  getInstance  (  DateTimeZone  zone  ,  ReadableInstant  gregorianCutover  ,  int  minDaysInFirstWeek  )  {  zone  =  DateTimeUtils  .  getZone  (  zone  )  ;  Instant  cutoverInstant  ;  if  (  gregorianCutover  =  =  null  )  {  cutoverInstant  =  DEFAULT_CUTOVER  ;  }  else  {  cutoverInstant  =  gregorianCutover  .  toInstant  (  )  ;  [BUGGY]  }  GJChronology  chrono  ;  synchronized  (  cCache  )  {  ArrayList<GJChronology>  chronos  =  cCache  .  get  (  zone  )  ;  if  (  chronos  =  =  null  )  {  	Time_6_GJChronology_3_1	196	0	src/main/java/org/joda/time/chrono/GJChronology.java
1978	if  (iConvertByWeekyear)  {  int  wyear  =  iGregorianChronology.weekyear().get(instant);  if  (wyear  <=  0)  {  instant  =  iGregorianChronology.weekyear().add(instant,  -1);  }  }  else  {  int  year  =  iGregorianChronology.year().get(instant);  if  (year  <=  0)  {  instant  =  iGregorianChronology.year().add(instant,  -1);  }  }  	[BUGGY]  [FE]  AssertionFailedError  [METHOD]  add  [TYPE]  long  [PARAMETER]  long  instant  int  value  [CLASS]  ImpreciseCutoverField  [TYPE]  long  instant  serialVersionUID  [TYPE]  int  value  [TYPE]  boolean  false  true  [CONTEXT]  public  long  add  (  long  instant  ,  int  value  )  {  if  (  instant  >  =  iCutover  )  {  instant  =  iGregorianField  .  add  (  instant  ,  value  )  ;  if  (  instant  <  iCutover  )  {  if  (  instant  +  iGapDuration  <  iCutover  )  {  [BUGGY]  instant  =  gregorianToJulian  (  instant  )  ;  }  }  }  else  {  instant  =  iJulianField  .  add  (  instant  ,  value  )  ;  if  (  instant  >  =  iCutover  )  {  if  (  instant  -  iGapDuration  >  =  iCutover  )  {  instant  =  julianToGregorian  (  instant  )  ;  }  }  }  return  instant  ;  }  	Time_6_GJChronology_3_2	979	0	src/main/java/org/joda/time/chrono/GJChronology.java
1979	if  (iConvertByWeekyear)  {  int  wyear  =  iGregorianChronology.weekyear().get(instant);  if  (wyear  <=  0)  {  instant  =  iGregorianChronology.weekyear().add(instant,  -1);  }  }  else  {  int  year  =  iGregorianChronology.year().get(instant);  if  (year  <=  0)  {  instant  =  iGregorianChronology.year().add(instant,  -1);  }  }  	[BUGGY]  [FE]  AssertionFailedError  [METHOD]  add  [TYPE]  long  [PARAMETER]  long  instant  long  value  [CLASS]  ImpreciseCutoverField  [TYPE]  long  instant  serialVersionUID  value  [TYPE]  boolean  false  true  [CONTEXT]  public  long  add  (  long  instant  ,  long  value  )  {  if  (  instant  >  =  iCutover  )  {  instant  =  iGregorianField  .  add  (  instant  ,  value  )  ;  if  (  instant  <  iCutover  )  {  if  (  instant  +  iGapDuration  <  iCutover  )  {  [BUGGY]  instant  =  gregorianToJulian  (  instant  )  ;  }  }  }  else  {  instant  =  iJulianField  .  add  (  instant  ,  value  )  ;  if  (  instant  >  =  iCutover  )  {  if  (  instant  -  iGapDuration  >  =  iCutover  )  {  instant  =  julianToGregorian  (  instant  )  ;  }  }  }  return  instant  ;  }  	Time_6_GJChronology_3_3	1001	0	src/main/java/org/joda/time/chrono/GJChronology.java
1980	int  defaultYear  =  DateTimeUtils.getChronology(chrono).year().get(instantMillis);  	[BUGGY]  int  defaultYear  =  chrono  .  year  (  )  .  get  (  instantLocal  )  ;  [FE]  timeIllegalFieldValueException:  Cannot  parse   "2  29 ":  Value  29  for  dayOfMonth  must  be  in  the  range  [1  ,  28]  assertEquals  (  new  MutableDateTime  (  2004  ,  2  ,  29  ,  0  ,  0  ,  0  ,  0  ,  NEWYORK  )  ,  result  )  ;  [METHOD]  parseInto  [TYPE]  int  [PARAMETER]  ReadWritableInstant  instant  String  text  int  position  [CLASS]  DateTimeFormatter  [TYPE]  Locale  iLocale  [TYPE]  Integer  iPivotYear  [TYPE]  DateTimeParser  iParser  parser  [TYPE]  boolean  false  iOffsetParsed  true  [TYPE]  DateTimeParserBucket  bucket  [TYPE]  ReadWritableInstant  instant  [TYPE]  Chronology  chrono  iChrono  [TYPE]  String  text  [TYPE]  DateTimePrinter  iPrinter  [TYPE]  DateTimeZone  iZone  parsedZone  [TYPE]  int  defaultYear  iDefaultYear  newPos  parsedOffset  position  [TYPE]  long  instantLocal  instantMillis  [CONTEXT]  public  int  parseInto  (  ReadWritableInstant  instant  ,  String  text  ,  int  position  )  {  DateTimeParser  parser  =  requireParser  (  )  ;  if  (  instant  =  =  null  )  {  throw  new  IllegalArgumentException  (   "Instant  must  not  be  null "  )  ;  }  long  instantMillis  =  instant  .  getMillis  (  )  ;  Chronology  chrono  =  instant  .  getChronology  (  )  ;  [BUGGY]  long  instantLocal  =  instantMillis  +  chrono  .  getZone  (  )  .  getOffset  (  instantMillis  )  ;  chrono  =  selectChronology  (  chrono  )  ;  int  defaultYear  =  chrono  .  year  (  )  .  get  (  instantLocal  )  ;  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket  (  instantLocal  ,  chrono  ,  iLocale  ,  iPivotYear  ,  defaultYear  )  ;  int  newPos  =  parser  .  parseInto  (  bucket  ,  text  ,  position  )  ;  instant  .  setMillis  (  bucket  .  computeMillis  (  false  ,  text  )  )  ;  if  (  iOffsetParsed  &&  bucket  .  getOffsetInteger  (  )  !  =  null  )  {  int  parsedOffset  =  bucket  .  getOffsetInteger  (  )  ;  DateTimeZone  parsedZone  =  DateTimeZone  .  forOffsetMillis  (  parsedOffset  )  ;  chrono  =  chrono  .  withZone  (  parsedZone  )  ;  }  else  if  (  bucket  .  getZone  (  )  !  =  null  )  {  chrono  =  chrono  .  withZone  (  bucket  .  getZone  (  )  )  ;  }  instant  .  setChronology  (  chrono  )  ;  if  (  iZone  !  =  null  )  {  instant  .  setZone  (  iZone  )  ;  }  return  newPos  ;  }  	Time_7_DateTimeFormatter_1_1	708	1	src/main/java/org/joda/time/format/DateTimeFormatter.java
1981	if  (minutesOffset  <  -59  ||  minutesOffset  >  59)  {  if  (hoursOffset  >  0  &&  minutesOffset  <  0)  {  throw  new  IllegalArgumentException( "Positive  hours  must  not  have  negative  minutes:   "  +  minutesOffset);  }  	[BUGGY]  if  (  minutesOffset  <  0  ||  minutesOffset  >  59  )  {  [FE]  IllegalArgumentException:  Minutes  out  of  range:  -15  assertEquals  (  DateTimeZone  .  forID  (   "-23:59 "  )  ,  DateTimeZone  .  forOffsetHoursMinutes  (  -23  ,  59  )  )  ;  [METHOD]  forOffsetHoursMinutes  [TYPE]  DateTimeZone  [PARAMETER]  int  hoursOffset  int  minutesOffset  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  ArithmeticException  ex  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  int  MAX_MILLIS  hoursInMinutes  hoursOffset  minutesOffset  offset  [TYPE]  Provider  cProvider  [CONTEXT]  public  static  DateTimeZone  forOffsetHoursMinutes  (  int  hoursOffset  ,  int  minutesOffset  )  throws  IllegalArgumentException  {  if  (  hoursOffset  =  =  0  &&  minutesOffset  =  =  0  )  {  return  DateTimeZone  .  UTC  ;  }  if  (  hoursOffset  <  -23  ||  hoursOffset  >  23  )  {  throw  new  IllegalArgumentException  (   "Hours  out  of  range:   "  +  hoursOffset  )  ;  }  [BUGGY]  if  (  minutesOffset  <  0  ||  minutesOffset  >  59  )  {  throw  new  IllegalArgumentException  (   "Minutes  out  of  range:   "  +  minutesOffset  )  ;  }  int  offset  =  0  ;  try  {  int  hoursInMinutes  =  hoursOffset  *  60  ;  if  (  hoursInMinutes  <  0  )  {  minutesOffset  =  hoursInMinutes  -  minutesOffset  ;  }  else  {  minutesOffset  =  hoursInMinutes  +  minutesOffset  ;  }  offset  =  FieldUtils  .  safeMultiply  (  minutesOffset  ,  DateTimeConstants  .  MILLIS_PER_MINUTE  )  ;  }  catch  (  ArithmeticException  ex  )  {  throw  new  IllegalArgumentException  (   "Offset  is  too  large "  )  ;  }  return  forOffsetMillis  (  offset  )  ;  }  	Time_8_DateTimeZone_2_1	279	1	src/main/java/org/joda/time/DateTimeZone.java
1982	minutesOffset  =  hoursInMinutes  -  Math.abs(minutesOffset);  	[BUGGY]  minutesOffset  =  hoursInMinutes  -  minutesOffset  ;  [FE]  IllegalArgumentException:  Minutes  out  of  range:  -15  assertEquals  (  DateTimeZone  .  forID  (   "-23:59 "  )  ,  DateTimeZone  .  forOffsetHoursMinutes  (  -23  ,  59  )  )  ;  [METHOD]  forOffsetHoursMinutes  [TYPE]  DateTimeZone  [PARAMETER]  int  hoursOffset  int  minutesOffset  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  ArithmeticException  ex  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  int  MAX_MILLIS  hoursInMinutes  hoursOffset  minutesOffset  offset  [TYPE]  Provider  cProvider  [CONTEXT]  public  static  DateTimeZone  forOffsetHoursMinutes  (  int  hoursOffset  ,  int  minutesOffset  )  throws  IllegalArgumentException  {  if  (  hoursOffset  =  =  0  &&  minutesOffset  =  =  0  )  {  return  DateTimeZone  .  UTC  ;  }  if  (  hoursOffset  <  -23  ||  hoursOffset  >  23  )  {  throw  new  IllegalArgumentException  (   "Hours  out  of  range:   "  +  hoursOffset  )  ;  }  if  (  minutesOffset  <  0  ||  minutesOffset  >  59  )  {  throw  new  IllegalArgumentException  (   "Minutes  out  of  range:   "  +  minutesOffset  )  ;  }  int  offset  =  0  ;  try  {  int  hoursInMinutes  =  hoursOffset  *  60  ;  if  (  hoursInMinutes  <  0  )  {  [BUGGY]  minutesOffset  =  hoursInMinutes  -  minutesOffset  ;  }  else  {  minutesOffset  =  hoursInMinutes  +  minutesOffset  ;  }  offset  =  FieldUtils  .  safeMultiply  (  minutesOffset  ,  DateTimeConstants  .  MILLIS_PER_MINUTE  )  ;  }  catch  (  ArithmeticException  ex  )  {  throw  new  IllegalArgumentException  (   "Offset  is  too  large "  )  ;  }  return  forOffsetMillis  (  offset  )  ;  }  	Time_8_DateTimeZone_2_2	286	1	src/main/java/org/joda/time/DateTimeZone.java
1983	private  static  final  int  MAX_MILLIS  =  (86400  *  1000)  -  1;  	[BUGGY]  [FE]  AssertionFailedError  assertEquals  (  DateTimeZone  .  forID  (   "-23:59 "  )  ,  DateTimeZone  .  forOffsetHoursMinutes  (  -23  ,  59  )  )  ;  [CLASS]  [CONTEXT]  	Time_9_DateTimeZone_4_1	96	0	src/main/java/org/joda/time/DateTimeZone.java
1984	if  (hoursOffset  <  -23  ||  hoursOffset  >  23)  {  throw  new  IllegalArgumentException( "Hours  out  of  range:   "  +  hoursOffset);  }  	[BUGGY]  [FE]  AssertionFailedError  assertEquals  (  DateTimeZone  .  forID  (   "-23:59 "  )  ,  DateTimeZone  .  forOffsetHoursMinutes  (  -23  ,  59  )  )  ;  [METHOD]  forOffsetHoursMinutes  [TYPE]  DateTimeZone  [PARAMETER]  int  hoursOffset  int  minutesOffset  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  ArithmeticException  ex  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  int  hoursInMinutes  hoursOffset  minutesOffset  offset  [TYPE]  Provider  cProvider  [CONTEXT]  public  static  DateTimeZone  forOffsetHoursMinutes  (  int  hoursOffset  ,  int  minutesOffset  )  throws  IllegalArgumentException  {  if  (  hoursOffset  =  =  0  &&  minutesOffset  =  =  0  )  {  return  DateTimeZone  .  UTC  ;  }  [BUGGY]  if  (  minutesOffset  <  0  ||  minutesOffset  >  59  )  {  throw  new  IllegalArgumentException  (   "Minutes  out  of  range:   "  +  minutesOffset  )  ;  }  int  offset  =  0  ;  try  {  int  hoursInMinutes  =  FieldUtils  .  safeMultiply  (  hoursOffset  ,  60  )  ;  if  (  hoursInMinutes  <  0  )  {  minutesOffset  =  FieldUtils  .  safeAdd  (  hoursInMinutes  ,  -minutesOffset  )  ;  }  else  {  minutesOffset  =  FieldUtils  .  safeAdd  (  hoursInMinutes  ,  minutesOffset  )  ;  }  offset  =  FieldUtils  .  safeMultiply  (  minutesOffset  ,  DateTimeConstants  .  MILLIS_PER_MINUTE  )  ;  }  catch  (  ArithmeticException  ex  )  {  throw  new  IllegalArgumentException  (   "Offset  is  too  large "  )  ;  }  return  forOffsetMillis  (  offset  )  ;  }  	Time_9_DateTimeZone_4_2	257	0	src/main/java/org/joda/time/DateTimeZone.java
1985	int  hoursInMinutes  =  hoursOffset  *  60;  minutesOffset  =  hoursInMinutes  -  minutesOffset;  minutesOffset  =  hoursInMinutes  +  minutesOffset;  	[BUGGY]  int  hoursInMinutes  =  FieldUtils  .  safeMultiply  (  hoursOffset  ,  60  )  ;  minutesOffset  =  FieldUtils  .  safeAdd  (  hoursInMinutes  ,  -minutesOffset  )  ;  minutesOffset  =  FieldUtils  .  safeAdd  (  hoursInMinutes  ,  minutesOffset  )  ;  [FE]  AssertionFailedError  assertEquals  (  DateTimeZone  .  forID  (   "-23:59 "  )  ,  DateTimeZone  .  forOffsetHoursMinutes  (  -23  ,  59  )  )  ;  [METHOD]  forOffsetHoursMinutes  [TYPE]  DateTimeZone  [PARAMETER]  int  hoursOffset  int  minutesOffset  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  ArithmeticException  ex  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  int  hoursInMinutes  hoursOffset  minutesOffset  offset  [TYPE]  Provider  cProvider  [CONTEXT]  public  static  DateTimeZone  forOffsetHoursMinutes  (  int  hoursOffset  ,  int  minutesOffset  )  throws  IllegalArgumentException  {  if  (  hoursOffset  =  =  0  &&  minutesOffset  =  =  0  )  {  return  DateTimeZone  .  UTC  ;  }  if  (  minutesOffset  <  0  ||  minutesOffset  >  59  )  {  throw  new  IllegalArgumentException  (   "Minutes  out  of  range:   "  +  minutesOffset  )  ;  }  int  offset  =  0  ;  try  {  [BUGGY]  int  hoursInMinutes  =  FieldUtils  .  safeMultiply  (  hoursOffset  ,  60  )  ;  if  (  hoursInMinutes  <  0  )  {  minutesOffset  =  FieldUtils  .  safeAdd  (  hoursInMinutes  ,  -minutesOffset  )  ;  }  else  {  minutesOffset  =  FieldUtils  .  safeAdd  (  hoursInMinutes  ,  minutesOffset  )  ;  }  offset  =  FieldUtils  .  safeMultiply  (  minutesOffset  ,  DateTimeConstants  .  MILLIS_PER_MINUTE  )  ;  }  catch  (  ArithmeticException  ex  )  {  throw  new  IllegalArgumentException  (   "Offset  is  too  large "  )  ;  }  return  forOffsetMillis  (  offset  )  ;  }  	Time_9_DateTimeZone_4_3	262	3	src/main/java/org/joda/time/DateTimeZone.java
1986	if  (millisOffset  <  -MAX_MILLIS  ||  millisOffset  >  MAX_MILLIS)  {  throw  new  IllegalArgumentException( "Millis  out  of  range:   "  +  millisOffset);  }  	[BUGGY]  [FE]  AssertionFailedError  assertEquals  (  DateTimeZone  .  forID  (   "-23:59 "  )  ,  DateTimeZone  .  forOffsetHoursMinutes  (  -23  ,  59  )  )  ;  [METHOD]  forOffsetMillis  [TYPE]  DateTimeZone  [PARAMETER]  int  millisOffset  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  id  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  int  millisOffset  [TYPE]  Provider  cProvider  [CONTEXT]  public  static  DateTimeZone  forOffsetMillis  (  int  millisOffset  )  {  [BUGGY]  String  id  =  printOffset  (  millisOffset  )  ;  return  fixedOffsetZone  (  id  ,  millisOffset  )  ;  }  	Time_9_DateTimeZone_4_4	282	0	src/main/java/org/joda/time/DateTimeZone.java
1987	private  static  final  long  START_1972  =  2L  *  365L  *  86400L  *  1000L;  	[BUGGY]  [FE]  timeIllegalFieldValueException:  Value  29  for  dayOfMonth  must  be  in  the  range  [1  ,  28]  assertEquals  (  -1  ,  Days  .  daysBetween  (  end2  ,  start2  )  .  getDays  (  )  )  ;  [CLASS]  [CONTEXT]  	Time_10_BaseSingleFieldPeriod_2_1	52	0	src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java
1988	int[]  values  =  chrono.get(zeroInstance,  chrono.set(start,  START_1972),  chrono.set(end,  START_1972));  	[BUGGY]  int[]  values  =  chrono  .  get  (  zeroInstance  ,  chrono  .  set  (  start  ,  0L  )  ,  chrono  .  set  (  end  ,  0L  )  )  ;  [FE]  timeIllegalFieldValueException:  Value  29  for  dayOfMonth  must  be  in  the  range  [1  ,  28]  assertEquals  (  -1  ,  Days  .  daysBetween  (  end2  ,  start2  )  .  getDays  (  )  )  ;  [METHOD]  between  [TYPE]  int  [PARAMETER]  ReadablePartial  start  ReadablePartial  end  ReadablePeriod  zeroInstance  [CLASS]  BaseSingleFieldPeriod  [TYPE]  ReadablePartial  end  start  [TYPE]  boolean  false  true  [TYPE]  ReadablePeriod  zeroInstance  [TYPE]  int[]  values  [TYPE]  Chronology  chrono  [TYPE]  long  serialVersionUID  [TYPE]  int  i  iPeriod  isize  [CONTEXT]  protected  static  int  between  (  ReadablePartial  start  ,  ReadablePartial  end  ,  ReadablePeriod  zeroInstance  )  {  if  (  start  =  =  null  ||  end  =  =  null  )  {  throw  new  IllegalArgumentException  (   "ReadablePartial  objects  must  not  be  null "  )  ;  }  if  (  start  .  size  (  )  !  =  end  .  size  (  )  )  {  throw  new  IllegalArgumentException  (   "ReadablePartial  objects  must  have  the  same  set  of  fields "  )  ;  }  for  (  int  i  =  0  ,  isize  =  start  .  size  (  )  ;  i  <  isize  ;  i++  )  {  if  (  start  .  getFieldType  (  i  )  !  =  end  .  getFieldType  (  i  )  )  {  throw  new  IllegalArgumentException  (   "ReadablePartial  objects  must  have  the  same  set  of  fields "  )  ;  }  }  if  (  DateTimeUtils  .  isContiguous  (  start  )  =  =  false  )  {  throw  new  IllegalArgumentException  (   "ReadablePartial  objects  must  be  contiguous "  )  ;  }  Chronology  chrono  =  DateTimeUtils  .  getChronology  (  start  .  getChronology  (  )  )  .  withUTC  (  )  ;  [BUGGY]  int[]  values  =  chrono  .  get  (  zeroInstance  ,  chrono  .  set  (  start  ,  0L  )  ,  chrono  .  set  (  end  ,  0L  )  )  ;  return  values[0]  ;  }  	Time_10_BaseSingleFieldPeriod_2_2	104	1	src/main/java/org/joda/time/base/BaseSingleFieldPeriod.java
1989	static  ThreadLocal<Boolean>  cVerbose  =  new  ThreadLocal<Boolean>()  {  protected  Boolean  initialValue()  {  return  Boolean.FALSE;  }  };  	[BUGGY]  static  ThreadLocal<Boolean>  cVerbose  =  new  ThreadLocal<Boolean>  (  )  ;  static  {  cVerbose  .  set  (  Boolean  .  FALSE  )  ;  }  [FE]  AssertionFailedError  [CLASS]  [CONTEXT]  	Time_11_ZoneInfoCompiler_1_1	68	4	src/main/java/org/joda/time/tz/ZoneInfoCompiler.java
1990	int  era  =  calendar.get(Calendar.ERA);  (era  ==  GregorianCalendar.AD  ?  yearOfEra  :  1  -  yearOfEra),  	[BUGGY]  yearOfEra  ,  [FE]  AssertionFailedError:  expected:<0000-02-03T04:05:06007>  but  was:<0001-02-03T04:05:06007>  assertEquals  (  expected  ,  LocalDateTime  .  fromDateFields  (  cal  .  getTime  (  )  )  )  ;  [METHOD]  fromCalendarFields  [TYPE]  LocalDate  [PARAMETER]  Calendar  calendar  [CLASS]  LocalDate  [TYPE]  Set  DATE_DURATION_TYPES  [TYPE]  boolean  false  true  [TYPE]  Calendar  calendar  [TYPE]  Chronology  iChronology  [TYPE]  DateTimeField  iField  [TYPE]  LocalDate  iInstant  [TYPE]  long  iLocalMillis  serialVersionUID  [TYPE]  int  DAY_OF_MONTH  MONTH_OF_YEAR  YEAR  iHash  yearOfEra  [CONTEXT]  public  static  LocalDate  fromCalendarFields  (  Calendar  calendar  )  {  if  (  calendar  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  calendar  must  not  be  null "  )  ;  }  [BUGGY]  int  yearOfEra  =  calendar  .  get  (  Calendar  .  YEAR  )  ;  return  new  LocalDate  (  yearOfEra  ,  calendar  .  get  (  Calendar  .  MONTH  )  +  1  ,  calendar  .  get  (  Calendar  .  DAY_OF_MONTH  )    )  ;  }  	Time_12_LocalDate_2_1	210	1	src/main/java/org/joda/time/LocalDate.java
1991	if  (date.getTime()  <  0)  {  GregorianCalendar  cal  =  new  GregorianCalendar();  cal.setTime(date);  return  fromCalendarFields(cal);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<0000-02-03T04:05:06007>  but  was:<0001-02-03T04:05:06007>  assertEquals  (  expected  ,  LocalDateTime  .  fromDateFields  (  cal  .  getTime  (  )  )  )  ;  [METHOD]  fromDateFields  [TYPE]  LocalDate  [PARAMETER]  Date  date  [CLASS]  LocalDate  [TYPE]  Set  DATE_DURATION_TYPES  [TYPE]  boolean  false  true  [TYPE]  Chronology  iChronology  [TYPE]  DateTimeField  iField  [TYPE]  LocalDate  iInstant  [TYPE]  long  iLocalMillis  serialVersionUID  [TYPE]  int  DAY_OF_MONTH  MONTH_OF_YEAR  YEAR  iHash  [TYPE]  Date  date  [CONTEXT]  public  static  LocalDate  fromDateFields  (  Date  date  )  {  if  (  date  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  date  must  not  be  null "  )  ;  }  [BUGGY]  return  new  LocalDate  (  date  .  getYear  (  )  +  1900  ,  date  .  getMonth  (  )  +  1  ,  date  .  getDate  (  )    )  ;  }  	Time_12_LocalDate_2_2	243	0	src/main/java/org/joda/time/LocalDate.java
1992	int  era  =  calendar.get(Calendar.ERA);  (era  ==  GregorianCalendar.AD  ?  yearOfEra  :  1  -  yearOfEra),  	[BUGGY]  yearOfEra  ,  [FE]  AssertionFailedError:  expected:<0000-02-03T04:05:06007>  but  was:<0001-02-03T04:05:06007>  assertEquals  (  expected  ,  LocalDateTime  .  fromDateFields  (  cal  .  getTime  (  )  )  )  ;  [METHOD]  fromCalendarFields  [TYPE]  LocalDateTime  [PARAMETER]  Calendar  calendar  [CLASS]  LocalDateTime  [TYPE]  LocalDateTime  iInstant  [TYPE]  boolean  false  true  [TYPE]  Calendar  calendar  [TYPE]  Chronology  iChronology  [TYPE]  DateTimeField  iField  [TYPE]  long  iLocalMillis  serialVersionUID  [TYPE]  int  DAY_OF_MONTH  MILLIS_OF_DAY  MONTH_OF_YEAR  YEAR  yearOfEra  [CONTEXT]  public  static  LocalDateTime  fromCalendarFields  (  Calendar  calendar  )  {  if  (  calendar  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  calendar  must  not  be  null "  )  ;  }  [BUGGY]  int  yearOfEra  =  calendar  .  get  (  Calendar  .  YEAR  )  ;  return  new  LocalDateTime  (  yearOfEra  ,  calendar  .  get  (  Calendar  .  MONTH  )  +  1  ,  calendar  .  get  (  Calendar  .  DAY_OF_MONTH  )  ,  calendar  .  get  (  Calendar  .  HOUR_OF_DAY  )  ,  calendar  .  get  (  Calendar  .  MINUTE  )  ,  calendar  .  get  (  Calendar  .  SECOND  )  ,  calendar  .  get  (  Calendar  .  MILLISECOND  )    )  ;  }  	Time_12_LocalDateTime_2_1	199	1	src/main/java/org/joda/time/LocalDateTime.java
1993	if  (date.getTime()  <  0)  {  GregorianCalendar  cal  =  new  GregorianCalendar();  cal.setTime(date);  return  fromCalendarFields(cal);  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<0000-02-03T04:05:06007>  but  was:<0001-02-03T04:05:06007>  assertEquals  (  expected  ,  LocalDateTime  .  fromDateFields  (  cal  .  getTime  (  )  )  )  ;  [METHOD]  fromDateFields  [TYPE]  LocalDateTime  [PARAMETER]  Date  date  [CLASS]  LocalDateTime  [TYPE]  LocalDateTime  iInstant  [TYPE]  boolean  false  true  [TYPE]  Chronology  iChronology  [TYPE]  DateTimeField  iField  [TYPE]  long  iLocalMillis  serialVersionUID  [TYPE]  int  DAY_OF_MONTH  MILLIS_OF_DAY  MONTH_OF_YEAR  YEAR  [TYPE]  Date  date  [CONTEXT]  public  static  LocalDateTime  fromDateFields  (  Date  date  )  {  if  (  date  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  date  must  not  be  null "  )  ;  }  [BUGGY]  return  new  LocalDateTime  (  date  .  getYear  (  )  +  1900  ,  date  .  getMonth  (  )  +  1  ,  date  .  getDate  (  )  ,  date  .  getHours  (  )  ,  date  .  getMinutes  (  )  ,  date  .  getSeconds  (  )  ,  (  (  (  int  )    (  date  .  getTime  (  )  %  1000  )  )  +  1000  )  %  1000  )  ;  }  	Time_12_LocalDateTime_2_2	236	0	src/main/java/org/joda/time/LocalDateTime.java
1994	sum  =  (valueLong  <  0  ?  Math.max(sum,  5)  :  Math.max(sum,  4));  	[BUGGY]  sum  =  Math  .  max  (  sum  ,  4  )  ;  [FE]  ComparisonFailure:  expected:<PT[-]0008S>  but  was:<PT[]0008S>  assertEquals  (   "PT-0  .  008S "  ,  ISOPeriodFormat  .  standard  (  )  .  print  (  p  )  )  ;  [METHOD]  calculatePrintedLength  [TYPE]  int  [PARAMETER]  ReadablePeriod  period  Locale  locale  [CLASS]  FieldFormatter  [TYPE]  Locale  locale  [TYPE]  boolean  false  iRejectSignedValues  true  [TYPE]  ReadablePeriod  period  [TYPE]  FieldFormatter[]  iFieldFormatters  [TYPE]  PeriodFieldAffix  iPrefix  iSuffix  [TYPE]  int  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  sum  value  [TYPE]  long  valueLong  [CONTEXT]  public  int  calculatePrintedLength  (  ReadablePeriod  period  ,  Locale  locale  )  {  long  valueLong  =  getFieldValue  (  period  )  ;  if  (  valueLong  =  =  Long  .  MAX_VALUE  )  {  return  0  ;  }  int  sum  =  Math  .  max  (  FormatUtils  .  calculateDigitCount  (  valueLong  )  ,  iMinPrintedDigits  )  ;  if  (  iFieldType  >  =  SECONDS_MILLIS  )  {    [BUGGY]  sum  =  Math  .  max  (  sum  ,  4  )  ;  sum++  ;  if  (  iFieldType  =  =  SECONDS_OPTIONAL_MILLIS  &&  (  Math  .  abs  (  valueLong  )  %  DateTimeConstants  .  MILLIS_PER_SECOND  )  =  =  0  )  {  sum  -  =  4  ;  //  remove  three  digits  and  decimal  point  	Time_13_PeriodFormatterBuilder_3_1	1098	1	src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
1995	int  bufLen  =  buf.length();  	[BUGGY]  [FE]  ComparisonFailure:  expected:<PT[-]0008S>  but  was:<PT[]0008S>  assertEquals  (   "PT-0  .  008S "  ,  ISOPeriodFormat  .  standard  (  )  .  print  (  p  )  )  ;  [METHOD]  printTo  [TYPE]  void  [PARAMETER]  StringBuffer  buf  ReadablePeriod  period  Locale  locale  [CLASS]  FieldFormatter  [TYPE]  Locale  locale  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  iRejectSignedValues  true  [TYPE]  ReadablePeriod  period  [TYPE]  FieldFormatter[]  iFieldFormatters  [TYPE]  PeriodFieldAffix  iPrefix  iSuffix  [TYPE]  int  dp  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  minDigits  value  [TYPE]  long  valueLong  [CONTEXT]  public  void  printTo  (  StringBuffer  buf  ,  ReadablePeriod  period  ,  Locale  locale  )  {  long  valueLong  =  getFieldValue  (  period  )  ;  if  (  valueLong  =  =  Long  .  MAX_VALUE  )  {  return  ;  }  int  value  =  (  int  )  valueLong  ;  if  (  iFieldType  >  =  SECONDS_MILLIS  )  {  value  =  (  int  )    (  valueLong  /  DateTimeConstants  .  MILLIS_PER_SECOND  )  ;  }  if  (  iPrefix  !  =  null  )  {  iPrefix  .  printTo  (  buf  ,  value  )  ;  }  [BUGGY]  int  minDigits  =  iMinPrintedDigits  ;  if  (  minDigits  <  =  1  )  {  FormatUtils  .  appendUnpaddedInteger  (  buf  ,  value  )  ;  }  else  {  FormatUtils  .  appendPaddedInteger  (  buf  ,  value  ,  minDigits  )  ;  }  if  (  iFieldType  >  =  SECONDS_MILLIS  )  {  int  dp  =  (  int  )    (  Math  .  abs  (  valueLong  )  %  DateTimeConstants  .  MILLIS_PER_SECOND  )  ;  if  (  iFieldType  =  =  SECONDS_MILLIS  ||  dp  >  0  )  {  buf  .  append  (  '  .  '  )  ;  FormatUtils  .  appendPaddedInteger  (  buf  ,  dp  ,  3  )  ;  }  }  if  (  iSuffix  !  =  null  )  {  iSuffix  .  printTo  (  buf  ,  value  )  ;  }  }  	Time_13_PeriodFormatterBuilder_3_2	1133	0	src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
1996	if  (valueLong  <  0  &&  valueLong  >  -DateTimeConstants.MILLIS_PER_SECOND)  {\n',   "+                                                buf.insert(bufLen,  '-');\n ",  '+                                        }\n',   "                                          buf.append('.');\n "]  	[BUGGY]  [FE]  ComparisonFailure:  expected:<PT[-]0008S>  but  was:<PT[]0008S>  assertEquals  (   "PT-0  .  008S "  ,  ISOPeriodFormat  .  standard  (  )  .  print  (  p  )  )  ;  [METHOD]  printTo  [TYPE]  void  [PARAMETER]  StringBuffer  buf  ReadablePeriod  period  Locale  locale  [CLASS]  FieldFormatter  [TYPE]  Locale  locale  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  iRejectSignedValues  true  [TYPE]  ReadablePeriod  period  [TYPE]  FieldFormatter[]  iFieldFormatters  [TYPE]  PeriodFieldAffix  iPrefix  iSuffix  [TYPE]  int  dp  iFieldType  iMaxParsedDigits  iMinPrintedDigits  iPrintZeroSetting  minDigits  value  [TYPE]  long  valueLong  [CONTEXT]  public  void  printTo  (  StringBuffer  buf  ,  ReadablePeriod  period  ,  Locale  locale  )  {  long  valueLong  =  getFieldValue  (  period  )  ;  if  (  valueLong  =  =  Long  .  MAX_VALUE  )  {  return  ;  }  int  value  =  (  int  )  valueLong  ;  if  (  iFieldType  >  =  SECONDS_MILLIS  )  {  value  =  (  int  )    (  valueLong  /  DateTimeConstants  .  MILLIS_PER_SECOND  )  ;  }  if  (  iPrefix  !  =  null  )  {  iPrefix  .  printTo  (  buf  ,  value  )  ;  }  int  minDigits  =  iMinPrintedDigits  ;  if  (  minDigits  <  =  1  )  {  FormatUtils  .  appendUnpaddedInteger  (  buf  ,  value  )  ;  }  else  {  FormatUtils  .  appendPaddedInteger  (  buf  ,  value  ,  minDigits  )  ;  }  if  (  iFieldType  >  =  SECONDS_MILLIS  )  {  int  dp  =  (  int  )    (  Math  .  abs  (  valueLong  )  %  DateTimeConstants  .  MILLIS_PER_SECOND  )  ;  if  (  iFieldType  =  =  SECONDS_MILLIS  ||  dp  >  0  )  {  [BUGGY]  buf  .  append  (  '  .  '  )  ;  FormatUtils  .  appendPaddedInteger  (  buf  ,  dp  ,  3  )  ;  }  }  if  (  iSuffix  !  =  null  )  {  iSuffix  .  printTo  (  buf  ,  value  )  ;  }  }  	Time_13_PeriodFormatterBuilder_3_3	1142	0	src/main/java/org/joda/time/format/PeriodFormatterBuilder.java
1997	if  (partial.size()  >  0  &&  partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear())  &&  fieldIndex  ==  0)  {  int  curMonth0  =  partial.getValue(0)  -  1;  int  newMonth  =  ((curMonth0  +  (valueToAdd  %  12)  +  12)  %  12)  +  1;  return  set(partial,  0,  values,  newMonth);  }  	[BUGGY]  [FE]  timeIllegalFieldValueException:  Value  29  for  dayOfMonth  must  be  in  the  range  [1  ,  28]  assertEquals  (  expected  ,  result  )  ;  [METHOD]  add  [TYPE]  int[]  [PARAMETER]  ReadablePartial  partial  int  fieldIndex  int[]  values  int  valueToAdd  [CLASS]  BasicMonthOfYearDateTimeField  [TYPE]  int[]  values  [TYPE]  ReadablePartial  partial  [TYPE]  boolean  false  true  [TYPE]  long  instant  serialVersionUID  [TYPE]  int  MIN  fieldIndex  i  iLeapMonth  iMax  isize  valueToAdd  [TYPE]  BasicChronology  iChronology  [CONTEXT]  public  int[]  add  (  ReadablePartial  partial  ,  int  fieldIndex  ,  int[]  values  ,  int  valueToAdd  )  {    if  (  valueToAdd  =  =  0  )  {  return  values  ;  }  [BUGGY]  if  (  DateTimeUtils  .  isContiguous  (  partial  )  )  {  long  instant  =  0L  ;  for  (  int  i  =  0  ,  isize  =  partial  .  size  (  )  ;  i  <  isize  ;  i++  )  {  instant  =  partial  .  getFieldType  (  i  )  .  getField  (  iChronology  )  .  set  (  instant  ,  values[i]  )  ;  }  instant  =  add  (  instant  ,  valueToAdd  )  ;  return  iChronology  .  get  (  partial  ,  instant  )  ;  }  else  {  return  super  .  add  (  partial  ,  fieldIndex  ,  values  ,  valueToAdd  )  ;  }  }  	Time_14_BasicMonthOfYearDateTimeField_1_1	209	0	src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java
1998	if  (val1  ==  Long.MIN_VALUE)  {  throw  new  ArithmeticException( "Multiplication  overflows  a  long:   "  +  val1  +   "  *   "  +  val2);  }  	[BUGGY]  [FE]  AssertionFailedError  assertEquals  (  -Long  .  MAX_VALUE  ,  FieldUtils  .  safeMultiply  (  Long  .  MAX_VALUE  ,  -1  )  )  ;  [METHOD]  safeMultiply  [TYPE]  long  [PARAMETER]  long  val1  int  val2  [CLASS]  FieldUtils  [TYPE]  boolean  false  true  [TYPE]  long  total  val1  [TYPE]  int  val2  [CONTEXT]  public  static  long  safeMultiply  (  long  val1  ,  int  val2  )  {  switch  (  val2  )  {  case  -1:  [BUGGY]  return  -val1  ;  case  0:  return  0L  ;  case  1:  return  val1  ;  }  long  total  =  val1  *  val2  ;  if  (  total  /  val2  !  =  val1  )  {  throw  new  ArithmeticException  (   "Multiplication  overflows  a  long:   "  +  val1  +   "  *   "  +  val2  )  ;  }  return  total  ;  }  	Time_15_FieldUtils_1_1	138	0	src/main/java/org/joda/time/field/FieldUtils.java
1999	DateTimeParserBucket bucket = new DateTimeParserBucket(instantLocal,  chrono,  iLocale,  iPivotYear,  chrono.year().get(instantLocal));  	[BUGGY] DateTimeParserBucket bucket = new DateTimeParserBucket( instantLocal  ,  chrono  ,  iLocale  ,  iPivotYear  ,  iDefaultYear  )  ;  [FE]  AssertionFailedError:  expected:<2004-05-01T12:20:30000+09:00>  but  was:<2000-05-01T12:20:30000+09:00>  assertEquals  (  new  MutableDateTime  (  2004  ,  5  ,  1  ,  12  ,  20  ,  30  ,  0  ,  TOKYO  )  ,  result  )  ;  [METHOD]  parseInto  [TYPE]  int  [PARAMETER]  ReadWritableInstant  instant  String  text  int  position  [CLASS]  DateTimeFormatter  [TYPE]  Locale  iLocale  [TYPE]  Integer  iPivotYear  [TYPE]  DateTimeParser  iParser  parser  [TYPE]  boolean  false  iOffsetParsed  true  [TYPE]  DateTimeParserBucket  bucket  [TYPE]  ReadWritableInstant  instant  [TYPE]  Chronology  chrono  iChrono  [TYPE]  String  text  [TYPE]  DateTimePrinter  iPrinter  [TYPE]  DateTimeZone  iZone  parsedZone  [TYPE]  int  iDefaultYear  newPos  parsedOffset  position  [TYPE]  long  instantLocal  instantMillis  [CONTEXT]  public  int  parseInto  (  ReadWritableInstant  instant  ,  String  text  ,  int  position  )  {  DateTimeParser  parser  =  requireParser  (  )  ;  if  (  instant  =  =  null  )  {  throw  new  IllegalArgumentException  (   "Instant  must  not  be  null "  )  ;  }  long  instantMillis  =  instant  .  getMillis  (  )  ;  Chronology  chrono  =  instant  .  getChronology  (  )  ;  long  instantLocal  =  instantMillis  +  chrono  .  getZone  (  )  .  getOffset  (  instantMillis  )  ;  chrono  =  selectChronology  (  chrono  )  ;  DateTimeParserBucket  bucket  =  new  DateTimeParserBucket  (  [BUGGY]  instantLocal  ,  chrono  ,  iLocale  ,  iPivotYear  ,  iDefaultYear  )  ;  int  newPos  =  parser  .  parseInto  (  bucket  ,  text  ,  position  )  ;  instant  .  setMillis  (  bucket  .  computeMillis  (  false  ,  text  )  )  ;  if  (  iOffsetParsed  &&  bucket  .  getOffsetInteger  (  )  !  =  null  )  {  int  parsedOffset  =  bucket  .  getOffsetInteger  (  )  ;  DateTimeZone  parsedZone  =  DateTimeZone  .  forOffsetMillis  (  parsedOffset  )  ;  chrono  =  chrono  .  withZone  (  parsedZone  )  ;  }  else  if  (  bucket  .  getZone  (  )  !  =  null  )  {  chrono  =  chrono  .  withZone  (  bucket  .  getZone  (  )  )  ;  }  instant  .  setChronology  (  chrono  )  ;  if  (  iZone  !  =  null  )  {  instant  .  setZone  (  iZone  )  ;  }  return  newPos  ;  }  	Time_16_DateTimeFormatter_1_1	708	2	src/main/java/org/joda/time/format/DateTimeFormatter.java
2000	long  instantBefore  =  instant  -  3  *  DateTimeConstants.MILLIS_PER_HOUR;  long  instantAfter  =  instant  +  3  *  DateTimeConstants.MILLIS_PER_HOUR;  long  offsetBefore  =  getOffset(instantBefore);  long  offsetAfter  =  getOffset(instantAfter);  if  (offsetBefore  <=  offsetAfter)  {  	[BUGGY]  long  instantBefore  =  convertUTCToLocal  (  instant  -  3  *  DateTimeConstants  .  MILLIS_PER_HOUR  )  ;  long  instantAfter  =  convertUTCToLocal  (  instant  +  3  *  DateTimeConstants  .  MILLIS_PER_HOUR  )  ;  if  (  instantBefore  =  =  instantAfter  )  {  [FE]  AssertionFailedError:  expected:<2012-02-25T23:15:00000-03:00>  but  was:<2012-02-25T23:15:00000-02:00>  assertEquals  (  baseAfter  ,  baseAfter  .  withEarlierOffsetAtOverlap  (  )  )  ;  [METHOD]  adjustOffset  [TYPE]  long  [PARAMETER]  long  instant  boolean  earlierOrLater  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  boolean  earlierOrLater  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  instant  instantAfter  instantBefore  local  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  Provider  cProvider  [CONTEXT]  public  long  adjustOffset  (  long  instant  ,  boolean  earlierOrLater  )  {    [BUGGY]  long  instantBefore  =  convertUTCToLocal  (  instant  -  3  *  DateTimeConstants  .  MILLIS_PER_HOUR  )  ;  long  instantAfter  =  convertUTCToLocal  (  instant  +  3  *  DateTimeConstants  .  MILLIS_PER_HOUR  )  ;  if  (  instantBefore  =  =  instantAfter  )  {  return  instant  ;  //  not  an  overlap  (  less  than  is  a  gap  ,  equal  is  normal  case  )  }  long  local  =  convertUTCToLocal  (  instant  )  ;  return  convertLocalToUTC  (  local  ,  false  ,  earlierOrLater  ?  instantAfter  :  instantBefore  )  ;      }  	Time_17_DateTimeZone_2_1	1167	3	src/main/java/org/joda/time/DateTimeZone.java
2001	long  diff  =  offsetBefore  -  offsetAfter;  long  transition  =  nextTransition(instantBefore);  long  overlapStart  =  transition  -  diff;  long  overlapEnd  =  transition  +  diff;  if  (instant  <  overlapStart  ||  instant  >=  overlapEnd)  {  return  instant;      }  long  afterStart  =  instant  -  overlapStart;  if  (afterStart  >=  diff)  {  return  earlierOrLater  ?  instant  :  instant  -  diff;  }  else  {  return  earlierOrLater  ?  instant  +  diff  :  instant;  }  	[BUGGY]  long  local  =  convertUTCToLocal  (  instant  )  ;  return  convertLocalToUTC  (  local  ,  false  ,  earlierOrLater  ?  instantAfter  :  instantBefore  )  ;  [FE]  AssertionFailedError:  expected:<2012-02-25T23:15:00000-03:00>  but  was:<2012-02-25T23:15:00000-02:00>  assertEquals  (  baseAfter  ,  baseAfter  .  withEarlierOffsetAtOverlap  (  )  )  ;  [METHOD]  adjustOffset  [TYPE]  long  [PARAMETER]  long  instant  boolean  earlierOrLater  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  boolean  earlierOrLater  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  instant  instantAfter  instantBefore  local  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  Provider  cProvider  [CONTEXT]  public  long  adjustOffset  (  long  instant  ,  boolean  earlierOrLater  )  {    long  instantBefore  =  convertUTCToLocal  (  instant  -  3  *  DateTimeConstants  .  MILLIS_PER_HOUR  )  ;  long  instantAfter  =  convertUTCToLocal  (  instant  +  3  *  DateTimeConstants  .  MILLIS_PER_HOUR  )  ;  if  (  instantBefore  =  =  instantAfter  )  {  return  instant  ;  //  not  an  overlap  (  less  than  is  a  gap  ,  equal  is  normal  case  )  }  [BUGGY]  long  local  =  convertUTCToLocal  (  instant  )  ;  return  convertLocalToUTC  (  local  ,  false  ,  earlierOrLater  ?  instantAfter  :  instantBefore  )  ;      }  	Time_17_DateTimeZone_2_2	1174	2	src/main/java/org/joda/time/DateTimeZone.java
2002	try  {  	[BUGGY]  [FE]  timeIllegalFieldValueException:  Value  29  for  dayOfMonth  must  be  in  the  range  [1  ,  28]  assertEquals  (  dt  .  getDayOfMonth  (  )  ,  29  )  ;  [METHOD]  getDateTimeMillis  [TYPE]  long  [PARAMETER]  int  year  int  monthOfYear  int  dayOfMonth  int  hourOfDay  int  minuteOfHour  int  secondOfMinute  int  millisOfSecond  [CLASS]  GJChronology  [TYPE]  boolean  false  iConvertByWeekyear  true  [TYPE]  JulianChronology  iJulianChronology  [TYPE]  Instant  DEFAULT_CUTOVER  iCutoverInstant  [TYPE]  GregorianChronology  iGregorianChronology  [TYPE]  ImpreciseCutoverField  iField  [TYPE]  DateTimeField  iGregorianField  iJulianField  [TYPE]  Chronology  base  [TYPE]  Map  cCache  [TYPE]  DurationField  iDurationField  iRangeDurationField  [TYPE]  long  iCutover  iCutoverMillis  iGapDuration  instant  serialVersionUID  [TYPE]  int  dayOfMonth  hourOfDay  millisOfSecond  minuteOfHour  monthOfYear  secondOfMinute  year  [CONTEXT]  public  long  getDateTimeMillis  (  int  year  ,  int  monthOfYear  ,  int  dayOfMonth  ,  int  hourOfDay  ,  int  minuteOfHour  ,  int  secondOfMinute  ,  int  millisOfSecond  )  throws  IllegalArgumentException  {  Chronology  base  ;  if  (  (  base  =  getBase  (  )  )  !  =  null  )  {  return  base  .  getDateTimeMillis  (  year  ,  monthOfYear  ,  dayOfMonth  ,  hourOfDay  ,  minuteOfHour  ,  secondOfMinute  ,  millisOfSecond  )  ;  }  long  instant  ;  [BUGGY]  instant  =  iGregorianChronology  .  getDateTimeMillis  (  year  ,  monthOfYear  ,  dayOfMonth  ,  hourOfDay  ,  minuteOfHour  ,  secondOfMinute  ,  millisOfSecond  )  ;  if  (  instant  <  iCutoverMillis  )  {  instant  =  iJulianChronology  .  getDateTimeMillis  (  year  ,  monthOfYear  ,  dayOfMonth  ,  hourOfDay  ,  minuteOfHour  ,  secondOfMinute  ,  millisOfSecond  )  ;  if  (  instant  >  =  iCutoverMillis  )  {  throw  new  IllegalArgumentException  (   "Specified  date  does  not  exist "  )  ;  }  }  return  instant  ;  }  	Time_18_GJChronology_2_1	364	0	src/main/java/org/joda/time/chrono/GJChronology.java
2003	}  catch  (IllegalFieldValueException  ex)  {  if  (monthOfYear  !=  2  ||  dayOfMonth  !=  29)  {  throw  ex;  }  instant  =  iGregorianChronology.getDateTimeMillis  (year,  monthOfYear,  28,  hourOfDay,  minuteOfHour,  secondOfMinute,  millisOfSecond);  if  (instant  >=  iCutoverMillis)  {  throw  ex;  }  }  	[BUGGY]  [FE]  timeIllegalFieldValueException:  Value  29  for  dayOfMonth  must  be  in  the  range  [1  ,  28]  assertEquals  (  dt  .  getDayOfMonth  (  )  ,  29  )  ;  [METHOD]  getDateTimeMillis  [TYPE]  long  [PARAMETER]  int  year  int  monthOfYear  int  dayOfMonth  int  hourOfDay  int  minuteOfHour  int  secondOfMinute  int  millisOfSecond  [CLASS]  GJChronology  [TYPE]  boolean  false  iConvertByWeekyear  true  [TYPE]  JulianChronology  iJulianChronology  [TYPE]  Instant  DEFAULT_CUTOVER  iCutoverInstant  [TYPE]  GregorianChronology  iGregorianChronology  [TYPE]  ImpreciseCutoverField  iField  [TYPE]  DateTimeField  iGregorianField  iJulianField  [TYPE]  Chronology  base  [TYPE]  Map  cCache  [TYPE]  DurationField  iDurationField  iRangeDurationField  [TYPE]  long  iCutover  iCutoverMillis  iGapDuration  instant  serialVersionUID  [TYPE]  int  dayOfMonth  hourOfDay  millisOfSecond  minuteOfHour  monthOfYear  secondOfMinute  year  [CONTEXT]  public  long  getDateTimeMillis  (  int  year  ,  int  monthOfYear  ,  int  dayOfMonth  ,  int  hourOfDay  ,  int  minuteOfHour  ,  int  secondOfMinute  ,  int  millisOfSecond  )  throws  IllegalArgumentException  {  Chronology  base  ;  if  (  (  base  =  getBase  (  )  )  !  =  null  )  {  return  base  .  getDateTimeMillis  (  year  ,  monthOfYear  ,  dayOfMonth  ,  hourOfDay  ,  minuteOfHour  ,  secondOfMinute  ,  millisOfSecond  )  ;  }  long  instant  ;  instant  =  iGregorianChronology  .  getDateTimeMillis  (  year  ,  monthOfYear  ,  dayOfMonth  ,  hourOfDay  ,  minuteOfHour  ,  secondOfMinute  ,  millisOfSecond  )  ;  [BUGGY]  if  (  instant  <  iCutoverMillis  )  {  instant  =  iJulianChronology  .  getDateTimeMillis  (  year  ,  monthOfYear  ,  dayOfMonth  ,  hourOfDay  ,  minuteOfHour  ,  secondOfMinute  ,  millisOfSecond  )  ;  if  (  instant  >  =  iCutoverMillis  )  {  throw  new  IllegalArgumentException  (   "Specified  date  does  not  exist "  )  ;  }  }  return  instant  ;  }  	Time_18_GJChronology_2_2	367	0	src/main/java/org/joda/time/chrono/GJChronology.java
2004	}  else  if  (offsetLocal  >=  0)  {  	[BUGGY]  }  else  if  (  offsetLocal  >  0  )  {  [FE]  ComparisonFailure:  expected:<1-10-30T01:15:00000[+01:00]>  but  was:<1-10-30T01:15:00000[Z]>  assertEquals  (   "2011-10-30T01:15:00  .  000Z "  ,  base  .  plusHours  (  1  )  .  toString  (  )  )  ;  [METHOD]  getOffsetFromLocal  [TYPE]  int  [PARAMETER]  long  instantLocal  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  instantAdjusted  instantLocal  nextAdjusted  nextLocal  prev  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  int  diff  offsetAdjusted  offsetLocal  offsetPrev  [TYPE]  Provider  cProvider  [CONTEXT]  public  int  getOffsetFromLocal  (  long  instantLocal  )  {  final  int  offsetLocal  =  getOffset  (  instantLocal  )  ;  final  long  instantAdjusted  =  instantLocal  -  offsetLocal  ;  final  int  offsetAdjusted  =  getOffset  (  instantAdjusted  )  ;  if  (  offsetLocal  !  =  offsetAdjusted  )  {    if  (  (  offsetLocal  -  offsetAdjusted  )  <  0  )  {    long  nextLocal  =  nextTransition  (  instantAdjusted  )  ;  long  nextAdjusted  =  nextTransition  (  instantLocal  -  offsetAdjusted  )  ;  if  (  nextLocal  !  =  nextAdjusted  )  {  return  offsetLocal  ;  }  }  [BUGGY]  }  else  if  (  offsetLocal  >  0  )  {  long  prev  =  previousTransition  (  instantAdjusted  )  ;  if  (  prev  <  instantAdjusted  )  {  int  offsetPrev  =  getOffset  (  prev  )  ;  int  diff  =  offsetPrev  -  offsetLocal  ;  if  (  instantAdjusted  -  prev  <  =  diff  )  {  	Time_19_DateTimeZone_1_1	900	1	src/main/java/org/joda/time/DateTimeZone.java
2005	String  best  =  null;  \tif  (best  ==  null  ||  id.length()  >  best.length())  {  \t\tbest  =  id;  \t}  if  (best  !=  null)  {  bucket.setZone(DateTimeZone.forID(best));  return  position  +  best.length();  }  	[BUGGY]  bucket  .  setZone  (  DateTimeZone  .  forID  (  id  )  )  ;  return  position  +  id  .  length  (  )  ;  [FE]  IllegalArgumentException:  Invalid  format:   "2007-03-04  12:30  America/Dawson_Creek "  is  malformed  at   "_Creek "  assertEquals  (  dt  ,  f  .  parseDateTime  (   "2007-03-04  12:30  America/Dawson_Creek "  )  )  ;  [METHOD]  parseInto  [TYPE]  int  [PARAMETER]  DateTimeParserBucket  bucket  String  text  int  position  [CLASS]  TimeZoneId  [TYPE]  Set  ALL_IDS  [TYPE]  String  id  str  text  [TYPE]  boolean  false  true  [TYPE]  DateTimeParserBucket  bucket  [TYPE]  int  MAX_LENGTH  position  [TYPE]  TimeZoneId  INSTANCE  [CONTEXT]  public  int  parseInto  (  DateTimeParserBucket  bucket  ,  String  text  ,  int  position  )  {  String  str  =  text  .  substring  (  position  )  ;  [BUGGY]  for  (  String  id  :  ALL_IDS  )  {  if  (  str  .  startsWith  (  id  )  )  {  bucket  .  setZone  (  DateTimeZone  .  forID  (  id  )  )  ;  return  position  +  id  .  length  (  )  ;  }  }  return  ~position  ;  }  	Time_20_DateTimeFormatterBuilder_1_1	2542	2	src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java
2006	super();  iType  =  PeriodType.time();  int[]  values  =  ISOChronology.getInstanceUTC().get(this,  duration);  iType  =  PeriodType.standard();  iValues  =  new  int[8];  System.arraycopy(values,  0,  iValues,  4,  4);  	[BUGGY]  this  (  duration  ,  null  ,  null  )  ;  [FE]  AssertionFailedError:  expected:<0>  but  was:<64>  assertEquals  (  8  ,  test  .  getMillis  (  )  )  ;  [CLASS]  [CONTEXT]  	Time_22_BasePeriod_1_1	222	1	src/main/java/org/joda/time/base/BasePeriod.java
2007	map.put( "WET ",   "WET ");  map.put( "CET ",   "CET ");  map.put( "MET ",   "CET ");  map.put( "ECT ",   "CET ");  map.put( "EET ",   "EET ");  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[WET]>  but  was:<[Europe/London]>  assertEquals  (  value  ,  zone  .  getID  (  )  )  ;  [METHOD]  getConvertedId  [TYPE]  String  [PARAMETER]  String  id  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  id  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  map  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  Provider  cProvider  [CONTEXT]  private  static  synchronized  String  getConvertedId  (  String  id  )  {  Map<String  ,  String>  map  =  cZoneIdConversion  ;  if  (  map  =  =  null  )  {  map  =  new  HashMap<String  ,  String>  (  )  ;  map  .  put  (   "GMT "  ,   "UTC "  )  ;  [BUGGY]  map  .  put  (   "MIT "  ,   "Pacific/Apia "  )  ;  map  .  put  (   "HST "  ,   "Pacific/Honolulu "  )  ;  //  JDK  1  .  1  compatible  map  .  put  (   "AST "  ,   "America/Anchorage "  )  ;  map  .  put  (   "PST "  ,   "America/Los_Angeles "  )  ;  map  .  put  (   "MST "  ,   "America/Denver "  )  ;  //  JDK  1  .  1  compatible  map  .  put  (   "PNT "  ,   "America/Phoenix "  )  ;  	Time_23_DateTimeZone_2_1	564	0	src/main/java/org/joda/time/DateTimeZone.java
2008	map.put( "IET ",   "America/Indiana/Indianapolis ");  map.put( "AGT ",   "America/Argentina/Buenos_Aires ");  map.put( "IST ",   "Asia/Kolkata ");  map.put( "VST ",   "Asia/Ho_Chi_Minh ");  	[BUGGY]  map  .  put  (   "IET "  ,   "America/Indianapolis "  )  ;  map  .  put  (   "AGT "  ,   "America/Buenos_Aires "  )  ;  map  .  put  (   "WET "  ,   "Europe/London "  )  ;  map  .  put  (   "ECT "  ,   "Europe/Paris "  )  ;  map  .  put  (   "EET "  ,   "Europe/Bucharest "  )  ;  map  .  put  (   "MET "  ,   "Asia/Tehran "  )  ;  map  .  put  (   "IST "  ,   "Asia/Calcutta "  )  ;  map  .  put  (   "VST "  ,   "Asia/Saigon "  )  ;  [FE]  ComparisonFailure:  expected:<[WET]>  but  was:<[Europe/London]>  assertEquals  (  value  ,  zone  .  getID  (  )  )  ;  [METHOD]  getConvertedId  [TYPE]  String  [PARAMETER]  String  id  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  id  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  map  [TYPE]  long  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  Provider  cProvider  [CONTEXT]  private  static  synchronized  String  getConvertedId  (  String  id  )  {  Map<String  ,  String>  map  =  cZoneIdConversion  ;  if  (  map  =  =  null  )  {  map  =  new  HashMap<String  ,  String>  (  )  ;  map  .  put  (   "GMT "  ,   "UTC "  )  ;  map  .  put  (   "MIT "  ,   "Pacific/Apia "  )  ;  map  .  put  (   "HST "  ,   "Pacific/Honolulu "  )  ;  //  JDK  1  .  1  compatible  map  .  put  (   "AST "  ,   "America/Anchorage "  )  ;  map  .  put  (   "PST "  ,   "America/Los_Angeles "  )  ;  map  .  put  (   "MST "  ,   "America/Denver "  )  ;  //  JDK  1  .  1  compatible  map  .  put  (   "PNT "  ,   "America/Phoenix "  )  ;  map  .  put  (   "CST "  ,   "America/Chicago "  )  ;  map  .  put  (   "EST "  ,   "America/New_York "  )  ;  //  JDK  1  .  1  compatible  [BUGGY]  map  .  put  (   "IET "  ,   "America/Indianapolis "  )  ;  map  .  put  (   "PRT "  ,   "America/Puerto_Rico "  )  ;  map  .  put  (   "CNT "  ,   "America/St_Johns "  )  ;  map  .  put  (   "AGT "  ,   "America/Buenos_Aires "  )  ;  map  .  put  (   "BET "  ,   "America/Sao_Paulo "  )  ;  map  .  put  (   "WET "  ,   "Europe/London "  )  ;  	Time_23_DateTimeZone_2_2	572	8	src/main/java/org/joda/time/DateTimeZone.java
2009	if  (resetFields)  {  for  (int  i  =  0;  i  <  count;  i++)  {  millis  =  savedFields[i].set(millis,  i  ==  (count  -  1));  }  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<2010-01-04>  but  was:<2008-12-29>  assertEquals  (  new  LocalDate  (  2010  ,  1  ,  4  ,  chrono  )  ,  f  .  parseLocalDate  (   "2010-01-01 "  )  )  ;  [METHOD]  computeMillis  [TYPE]  long  [PARAMETER]  boolean  resetFields  String  text  [CLASS]  DateTimeParserBucket  [TYPE]  Locale  iLocale  [TYPE]  IllegalFieldValueException  e  [TYPE]  SavedField[]  iSavedFields  savedFields  [TYPE]  DateTimeField  iField  [TYPE]  String  iText  message  text  [TYPE]  long  iMillis  millis  [TYPE]  DateTimeZone  iZone  [TYPE]  int  count  i  iDefaultYear  iOffset  iSavedFieldsCount  iValue  offset  [TYPE]  Integer  iPivotYear  [TYPE]  boolean  false  iSavedFieldsShared  resetFields  true  [TYPE]  Object  iSavedState  [TYPE]  Chronology  iChrono  [TYPE]  DurationField  days  first  months  [CONTEXT]  public  long  computeMillis  (  boolean  resetFields  ,  String  text  )  {  SavedField[]  savedFields  =  iSavedFields  ;  int  count  =  iSavedFieldsCount  ;  if  (  iSavedFieldsShared  )  {  iSavedFields  =  savedFields  =  (  SavedField[]  )  iSavedFields  .  clone  (  )  ;  iSavedFieldsShared  =  false  ;  }  sort  (  savedFields  ,  count  )  ;  if  (  count  >  0  )  {  DurationField  months  =  DurationFieldType  .  months  (  )  .  getField  (  iChrono  )  ;  DurationField  days  =  DurationFieldType  .  days  (  )  .  getField  (  iChrono  )  ;  DurationField  first  =  savedFields[0]  .  iField  .  getDurationField  (  )  ;  if  (  compareReverse  (  first  ,  months  )  >  =  0  &&  compareReverse  (  first  ,  days  )  <  =  0  )  {  saveField  (  DateTimeFieldType  .  year  (  )  ,  iDefaultYear  )  ;  return  computeMillis  (  resetFields  ,  text  )  ;  }  }  long  millis  =  iMillis  ;  try  {  for  (  int  i  =  0  ;  i  <  count  ;  i++  )  {  millis  =  savedFields[i]  .  set  (  millis  ,  resetFields  )  ;  }  [BUGGY]  }  catch  (  IllegalFieldValueException  e  )  {  if  (  text  !  =  null  )  {  e  .  prependMessage  (   "Cannot  parse  \ " "  +  text  +  ' "'  )  ;  }  throw  e  ;  }  	Time_24_DateTimeParserBucket_1_1	355	0	src/main/java/org/joda/time/format/DateTimeParserBucket.java
2010	}  else  if  (offsetLocal  >  0)  {  long  prev  =  previousTransition(instantAdjusted);  if  (prev  <  instantAdjusted)  {  int  offsetPrev  =  getOffset(prev);  int  diff  =  offsetPrev  -  offsetLocal;  if  (instantAdjusted  -  prev  <=  diff)  {  return  offsetPrev;  }  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<10-28T02:30:00000+0[4]:00>  but  was:<10-28T02:30:00000+0[3]:00>  assertEquals  (   "2007-10-28T02:30:00  .  000+04:00 "  ,  dt  .  toString  (  )  )  ;  [METHOD]  getOffsetFromLocal  [TYPE]  int  [PARAMETER]  long  instantLocal  [CLASS]  DateTimeZone  [TYPE]  Set  cAvailableIDs  [TYPE]  boolean  false  true  [TYPE]  NameProvider  cNameProvider  [TYPE]  String  iID  [TYPE]  DateTimeFormatter  cOffsetFormatter  [TYPE]  Map  cZoneIdConversion  iFixedOffsetCache  [TYPE]  long  instantAdjusted  instantLocal  nextAdjusted  nextLocal  serialVersionUID  [TYPE]  DateTimeZone  UTC  cDefault  [TYPE]  int  offsetAdjusted  offsetLocal  [TYPE]  Provider  cProvider  [CONTEXT]  public  int  getOffsetFromLocal  (  long  instantLocal  )  {  final  int  offsetLocal  =  getOffset  (  instantLocal  )  ;  final  long  instantAdjusted  =  instantLocal  -  offsetLocal  ;  final  int  offsetAdjusted  =  getOffset  (  instantAdjusted  )  ;  if  (  offsetLocal  !  =  offsetAdjusted  )  {    if  (  (  offsetLocal  -  offsetAdjusted  )  <  0  )  {    long  nextLocal  =  nextTransition  (  instantAdjusted  )  ;  long  nextAdjusted  =  nextTransition  (  instantLocal  -  offsetAdjusted  )  ;  if  (  nextLocal  !  =  nextAdjusted  )  {  return  offsetLocal  ;  }  }  [BUGGY]  }  return  offsetAdjusted  ;  }  	Time_25_DateTimeZone_1_1	899	0	src/main/java/org/joda/time/DateTimeZone.java
2011	char  firstSigDigit  =  0;    for(int  i  =  pfxLen;  i  <  str.length();  i++)  {  firstSigDigit  =  str.charAt(i);\n',   "+                                if  (firstSigDigit  ==  '0')  {    }  else  {  break;  }  }  	[BUGGY]  if  (  hexDigits  >  16  )  {  if  (  hexDigits  >  8  )  {  [FE]  NumberFormatException:  For  input  string:   "80000000 "  assertEquals  (  new  BigInteger  (   "FFFFFFFFFFFFFFFF "  ,  16  )  ,  NumberUtils  .  createNumber  (   "0x0FFFFFFFFFFFFFFFF "  )  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  pfx  str  [TYPE]  String[]  hex_prefixes  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  hexDigits  numDecimals  pfxLen  [CONTEXT]  public  static  Number  createNumber  (  final  String  str  )  throws  NumberFormatException  {  if  (  str  =  =  null  )  {  return  null  ;  }  if  (  StringUtils  .  isBlank  (  str  )  )  {  throw  new  NumberFormatException  (   "A  blank  string  is  not  a  valid  number "  )  ;  }  final  String[]  hex_prefixes  =  { "0x "  ,   "0X "  ,   "-0x "  ,   "-0X "  ,   "# "  ,   "-# "}  ;  int  pfxLen  =  0  ;  for  (  final  String  pfx  :  hex_prefixes  )  {  if  (  str  .  startsWith  (  pfx  )  )  {  pfxLen  +  =  pfx  .  length  (  )  ;  break  ;  }  }  if  (  pfxLen  >  0  )  {  //  we  have  a  hex  number  [BUGGY]  final  int  hexDigits  =  str  .  length  (  )  -  pfxLen  ;  if  (  hexDigits  >  16  )  {  //  too  many  for  Long  return  createBigInteger  (  str  )  ;  }  if  (  hexDigits  >  8  )  {  //  too  many  for  an  int  return  createLong  (  str  )  ;  	Lang_1_NumberUtils_1_1	467	2	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2012	if(numDecimals  <=  7){  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  NumberUtils  .  createNumber  (  shouldBeBigDecimal  )  instanceof  BigDecimal  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  pfx  str  [TYPE]  String[]  hex_prefixes  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  hexDigits  numDecimals  pfxLen  [CONTEXT]    if  (  expPos  >  -1  &&  expPos  <  str  .  length  (  )  -  1  )  {  exp  =  str  .  substring  (  expPos  +  1  ,  str  .  length  (  )  )  ;  }  else  {  exp  =  null  ;  }  if  (  dec  =  =  null  &&  exp  =  =  null  )  {  //  no  decimal  point  and  no  exponent  try  {  return  createInteger  (  str  )  ;  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  try  {  return  createLong  (  str  )  ;  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  return  createBigInteger  (  str  )  ;  }  final  boolean  allZeros  =  isAllZeros  (  mant  )  &&  isAllZeros  (  exp  )  ;  try  {  [BUGGY]  final  Float  f  =  createFloat  (  str  )  ;  if  (  !  (  f  .  isInfinite  (  )  ||  (  f  .  floatValue  (  )  =  =  0  .  0F  &&  !allZeros  )  )  )  {  return  f  ;  }  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  	Lang_3_NumberUtils_4_1	593	0	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2013	}  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  NumberUtils  .  createNumber  (  shouldBeBigDecimal  )  instanceof  BigDecimal  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  pfx  str  [TYPE]  String[]  hex_prefixes  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  hexDigits  numDecimals  pfxLen  [CONTEXT]  }  else  {  exp  =  null  ;  }  if  (  dec  =  =  null  &&  exp  =  =  null  )  {  //  no  decimal  point  and  no  exponent  try  {  return  createInteger  (  str  )  ;  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  try  {  return  createLong  (  str  )  ;  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  return  createBigInteger  (  str  )  ;  }  final  boolean  allZeros  =  isAllZeros  (  mant  )  &&  isAllZeros  (  exp  )  ;  try  {  final  Float  f  =  createFloat  (  str  )  ;  if  (  !  (  f  .  isInfinite  (  )  ||  (  f  .  floatValue  (  )  =  =  0  .  0F  &&  !allZeros  )  )  )  {  return  f  ;  }  [BUGGY]  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  try  {  final  Double  d  =  createDouble  (  str  )  ;  if  (  !  (  d  .  isInfinite  (  )  ||  (  d  .  doubleValue  (  )  =  =  0  .  0D  &&  !allZeros  )  )  )  {  	Lang_3_NumberUtils_4_2	597	0	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2014	if(numDecimals  <=  16){  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  NumberUtils  .  createNumber  (  shouldBeBigDecimal  )  instanceof  BigDecimal  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  pfx  str  [TYPE]  String[]  hex_prefixes  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  hexDigits  numDecimals  pfxLen  [CONTEXT]  try  {  return  createInteger  (  str  )  ;  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  try  {  return  createLong  (  str  )  ;  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  return  createBigInteger  (  str  )  ;  }  final  boolean  allZeros  =  isAllZeros  (  mant  )  &&  isAllZeros  (  exp  )  ;  try  {  final  Float  f  =  createFloat  (  str  )  ;  if  (  !  (  f  .  isInfinite  (  )  ||  (  f  .  floatValue  (  )  =  =  0  .  0F  &&  !allZeros  )  )  )  {  return  f  ;  }  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  try  {  [BUGGY]  final  Double  d  =  createDouble  (  str  )  ;  if  (  !  (  d  .  isInfinite  (  )  ||  (  d  .  doubleValue  (  )  =  =  0  .  0D  &&  !allZeros  )  )  )  {  return  d  ;  }  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  	Lang_3_NumberUtils_4_3	601	0	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2015	}  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  NumberUtils  .  createNumber  (  shouldBeBigDecimal  )  instanceof  BigDecimal  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  pfx  str  [TYPE]  String[]  hex_prefixes  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  hexDigits  numDecimals  pfxLen  [CONTEXT]  }  try  {  return  createLong  (  str  )  ;  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  return  createBigInteger  (  str  )  ;  }  final  boolean  allZeros  =  isAllZeros  (  mant  )  &&  isAllZeros  (  exp  )  ;  try  {  final  Float  f  =  createFloat  (  str  )  ;  if  (  !  (  f  .  isInfinite  (  )  ||  (  f  .  floatValue  (  )  =  =  0  .  0F  &&  !allZeros  )  )  )  {  return  f  ;  }  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  try  {  final  Double  d  =  createDouble  (  str  )  ;  if  (  !  (  d  .  isInfinite  (  )  ||  (  d  .  doubleValue  (  )  =  =  0  .  0D  &&  !allZeros  )  )  )  {  return  d  ;  }  [BUGGY]  }  catch  (  final  NumberFormatException  nfe  )  {  //  NOPMD  }  return  createBigDecimal  (  str  )  ;  }  	Lang_3_NumberUtils_4_4	605	0	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2016	private  final  HashMap<String,  CharSequence>  lookupMap;  	[BUGGY]  private  final  HashMap<CharSequence  ,  CharSequence>  lookupMap  ;  [FE]  AssertionFailedError:  Incorrect  codepoint  consumption  expected:<3>  but  was:<0>  assertEquals  (   "Incorrect  value "  ,   "two "  ,  out  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Lang_4_LookupTranslator_4_1	31	1	src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java
2017	lookupMap  =  new  HashMap<String,  CharSequence>();  	[BUGGY]  lookupMap  =  new  HashMap<CharSequence  ,  CharSequence>  (  )  ;  [FE]  AssertionFailedError:  Incorrect  codepoint  consumption  expected:<3>  but  was:<0>  assertEquals  (   "Incorrect  value "  ,   "two "  ,  out  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Lang_4_LookupTranslator_4_2	46	1	src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java
2018	this.lookupMap.put(seq[0].toString(),  seq[1]);  	[BUGGY]  this  .  lookupMap  .  put  (  seq[0]  ,  seq[1]  )  ;  [FE]  AssertionFailedError:  Incorrect  codepoint  consumption  expected:<3>  but  was:<0>  assertEquals  (   "Incorrect  value "  ,   "two "  ,  out  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Lang_4_LookupTranslator_4_3	51	1	src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java
2019	final  CharSequence  result  =  lookupMap.get(subSeq.toString());  	[BUGGY]  final  CharSequence  result  =  lookupMap  .  get  (  subSeq  )  ;  [FE]  AssertionFailedError:  Incorrect  codepoint  consumption  expected:<3>  but  was:<0>  assertEquals  (   "Incorrect  value "  ,   "two "  ,  out  .  toString  (  )  )  ;  [METHOD]  translate  [TYPE]  int  [PARAMETER]  CharSequence  input  final  int  index  Writer  out  [CLASS]  LookupTranslator  [TYPE]  CharSequence  input  result  subSeq  [TYPE]  boolean  false  true  [TYPE]  HashMap  lookupMap  [TYPE]  int  i  index  longest  max  shortest  [TYPE]  Writer  out  [CONTEXT]  public  int  translate  (  final  CharSequence  input  ,  final  int  index  ,  final  Writer  out  )  throws  IOException  {  int  max  =  longest  ;  if  (  index  +  longest  >  input  .  length  (  )  )  {  max  =  input  .  length  (  )  -  index  ;  }  for  (  int  i  =  max  ;  i  >  =  shortest  ;  i--  )  {  final  CharSequence  subSeq  =  input  .  subSequence  (  index  ,  index  +  i  )  ;  [BUGGY]  final  CharSequence  result  =  lookupMap  .  get  (  subSeq  )  ;  if  (  result  !  =  null  )  {  out  .  write  (  result  .  toString  (  )  )  ;  return  i  ;  }  }  return  0  ;  }  	Lang_4_LookupTranslator_4_4	77	1	src/main/java/org/apache/commons/lang3/text/translate/LookupTranslator.java
2020	throw  new  IllegalArgumentException( "Invalid  locale  format:   "  +  str);  }  final  char  ch1  =  str.charAt(1);  final  char  ch2  =  str.charAt(2);  if  (!Character.isUpperCase(ch1)  ||  !Character.isUpperCase(ch2))  {  throw  new  IllegalArgumentException( "Invalid  locale  format:   "  +  str);  }  if  (len  ==  3)  {  return  new  Locale( " ",  str.substring(1,  3));  }  if  (len  <  5)  {  throw  new  IllegalArgumentException( "Invalid  locale  format:   "  +  str);  }\n',   "+                        if  (str.charAt(3)  !=  '_')  {\n ",  '+                                throw  new  IllegalArgumentException( "Invalid  locale  format:   "  +  str);  }  return  new  Locale( " ",  str.substring(1,  3),  str.substring(4));  }  else  {  	[BUGGY]  [FE]  IllegalArgumentException:  Invalid  locale  format:  _GB  assertValidToLocale  (   "_GB_POSIX "  ,   " "  ,   "GB "  ,   "POSIX "  )  ;  [METHOD]  toLocale  [TYPE]  Locale  [PARAMETER]  String  str  [CLASS]  LocaleUtils  [TYPE]  Set  AVAILABLE_LOCALE_SET  [TYPE]  boolean  false  true  [TYPE]  ConcurrentMap  cCountriesByLanguage  cLanguagesByCountry  [TYPE]  char  ch0  ch1  ch3  ch4  [TYPE]  List  AVAILABLE_LOCALE_LIST  [TYPE]  String  str  [TYPE]  int  len  [CONTEXT]  public  static  Locale  toLocale  (  final  String  str  )  {  if  (  str  =  =  null  )  {  return  null  ;  }  final  int  len  =  str  .  length  (  )  ;  if  (  len  <  2  )  {  throw  new  IllegalArgumentException  (   "Invalid  locale  format:   "  +  str  )  ;  }  final  char  ch0  =  str  .  charAt  (  0  )  ;  [BUGGY]  final  char  ch1  =  str  .  charAt  (  1  )  ;  if  (  !Character  .  isLowerCase  (  ch0  )  ||  !Character  .  isLowerCase  (  ch1  )  )  {  throw  new  IllegalArgumentException  (   "Invalid  locale  format:   "  +  str  )  ;  }  if  (  len  =  =  2  )  {  return  new  Locale  (  str  )  ;  	Lang_5_LocaleUtils_2_1	97	0	src/main/java/org/apache/commons/lang3/LocaleUtils.java
2021	}  	[BUGGY]  [FE]  IllegalArgumentException:  Invalid  locale  format:  _GB  assertValidToLocale  (   "_GB_POSIX "  ,   " "  ,   "GB "  ,   "POSIX "  )  ;  [CLASS]  [CONTEXT]  	Lang_5_LocaleUtils_2_2	128	0	src/main/java/org/apache/commons/lang3/LocaleUtils.java
2022	pos  +=  Character.charCount(Character.codePointAt(input,  pt));  	[BUGGY]  pos  +  =  Character  .  charCount  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  2  assertEquals  (   "\uDBFF\uDFFD "  ,  StringEscapeUtils  .  escapeCsv  (   "\uDBFF\uDFFD "  )  )  ;  [METHOD]  translate  [TYPE]  void  [PARAMETER]  CharSequence  input  Writer  out  [CLASS]  CharSequenceTranslator  [TYPE]  boolean  false  true  [TYPE]  CharSequence  input  [TYPE]  Writer  out  [TYPE]  int  consumed  len  pos  pt  [TYPE]  char[]  c  [CONTEXT]  public  final  void  translate  (  CharSequence  input  ,  Writer  out  )  throws  IOException  {  if  (  out  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  Writer  must  not  be  null "  )  ;  }  if  (  input  =  =  null  )  {  return  ;  }  int  pos  =  0  ;  int  len  =  input  .  length  (  )  ;  while  (  pos  <  len  )  {  int  consumed  =  translate  (  input  ,  pos  ,  out  )  ;  if  (  consumed  =  =  0  )  {  char[]  c  =  Character  .  toChars  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  out  .  write  (  c  )  ;  pos+  =  c  .  length  ;  continue  ;  }    for  (  int  pt  =  0  ;  pt  <  consumed  ;  pt++  )  {  [BUGGY]  pos  +  =  Character  .  charCount  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  }  }  }  	Lang_6_CharSequenceTranslator_1_1	95	1	src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
2023		[BUGGY]  if  (  str  .  startsWith  (   "-- "  )  )  {   [FE]  AssertionFailedError:  Expected  NumberFormatException  NumberUtils.createNumber("--1.1E-700F"); fail("Expected NumberFormatException");  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  hexDigits  [CONTEXT]  public  static  Number  createNumber  (  String  str  )  throws  NumberFormatException  {  if  (  str  =  =  null  )  {  return  null  ;  }  if  (  StringUtils  .  isBlank  (  str  )  )  {  throw  new  NumberFormatException  (   "A  blank  string  is  not  a  valid  number "  )  ;  }  [BUGGY]  if  (  str  .  startsWith  (   "-- "  )  )  {  return  null  ;  }  if  (  str  .  startsWith  (   "0x "  )  ||  str  .  startsWith  (   "-0x "  )  ||  str  .  startsWith  (   "0X "  )  ||  str  .  startsWith  (   "-0X "  )  )  {  int  hexDigits  =  str  .  length  (  )  -  2  ;  //  drop  0x  if  (  str  .  startsWith  (   "- "  )  )  {    	Lang_7_NumberUtils_2_1	452	1	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2024	if  (str.trim().startsWith( "-- "))  {  throw new NumberFormatException(str + " is not a valid number.") } 	[BUGGY]  [FE]  AssertionFailedError:  Expected  NumberFormatException NumberUtils.createNumber("--1.1E-700F"); fail("Expected NumberFormatException");   [METHOD]  createBigDecimal  [TYPE]  BigDecimal  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  [TYPE]  boolean  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  String  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [CONTEXT]  public  static  BigDecimal  createBigDecimal  (  String  str  )  {  if  (  str  =  =  null  )  {  return  null  ;  }  if  (  StringUtils  .  isBlank  (  str  )  )  {  throw  new  NumberFormatException  (   "A  blank  string  is  not  a  valid  number "  )  ;  }  [BUGGY]      return  new  BigDecimal  (  str  )  ;  }  	Lang_7_NumberUtils_2_2	721	0	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2026		[BUGGY]  private  final  TimeZone  zone  ;  [FE]  AssertionFailedError:  expected:<2:43PM  [IC]T>  but  was:<2:43PM  [PS]T>  [CLASS]  [CONTEXT]  	Lang_8_FastDatePrinter_3_1	1098	1	src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java
2027		[BUGGY]  zone  =  timeZone  ;  [FE]  AssertionFailedError:  expected:<2:43PM  [IC]T>  but  was:<2:43PM  [PS]T>  [CLASS]  [CONTEXT]  	Lang_8_FastDatePrinter_3_2	1112	1	src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java
2028	TimeZone  zone  =  calendar.getTimeZone();  	[BUGGY]  [FE]  AssertionFailedError:  expected:<2:43PM  [IC]T>  but  was:<2:43PM  [PS]T>  [METHOD]  appendTo  [TYPE]  void  [PARAMETER]  StringBuffer  buffer  Calendar  calendar  [CLASS]  TimeZoneNameRule  [TYPE]  Locale  mLocale  [TYPE]  TimeZone  zone  [TYPE]  StringBuffer  buffer  [TYPE]  boolean  false  true  [TYPE]  Calendar  calendar  [TYPE]  String  mDaylight  mStandard  [TYPE]  int  mStyle  [CONTEXT]  public  void  appendTo  (  StringBuffer  buffer  ,  Calendar  calendar  )  {  [BUGGY]  if  (  zone  .  useDaylightTime  (  )  &&  calendar  .  get  (  Calendar  .  DST_OFFSET  )  !  =  0  )  {  buffer  .  append  (  getTimeZoneDisplay  (  zone  ,  true  ,  mStyle  ,  mLocale  )  )  ;  }  else  {  buffer  .  append  (  getTimeZoneDisplay  (  zone  ,  false  ,  mStyle  ,  mLocale  )  )  ;  }  }  	Lang_8_FastDatePrinter_3_3	1134	0	src/main/java/org/apache/commons/lang3/time/FastDatePrinter.java
2029	if  (patternMatcher.regionStart()  !=  patternMatcher.regionEnd())  {  throw  new  IllegalArgumentException( "Failed  to  parse  \\ " "+pattern+ "\\ "  ;  gave  up  at  index   "+patternMatcher.regionStart());  }  	[BUGGY]  [FE]  AssertionFailedError:  Parsed  dates  should  be  equal  expected:<null>  but  was:<Fri  Jan  02  21:00:00  PST  1970>  [METHOD]  init  [TYPE]  void  [PARAMETER]  [CLASS]  FastDateParser  [TYPE]  Locale  JAPANESE_IMPERIAL  locale  [TYPE]  Pattern  formatPattern  parsePattern  [TYPE]  StringBuilder  regex  [TYPE]  Matcher  patternMatcher  [TYPE]  ConcurrentMap  nameValues  tzsCache  [TYPE]  String  currentFormatField  formatField  key  nextFormatField  pattern  validTimeZoneChars  [TYPE]  long  serialVersionUID  [TYPE]  int  field  thisYear  value  [TYPE]  Comparator  IGNORE_CASE_COMPARATOR  [TYPE]  TimeZone  timeZone  [TYPE]  Strategy[]  strategies  [TYPE]  boolean  false  true  [TYPE]  SortedMap  tzNames  [TYPE]  Strategy  ABBREVIATED_YEAR_STRATEGY  AM_PM_STRATEGY  DAY_OF_MONTH_STRATEGY  DAY_OF_WEEK_IN_MONTH_STRATEGY  DAY_OF_WEEK_STRATEGY  DAY_OF_YEAR_STRATEGY  ERA_STRATEGY  HOUR_OF_DAY_STRATEGY  HOUR_STRATEGY  LITERAL_YEAR_STRATEGY  MILLISECOND_STRATEGY  MINUTE_STRATEGY  MODULO_HOUR_OF_DAY_STRATEGY  MODULO_HOUR_STRATEGY  NUMBER_MONTH_STRATEGY  SECOND_STRATEGY  TEXT_MONTH_STRATEGY  WEEK_OF_MONTH_STRATEGY  WEEK_OF_YEAR_STRATEGY  currentStrategy  nextStrategy  [TYPE]  List  collector  [CONTEXT]  StringBuilder  regex  =  new  StringBuilder  (  )  ;  List<Strategy>  collector  =  new  ArrayList<Strategy>  (  )  ;  Matcher  patternMatcher  =  formatPattern  .  matcher  (  pattern  )  ;  if  (  !patternMatcher  .  lookingAt  (  )  )  {  throw  new  IllegalArgumentException  (   "Invalid  pattern "  )  ;  }  currentFormatField  =  patternMatcher  .  group  (  )  ;  Strategy  currentStrategy  =  getStrategy  (  currentFormatField  )  ;  for  (  ;  ;  )  {  patternMatcher  .  region  (  patternMatcher  .  end  (  )  ,  patternMatcher  .  regionEnd  (  )  )  ;  if  (  !patternMatcher  .  lookingAt  (  )  )  {  nextStrategy  =  null  ;  break  ;  }  String  nextFormatField  =  patternMatcher  .  group  (  )  ;  nextStrategy  =  getStrategy  (  nextFormatField  )  ;  if  (  currentStrategy  .  addRegex  (  this  ,  regex  )  )  {  collector  .  add  (  currentStrategy  )  ;  }  currentFormatField  =  nextFormatField  ;  currentStrategy  =  nextStrategy  ;  }  [BUGGY]  if  (  currentStrategy  .  addRegex  (  this  ,  regex  )  )  {  collector  .  add  (  currentStrategy  )  ;  }  currentFormatField  =  null  ;  strategies  =  collector  .  toArray  (  new  Strategy[collector  .  size  (  )  ]  )  ;  parsePattern  =  Pattern  .  compile  (  regex  .  toString  (  )  )  ;  	Lang_9_FastDateParser_1_1	144	0	src/main/java/org/apache/commons/lang3/time/FastDateParser.java
2030	boolean  wasWhite  =  true  ;	[BUGGY]  boolean  wasWhite  =  false  ;  [FE]  AssertionFailedError:  Parsed  dates  should  be  equal  expected:<null>  but  was:<Mon  Mar  02  21:00:00  PST  1970>  [METHOD]  escapeRegex  [TYPE]  StringBuilder  [PARAMETER]  StringBuilder  regex  String  value  boolean  unquote  [CLASS]  FastDateParser  [TYPE]  Locale  JAPANESE_IMPERIAL  locale  [TYPE]  Pattern  formatPattern  parsePattern  [TYPE]  StringBuilder  regex  [TYPE]  ConcurrentMap  nameValues  tzsCache  [TYPE]  String  currentFormatField  formatField  key  pattern  validTimeZoneChars  value  [TYPE]  long  serialVersionUID  [TYPE]  int  field  i  thisYear  value  [TYPE]  Comparator  IGNORE_CASE_COMPARATOR  [TYPE]  TimeZone  timeZone  [TYPE]  Strategy[]  strategies  [TYPE]  boolean  false  true  unquote  wasWhite  [TYPE]  SortedMap  tzNames  [TYPE]  char  c  [TYPE]  Strategy  ABBREVIATED_YEAR_STRATEGY  AM_PM_STRATEGY  DAY_OF_MONTH_STRATEGY  DAY_OF_WEEK_IN_MONTH_STRATEGY  DAY_OF_WEEK_STRATEGY  DAY_OF_YEAR_STRATEGY  ERA_STRATEGY  HOUR_OF_DAY_STRATEGY  HOUR_STRATEGY  LITERAL_YEAR_STRATEGY  MILLISECOND_STRATEGY  MINUTE_STRATEGY  MODULO_HOUR_OF_DAY_STRATEGY  MODULO_HOUR_STRATEGY  NUMBER_MONTH_STRATEGY  SECOND_STRATEGY  TEXT_MONTH_STRATEGY  WEEK_OF_MONTH_STRATEGY  WEEK_OF_YEAR_STRATEGY  nextStrategy  [CONTEXT]  private  static  StringBuilder  escapeRegex  (  StringBuilder  regex  ,  String  value  ,  boolean  unquote  )  {  [BUGGY]  boolean  wasWhite  =  false  ;  for  (  int  i  =  0  ;  i<value  .  length  (  )  ;  ++i  )  {  char  c  =  value  .  charAt  (  i  )  ;  if  (  Character  .  isWhitespace  (  c  )  )  {  if  (  !wasWhite  )  {  wasWhite  =  true  ;  	Lang_10_FastDateParser_1_1	304	1	src/main/java/org/apache/commons/lang3/time/FastDateParser.java
2031	}  else  {  if  (end  <=  start)  {  throw  new  IllegalArgumentException( "Parameter  end  ( "  +  end  +   ")  must  be  greater  than  start  ( "  +  start  +   ") ");  }  	[BUGGY]  [FE]  AssertionFailedError:  Message  (  bound  must  be  positive  )  must  contain  'start'  assertTrue  (   "Message  (   "  +  msg  +   "  )  must  contain  'end' "  ,  msg  .  contains  (   "end "  )  )  ;  [METHOD]  random  [TYPE]  String  [PARAMETER]  int  count  int  start  int  end  boolean  letters  boolean  numbers  char[]  chars  Random  random  [CLASS]  RandomStringUtils  [TYPE]  char  ch  [TYPE]  boolean  false  letters  numbers  true  [TYPE]  Random  RANDOM  random  [TYPE]  int  count  end  gap  start  [TYPE]  char[]  buffer  chars  [CONTEXT]  public  static  String  random  (  int  count  ,  int  start  ,  int  end  ,  boolean  letters  ,  boolean  numbers  ,  char[]  chars  ,  Random  random  )  {  if  (  count  =  =  0  )  {  return   " "  ;  }  else  if  (  count  <  0  )  {  throw  new  IllegalArgumentException  (   "Requested  random  string  length   "  +  count  +   "  is  less  than  0  .   "  )  ;  }  if  (  chars  !  =  null  &&  chars  .  length  =  =  0  )  {  throw  new  IllegalArgumentException  (   "The  chars  array  must  not  be  empty "  )  ;  }  if  (  start  =  =  0  &&  end  =  =  0  )  {  if  (  chars  !  =  null  )  {  end  =  chars  .  length  ;  }  else  {  if  (  !letters  &&  !numbers  )  {  end  =  Integer  .  MAX_VALUE  ;  }  else  {  end  =  'z'  +  1  ;  start  =  '  '  ;  }  }  [BUGGY]  }  char[]  buffer  =  new  char[count]  ;  int  gap  =  end  -  start  ;  while  (  count--  !  =  0  )  {  	Lang_11_RandomStringUtils_1_1	245	0	src/main/java/org/apache/commons/lang3/RandomStringUtils.java
2032	if  (chars  !=  null  &&  chars.length  ==  0)  {  throw  new  IllegalArgumentException( "The  chars  array  must  not  be  empty ");  }  if  (chars  !=  null)  {  end  =  chars.length;  }  else  {  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  1171399597  [METHOD]  random  [TYPE]  String  [PARAMETER]  int  count  int  start  int  end  boolean  letters  boolean  numbers  char[]  chars  Random  random  [CLASS]  RandomStringUtils  [TYPE]  char  ch  [TYPE]  boolean  false  letters  numbers  true  [TYPE]  Random  RANDOM  random  [TYPE]  int  count  end  gap  start  [TYPE]  char[]  buffer  chars  [CONTEXT]  public  static  String  random  (  int  count  ,  int  start  ,  int  end  ,  boolean  letters  ,  boolean  numbers  ,  char[]  chars  ,  Random  random  )  {  if  (  count  =  =  0  )  {  return   " "  ;  }  else  if  (  count  <  0  )  {  throw  new  IllegalArgumentException  (   "Requested  random  string  length   "  +  count  +   "  is  less  than  0  .   "  )  ;  }  [BUGGY]  if  (  start  =  =  0  &&  end  =  =  0  )  {  if  (  !letters  &&  !numbers  )  {  end  =  Integer  .  MAX_VALUE  ;  }  else  {  end  =  'z'  +  1  ;  	Lang_12_RandomStringUtils_2_1	230	0	src/main/java/org/apache/commons/lang3/RandomStringUtils.java
2033	}  	[BUGGY]  [FE]  ArrayIndexOutOfBoundsException:  1171399597  [METHOD]  random  [TYPE]  String  [PARAMETER]  int  count  int  start  int  end  boolean  letters  boolean  numbers  char[]  chars  Random  random  [CLASS]  RandomStringUtils  [TYPE]  char  ch  [TYPE]  boolean  false  letters  numbers  true  [TYPE]  Random  RANDOM  random  [TYPE]  int  count  end  gap  start  [TYPE]  char[]  buffer  chars  [CONTEXT]  public  static  String  random  (  int  count  ,  int  start  ,  int  end  ,  boolean  letters  ,  boolean  numbers  ,  char[]  chars  ,  Random  random  )  {  if  (  count  =  =  0  )  {  return   " "  ;  }  else  if  (  count  <  0  )  {  throw  new  IllegalArgumentException  (   "Requested  random  string  length   "  +  count  +   "  is  less  than  0  .   "  )  ;  }  if  (  start  =  =  0  &&  end  =  =  0  )  {  if  (  !letters  &&  !numbers  )  {  end  =  Integer  .  MAX_VALUE  ;  }  else  {  end  =  'z'  +  1  ;  start  =  '  '  ;  }  [BUGGY]  }  char[]  buffer  =  new  char[count]  ;  int  gap  =  end  -  start  ;  while  (  count--  !  =  0  )  {  	Lang_12_RandomStringUtils_2_2	238	0	src/main/java/org/apache/commons/lang3/RandomStringUtils.java
2034	private  static  final  Map<String,  Class<?>>  primitiveTypes  =  new  HashMap<String,  Class<?>>();  	[BUGGY]  [FE]  commonslang3SerializationException:  ClassNotFoundException  while  reading  cloned  object  data  assertEquals  (  primitiveType  ,  clone  )  ;  [CLASS]  [CONTEXT]  	Lang_13_SerializationUtils_3_1	239	0	src/main/java/org/apache/commons/lang3/SerializationUtils.java
2035	primitiveTypes.put( "byte ",  byte.class);  primitiveTypes.put( "short ",  short.class);  primitiveTypes.put( "int ",  int.class);  primitiveTypes.put( "long ",  long.class);  primitiveTypes.put( "float ",  float.class);  primitiveTypes.put( "double ",  double.class);  primitiveTypes.put( "boolean ",  boolean.class);  primitiveTypes.put( "char ",  char.class);  primitiveTypes.put( "void ",  void.class);  	[BUGGY]  [FE]  commonslang3SerializationException:  ClassNotFoundException  while  reading  cloned  object  data  assertEquals  (  primitiveType  ,  clone  )  ;  [CLASS]  [CONTEXT]  	Lang_13_SerializationUtils_3_2	252	0	src/main/java/org/apache/commons/lang3/SerializationUtils.java
2036	try  {  }  catch  (ClassNotFoundException  cnfe)  {  Class<?>  cls  =  primitiveTypes.get(name);  if  (cls  !=  null)  return  cls;  else  throw  cnfe;  }  	[BUGGY]  [FE]  commonslang3SerializationException:  ClassNotFoundException  while  reading  cloned  object  data  assertEquals  (  primitiveType  ,  clone  )  ;  [METHOD]  resolveClass  [TYPE]  Class  [PARAMETER]  ObjectStreamClass  desc  [CLASS]  ClassLoaderAwareObjectInputStream  [TYPE]  ClassLoader  classLoader  [TYPE]  String  name  [TYPE]  boolean  false  true  [TYPE]  ObjectStreamClass  desc  [TYPE]  ClassNotFoundException  ex  [CONTEXT]  protected  Class<?>  resolveClass  (  ObjectStreamClass  desc  )  throws  IOException  ,  ClassNotFoundException  {  String  name  =  desc  .  getName  (  )  ;  try  {  return  Class  .  forName  (  name  ,  false  ,  classLoader  )  ;  }  catch  (  ClassNotFoundException  ex  )  {  [BUGGY]  return  Class  .  forName  (  name  ,  false  ,  Thread  .  currentThread  (  )  .  getContextClassLoader  (  )  )  ;  }  }  	Lang_13_SerializationUtils_3_3	268	0	src/main/java/org/apache/commons/lang3/SerializationUtils.java
2037	if  (cs1  instanceof  String  &&  cs2  instanceof  String)  {  }  return  CharSequenceUtils.regionMatches(cs1,  false,  0,  cs2,  0,  Math.max(cs1.length(),  cs2.length()));  	[BUGGY]  [FE]  AssertionFailedError  assertEquals  (  false  ,  StringUtils  .  equalsIgnoreCase  (  null  ,  FOO  )  )  ;  [METHOD]  equals  [TYPE]  boolean  [PARAMETER]  CharSequence  cs1  CharSequence  cs2  [CLASS]  StringUtils  [TYPE]  Pattern  WHITESPACE_BLOCK  java6Pattern  sunPattern  [TYPE]  boolean  false  true  [TYPE]  CharSequence  cs1  cs2  [TYPE]  Throwable  java6Exception  sunException  [TYPE]  Object  java6NormalizerFormNFD  [TYPE]  String  EMPTY  [TYPE]  Method  java6NormalizeMethod  sunDecomposeMethod  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  [CONTEXT]  public  static  boolean  equals  (  CharSequence  cs1  ,  CharSequence  cs2  )  {  if  (  cs1  =  =  cs2  )  {  return  true  ;  }  if  (  cs1  =  =  null  ||  cs2  =  =  null  )  {  return  false  ;  }  [BUGGY]  return  cs1  .  equals  (  cs2  )  ;  }  	Lang_14_StringUtils_1_1	788	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2038	for  (TypeVariable<?>  var  :  toTypeVarAssigns.keySet())  {  Type  toTypeArg  =  unrollVariableAssignments(var,  toTypeVarAssigns);  Type  fromTypeArg  =  unrollVariableAssignments(var,  fromTypeVarAssigns);  	[BUGGY]  for  (  Map  .  Entry<TypeVariable<?>  ,  Type>  entry  :  toTypeVarAssigns  .  entrySet  (  )  )  {  Type  toTypeArg  =  entry  .  getValue  (  )  ;  Type  fromTypeArg  =  fromTypeVarAssigns  .  get  (  entry  .  getKey  (  )  )  ;  [FE]  AssertionFailedError:  expected:<2>  but  was:<0>  Assert  .  assertEquals  (  Other  .  class  .  getTypeParameters  (  )  [0]  ,  typeVarAssigns  .  get  (  This  .  class  .  getTypeParameters  (  )  [1]  )  )  ;  [METHOD]  isAssignable  [TYPE]  boolean  [PARAMETER]  Type  type  ParameterizedType  toParameterizedType  Type>  typeVarAssigns  [CLASS]  TypeUtils  [TYPE]  ParameterizedType  toParameterizedType  [TYPE]  Type  fromTypeArg  toTypeArg  type  [TYPE]  Entry  entry  [TYPE]  boolean  false  true  [TYPE]  Class  toClass  [TYPE]  Map  fromTypeVarAssigns  toTypeVarAssigns  typeVarAssigns  [CONTEXT]  }  Class<?>  toClass  =  getRawType  (  toParameterizedType  )  ;    Map<TypeVariable<?>  ,  Type>  fromTypeVarAssigns  =  getTypeArguments  (  type  ,  toClass  ,  null  )  ;    if  (  fromTypeVarAssigns  =  =  null  )  {  return  false  ;  }    if  (  fromTypeVarAssigns  .  isEmpty  (  )  )  {  return  true  ;  }  Map<TypeVariable<?>  ,  Type>  toTypeVarAssigns  =  getTypeArguments  (  toParameterizedType  ,  toClass  ,  typeVarAssigns  )  ;    [BUGGY]  for  (  Map  .  Entry<TypeVariable<?>  ,  Type>  entry  :  toTypeVarAssigns  .  entrySet  (  )  )  {  Type  toTypeArg  =  entry  .  getValue  (  )  ;  Type  fromTypeArg  =  fromTypeVarAssigns  .  get  (  entry  .  getKey  (  )  )  ;    	Lang_15_TypeUtils_2_1	219	3	src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java
2039	if  (toClass.equals(cls))  {  	[BUGGY]  if  (  cls  .  getTypeParameters  (  )  .  length  >  0  ||  toClass  .  equals  (  cls  )  )  {  [FE]  AssertionFailedError:  expected:<2>  but  was:<0>  Assert  .  assertEquals  (  Other  .  class  .  getTypeParameters  (  )  [0]  ,  typeVarAssigns  .  get  (  This  .  class  .  getTypeParameters  (  )  [1]  )  )  ;  [METHOD]  getTypeArguments  [TYPE]  Map  [PARAMETER]  Class<?>  cls  Class<?>  toClass  Type>  subtypeVarAssigns  [CLASS]  TypeUtils  [TYPE]  boolean  false  true  [TYPE]  HashMap  typeVarAssigns  [TYPE]  Class  cls  toClass  [TYPE]  Map  subtypeVarAssigns  [CONTEXT]  private  static  Map<TypeVariable<?>  ,  Type>  getTypeArguments  (  Class<?>  cls  ,  Class<?>  toClass  ,  Map<TypeVariable<?>  ,  Type>  subtypeVarAssigns  )  {  if  (  !isAssignable  (  cls  ,  toClass  )  )  {  return  null  ;  }  if  (  cls  .  isPrimitive  (  )  )  {  if  (  toClass  .  isPrimitive  (  )  )  {    return  new  HashMap<TypeVariable<?>  ,  Type>  (  )  ;  }  cls  =  ClassUtils  .  primitiveToWrapper  (  cls  )  ;  }  HashMap<TypeVariable<?>  ,  Type>  typeVarAssigns  =  subtypeVarAssigns  =  =  null  ?  new  HashMap<TypeVariable<?>  ,  Type>  (  )  :  new  HashMap<TypeVariable<?>  ,  Type>  (  subtypeVarAssigns  )  ;    [BUGGY]  if  (  cls  .  getTypeParameters  (  )  .  length  >  0  ||  toClass  .  equals  (  cls  )  )  {  return  typeVarAssigns  ;  }  return  getTypeArguments  (  getClosestParentType  (  cls  ,  toClass  )  ,  toClass  ,  typeVarAssigns  )  ;  	Lang_15_TypeUtils_2_2	675	1	src/main/java/org/apache/commons/lang3/reflect/TypeUtils.java
2040	if  (str.startsWith( "0x ")  ||  str.startsWith( "-0x ")  ||  str.startsWith( "0X ")  ||  str.startsWith( "-0X "))  {  	[BUGGY]  if  (  str  .  startsWith  (   "0x "  )  ||  str  .  startsWith  (   "-0x "  )  )  {  [FE]  NumberFormatException:  0Xfade  is  not  a  valid  number  assertEquals  (   "createNumber  (  String  )  LANG-693  failed "  ,  Double  .  valueOf  (  Double  .  MAX_VALUE  )  ,  NumberUtils  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  [CONTEXT]  public  static  Number  createNumber  (  String  str  )  throws  NumberFormatException  {  if  (  str  =  =  null  )  {  return  null  ;  }  if  (  StringUtils  .  isBlank  (  str  )  )  {  throw  new  NumberFormatException  (   "A  blank  string  is  not  a  valid  number "  )  ;  }  if  (  str  .  startsWith  (   "-- "  )  )  {      return  null  ;  }  [BUGGY]  if  (  str  .  startsWith  (   "0x "  )  ||  str  .  startsWith  (   "-0x "  )  )  {  return  createInteger  (  str  )  ;  }  char  lastChar  =  str  .  charAt  (  str  .  length  (  )  -  1  )  ;  String  mant  ;  String  dec  ;  	Lang_16_NumberUtils_1_1	458	1	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2041	int  len  =  input.length();  	[BUGGY]  int  len  =  Character  .  codePointCount  (  input  ,  0  ,  input  .  length  (  )  )  ;  [FE]  ComparisonFailure:  expected:<  assertEquals  (  input  ,  escaped  )  ;  [METHOD]  translate  [TYPE]  void  [PARAMETER]  CharSequence  input  Writer  out  [CLASS]  CharSequenceTranslator  [TYPE]  boolean  false  true  [TYPE]  CharSequence  input  [TYPE]  Writer  out  [TYPE]  int  consumed  len  pos  pt  [TYPE]  char[]  c  [CONTEXT]  public  final  void  translate  (  CharSequence  input  ,  Writer  out  )  throws  IOException  {  if  (  out  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  Writer  must  not  be  null "  )  ;  }  if  (  input  =  =  null  )  {  return  ;  }  int  pos  =  0  ;  [BUGGY]  int  len  =  Character  .  codePointCount  (  input  ,  0  ,  input  .  length  (  )  )  ;  while  (  pos  <  len  )  {  int  consumed  =  translate  (  input  ,  pos  ,  out  )  ;  if  (  consumed  =  =  0  )  {  char[]  c  =  Character  .  toChars  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  out  .  write  (  c  )  ;  }  else  {    for  (  int  pt  =  0  ;  pt  <  consumed  ;  pt++  )  {  if  (  pos  <  len  -  2  )  {  pos  +  =  Character  .  charCount  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  }  else  {  pos++  ;  }  }  pos--  ;  }  pos++  ;  }  }  	Lang_17_CharSequenceTranslator_3_1	83	1	src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
2042	pos+=  c.length;  continue;  	[BUGGY]  else  {  [FE]  ComparisonFailure:  expected:<  assertEquals  (  input  ,  escaped  )  ;  [METHOD]  translate  [TYPE]  void  [PARAMETER]  CharSequence  input  Writer  out  [CLASS]  CharSequenceTranslator  [TYPE]  boolean  false  true  [TYPE]  CharSequence  input  [TYPE]  Writer  out  [TYPE]  int  consumed  len  pos  pt  [TYPE]  char[]  c  [CONTEXT]  public  final  void  translate  (  CharSequence  input  ,  Writer  out  )  throws  IOException  {  if  (  out  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  Writer  must  not  be  null "  )  ;  }  if  (  input  =  =  null  )  {  return  ;  }  int  pos  =  0  ;  int  len  =  Character  .  codePointCount  (  input  ,  0  ,  input  .  length  (  )  )  ;  while  (  pos  <  len  )  {  int  consumed  =  translate  (  input  ,  pos  ,  out  )  ;  if  (  consumed  =  =  0  )  {  char[]  c  =  Character  .  toChars  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  out  .  write  (  c  )  ;  [BUGGY]  }  else  {    for  (  int  pt  =  0  ;  pt  <  consumed  ;  pt++  )  {  if  (  pos  <  len  -  2  )  {  pos  +  =  Character  .  charCount  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  }  else  {  pos++  ;  }  }  pos--  ;  }  pos++  ;  }  }  	Lang_17_CharSequenceTranslator_3_2	89	1	src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
2043		[BUGGY]  if  (  pos  <  len  -  2  )  {  }  else  {  pos++  ;  }  }  pos--  ;  pos++  ;  [FE]  ComparisonFailure:  expected:<  assertEquals  (  input  ,  escaped  )  ;  [METHOD]  translate  [TYPE]  void  [PARAMETER]  CharSequence  input  Writer  out  [CLASS]  CharSequenceTranslator  [TYPE]  boolean  false  true  [TYPE]  CharSequence  input  [TYPE]  Writer  out  [TYPE]  int  consumed  len  pos  pt  [TYPE]  char[]  c  [CONTEXT]  public  final  void  translate  (  CharSequence  input  ,  Writer  out  )  throws  IOException  {  if  (  out  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  Writer  must  not  be  null "  )  ;  }  if  (  input  =  =  null  )  {  return  ;  }  int  pos  =  0  ;  int  len  =  Character  .  codePointCount  (  input  ,  0  ,  input  .  length  (  )  )  ;  while  (  pos  <  len  )  {  int  consumed  =  translate  (  input  ,  pos  ,  out  )  ;  if  (  consumed  =  =  0  )  {  char[]  c  =  Character  .  toChars  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  out  .  write  (  c  )  ;  }  else  {    for  (  int  pt  =  0  ;  pt  <  consumed  ;  pt++  )  {  [BUGGY]  if  (  pos  <  len  -  2  )  {  pos  +  =  Character  .  charCount  (  Character  .  codePointAt  (  input  ,  pos  )  )  ;  }  else  {  pos++  ;  }  }  pos--  ;  }  pos++  ;  }  }  	Lang_17_CharSequenceTranslator_3_3	94	7	src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java
2044	if  (tokenLen  ==  2)  {  }  else  {  rule  =  selectNumberRule(Calendar.YEAR,  tokenLen  <  4  ?  4  :  tokenLen);  	[BUGGY]  rule  =  selectNumberRule  (  Calendar  .  YEAR  ,  tokenLen  )  ;  }  else  {  [FE]  ComparisonFailure:  expected:<AD  AD  AD  AD  2003  [2003  03  20]03  January  Jan  01  1  >  but  was:<AD  AD  AD  AD  2003  [03  03  ]03  January  Jan  01  1  >  assertEquals  (  sdf  .  format  (  date2  )  .  replaceAll  (   "2003  03  03  03 "  ,   "2003  2003  03  2003 "  )  ,  fdf  .  format  (  date2  )  )  ;  [METHOD]  parsePattern  [TYPE]  List  [PARAMETER]  [CLASS]  FastDateFormat  [TYPE]  Locale  mLocale  [TYPE]  TimeZoneNumberRule  INSTANCE_COLON  INSTANCE_NO_COLON  [TYPE]  ConcurrentMap  cTimeZoneDisplayCache  [TYPE]  TwoDigitYearField  INSTANCE  [TYPE]  int[]  indexRef  [TYPE]  String  mDaylight  mPattern  mStandard  mValue  sub  token  [TYPE]  String[]  AmPmStrings  ERAs  mValues  months  shortMonths  shortWeekdays  weekdays  [TYPE]  FormatCache  cache  [TYPE]  long  serialVersionUID  [TYPE]  int  FULL  LONG  MEDIUM  SHORT  i  length  mField  mMaxLengthEstimate  mSize  mStyle  tokenLen  [TYPE]  Rule[]  mRules  [TYPE]  TimeZone  mTimeZone  [TYPE]  boolean  false  mColon  true  [TYPE]  NumberRule  mRule  [TYPE]  char  c  mValue  [TYPE]  TwoDigitMonthField  INSTANCE  [TYPE]  UnpaddedMonthField  INSTANCE  [TYPE]  DateFormatSymbols  symbols  [TYPE]  List  rules  [TYPE]  Rule  rule  [CONTEXT]  String[]  weekdays  =  symbols  .  getWeekdays  (  )  ;  String[]  shortWeekdays  =  symbols  .  getShortWeekdays  (  )  ;  String[]  AmPmStrings  =  symbols  .  getAmPmStrings  (  )  ;  int  length  =  mPattern  .  length  (  )  ;  int[]  indexRef  =  new  int[1]  ;  for  (  int  i  =  0  ;  i  <  length  ;  i++  )  {  indexRef[0]  =  i  ;  String  token  =  parseToken  (  mPattern  ,  indexRef  )  ;  i  =  indexRef[0]  ;  int  tokenLen  =  token  .  length  (  )  ;  if  (  tokenLen  =  =  0  )  {  break  ;  }  Rule  rule  ;  char  c  =  token  .  charAt  (  0  )  ;  switch  (  c  )  {  case  'G':  //  era  designator  (  text  )  rule  =  new  TextField  (  Calendar  .  ERA  ,  ERAs  )  ;  break  ;  case  'y':  //  year  (  number  )  [BUGGY]  if  (  tokenLen  >  =  4  )  {  rule  =  selectNumberRule  (  Calendar  .  YEAR  ,  tokenLen  )  ;  }  else  {  rule  =  TwoDigitYearField  .  INSTANCE  ;  }  break  ;  	Lang_18_FastDateFormat_1_1	495	2	src/main/java/org/apache/commons/lang3/time/FastDateFormat.java
2045		[BUGGY]  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  19  assertEquals  (   "Failed  to  support  unfinished  entities  (  i  .  e  .  missing  semi-colon "  ,  expected  ,  result  )  ;  [METHOD]  translate  [TYPE]  int  [PARAMETER]  CharSequence  input  int  index  Writer  out  [CLASS]  NumericEntityUnescaper  [TYPE]  boolean  false  isHex  true  [TYPE]  CharSequence  input  [TYPE]  char  firstChar  [TYPE]  NumberFormatException  nfe  [TYPE]  int  end  entityValue  index  seqEnd  start  [TYPE]  Writer  out  [TYPE]  char[]  chrs  [CONTEXT]  public  int  translate  (  CharSequence  input  ,  int  index  ,  Writer  out  )  throws  IOException  {  int  seqEnd  =  input  .  length  (  )  ;  [BUGGY]  if  (  input  .  charAt  (  index  )  =  =  '&'  &&  index  <  seqEnd  -  1  &&  input  .  charAt  (  index  +  1  )  =  =  '#'  )  {  int  start  =  index  +  2  ;  boolean  isHex  =  false  ;  char  firstChar  =  input  .  charAt  (  start  )  ;  if  (  firstChar  =  =  'x'  ||  firstChar  =  =  'X'  )  {  	Lang_19_NumericEntityUnescaper_4_1	40	0	src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
2046	return  0;  }  	[BUGGY]  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  19  assertEquals  (   "Failed  to  support  unfinished  entities  (  i  .  e  .  missing  semi-colon "  ,  expected  ,  result  )  ;  [METHOD]  translate  [TYPE]  int  [PARAMETER]  CharSequence  input  int  index  Writer  out  [CLASS]  NumericEntityUnescaper  [TYPE]  boolean  false  isHex  true  [TYPE]  CharSequence  input  [TYPE]  char  firstChar  [TYPE]  NumberFormatException  nfe  [TYPE]  int  end  entityValue  index  seqEnd  start  [TYPE]  Writer  out  [TYPE]  char[]  chrs  [CONTEXT]  public  int  translate  (  CharSequence  input  ,  int  index  ,  Writer  out  )  throws  IOException  {  int  seqEnd  =  input  .  length  (  )  ;  if  (  input  .  charAt  (  index  )  =  =  '&'  &&  index  <  seqEnd  -  1  &&  input  .  charAt  (  index  +  1  )  =  =  '#'  )  {  int  start  =  index  +  2  ;  boolean  isHex  =  false  ;  char  firstChar  =  input  .  charAt  (  start  )  ;  if  (  firstChar  =  =  'x'  ||  firstChar  =  =  'X'  )  {  start++  ;  isHex  =  true  ;    [BUGGY]  }  int  end  =  start  ;  while  (  input  .  charAt  (  end  )  !  =  '  ;  '  )  {  	Lang_19_NumericEntityUnescaper_4_2	50	0	src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
2047		[BUGGY]  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  19  assertEquals  (   "Failed  to  support  unfinished  entities  (  i  .  e  .  missing  semi-colon "  ,  expected  ,  result  )  ;  [METHOD]  translate  [TYPE]  int  [PARAMETER]  CharSequence  input  int  index  Writer  out  [CLASS]  NumericEntityUnescaper  [TYPE]  boolean  false  isHex  true  [TYPE]  CharSequence  input  [TYPE]  char  firstChar  [TYPE]  NumberFormatException  nfe  [TYPE]  int  end  entityValue  index  seqEnd  start  [TYPE]  Writer  out  [TYPE]  char[]  chrs  [CONTEXT]  public  int  translate  (  CharSequence  input  ,  int  index  ,  Writer  out  )  throws  IOException  {  int  seqEnd  =  input  .  length  (  )  ;  if  (  input  .  charAt  (  index  )  =  =  '&'  &&  index  <  seqEnd  -  1  &&  input  .  charAt  (  index  +  1  )  =  =  '#'  )  {  int  start  =  index  +  2  ;  boolean  isHex  =  false  ;  char  firstChar  =  input  .  charAt  (  start  )  ;  if  (  firstChar  =  =  'x'  ||  firstChar  =  =  'X'  )  {  start++  ;  isHex  =  true  ;    }  int  end  =  start  ;  [BUGGY]  while  (  input  .  charAt  (  end  )  !  =  '  ;  '  )  {  end++  ;  }  int  entityValue  ;  	Lang_19_NumericEntityUnescaper_4_3	54	0	src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
2048	return  2  +  (end  -  start)  +  (isHex  ?  1  :  0)  +  (semiNext  ?  1  :  0);  	[BUGGY]  return  2  +  (  end  -  start  )  +  (  isHex  ?  1  :  0  )  +  1  ;  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  19  assertEquals  (   "Failed  to  support  unfinished  entities  (  i  .  e  .  missing  semi-colon "  ,  expected  ,  result  )  ;  [METHOD]  translate  [TYPE]  int  [PARAMETER]  CharSequence  input  int  index  Writer  out  [CLASS]  NumericEntityUnescaper  [TYPE]  boolean  false  isHex  true  [TYPE]  CharSequence  input  [TYPE]  char  firstChar  [TYPE]  NumberFormatException  nfe  [TYPE]  int  end  entityValue  index  seqEnd  start  [TYPE]  Writer  out  [TYPE]  char[]  chrs  [CONTEXT]  while  (  input  .  charAt  (  end  )  !  =  '  ;  '  )  {  end++  ;  }  int  entityValue  ;  try  {  if  (  isHex  )  {  entityValue  =  Integer  .  parseInt  (  input  .  subSequence  (  start  ,  end  )  .  toString  (  )  ,  16  )  ;  }  else  {  entityValue  =  Integer  .  parseInt  (  input  .  subSequence  (  start  ,  end  )  .  toString  (  )  ,  10  )  ;  }  }  catch  (  NumberFormatException  nfe  )  {  System  .  err  .  println  (   "FAIL:   "  +  input  .  subSequence  (  start  ,  end  )  +   "[ "  +  start  + "][ "+  end  + "] "  )  ;  return  0  ;  }  if  (  entityValue  >  0xFFFF  )  {  char[]  chrs  =  Character  .  toChars  (  entityValue  )  ;  out  .  write  (  chrs[0]  )  ;  out  .  write  (  chrs[1]  )  ;  }  else  {  out  .  write  (  entityValue  )  ;  }  [BUGGY]  return  2  +  (  end  -  start  )  +  (  isHex  ?  1  :  0  )  +  1  ;  }  return  0  ;  }  }  	Lang_19_NumericEntityUnescaper_4_4	79	1	src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
2049	StringBuilder  buf  =  new  StringBuilder(noOfItems  *  16);  	[BUGGY]  StringBuilder  buf  =  new  StringBuilder  (  (  array[startIndex]  =  =  null  ?  16  :  array[startIndex]  .  toString  (  )  .  length  (  )  )  +  1  )  ;  [FE]  NullPointerException  assertEquals  (   " "  ,  StringUtils  .  join  (  MIXED_TYPE_LIST  ,  '/'  ,  2  ,  1  )  )  ;  [METHOD]  join  [TYPE]  String  [PARAMETER]  Object[]  array  char  separator  int  startIndex  int  endIndex  [CLASS]  StringUtils  [TYPE]  Pattern  WHITESPACE_BLOCK  java6Pattern  sunPattern  [TYPE]  boolean  false  java6Available  sunAvailable  true  [TYPE]  StringBuilder  buf  [TYPE]  char  separator  [TYPE]  Object  java6NormalizerFormNFD  [TYPE]  String  EMPTY  [TYPE]  Method  java6NormalizeMethod  sunDecomposeMethod  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  endIndex  i  noOfItems  startIndex  [TYPE]  Object[]  array  [CONTEXT]  public  static  String  join  (  Object[]  array  ,  char  separator  ,  int  startIndex  ,  int  endIndex  )  {  if  (  array  =  =  null  )  {  return  null  ;  }  int  noOfItems  =  (  endIndex  -  startIndex  )  ;  if  (  noOfItems  <  =  0  )  {  return  EMPTY  ;  }  [BUGGY]  StringBuilder  buf  =  new  StringBuilder  (  (  array[startIndex]  =  =  null  ?  16  :  array[startIndex]  .  toString  (  )  .  length  (  )  )  +  1  )  ;  for  (  int  i  =  startIndex  ;  i  <  endIndex  ;  i++  )  {  if  (  i  >  startIndex  )  {  buf  .  append  (  separator  )  ;  }  if  (  array[i]  !  =  null  )  {  buf  .  append  (  array[i]  )  ;  }  }  return  buf  .  toString  (  )  ;  }  	Lang_20_StringUtils_2_1	3298	1	src/main/java/org/apache/commons/lang3/StringUtils.java
2050	StringBuilder  buf  =  new  StringBuilder(noOfItems  *  16);  	[BUGGY]  StringBuilder  buf  =  new  StringBuilder  (  (  array[startIndex]  =  =  null  ?  16  :  array[startIndex]  .  toString  (  )  .  length  (  )  )  +  separator  .  length  (  )  )  ;  [FE]  NullPointerException  assertEquals  (   " "  ,  StringUtils  .  join  (  MIXED_TYPE_LIST  ,  '/'  ,  2  ,  1  )  )  ;  [METHOD]  join  [TYPE]  String  [PARAMETER]  Object[]  array  String  separator  int  startIndex  int  endIndex  [CLASS]  StringUtils  [TYPE]  Pattern  WHITESPACE_BLOCK  java6Pattern  sunPattern  [TYPE]  boolean  false  java6Available  sunAvailable  true  [TYPE]  StringBuilder  buf  [TYPE]  Object  java6NormalizerFormNFD  [TYPE]  String  EMPTY  separator  [TYPE]  Method  java6NormalizeMethod  sunDecomposeMethod  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  endIndex  i  noOfItems  startIndex  [TYPE]  Object[]  array  [CONTEXT]  public  static  String  join  (  Object[]  array  ,  String  separator  ,  int  startIndex  ,  int  endIndex  )  {  if  (  array  =  =  null  )  {  return  null  ;  }  if  (  separator  =  =  null  )  {  separator  =  EMPTY  ;  }    int  noOfItems  =  (  endIndex  -  startIndex  )  ;  if  (  noOfItems  <  =  0  )  {  return  EMPTY  ;  }  [BUGGY]  StringBuilder  buf  =  new  StringBuilder  (  (  array[startIndex]  =  =  null  ?  16  :  array[startIndex]  .  toString  (  )  .  length  (  )  )  +  separator  .  length  (  )  )  ;  for  (  int  i  =  startIndex  ;  i  <  endIndex  ;  i++  )  {  if  (  i  >  startIndex  )  {  buf  .  append  (  separator  )  ;  }  if  (  array[i]  !  =  null  )  {  buf  .  append  (  array[i]  )  ;  }  }  return  buf  .  toString  (  )  ;  }  	Lang_20_StringUtils_2_2	3383	1	src/main/java/org/apache/commons/lang3/StringUtils.java
2051	cal1.get(Calendar.HOUR_OF_DAY)  ==  cal2.get(Calendar.HOUR_OF_DAY)  &&  	[BUGGY]  cal1  .  get  (  Calendar  .  HOUR  )  =  =  cal2  .  get  (  Calendar  .  HOUR  )  &&  [FE]  AssertionFailedError:  LANG-677  assertEquals  (  false  ,  DateUtils  .  isSameLocalTime  (  cal1  ,  cal2  )  )  ;  [METHOD]  isSameLocalTime  [TYPE]  boolean  [PARAMETER]  Calendar  cal1  Calendar  cal2  [CLASS]  DateUtils  [TYPE]  TimeZone  UTC_TIME_ZONE  [TYPE]  int[][]  fields  [TYPE]  boolean  false  true  [TYPE]  long  MILLIS_PER_DAY  MILLIS_PER_HOUR  MILLIS_PER_MINUTE  MILLIS_PER_SECOND  [TYPE]  int  MODIFY_CEILING  MODIFY_ROUND  MODIFY_TRUNCATE  RANGE_MONTH_MONDAY  RANGE_MONTH_SUNDAY  RANGE_WEEK_CENTER  RANGE_WEEK_MONDAY  RANGE_WEEK_RELATIVE  RANGE_WEEK_SUNDAY  SEMI_MONTH  [TYPE]  Calendar  cal1  cal2  endFinal  spot  [CONTEXT]  public  static  boolean  isSameLocalTime  (  Calendar  cal1  ,  Calendar  cal2  )  {  if  (  cal1  =  =  null  ||  cal2  =  =  null  )  {  throw  new  IllegalArgumentException  (   "The  date  must  not  be  null "  )  ;  }  return  (  cal1  .  get  (  Calendar  .  MILLISECOND  )  =  =  cal2  .  get  (  Calendar  .  MILLISECOND  )  &&  cal1  .  get  (  Calendar  .  SECOND  )  =  =  cal2  .  get  (  Calendar  .  SECOND  )  &&  cal1  .  get  (  Calendar  .  MINUTE  )  =  =  cal2  .  get  (  Calendar  .  MINUTE  )  &&  [BUGGY]  cal1  .  get  (  Calendar  .  HOUR  )  =  =  cal2  .  get  (  Calendar  .  HOUR  )  &&  cal1  .  get  (  Calendar  .  DAY_OF_YEAR  )  =  =  cal2  .  get  (  Calendar  .  DAY_OF_YEAR  )  &&  cal1  .  get  (  Calendar  .  YEAR  )  =  =  cal2  .  get  (  Calendar  .  YEAR  )  &&  cal1  .  get  (  Calendar  .  ERA  )  =  =  cal2  .  get  (  Calendar  .  ERA  )  &&  cal1  .  getClass  (  )  =  =  cal2  .  getClass  (  )  )  ;  }  	Lang_21_DateUtils_1_1	265	1	src/main/java/org/apache/commons/lang3/time/DateUtils.java
2052	if  ((u  ==  0)  ||  (v  ==  0))  {  if  ((u  ==  Integer.MIN_VALUE)  ||  (v  ==  Integer.MIN_VALUE))  {  throw  new  ArithmeticException( "overflow:  gcd  is  2^31 ");  }  return  Math.abs(u)  +  Math.abs(v);  }  if  (Math.abs(u)  ==  1  ||  Math.abs(v)  ==  1)  {  	[BUGGY]  if  (  Math  .  abs  (  u  )  <  =  1  ||  Math  .  abs  (  v  )  <  =  1  )  {  [FE]  AssertionFailedError:  expected:<-1073741824>  but  was:<-2147483648>  assertEquals  (  1  ,  f  .  getDenominator  (  )  )  ;  [METHOD]  greatestCommonDivisor  [TYPE]  int  [PARAMETER]  int  u  int  v  [CLASS]  Fraction  [TYPE]  Fraction  FOUR_FIFTHS  ONE  ONE_FIFTH  ONE_HALF  ONE_QUARTER  ONE_THIRD  THREE_FIFTHS  THREE_QUARTERS  TWO_FIFTHS  TWO_QUARTERS  TWO_THIRDS  ZERO  [TYPE]  String  toProperString  toString  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  denominator  hashCode  k  numerator  t  u  v  [CONTEXT]  private  static  int  greatestCommonDivisor  (  int  u  ,  int  v  )  {  [BUGGY]  if  (  Math  .  abs  (  u  )  <  =  1  ||  Math  .  abs  (  v  )  <  =  1  )  {  return  1  ;  }    	Lang_22_Fraction_1_1	583	1	src/main/java/org/apache/commons/lang3/math/Fraction.java
2053	private  static  final  int  HASH_SEED  =  31;  	[BUGGY]  [FE]  AssertionFailedError:  registry  ,  hashcode  (  )  assertEquals  (  message  ,  expected  ,  actual  )  ;  [CLASS]  [CONTEXT]  	Lang_23_ExtendedMessageFormat_3_1	73	0	src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
2054	@Override  public  boolean  equals(Object  obj)  {  if  (obj  ==  this)  {  return  true;  }  if  (obj  ==  null)  {  return  false;  }  if  (!super.equals(obj))  {  return  false;  }  if  (ObjectUtils.notEqual(getClass(),  obj.getClass()))  {  return  false;  }  ExtendedMessageFormat  rhs  =  (ExtendedMessageFormat)obj;  if  (ObjectUtils.notEqual(toPattern,  rhs.toPattern))  {  return  false;  }  if  (ObjectUtils.notEqual(registry,  rhs.registry))  {  return  false;  }  return  true;  }  	[BUGGY]  [FE]  AssertionFailedError:  registry  ,  hashcode  (  )  assertEquals  (  message  ,  expected  ,  actual  )  ;  [CLASS]  [CONTEXT]  	Lang_23_ExtendedMessageFormat_3_2	263	0	src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
2055	@Override  public  int  hashCode()  {  int  result  =  super.hashCode();  result  =  HASH_SEED  *  result  +  ObjectUtils.hashCode(registry);  result  =  HASH_SEED  *  result  +  ObjectUtils.hashCode(toPattern);  return  result;  }  	[BUGGY]  [FE]  AssertionFailedError:  registry  ,  hashcode  (  )  assertEquals  (  message  ,  expected  ,  actual  )  ;  [CLASS]  [CONTEXT]  	Lang_23_ExtendedMessageFormat_3_3	269	0	src/main/java/org/apache/commons/lang3/text/ExtendedMessageFormat.java
2056	return  foundDigit  &&  !hasExp  &&  !hasDecPoint;  	[BUGGY]  return  foundDigit  &&  !hasExp  ;  [FE]  AssertionFailedError:  isNumber  (  String  )  LANG-664  failed  assertFalse  (   "isNumber  (  String  )  LANG-664  failed "  ,  NumberUtils  .  isNumber  (  val  )  )  ;  [METHOD]  isNumber  [TYPE]  boolean  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  [TYPE]  boolean  allowSigns  false  foundDigit  hasDecPoint  hasExp  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  String  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  i  start  sz  [TYPE]  char[]  chars  [CONTEXT]  return  true  ;  }  if  (  chars[i]  =  =  'e'  ||  chars[i]  =  =  'E'  )  {  return  false  ;  }  if  (  chars[i]  =  =  '  .  '  )  {  if  (  hasDecPoint  ||  hasExp  )  {  return  false  ;  }  return  foundDigit  ;  }  if  (  !allowSigns  &&  (  chars[i]  =  =  'd'  ||  chars[i]  =  =  'D'  ||  chars[i]  =  =  'f'  ||  chars[i]  =  =  'F'  )  )  {  return  foundDigit  ;  }  if  (  chars[i]  =  =  'l'  ||  chars[i]  =  =  'L'  )  {  [BUGGY]  return  foundDigit  &&  !hasExp  ;  }  return  false  ;  }  	Lang_24_NumberUtils_1_1	1413	1	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2057	{ "\\u00CA ",   "&Ecirc; "},    { "\\u00CB ",   "&Euml; "},    { "\\u00CC ",   "&Igrave; "},    { "\\u00CD ",   "&Iacute; "},    { "\\u00CE ",   "&Icirc; "},    { "\\u00CF ",   "&Iuml; "},    { "\\u00D0 ",   "&ETH; "},    { "\\u00D1 ",   "&Ntilde; "},    { "\\u00D2 ",   "&Ograve; "},    { "\\u00D3 ",   "&Oacute; "},    { "\\u00D4 ",   "&Ocirc; "},    { "\\u00D5 ",   "&Otilde; "},    { "\\u00D6 ",   "&Ouml; "},    { "\\u00D7 ",   "&times; "},    { "\\u00D8 ",   "&Oslash; "},    { "\\u00D9 ",   "&Ugrave; "},    { "\\u00DA ",   "&Uacute; "},    { "\\u00DB ",   "&Ucirc; "},    { "\\u00DC ",   "&Uuml; "},    { "\\u00DD ",   "&Yacute; "},    { "\\u00DE ",   "&THORN; "},    { "\\u00DF ",   "&szlig; "},    { "\\u00E0 ",   "&agrave; "},    { "\\u00E1 ",   "&aacute; "},    { "\\u00E2 ",   "&acirc; "},    { "\\u00E3 ",   "&atilde; "},    { "\\u00E4 ",   "&auml; "},    	[BUGGY]  { "\\u00CB "  ,   "&Ecirc  ;   "}  ,  { "\\u00CC "  ,   "&Euml  ;   "}  ,  { "\\u00CD "  ,   "&Igrave  ;   "}  ,  { "\\u00CE "  ,   "&Iacute  ;   "}  ,  { "\\u00CF "  ,   "&Icirc  ;   "}  ,  { "\\u00D0 "  ,   "&Iuml  ;   "}  ,  { "\\u00D1 "  ,   "&ETH  ;   "}  ,  { "\\u00D2 "  ,   "&Ntilde  ;   "}  ,  { "\\u00D3 "  ,   "&Ograve  ;   "}  ,  { "\\u00D4 "  ,   "&Oacute  ;   "}  ,  { "\\u00D5 "  ,   "&Ocirc  ;   "}  ,  { "\\u00D6 "  ,   "&Otilde  ;   "}  ,  { "\\u00D7 "  ,   "&Ouml  ;   "}  ,  { "\\u00D8 "  ,   "&times  ;   "}  ,  { "\\u00D9 "  ,   "&Oslash  ;   "}  ,  { "\\u00DA "  ,   "&Ugrave  ;   "}  ,  { "\\u00DB "  ,   "&Uacute  ;   "}  ,  { "\\u00DC "  ,   "&Ucirc  ;   "}  ,  { "\\u00DD "  ,   "&Uuml  ;   "}  ,  { "\\u00DE "  ,   "&Yacute  ;   "}  ,  { "\\u00DF "  ,   "&THORN  ;   "}  ,  { "\\u00E0 "  ,   "&szlig  ;   "}  ,  { "\\u00E1 "  ,   "&agrave  ;   "}  ,  { "\\u00E2 "  ,   "&aacute  ;   "}  ,  { "\\u00E3 "  ,   "&acirc  ;   "}  ,  { "\\u00E4 "  ,   "&atilde  ;   "}  ,  { "\\u00E5 "  ,   "&auml  ;   "}  ,  [FE]  AssertionFailedError:  One  or  more  errors  detected  assertTrue  (   "One  or  more  errors  detected "  ,  success  )  ;  [CLASS]  [CONTEXT]  	Lang_25_EntityArrays_1_1	74	27	src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java
2058	Calendar  c  =  new  GregorianCalendar(mTimeZone,  mLocale);  	[BUGGY]  Calendar  c  =  new  GregorianCalendar  (  mTimeZone  )  ;  [FE]  ComparisonFailure:  expected:<fredag  ,  week  [53]>  but  was:<fredag  ,  week  [01]>  assertEquals  (   "fredag  ,  week  53 "  ,  fdf  .  format  (  d  )  )  ;  [METHOD]  format  [TYPE]  String  [PARAMETER]  Date  date  [CLASS]  FastDateFormat  [TYPE]  Locale  mLocale  [TYPE]  TimeZoneNumberRule  INSTANCE_COLON  INSTANCE_NO_COLON  [TYPE]  Calendar  c  [TYPE]  TwoDigitYearField  INSTANCE  [TYPE]  String  cDefaultPattern  mDaylight  mPattern  mStandard  mValue  [TYPE]  String[]  mValues  [TYPE]  long  serialVersionUID  [TYPE]  int  FULL  LONG  MEDIUM  SHORT  mField  mMaxLengthEstimate  mSize  mStyle  [TYPE]  Rule[]  mRules  [TYPE]  Date  date  [TYPE]  TimeZone  mTimeZone  [TYPE]  boolean  false  mColon  mLocaleForced  mTimeZoneForced  true  [TYPE]  NumberRule  mRule  [TYPE]  char  mValue  [TYPE]  TwoDigitMonthField  INSTANCE  [TYPE]  UnpaddedMonthField  INSTANCE  [TYPE]  Object  mObj1  mObj2  [TYPE]  Map  cDateInstanceCache  cDateTimeInstanceCache  cInstanceCache  cTimeInstanceCache  cTimeZoneDisplayCache  [CONTEXT]  public  String  format  (  Date  date  )  {  [BUGGY]  Calendar  c  =  new  GregorianCalendar  (  mTimeZone  )  ;  c  .  setTime  (  date  )  ;  return  applyRules  (  c  ,  new  StringBuffer  (  mMaxLengthEstimate  )  )  .  toString  (  )  ;  }  	Lang_26_FastDateFormat_1_1	820	1	src/main/java/org/apache/commons/lang3/time/FastDateFormat.java
2059	if  (expPos  <  decPos  ||  expPos  >  str.length())  {  	[BUGGY]  if  (  expPos  <  decPos  )  {  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  4  assertFalse  (   "createNumber  (  String  )  succeeded "  ,  checkCreateNumber  (   "1eE "  )  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  [CONTEXT]  return  null  ;  }  if  (  StringUtils  .  isBlank  (  str  )  )  {  throw  new  NumberFormatException  (   "A  blank  string  is  not  a  valid  number "  )  ;  }  if  (  str  .  startsWith  (   "-- "  )  )  {      return  null  ;  }  if  (  str  .  startsWith  (   "0x "  )  ||  str  .  startsWith  (   "-0x "  )  )  {  return  createInteger  (  str  )  ;  }  char  lastChar  =  str  .  charAt  (  str  .  length  (  )  -  1  )  ;  String  mant  ;  String  dec  ;  String  exp  ;  int  decPos  =  str  .  indexOf  (  '  .  '  )  ;  int  expPos  =  str  .  indexOf  (  'e'  )  +  str  .  indexOf  (  'E'  )  +  1  ;  if  (  decPos  >  -1  )  {  if  (  expPos  >  -1  )  {  [BUGGY]  if  (  expPos  <  decPos  )  {  throw  new  NumberFormatException  (  str  +   "  is  not  a  valid  number  .   "  )  ;  }  dec  =  str  .  substring  (  decPos  +  1  ,  expPos  )  ;  }  else  {  dec  =  str  .  substring  (  decPos  +  1  )  ;  	Lang_27_NumberUtils_2_1	479	1	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2060	if  (expPos  >  str.length())  {  throw  new  NumberFormatException(str  +   "  is  not  a  valid  number. ");  }  	[BUGGY]  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  4  assertFalse  (   "createNumber  (  String  )  succeeded "  ,  checkCreateNumber  (   "1eE "  )  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  [CONTEXT]  return  null  ;  }  if  (  str  .  startsWith  (   "0x "  )  ||  str  .  startsWith  (   "-0x "  )  )  {  return  createInteger  (  str  )  ;  }  char  lastChar  =  str  .  charAt  (  str  .  length  (  )  -  1  )  ;  String  mant  ;  String  dec  ;  String  exp  ;  int  decPos  =  str  .  indexOf  (  '  .  '  )  ;  int  expPos  =  str  .  indexOf  (  'e'  )  +  str  .  indexOf  (  'E'  )  +  1  ;  if  (  decPos  >  -1  )  {  if  (  expPos  >  -1  )  {  if  (  expPos  <  decPos  )  {  throw  new  NumberFormatException  (  str  +   "  is  not  a  valid  number  .   "  )  ;  }  dec  =  str  .  substring  (  decPos  +  1  ,  expPos  )  ;  }  else  {  dec  =  str  .  substring  (  decPos  +  1  )  ;  }  mant  =  str  .  substring  (  0  ,  decPos  )  ;  }  else  {  if  (  expPos  >  -1  )  {  [BUGGY]  mant  =  str  .  substring  (  0  ,  expPos  )  ;  }  else  {  mant  =  str  ;  }  dec  =  null  ;  }  	Lang_27_NumberUtils_2_2	489	0	src/main/java/org/apache/commons/lang3/math/NumberUtils.java
2061	if(entityValue  >  0xFFFF)  {  char[]  chrs  =  Character.toChars(entityValue);  out.write(chrs[0]);  out.write(chrs[1]);  }  else  {  }  	[BUGGY]  [FE]  ComparisonFailure:  Failed  to  unescape  numeric  entities  supplementary  characters  expected:<[  assertEquals  (   "Failed  to  unescape  numeric  entities  supplementary  characters "  ,  expected  ,  result  )  ;  [METHOD]  translate  [TYPE]  int  [PARAMETER]  CharSequence  input  int  index  Writer  out  [CLASS]  NumericEntityUnescaper  [TYPE]  boolean  false  isHex  true  [TYPE]  CharSequence  input  [TYPE]  char  firstChar  [TYPE]  NumberFormatException  nfe  [TYPE]  int  end  entityValue  index  start  [TYPE]  Writer  out  [CONTEXT]  int  start  =  index  +  2  ;  boolean  isHex  =  false  ;  char  firstChar  =  input  .  charAt  (  start  )  ;  if  (  firstChar  =  =  'x'  ||  firstChar  =  =  'X'  )  {  start++  ;  isHex  =  true  ;  }  int  end  =  start  ;  while  (  input  .  charAt  (  end  )  !  =  '  ;  '  )  {  end++  ;  }  int  entityValue  ;  try  {  if  (  isHex  )  {  entityValue  =  Integer  .  parseInt  (  input  .  subSequence  (  start  ,  end  )  .  toString  (  )  ,  16  )  ;  }  else  {  entityValue  =  Integer  .  parseInt  (  input  .  subSequence  (  start  ,  end  )  .  toString  (  )  ,  10  )  ;  }  }  catch  (  NumberFormatException  nfe  )  {  return  0  ;  }  [BUGGY]  out  .  write  (  entityValue  )  ;  return  2  +  (  end  -  start  )  +  (  isHex  ?  1  :  0  )  +  1  ;  }  return  0  ;  }  }  	Lang_28_NumericEntityUnescaper_1_1	63	0	src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java
2062	static  int  toJavaVersionInt(String  version)  {  	[BUGGY]  static  float  toJavaVersionInt  (  String  version  )  {  [FE]  AssertionFailedError:  expected:<0>  but  was:<00>  assertEquals  (  130  ,  SystemUtils  .  toJavaVersionInt  (   "XXX-1  .  3  .  x "  )  )  ;  [CLASS]  [CONTEXT]  	Lang_29_SystemUtils_1_1	1672	1	src/main/java/org/apache/commons/lang3/SystemUtils.java
2063	int  csLast  =  csLen  -  1;  int  searchLast  =  searchLen  -  1;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  indexOfAny  [TYPE]  int  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLen  i  j  searchLen  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  int  indexOfAny  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  isEmpty  (  cs  )  ||  ArrayUtils  .  isEmpty  (  searchChars  )  )  {  return  INDEX_NOT_FOUND  ;  }  int  csLen  =  cs  .  length  (  )  ;  [BUGGY]  int  searchLen  =  searchChars  .  length  ;  for  (  int  i  =  0  ;  i  <  csLen  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLen  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {  return  i  ;  }  }  }  return  INDEX_NOT_FOUND  ;  }  	Lang_30_StringUtils_10_1	1376	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2064	if  (i  <  csLast  &&  j  <  searchLast  &&  Character.isHighSurrogate(ch))  {  if  (searchChars[j  +  1]  ==  cs.charAt(i  +  1))  {  return  i;  }  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  indexOfAny  [TYPE]  int  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLen  i  j  searchLen  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  int  indexOfAny  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  isEmpty  (  cs  )  ||  ArrayUtils  .  isEmpty  (  searchChars  )  )  {  return  INDEX_NOT_FOUND  ;  }  int  csLen  =  cs  .  length  (  )  ;  int  searchLen  =  searchChars  .  length  ;  for  (  int  i  =  0  ;  i  <  csLen  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLen  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {  [BUGGY]  return  i  ;  }  }  }  return  INDEX_NOT_FOUND  ;  }  	Lang_30_StringUtils_10_2	1381	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2065	public  static  boolean  containsAny(String  cs,  char[]  searchChars)  {  	[BUGGY]  public  static  boolean  containsAny  (  CharSequence  cs  ,  char[]  searchChars  )  {  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Lang_30_StringUtils_10_3	1443	1	src/main/java/org/apache/commons/lang3/StringUtils.java
2066	if  (Character.isHighSurrogate(ch))  {  if  (j  ==  searchLast)  {  return  true;  }  if  (i  <  csLast  &&  searchChars[j  +  1]  ==  cs.charAt(i  +  1))  {  	[BUGGY]  if  (  i  <  csLast  &&  j  <  searchLast  &&  ch  >  =  Character  .  MIN_HIGH_SURROGATE  &&  ch  <  =  Character  .  MAX_HIGH_SURROGATE  )  {  if  (  searchChars[j  +  1]  =  =  cs  .  charAt  (  i  +  1  )  )  {  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  containsAny  [TYPE]  boolean  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLast  csLength  i  j  searchLast  searchLength  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  boolean  containsAny  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  isEmpty  (  cs  )  ||  ArrayUtils  .  isEmpty  (  searchChars  )  )  {  return  false  ;  }  int  csLength  =  cs  .  length  (  )  ;  int  searchLength  =  searchChars  .  length  ;  int  csLast  =  csLength  -  1  ;  int  searchLast  =  searchLength  -  1  ;  for  (  int  i  =  0  ;  i  <  csLength  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLength  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {  [BUGGY]  if  (  i  <  csLast  &&  j  <  searchLast  &&  ch  >  =  Character  .  MIN_HIGH_SURROGATE  &&  ch  <  =  Character  .  MAX_HIGH_SURROGATE  )  {  if  (  searchChars[j  +  1]  =  =  cs  .  charAt  (  i  +  1  )  )  {  return  true  ;  }  }  else  {  return  true  ;  }  }  }  }  return  false  ;  }  	Lang_30_StringUtils_10_4	1455	2	src/main/java/org/apache/commons/lang3/StringUtils.java
2067	public  static  boolean  containsAny(String  cs,  String  searchChars)  {  	[BUGGY]  public  static  boolean  containsAny  (  CharSequence  cs  ,  String  searchChars  )  {  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Lang_30_StringUtils_10_5	1497	1	src/main/java/org/apache/commons/lang3/StringUtils.java
2068	int  csLast  =  csLen  -  1;  int  searchLast  =  searchLen  -  1;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  indexOfAnyBut  [TYPE]  int  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLen  i  j  searchLen  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  int  indexOfAnyBut  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  isEmpty  (  cs  )  ||  ArrayUtils  .  isEmpty  (  searchChars  )  )  {  return  INDEX_NOT_FOUND  ;  }  int  csLen  =  cs  .  length  (  )  ;  [BUGGY]  int  searchLen  =  searchChars  .  length  ;  outer:  for  (  int  i  =  0  ;  i  <  csLen  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLen  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {  continue  outer  ;  }  }  return  i  ;  }  return  INDEX_NOT_FOUND  ;  }  	Lang_30_StringUtils_10_6	1533	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2069	if  (i  <  csLast  &&  j  <  searchLast  &&  Character.isHighSurrogate(ch))  {  if  (searchChars[j  +  1]  ==  cs.charAt(i  +  1))  {  continue  outer;  }  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  indexOfAnyBut  [TYPE]  int  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLen  i  j  searchLen  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  int  indexOfAnyBut  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  isEmpty  (  cs  )  ||  ArrayUtils  .  isEmpty  (  searchChars  )  )  {  return  INDEX_NOT_FOUND  ;  }  int  csLen  =  cs  .  length  (  )  ;  int  searchLen  =  searchChars  .  length  ;  outer:  for  (  int  i  =  0  ;  i  <  csLen  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLen  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {  [BUGGY]  continue  outer  ;  }  }  return  i  ;  }  return  INDEX_NOT_FOUND  ;  }  	Lang_30_StringUtils_10_7	1539	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2070	boolean  chFound  =  searchChars.indexOf(ch)  >=  0;  if  (i  +  1  <  strLen  &&  Character.isHighSurrogate(ch))  {  char  ch2  =  str.charAt(i  +  1);  if  (chFound  &&  searchChars.indexOf(ch2)  <  0)  {  }  }  else  {  if  (!chFound)  {  return  i;  }  	[BUGGY]  if  (  searchChars  .  indexOf  (  ch  )  <  0  )  {  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  indexOfAnyBut  [TYPE]  int  [PARAMETER]  String  str  String  searchChars  [CLASS]  StringUtils  [TYPE]  char  ch  [TYPE]  String  EMPTY  searchChars  str  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  i  strLen  [CONTEXT]  public  static  int  indexOfAnyBut  (  String  str  ,  String  searchChars  )  {  if  (  isEmpty  (  str  )  ||  isEmpty  (  searchChars  )  )  {  return  INDEX_NOT_FOUND  ;  }  int  strLen  =  str  .  length  (  )  ;  for  (  int  i  =  0  ;  i  <  strLen  ;  i++  )  {  char  ch  =  str  .  charAt  (  i  )  ;  [BUGGY]  if  (  searchChars  .  indexOf  (  ch  )  <  0  )  {  return  i  ;  }  }  return  INDEX_NOT_FOUND  ;  }  	Lang_30_StringUtils_10_8	1576	1	src/main/java/org/apache/commons/lang3/StringUtils.java
2071	int  csLast  =  csLen  -  1;  int  searchLast  =  searchLen  -  1;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  containsNone  [TYPE]  boolean  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLen  i  j  searchLen  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  boolean  containsNone  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  cs  =  =  null  ||  searchChars  =  =  null  )  {  return  true  ;  }  int  csLen  =  cs  .  length  (  )  ;  [BUGGY]  int  searchLen  =  searchChars  .  length  ;  for  (  int  i  =  0  ;  i  <  csLen  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLen  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {    return  false  ;  }  }  }  return  true  ;  }  	Lang_30_StringUtils_10_9	1678	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2072	if  (Character.isHighSurrogate(ch))  {  if  (j  ==  searchLast)  {  return  false;  }  if  (i  <  csLast  &&  searchChars[j  +  1]  ==  cs.charAt(i  +  1))  {  return  false;  }  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<true>  but  was:<false>  assertEquals  (  true  ,  StringUtils  .  containsNone  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  containsNone  [TYPE]  boolean  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLen  i  j  searchLen  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  boolean  containsNone  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  cs  =  =  null  ||  searchChars  =  =  null  )  {  return  true  ;  }  int  csLen  =  cs  .  length  (  )  ;  int  searchLen  =  searchChars  .  length  ;  for  (  int  i  =  0  ;  i  <  csLen  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLen  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {  [BUGGY]    return  false  ;  }  }  }  return  true  ;  }  	Lang_30_StringUtils_10_10	1683	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2073	\t\tint  csLastIndex  =  csLength  -  1;  \t\tint  searchLastIndex  =  searchLength  -  1;  	[BUGGY]  [FE]  AssertionFailedError:  expected:<false>  but  was:<true>  assertEquals  (  false  ,  StringUtils  .  containsAny  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  containsAny  [TYPE]  boolean  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLength  i  j  searchLength  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  boolean  containsAny  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  isEmpty  (  cs  )  ||  ArrayUtils  .  isEmpty  (  searchChars  )  )  {  return  false  ;  }  int  csLength  =  cs  .  length  (  )  ;  int  searchLength  =  searchChars  .  length  ;  [BUGGY]  for  (  int  i  =  0  ;  i  <  csLength  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLength  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {    return  true  ;  }  }  }  return  false  ;  }  	Lang_31_StringUtils_2_1	1446	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2074	\t\t\t\t\tif  (i  <  csLastIndex  &&  j  <  searchLastIndex  &&  ch  >=  Character.MIN_HIGH_SURROGATE  &&  ch  <=  Character.MAX_HIGH_SURROGATE)  {  \t\t\t\t\t\tif  (searchChars[j  +  1]  ==  cs.charAt(i  +  1))  {  \t\t\t\t\t\t\treturn  true;  \t\t\t\t\t\t}  \t\t\t\t\t}  else  {  \t\t\t\t\t}  	[BUGGY]  [FE]  AssertionFailedError:  expected:<false>  but  was:<true>  assertEquals  (  false  ,  StringUtils  .  containsAny  (  CharU20001  ,  CharU20000  .  toCharArray  (  )  )  )  ;  [METHOD]  containsAny  [TYPE]  boolean  [PARAMETER]  CharSequence  cs  char[]  searchChars  [CLASS]  StringUtils  [TYPE]  CharSequence  cs  [TYPE]  char  ch  [TYPE]  String  EMPTY  [TYPE]  boolean  false  true  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  csLength  i  j  searchLength  [TYPE]  char[]  searchChars  [CONTEXT]  public  static  boolean  containsAny  (  CharSequence  cs  ,  char[]  searchChars  )  {  if  (  isEmpty  (  cs  )  ||  ArrayUtils  .  isEmpty  (  searchChars  )  )  {  return  false  ;  }  int  csLength  =  cs  .  length  (  )  ;  int  searchLength  =  searchChars  .  length  ;  for  (  int  i  =  0  ;  i  <  csLength  ;  i++  )  {  char  ch  =  cs  .  charAt  (  i  )  ;  for  (  int  j  =  0  ;  j  <  searchLength  ;  j++  )  {  if  (  searchChars[j]  =  =  ch  )  {  [BUGGY]    return  true  ;  }  }  }  return  false  ;  }  	Lang_31_StringUtils_2_2	1450	0	src/main/java/org/apache/commons/lang3/StringUtils.java
2075	private  static  final  ThreadLocal<Set<IDKey>>  REGISTRY  =  new  ThreadLocal<Set<IDKey>>();  	[BUGGY]  private  static  final  ThreadLocal<Set<IDKey>>  REGISTRY  =  new  ThreadLocal<Set<IDKey>>  (  )  {  @Override  protected  Set<IDKey>  initialValue  (  )  {  return  new  HashSet<IDKey>  (  )  ;  }  }  ;  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  []  assertNull  (  HashCodeBuilder  .  getRegistry  (  )  )  ;  [CLASS]  [CONTEXT]  	Lang_32_HashCodeBuilder_4_1	104	6	src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java
2076	Set<IDKey>  registry  =  getRegistry();  return  registry  !=  null  &&  registry.contains(new  IDKey(value));  	[BUGGY]  return  getRegistry  (  )  .  contains  (  new  IDKey  (  value  )  )  ;  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  []  assertNull  (  HashCodeBuilder  .  getRegistry  (  )  )  ;  [METHOD]  isRegistered  [TYPE]  boolean  [PARAMETER]  Object  value  [CLASS]  HashCodeBuilder  [TYPE]  Object  value  [TYPE]  boolean  false  true  [TYPE]  ThreadLocal  REGISTRY  [TYPE]  int  iConstant  iTotal  [CONTEXT]  static  boolean  isRegistered  (  Object  value  )  {  [BUGGY]  return  getRegistry  (  )  .  contains  (  new  IDKey  (  value  )  )  ;  }  	Lang_32_HashCodeBuilder_4_2	152	1	src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java
2077	synchronized  (HashCodeBuilder.class)  {  if  (getRegistry()  ==  null)  {  REGISTRY.set(new  HashSet<IDKey>());  }  }  	[BUGGY]  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  []  assertNull  (  HashCodeBuilder  .  getRegistry  (  )  )  ;  [METHOD]  register  [TYPE]  void  [PARAMETER]  Object  value  [CLASS]  HashCodeBuilder  [TYPE]  Object  value  [TYPE]  boolean  false  true  [TYPE]  ThreadLocal  REGISTRY  [TYPE]  int  iConstant  iTotal  [CONTEXT]  static  void  register  (  Object  value  )  {  [BUGGY]  getRegistry  (  )  .  add  (  new  IDKey  (  value  )  )  ;  }  	Lang_32_HashCodeBuilder_4_3	522	0	src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java
2078	Set<IDKey>  s  =  getRegistry();  if  (s  !=  null)  {  s.remove(new  IDKey(value));  synchronized  (HashCodeBuilder.class)  {  if  (s.isEmpty())  {  REGISTRY.remove();  }  }  }  	[BUGGY]  getRegistry  (  )  .  remove  (  new  IDKey  (  value  )  )  ;  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  []  assertNull  (  HashCodeBuilder  .  getRegistry  (  )  )  ;  [METHOD]  unregister  [TYPE]  void  [PARAMETER]  Object  value  [CLASS]  HashCodeBuilder  [TYPE]  Object  value  [TYPE]  boolean  false  true  [TYPE]  ThreadLocal  REGISTRY  [TYPE]  int  iConstant  iTotal  [CONTEXT]  static  void  unregister  (  Object  value  )  {  [BUGGY]  getRegistry  (  )  .  remove  (  new  IDKey  (  value  )  )  ;  }  	Lang_32_HashCodeBuilder_4_4	538	1	src/main/java/org/apache/commons/lang3/builder/HashCodeBuilder.java
2079	classes[i]  =  array[i]  ==  null  ?  null  :  array[i].getClass();  	[BUGGY]  classes[i]  =  array[i]  .  getClass  (  )  ;  [FE]  NullPointerException  assertTrue  (  Arrays  .  equals  (  new  Class[]  {  String  .  class  ,  null  ,  Double  .  class  }  ,  [METHOD]  toClass  [TYPE]  Class[]  [PARAMETER]  Object[]  array  [CLASS]  ClassUtils  [TYPE]  Class[]  classes  [TYPE]  boolean  false  true  [TYPE]  char  INNER_CLASS_SEPARATOR_CHAR  PACKAGE_SEPARATOR_CHAR  [TYPE]  String  INNER_CLASS_SEPARATOR  PACKAGE_SEPARATOR  [TYPE]  Map  abbreviationMap  primitiveWrapperMap  reverseAbbreviationMap  wrapperPrimitiveMap  [TYPE]  Object[]  array  [TYPE]  int  i  [CONTEXT]  public  static  Class<?>[]  toClass  (  Object[]  array  )  {  if  (  array  =  =  null  )  {  return  null  ;  }  else  if  (  array  .  length  =  =  0  )  {  return  ArrayUtils  .  EMPTY_CLASS_ARRAY  ;  }  Class<?>[]  classes  =  new  Class[array  .  length]  ;  for  (  int  i  =  0  ;  i  <  array  .  length  ;  i++  )  {  [BUGGY]  classes[i]  =  array[i]  .  getClass  (  )  ;  }  return  classes  ;  }  	Lang_33_ClassUtils_1_1	910	1	src/main/java/org/apache/commons/lang3/ClassUtils.java
2080	return  REGISTRY.get();  	[BUGGY]  return  REGISTRY  .  get  (  )  !  =  null  ?  REGISTRY  .  get  (  )  :  Collections  .  <Object  ,  Object>emptyMap  (  )  ;  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  {}  assertEquals  (  expected  ,  a  .  toString  (  )  )  ;  [METHOD]  getRegistry  [TYPE]  Map  [PARAMETER]  [CLASS]  ToStringStyle  [TYPE]  ToStringStyle  DEFAULT_STYLE  MULTI_LINE_STYLE  NO_FIELD_NAMES_STYLE  SHORT_PREFIX_STYLE  SIMPLE_STYLE  [TYPE]  boolean  arrayContentDetail  defaultFullDetail  false  fieldSeparatorAtEnd  fieldSeparatorAtStart  true  useClassName  useFieldNames  useIdentityHashCode  useShortClassName  [TYPE]  String  arrayEnd  arraySeparator  arrayStart  contentEnd  contentStart  fieldNameValueSeparator  fieldSeparator  nullText  sizeEndText  sizeStartText  summaryObjectEndText  summaryObjectStartText  [TYPE]  ThreadLocal  REGISTRY  [TYPE]  long  serialVersionUID  [CONTEXT]  static  Map<Object  ,  Object>  getRegistry  (  )  {  [BUGGY]  return  REGISTRY  .  get  (  )  !  =  null  ?  REGISTRY  .  get  (  )  :  Collections  .  <Object  ,  Object>emptyMap  (  )  ;  }  	Lang_34_ToStringStyle_2_1	148	1	src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java
2081	return  m  !=  null  &&  m.containsKey(value);  	[BUGGY]  return  m  .  containsKey  (  value  )  ;  [FE]  AssertionFailedError:  Expected:  <null>  but  was:  {}  assertEquals  (  expected  ,  a  .  toString  (  )  )  ;  [METHOD]  isRegistered  [TYPE]  boolean  [PARAMETER]  Object  value  [CLASS]  ToStringStyle  [TYPE]  boolean  arrayContentDetail  defaultFullDetail  false  fieldSeparatorAtEnd  fieldSeparatorAtStart  true  useClassName  useFieldNames  useIdentityHashCode  useShortClassName  [TYPE]  ThreadLocal  REGISTRY  [TYPE]  ToStringStyle  DEFAULT_STYLE  MULTI_LINE_STYLE  NO_FIELD_NAMES_STYLE  SHORT_PREFIX_STYLE  SIMPLE_STYLE  [TYPE]  Object  value  [TYPE]  String  arrayEnd  arraySeparator  arrayStart  contentEnd  contentStart  fieldNameValueSeparator  fieldSeparator  nullText  sizeEndText  sizeStartText  summaryObjectEndText  summaryObjectStartText  [TYPE]  Map  m  [TYPE]  long  serialVersionUID  [CONTEXT]  static  boolean  isRegistered  (  Object  value  )  {  Map<Object  ,  Object>  m  =  getRegistry  (  )  ;  [BUGGY]  return  m  .  containsKey  (  value  )  ;  }  	Lang_34_ToStringStyle_2_2	164	1	src/main/java/org/apache/commons/lang3/builder/ToStringStyle.java
2082	throw  new  IllegalArgumentException( "Arguments  cannot  both  be  null ");  	[BUGGY]  type  =  Object  .  class  ;  [FE]  ClassCastException:  [LjavalangObject  ;  cannot  be  cast  to  [LjavalangString  ;  [METHOD]  add  [TYPE]  <T>  [PARAMETER]  T[]  array  T  element  [CLASS]  ArrayUtils  [TYPE]  Class[]  EMPTY_CLASS_ARRAY  [TYPE]  long[]  EMPTY_LONG_ARRAY  [TYPE]  short[]  EMPTY_SHORT_ARRAY  [TYPE]  Character[]  EMPTY_CHARACTER_OBJECT_ARRAY  [TYPE]  Boolean[]  EMPTY_BOOLEAN_OBJECT_ARRAY  [TYPE]  int[]  EMPTY_INT_ARRAY  [TYPE]  String[]  EMPTY_STRING_ARRAY  [TYPE]  Integer[]  EMPTY_INTEGER_OBJECT_ARRAY  [TYPE]  int  INDEX_NOT_FOUND  [TYPE]  float[]  EMPTY_FLOAT_ARRAY  [TYPE]  char[]  EMPTY_CHAR_ARRAY  [TYPE]  Short[]  EMPTY_SHORT_OBJECT_ARRAY  [TYPE]  byte[]  EMPTY_BYTE_ARRAY  [TYPE]  Double[]  EMPTY_DOUBLE_OBJECT_ARRAY  [TYPE]  boolean  false  true  [TYPE]  double[]  EMPTY_DOUBLE_ARRAY  [TYPE]  T  element  [TYPE]  Byte[]  EMPTY_BYTE_OBJECT_ARRAY  [TYPE]  Float[]  EMPTY_FLOAT_OBJECT_ARRAY  [TYPE]  T[]  array  newArray  [TYPE]  Class  type  [TYPE]  boolean[]  EMPTY_BOOLEAN_ARRAY  [TYPE]  Object[]  EMPTY_OBJECT_ARRAY  [TYPE]  Long[]  EMPTY_LONG_OBJECT_ARRAY  [CONTEXT]  public  static  <T>  T[]  add  (  T[]  array  ,  T  element  )  {  Class<?>  type  ;  if  (  array  !  =  null  )  {  type  =  array  .  getClass  (  )  ;  }  else  if  (  element  !  =  null  )  {  type  =  element  .  getClass  (  )  ;  }  else  {  [BUGGY]  type  =  Object  .  class  ;  }  @SuppressWarnings  (   "unchecked "  )  //  type  must  be  T  T[]  newArray  =  (  T[]  )  copyArrayGrow1  (  array  ,  type  )  ;  newArray[newArray  .  length  -  1]  =  element  ;  return  newArray  ;  }  	Lang_35_ArrayUtils_2_1	3295	1	src/main/java/org/apache/commons/lang3/ArrayUtils.java
2083	throw  new  IllegalArgumentException( "Array  and  element  cannot  both  be  null ");  	[BUGGY]  return  (  T[]  )  new  Object[]  {  null  }  ;  [FE]  ClassCastException:  [LjavalangObject  ;  cannot  be  cast  to  [LjavalangString  ;  [METHOD]  add  [TYPE]  <T>  [PARAMETER]  T[]  array  int  index  T  element  [CLASS]  ArrayUtils  [TYPE]  Class[]  EMPTY_CLASS_ARRAY  [TYPE]  long[]  EMPTY_LONG_ARRAY  [TYPE]  short[]  EMPTY_SHORT_ARRAY  [TYPE]  Character[]  EMPTY_CHARACTER_OBJECT_ARRAY  [TYPE]  Boolean[]  EMPTY_BOOLEAN_OBJECT_ARRAY  [TYPE]  int[]  EMPTY_INT_ARRAY  [TYPE]  String[]  EMPTY_STRING_ARRAY  [TYPE]  Integer[]  EMPTY_INTEGER_OBJECT_ARRAY  [TYPE]  int  INDEX_NOT_FOUND  index  [TYPE]  float[]  EMPTY_FLOAT_ARRAY  [TYPE]  char[]  EMPTY_CHAR_ARRAY  [TYPE]  Short[]  EMPTY_SHORT_OBJECT_ARRAY  [TYPE]  byte[]  EMPTY_BYTE_ARRAY  [TYPE]  Double[]  EMPTY_DOUBLE_OBJECT_ARRAY  [TYPE]  boolean  false  true  [TYPE]  double[]  EMPTY_DOUBLE_ARRAY  [TYPE]  T  element  [TYPE]  Byte[]  EMPTY_BYTE_OBJECT_ARRAY  [TYPE]  Float[]  EMPTY_FLOAT_OBJECT_ARRAY  [TYPE]  T[]  array  newArray  [TYPE]  Class  clss  [TYPE]  boolean[]  EMPTY_BOOLEAN_ARRAY  [TYPE]  Object[]  EMPTY_OBJECT_ARRAY  [TYPE]  Long[]  EMPTY_LONG_OBJECT_ARRAY  [CONTEXT]  public  static  <T>  T[]  add  (  T[]  array  ,  int  index  ,  T  element  )  {  Class<?>  clss  =  null  ;  if  (  array  !  =  null  )  {  clss  =  array  .  getClass  (  )  .  getComponentType  (  )  ;  }  else  if  (  element  !  =  null  )  {  clss  =  element  .  getClass  (  )  ;  }  else  {  [BUGGY]  return  (  T[]  )  new  Object[]  {  null  }  ;  }  @SuppressWarnings  (   "unchecked "  )  //  the  add  method  creates  an  array  of  type  clss  ,  which  is  type  T  final  T[]  newArray  =  (  T[]  )  add  (  array  ,  index  ,  element  ,  clss  )  ;  return  newArray  ;  }  	Lang_35_ArrayUtils_2_2	3574	1	src/main/java/org/apache/commons/lang3/ArrayUtils.java
2084		[BUGGY]  if  (  !Character  .  isDigit  (  lastChar  )  )  {\n'  ,   "+    if  (  !Character  .  isDigit  (  lastChar  )  &&  lastChar  !  =  '  .  '  )  {\n "  ,  '        if  (  expPos  >  -1  &&  expPos  <  str  .  length  (  )  -  1  )  {  [FE]  NumberFormatException:  2  is  not  a  valid  number  assertEquals  (   "createNumber  (  String  )  LANG-521  failed "  ,  new  Float  (   "2  .   "  )  ,  NumberUtils  .  createNumber  (   "2  .   "  )  )  ;  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  [CONTEXT]  String  mant  ;  String  dec  ;  String  exp  ;  int  decPos  =  str  .  indexOf  (  '  .  '  )  ;  int  expPos  =  str  .  indexOf  (  'e'  )  +  str  .  indexOf  (  'E'  )  +  1  ;  if  (  decPos  >  -1  )  {  if  (  expPos  >  -1  )  {  if  (  expPos  <  decPos  )  {  throw  new  NumberFormatException  (  str  +   "  is  not  a  valid  number  .   "  )  ;  }  dec  =  str  .  substring  (  decPos  +  1  ,  expPos  )  ;  }  else  {  dec  =  str  .  substring  (  decPos  +  1  )  ;  }  mant  =  str  .  substring  (  0  ,  decPos  )  ;  }  else  {  if  (  expPos  >  -1  )  {  mant  =  str  .  substring  (  0  ,  expPos  )  ;  }  else  {  mant  =  str  ;  }  dec  =  null  ;  }  [BUGGY]  if  (  !Character  .  isDigit  (  lastChar  )  )  {  if  (  expPos  >  -1  &&  expPos  <  str  .  length  (  )  -  1  )  {  exp  =  str  .  substring  (  expPos  +  1  ,  str  .  length  (  )  -  1  )  ;  }  else  {  exp  =  null  ;  }  	Lang_36_NumberUtils_2_1	491	1	src/java/org/apache/commons/lang3/math/NumberUtils.java
2085	return  false;  }  return  foundDigit;  }  	[BUGGY]  [FE]  NumberFormatException:  2  is  not  a  valid  number  assertEquals  (   "createNumber  (  String  )  LANG-521  failed "  ,  new  Float  (   "2  .   "  )  ,  NumberUtils  .  createNumber  (   "2  .   "  )  )  ;  [METHOD]  isNumber  [TYPE]  boolean  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  [TYPE]  boolean  allowSigns  false  foundDigit  hasDecPoint  hasExp  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  String  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  i  start  sz  [TYPE]  char[]  chars  [CONTEXT]  if  (  !foundDigit  )  {  return  false  ;  }  hasExp  =  true  ;  allowSigns  =  true  ;  }  else  if  (  chars[i]  =  =  '+'  ||  chars[i]  =  =  '-'  )  {  if  (  !allowSigns  )  {  return  false  ;  }  allowSigns  =  false  ;  foundDigit  =  false  ;  //  we  need  a  digit  after  the  E  }  else  {  return  false  ;  }  i++  ;  }  if  (  i  <  chars  .  length  )  {  if  (  chars[i]  >  =  '0'  &&  chars[i]  <  =  '9'  )  {  return  true  ;  }  if  (  chars[i]  =  =  'e'  ||  chars[i]  =  =  'E'  )  {  return  false  ;  }  [BUGGY]  if  (  !allowSigns  &&  (  chars[i]  =  =  'd'  ||  chars[i]  =  =  'D'  ||  chars[i]  =  =  'f'  ||  chars[i]  =  =  'F'  )  )  {  return  foundDigit  ;  	Lang_36_NumberUtils_2_2	1388	0	src/java/org/apache/commons/lang3/math/NumberUtils.java
2086	try  {  }  catch  (ArrayStoreException  ase)  {  final  Class<?>  type2  =  array2.getClass().getComponentType();  if  (!type1.isAssignableFrom(type2)){  throw  new  IllegalArgumentException( "Cannot  store   "+type2.getName()+ "  in  an  array  of   "+type1.getName());  }  throw  ase;    }  	[BUGGY]  [FE]  ArrayStoreException  assertEquals  (  Number  .  class  ,  n  .  getClass  (  )  .  getComponentType  (  )  )  ;  [METHOD]  addAll  [TYPE]  <T>  [PARAMETER]  T[]  array1  array2  [CLASS]  ArrayUtils  [TYPE]  Class[]  EMPTY_CLASS_ARRAY  [TYPE]  long[]  EMPTY_LONG_ARRAY  [TYPE]  short[]  EMPTY_SHORT_ARRAY  [TYPE]  Character[]  EMPTY_CHARACTER_OBJECT_ARRAY  [TYPE]  Boolean[]  EMPTY_BOOLEAN_OBJECT_ARRAY  [TYPE]  int[]  EMPTY_INT_ARRAY  [TYPE]  String[]  EMPTY_STRING_ARRAY  [TYPE]  Integer[]  EMPTY_INTEGER_OBJECT_ARRAY  [TYPE]  int  INDEX_NOT_FOUND  [TYPE]  float[]  EMPTY_FLOAT_ARRAY  [TYPE]  char[]  EMPTY_CHAR_ARRAY  [TYPE]  Short[]  EMPTY_SHORT_OBJECT_ARRAY  [TYPE]  byte[]  EMPTY_BYTE_ARRAY  [TYPE]  Double[]  EMPTY_DOUBLE_OBJECT_ARRAY  [TYPE]  boolean  false  true  [TYPE]  double[]  EMPTY_DOUBLE_ARRAY  [TYPE]  Byte[]  EMPTY_BYTE_OBJECT_ARRAY  [TYPE]  Float[]  EMPTY_FLOAT_OBJECT_ARRAY  [TYPE]  T[]  array1  array2  joinedArray  [TYPE]  Class  type1  [TYPE]  boolean[]  EMPTY_BOOLEAN_ARRAY  [TYPE]  Object[]  EMPTY_OBJECT_ARRAY  [TYPE]  Long[]  EMPTY_LONG_OBJECT_ARRAY  [CONTEXT]  public  static  <T>  T[]  addAll  (  T[]  array1  ,  T  .  .  .  array2  )  {  if  (  array1  =  =  null  )  {  return  clone  (  array2  )  ;  }  else  if  (  array2  =  =  null  )  {  return  clone  (  array1  )  ;  }  final  Class<?>  type1  =  array1  .  getClass  (  )  .  getComponentType  (  )  ;  T[]  joinedArray  =  (  T[]  )  Array  .  newInstance  (  type1  ,  array1  .  length  +  array2  .  length  )  ;  System  .  arraycopy  (  array1  ,  0  ,  joinedArray  ,  0  ,  array1  .  length  )  ;  [BUGGY]  System  .  arraycopy  (  array2  ,  0  ,  joinedArray  ,  array1  .  length  ,  array2  .  length  )  ;  return  joinedArray  ;  }  	Lang_37_ArrayUtils_1_1	2962	0	src/java/org/apache/commons/lang3/ArrayUtils.java
2087	calendar.getTime();    	[BUGGY]  [FE]  ComparisonFailure:  dateTime  expected:<2009-10-16T[16]:42:16000Z>  but  was:<2009-10-16T[08]:42:16000Z>  assertEquals  (   "dateTime "  ,  dateTime  ,  format  .  format  (  cal  )  )  ;  [METHOD]  format  [TYPE]  StringBuffer  [PARAMETER]  Calendar  calendar  StringBuffer  buf  [CLASS]  FastDateFormat  [TYPE]  Locale  mLocale  [TYPE]  TimeZoneNumberRule  INSTANCE_COLON  INSTANCE_NO_COLON  [TYPE]  Calendar  calendar  [TYPE]  TwoDigitYearField  INSTANCE  [TYPE]  String  cDefaultPattern  mDaylight  mPattern  mStandard  mValue  [TYPE]  String[]  mValues  [TYPE]  long  serialVersionUID  [TYPE]  int  FULL  LONG  MEDIUM  SHORT  mField  mMaxLengthEstimate  mSize  mStyle  [TYPE]  Rule[]  mRules  [TYPE]  TimeZone  mTimeZone  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  mColon  mLocaleForced  mTimeZoneForced  true  [TYPE]  NumberRule  mRule  [TYPE]  char  mValue  [TYPE]  TwoDigitMonthField  INSTANCE  [TYPE]  UnpaddedMonthField  INSTANCE  [TYPE]  Object  mObj1  mObj2  [TYPE]  Map  cDateInstanceCache  cDateTimeInstanceCache  cInstanceCache  cTimeInstanceCache  cTimeZoneDisplayCache  [CONTEXT]  public  StringBuffer  format  (  Calendar  calendar  ,  StringBuffer  buf  )  {  if  (  mTimeZoneForced  )  {  [BUGGY]  calendar  =  (  Calendar  )  calendar  .  clone  (  )  ;  calendar  .  setTimeZone  (  mTimeZone  )  ;  }  return  applyRules  (  calendar  ,  buf  )  ;  }  	Lang_38_FastDateFormat_1_1	872	0	src/java/org/apache/commons/lang3/time/FastDateFormat.java
2088	if  (searchList[i]  ==  null  ||  replacementList[i]  ==  null)  {  continue;  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  StringUtils  .  replaceEachRepeatedly  (   "abcde "  ,  new  String[]{ "ab "  ,   "d "}  ,  new  String[]{ "d "  ,   "t "}  )  ,   "tcte "  )  ;  [METHOD]  replaceEach  [TYPE]  String  [PARAMETER]  String  text  String[]  searchList  String[]  replacementList  boolean  repeat  int  timeToLive  [CLASS]  StringUtils  [TYPE]  String  EMPTY  result  text  [TYPE]  String[]  replacementList  searchList  [TYPE]  boolean  false  repeat  true  [TYPE]  boolean[]  noMoreMatchesForReplIndex  [TYPE]  StringBuilder  buf  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  greater  i  increase  replaceIndex  replacementLength  searchLength  start  tempIndex  textIndex  textLength  timeToLive  [CONTEXT]  if  (  tempIndex  =  =  -1  )  {  noMoreMatchesForReplIndex[i]  =  true  ;  }  else  {  if  (  textIndex  =  =  -1  ||  tempIndex  <  textIndex  )  {  textIndex  =  tempIndex  ;  replaceIndex  =  i  ;  }  }  }    if  (  textIndex  =  =  -1  )  {  return  text  ;  }  int  start  =  0  ;    int  increase  =  0  ;    for  (  int  i  =  0  ;  i  <  searchList  .  length  ;  i++  )  {  [BUGGY]  int  greater  =  replacementList[i]  .  length  (  )  -  searchList[i]  .  length  (  )  ;  if  (  greater  >  0  )  {  increase  +  =  3  *  greater  ;  //  assume  3  matches  }  }  	Lang_39_StringUtils_1_1	3676	0	src/java/org/apache/commons/lang3/StringUtils.java
2089	int  len  =  searchStr.length();  int  max  =  str.length()  -  len;  for  (int  i  =  0;  i  <=  max;  i++)  {  if  (str.regionMatches(true,  i,  searchStr,  0,  len))  {  return  true;  }  }  return  false;  	[BUGGY]  return  contains  (  str  .  toUpperCase  (  )  ,  searchStr  .  toUpperCase  (  )  )  ;  [FE]  AssertionFailedError:  en:  0  assertFalse  (  Locale  .  getDefault  (  )  +   ":   "  +  j  +   "   "  +  fdata[j][0]  +   "   "  +  fdata[j][1]  ,  StringUtils  [METHOD]  containsIgnoreCase  [TYPE]  boolean  [PARAMETER]  String  str  String  searchStr  [CLASS]  StringUtils  [TYPE]  int  INDEX_NOT_FOUND  PAD_LIMIT  [TYPE]  String  EMPTY  searchStr  str  [TYPE]  boolean  false  true  [CONTEXT]  public  static  boolean  containsIgnoreCase  (  String  str  ,  String  searchStr  )  {  if  (  str  =  =  null  ||  searchStr  =  =  null  )  {  return  false  ;  }  [BUGGY]  return  contains  (  str  .  toUpperCase  (  )  ,  searchStr  .  toUpperCase  (  )  )  ;  }  	Lang_40_StringUtils_1_1	1048	1	src/java/org/apache/commons/lang/StringUtils.java
2090	StringBuffer  arrayPrefix  =  new  StringBuffer();  if  (className.startsWith( "[ "))  {\n',   "+                        while  (className.charAt(0)  ==  '[')  {\n ",  '+                                className  =  className.substring(1);  arrayPrefix.append( "[] ");  }  }  }  if  (reverseAbbreviationMap.containsKey(className))  {  className  =  reverseAbbreviationMap.get(className);  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<String[[]]>  but  was:<String[  ;  ]>  assertEquals  (   "String[][][][] "  ,  ClassUtils  .  getShortClassName  (  String[][][][]  .  class  )  )  ;  [METHOD]  getShortClassName  [TYPE]  String  [PARAMETER]  String  className  [CLASS]  ClassUtils  [TYPE]  char  INNER_CLASS_SEPARATOR_CHAR  PACKAGE_SEPARATOR_CHAR  [TYPE]  String  INNER_CLASS_SEPARATOR  PACKAGE_SEPARATOR  className  out  [TYPE]  boolean  false  true  [TYPE]  Map  abbreviationMap  primitiveWrapperMap  reverseAbbreviationMap  wrapperPrimitiveMap  [TYPE]  int  innerIdx  lastDotIdx  [CONTEXT]  public  static  String  getShortClassName  (  String  className  )  {  if  (  className  =  =  null  )  {  return  StringUtils  .  EMPTY  ;  }  if  (  className  .  length  (  )  =  =  0  )  {  return  StringUtils  .  EMPTY  ;  }  [BUGGY]    int  lastDotIdx  =  className  .  lastIndexOf  (  PACKAGE_SEPARATOR_CHAR  )  ;  int  innerIdx  =  className  .  indexOf  (  INNER_CLASS_SEPARATOR_CHAR  ,  lastDotIdx  =  =  -1  ?  0  :  lastDotIdx  +  1  )  ;  String  out  =  className  .  substring  (  lastDotIdx  +  1  )  ;  if  (  innerIdx  !  =  -1  )  {  out  =  out  .  replace  (  INNER_CLASS_SEPARATOR_CHAR  ,  PACKAGE_SEPARATOR_CHAR  )  ;  }  return  out  ;  }  	Lang_41_ClassUtils_4_1	191	0	src/java/org/apache/commons/lang/ClassUtils.java
2091	return  out  +  arrayPrefix;  	[BUGGY]  return  out  ;  [FE]  ComparisonFailure:  expected:<String[[]]>  but  was:<String[  ;  ]>  assertEquals  (   "String[][][][] "  ,  ClassUtils  .  getShortClassName  (  String[][][][]  .  class  )  )  ;  [METHOD]  getShortClassName  [TYPE]  String  [PARAMETER]  String  className  [CLASS]  ClassUtils  [TYPE]  char  INNER_CLASS_SEPARATOR_CHAR  PACKAGE_SEPARATOR_CHAR  [TYPE]  String  INNER_CLASS_SEPARATOR  PACKAGE_SEPARATOR  className  out  [TYPE]  boolean  false  true  [TYPE]  Map  abbreviationMap  primitiveWrapperMap  reverseAbbreviationMap  wrapperPrimitiveMap  [TYPE]  int  innerIdx  lastDotIdx  [CONTEXT]  public  static  String  getShortClassName  (  String  className  )  {  if  (  className  =  =  null  )  {  return  StringUtils  .  EMPTY  ;  }  if  (  className  .  length  (  )  =  =  0  )  {  return  StringUtils  .  EMPTY  ;  }      int  lastDotIdx  =  className  .  lastIndexOf  (  PACKAGE_SEPARATOR_CHAR  )  ;  int  innerIdx  =  className  .  indexOf  (  INNER_CLASS_SEPARATOR_CHAR  ,  lastDotIdx  =  =  -1  ?  0  :  lastDotIdx  +  1  )  ;  String  out  =  className  .  substring  (  lastDotIdx  +  1  )  ;  if  (  innerIdx  !  =  -1  )  {  out  =  out  .  replace  (  INNER_CLASS_SEPARATOR_CHAR  ,  PACKAGE_SEPARATOR_CHAR  )  ;  }  [BUGGY]  return  out  ;  }  	Lang_41_ClassUtils_4_2	203	1	src/java/org/apache/commons/lang/ClassUtils.java
2092	if  (className  ==  null  ||  className.length()  ==  0)  {  	[BUGGY]  if  (  className  =  =  null  )  {  [FE]  ComparisonFailure:  expected:<String[[]]>  but  was:<String[  ;  ]>  assertEquals  (   "String[][][][] "  ,  ClassUtils  .  getShortClassName  (  String[][][][]  .  class  )  )  ;  [METHOD]  getPackageName  [TYPE]  String  [PARAMETER]  String  className  [CLASS]  ClassUtils  [TYPE]  char  INNER_CLASS_SEPARATOR_CHAR  PACKAGE_SEPARATOR_CHAR  [TYPE]  String  INNER_CLASS_SEPARATOR  PACKAGE_SEPARATOR  className  [TYPE]  boolean  false  true  [TYPE]  Map  abbreviationMap  primitiveWrapperMap  reverseAbbreviationMap  wrapperPrimitiveMap  [TYPE]  int  i  [CONTEXT]  public  static  String  getPackageName  (  String  className  )  {  [BUGGY]  if  (  className  =  =  null  )  {  return  StringUtils  .  EMPTY  ;  }    int  i  =  className  .  lastIndexOf  (  PACKAGE_SEPARATOR_CHAR  )  ;  if  (  i  =  =  -1  )  {  return  StringUtils  .  EMPTY  ;  }  return  className  .  substring  (  0  ,  i  )  ;  }  	Lang_41_ClassUtils_4_3	245	1	src/java/org/apache/commons/lang/ClassUtils.java
2093	}  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<String[[]]>  but  was:<String[  ;  ]>  assertEquals  (   "String[][][][] "  ,  ClassUtils  .  getShortClassName  (  String[][][][]  .  class  )  )  ;  [METHOD]  getPackageName  [TYPE]  String  [PARAMETER]  String  className  [CLASS]  ClassUtils  [TYPE]  char  INNER_CLASS_SEPARATOR_CHAR  PACKAGE_SEPARATOR_CHAR  [TYPE]  String  INNER_CLASS_SEPARATOR  PACKAGE_SEPARATOR  className  [TYPE]  boolean  false  true  [TYPE]  Map  abbreviationMap  primitiveWrapperMap  reverseAbbreviationMap  wrapperPrimitiveMap  [TYPE]  int  i  [CONTEXT]  public  static  String  getPackageName  (  String  className  )  {  if  (  className  =  =  null  )  {  return  StringUtils  .  EMPTY  ;  }  [BUGGY]  int  i  =  className  .  lastIndexOf  (  PACKAGE_SEPARATOR_CHAR  )  ;  if  (  i  =  =  -1  )  {  return  StringUtils  .  EMPTY  ;  }  return  className  .  substring  (  0  ,  i  )  ;  }  	Lang_41_ClassUtils_4_4	250	0	src/java/org/apache/commons/lang/ClassUtils.java
2094	int  c  =  Character.codePointAt(str,  i);  if  (c  >=  0x010000  &&  i  <  len  -  1)  {  writer.write( "&# ");  writer.write(Integer.toString(c,  10));\n',   "+                                        writer.write(';');\n ",  '+                                        i++;  }  else  if  (c  >  0x7F)  {  	[BUGGY]  char  c  =  str  .  charAt  (  i  )  ;  if  (  c  >  0x7F  )  {  [FE]  ComparisonFailure:  High  unicode  was  not  escaped  correctly  expected:<&#[119650]  ;  >  but  was:<&#[55348  ;  &#57186]  ;  >  assertEquals  (   "High  unicode  was  not  escaped  correctly "  ,   "&#119650  ;   "  ,  escaped  )  ;  [METHOD]  escape  [TYPE]  void  [PARAMETER]  Writer  writer  String  str  [CLASS]  Entities  [TYPE]  IntHashMap  mapValueToName  [TYPE]  boolean  false  true  [TYPE]  String[][]  APOS_ARRAY  BASIC_ARRAY  HTML40_ARRAY  ISO8859_1_ARRAY  [TYPE]  EntityMap  map  [TYPE]  char  c  [TYPE]  int[]  values  [TYPE]  String[]  lookupTable  names  [TYPE]  String  entityName  str  [TYPE]  Map  mapNameToValue  mapValueToName  [TYPE]  int  LOOKUP_TABLE_SIZE  growBy  i  len  size  [TYPE]  Writer  writer  [TYPE]  Entities  HTML32  HTML40  XML  [CONTEXT]  public  void  escape  (  Writer  writer  ,  String  str  )  throws  IOException  {  int  len  =  str  .  length  (  )  ;  for  (  int  i  =  0  ;  i  <  len  ;  i++  )  {  [BUGGY]  char  c  =  str  .  charAt  (  i  )  ;  String  entityName  =  this  .  entityName  (  c  )  ;  if  (  entityName  =  =  null  )  {  if  (  c  >  0x7F  )  {  writer  .  write  (   "&# "  )  ;  writer  .  write  (  Integer  .  toString  (  c  ,  10  )  )  ;  writer  .  write  (  '  ;  '  )  ;  }  else  {  writer  .  write  (  c  )  ;  }  }  else  {  writer  .  write  (  '&'  )  ;  writer  .  write  (  entityName  )  ;  writer  .  write  (  '  ;  '  )  ;  }  }  }  	Lang_42_Entities_1_1	828	2	src/java/org/apache/commons/lang/Entities.java
2095	next(pos);  	[BUGGY]  [FE]  OutOfMemoryError:  Java  heap  space  assertEquals  (   "it's  a  dummy  test! "  ,  emf  .  format  (  new  Object[]  { "DUMMY "}  )  )  ;  [METHOD]  appendQuotedString  [TYPE]  StringBuffer  [PARAMETER]  String  pattern  ParsePosition  pos  StringBuffer  appendTo  boolean  escapingOn  [CLASS]  ExtendedMessageFormat  [TYPE]  StringBuffer  appendTo  [TYPE]  boolean  escapingOn  false  true  [TYPE]  char  END_FE  QUOTE  START_FE  START_FMT  [TYPE]  String  DUMMY_PATTERN  ESCAPED_QUOTE  pattern  toPattern  [TYPE]  Map  registry  [TYPE]  long  serialVersionUID  [TYPE]  int  i  lastHold  start  [TYPE]  ParsePosition  pos  [TYPE]  char[]  c  [CONTEXT]  private  StringBuffer  appendQuotedString  (  String  pattern  ,  ParsePosition  pos  ,  StringBuffer  appendTo  ,  boolean  escapingOn  )  {  int  start  =  pos  .  getIndex  (  )  ;  char[]  c  =  pattern  .  toCharArray  (  )  ;  if  (  escapingOn  &&  c[start]  =  =  QUOTE  )  {  [BUGGY]  return  appendTo  =  =  null  ?  null  :  appendTo  .  append  (  QUOTE  )  ;  }  int  lastHold  =  start  ;  for  (  int  i  =  pos  .  getIndex  (  )  ;  i  <  pattern  .  length  (  )  ;  i++  )  {  if  (  escapingOn  &&  pattern  .  substring  (  i  )  .  startsWith  (  ESCAPED_QUOTE  )  )  {  appendTo  .  append  (  c  ,  lastHold  ,  pos  .  getIndex  (  )  -  lastHold  )  .  append  (  QUOTE  )  ;  pos  .  setIndex  (  i  +  ESCAPED_QUOTE  .  length  (  )  )  ;  lastHold  =  pos  .  getIndex  (  )  ;  continue  ;  }  switch  (  c[pos  .  getIndex  (  )  ]  )  {  case  QUOTE:  next  (  pos  )  ;  return  appendTo  =  =  null  ?  null  :  appendTo  .  append  (  c  ,  lastHold  ,  pos  .  getIndex  (  )  -  lastHold  )  ;  default:  next  (  pos  )  ;  }  }  throw  new  IllegalArgumentException  (   "Unterminated  quoted  string  at  position   "  +  start  )  ;  }  	Lang_43_ExtendedMessageFormat_1_1	422	0	src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java
2096	if  (val.length()  ==  1  &&  !Character.isDigit(val.charAt(0)))  {  throw  new  NumberFormatException(val  +   "  is  not  a  valid  number. ");  }  	[BUGGY]  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  0  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  val  [CLASS]  NumberUtils  [TYPE]  Float  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  val  [TYPE]  Double  d  [TYPE]  int  decPos  expPos  [CONTEXT]  public  static  Number  createNumber  (  String  val  )  throws  NumberFormatException  {  if  (  val  =  =  null  )  {  return  null  ;  }  if  (  val  .  length  (  )  =  =  0  )  {  throw  new  NumberFormatException  (   "\ "\ "  is  not  a  valid  number  .   "  )  ;  }  [BUGGY]  if  (  val  .  startsWith  (   "-- "  )  )  {      return  null  ;  	Lang_44_NumberUtils_1_1	145	0	src/java/org/apache/commons/lang/NumberUtils.java
2097	if  (lower  >  str.length())  {  lower  =  str.length();  }  	[BUGGY]  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  15  assertEquals  (   " "  ,  WordUtils  .  abbreviate  (   "  0123456790 "  ,  0  ,  -1  ,   " "  )  )  ;  [METHOD]  abbreviate  [TYPE]  String  [PARAMETER]  String  str  int  lower  int  upper  String  appendToEnd  [CLASS]  WordUtils  [TYPE]  StringBuffer  result  [TYPE]  boolean  false  true  [TYPE]  String  appendToEnd  str  [TYPE]  int  index  lower  upper  [CONTEXT]  public  static  String  abbreviate  (  String  str  ,  int  lower  ,  int  upper  ,  String  appendToEnd  )  {  if  (  str  =  =  null  )  {  return  null  ;  }  if  (  str  .  length  (  )  =  =  0  )  {  return  StringUtils  .  EMPTY  ;  }    [BUGGY]    if  (  upper  =  =  -1  ||  upper  >  str  .  length  (  )  )  {  upper  =  str  .  length  (  )  ;  }  	Lang_45_WordUtils_1_1	616	0	src/java/org/apache/commons/lang/WordUtils.java
2098	return  escapeJavaStyleString(str,  false,  false);  	[BUGGY]  return  escapeJavaStyleString  (  str  ,  false  )  ;  [FE]  ComparisonFailure:  expected:<tring  with  a  slash  (  []/  )  in  it>  but  was:<tring  with  a  slash  (  [  assertEquals  (  expected  ,  writer  .  toString  (  )  )  ;  [METHOD]  escapeJava  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  StringEscapeUtils  [TYPE]  char  CSV_DELIMITER  CSV_QUOTE  [TYPE]  String  CSV_QUOTE_STR  str  [TYPE]  boolean  false  true  [TYPE]  char[]  CSV_SEARCH_CHARS  [CONTEXT]  public  static  String  escapeJava  (  String  str  )  {  [BUGGY]  return  escapeJavaStyleString  (  str  ,  false  )  ;  }  	Lang_46_StringEscapeUtils_8_1	86	1	src/java/org/apache/commons/lang/StringEscapeUtils.java
2099	escapeJavaStyleString(out,  str,  false,  false);  	[BUGGY]  escapeJavaStyleString  (  out  ,  str  ,  false  )  ;  [FE]  ComparisonFailure:  expected:<tring  with  a  slash  (  []/  )  in  it>  but  was:<tring  with  a  slash  (  [  assertEquals  (  expected  ,  writer  .  toString  (  )  )  ;  [METHOD]  escapeJava  [TYPE]  void  [PARAMETER]  Writer  out  String  str  [CLASS]  StringEscapeUtils  [TYPE]  char  CSV_DELIMITER  CSV_QUOTE  [TYPE]  String  CSV_QUOTE_STR  str  [TYPE]  boolean  false  true  [TYPE]  Writer  out  [TYPE]  char[]  CSV_SEARCH_CHARS  [CONTEXT]  public  static  void  escapeJava  (  Writer  out  ,  String  str  )  throws  IOException  {  [BUGGY]  escapeJavaStyleString  (  out  ,  str  ,  false  )  ;  }  	Lang_46_StringEscapeUtils_8_2	102	1	src/java/org/apache/commons/lang/StringEscapeUtils.java
2100	return  escapeJavaStyleString(str,  true,  true);  	[BUGGY]  return  escapeJavaStyleString  (  str  ,  true  )  ;  [FE]  ComparisonFailure:  expected:<tring  with  a  slash  (  []/  )  in  it>  but  was:<tring  with  a  slash  (  [  assertEquals  (  expected  ,  writer  .  toString  (  )  )  ;  [METHOD]  escapeJavaScript  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  StringEscapeUtils  [TYPE]  char  CSV_DELIMITER  CSV_QUOTE  [TYPE]  String  CSV_QUOTE_STR  str  [TYPE]  boolean  false  true  [TYPE]  char[]  CSV_SEARCH_CHARS  [CONTEXT]  public  static  String  escapeJavaScript  (  String  str  )  {  [BUGGY]  return  escapeJavaStyleString  (  str  ,  true  )  ;  }  	Lang_46_StringEscapeUtils_8_3	127	1	src/java/org/apache/commons/lang/StringEscapeUtils.java
2101	escapeJavaStyleString(out,  str,  true,  true);  	[BUGGY]  escapeJavaStyleString  (  out  ,  str  ,  true  )  ;  [FE]  ComparisonFailure:  expected:<tring  with  a  slash  (  []/  )  in  it>  but  was:<tring  with  a  slash  (  [  assertEquals  (  expected  ,  writer  .  toString  (  )  )  ;  [METHOD]  escapeJavaScript  [TYPE]  void  [PARAMETER]  Writer  out  String  str  [CLASS]  StringEscapeUtils  [TYPE]  char  CSV_DELIMITER  CSV_QUOTE  [TYPE]  String  CSV_QUOTE_STR  str  [TYPE]  boolean  false  true  [TYPE]  Writer  out  [TYPE]  char[]  CSV_SEARCH_CHARS  [CONTEXT]  public  static  void  escapeJavaScript  (  Writer  out  ,  String  str  )  throws  IOException  {  [BUGGY]  escapeJavaStyleString  (  out  ,  str  ,  true  )  ;  }  	Lang_46_StringEscapeUtils_8_4	143	1	src/java/org/apache/commons/lang/StringEscapeUtils.java
2102	private  static  String  escapeJavaStyleString(String  str,  boolean  escapeSingleQuotes,  boolean  escapeForwardSlash)  {  	[BUGGY]  private  static  String  escapeJavaStyleString  (  String  str  ,  boolean  escapeSingleQuotes  )  {  [FE]  ComparisonFailure:  expected:<tring  with  a  slash  (  []/  )  in  it>  but  was:<tring  with  a  slash  (  [  assertEquals  (  expected  ,  writer  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Lang_46_StringEscapeUtils_8_5	154	1	src/java/org/apache/commons/lang/StringEscapeUtils.java
2103	escapeJavaStyleString(writer,  str,  escapeSingleQuotes,  escapeForwardSlash);  	[BUGGY]  escapeJavaStyleString  (  writer  ,  str  ,  escapeSingleQuotes  )  ;  [FE]  ComparisonFailure:  expected:<tring  with  a  slash  (  []/  )  in  it>  but  was:<tring  with  a  slash  (  [  assertEquals  (  expected  ,  writer  .  toString  (  )  )  ;  [METHOD]  escapeJavaStyleString  [TYPE]  String  [PARAMETER]  String  str  boolean  escapeSingleQuotes  [CLASS]  StringEscapeUtils  [TYPE]  char  CSV_DELIMITER  CSV_QUOTE  [TYPE]  String  CSV_QUOTE_STR  str  [TYPE]  boolean  escapeSingleQuotes  false  true  [TYPE]  IOException  ioe  [TYPE]  StringWriter  writer  [TYPE]  char[]  CSV_SEARCH_CHARS  [CONTEXT]  private  static  String  escapeJavaStyleString  (  String  str  ,  boolean  escapeSingleQuotes  )  {  if  (  str  =  =  null  )  {  return  null  ;  }  try  {  StringWriter  writer  =  new  StringWriter  (  str  .  length  (  )  *  2  )  ;  [BUGGY]  escapeJavaStyleString  (  writer  ,  str  ,  escapeSingleQuotes  )  ;  return  writer  .  toString  (  )  ;  }  catch  (  IOException  ioe  )  {  ioe  .  printStackTrace  (  )  ;  return  null  ;  }  }  	Lang_46_StringEscapeUtils_8_6	160	1	src/java/org/apache/commons/lang/StringEscapeUtils.java
2104	private  static  void  escapeJavaStyleString(Writer  out,  String  str,  boolean  escapeSingleQuote,  boolean  escapeForwardSlash)  throws  IOException  {  	[BUGGY]  private  static  void  escapeJavaStyleString  (  Writer  out  ,  String  str  ,  boolean  escapeSingleQuote  )  throws  IOException  {  [FE]  ComparisonFailure:  expected:<tring  with  a  slash  (  []/  )  in  it>  but  was:<tring  with  a  slash  (  [  assertEquals  (  expected  ,  writer  .  toString  (  )  )  ;  [CLASS]  [CONTEXT]  	Lang_46_StringEscapeUtils_8_7	178	1	src/java/org/apache/commons/lang/StringEscapeUtils.java
2105		[BUGGY]  [FE]  ComparisonFailure:  expected:<tring  with  a  slash  (  []/  )  in  it>  but  was:<tring  with  a  slash  (  [  assertEquals  (  expected  ,  writer  .  toString  (  )  )  ;  [METHOD]  escapeJavaStyleString  [TYPE]  void  [PARAMETER]  Writer  out  String  str  boolean  escapeSingleQuote  [CLASS]  StringEscapeUtils  [TYPE]  char  CSV_DELIMITER  CSV_QUOTE  ch  [TYPE]  String  CSV_QUOTE_STR  str  [TYPE]  boolean  escapeSingleQuote  false  true  [TYPE]  Writer  out  [TYPE]  int  i  sz  [TYPE]  char[]  CSV_SEARCH_CHARS  [CONTEXT]  default  :  if  (  ch  >  0xf  )  {  out  .  write  (   "\\u00 "  +  hex  (  ch  )  )  ;  }  else  {  out  .  write  (   "\\u000 "  +  hex  (  ch  )  )  ;  }  break  ;  }  }  else  {  switch  (  ch  )  {  case  '\''  :  if  (  escapeSingleQuote  )  {  out  .  write  (  '\\'  )  ;  }  out  .  write  (  '\''  )  ;  break  ;  case  ' "'  :  out  .  write  (  '\\'  )  ;  out  .  write  (  ' "'  )  ;  break  ;  case  '\\'  :  out  .  write  (  '\\'  )  ;  out  .  write  (  '\\'  )  ;  break  ;  case  '/'  :  [BUGGY]  out  .  write  (  '\\'  )  ;  out  .  write  (  '/'  )  ;  break  ;  default  :  out  .  write  (  ch  )  ;  break  ;  	Lang_46_StringEscapeUtils_8_8	244	0	src/java/org/apache/commons/lang/StringEscapeUtils.java
2106	if  (str  ==  null)  {  str  =   " ";  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (   "Failed  to  invoke  appendFixedWidthPadLeft  correctly "  ,   "********** "  ,  sb  .  toString  (  )  )  ;  [METHOD]  appendFixedWidthPadLeft  [TYPE]  StrBuilder  [PARAMETER]  Object  obj  int  width  char  padChar  [CLASS]  StrBuilder  [TYPE]  boolean  false  true  [TYPE]  char  padChar  [TYPE]  Object  obj  [TYPE]  String  newLine  nullText  str  [TYPE]  int  CAPACITY  i  mark  padLen  pos  size  strLen  width  [TYPE]  long  serialVersionUID  [TYPE]  char[]  buffer  [CONTEXT]  public  StrBuilder  appendFixedWidthPadLeft  (  Object  obj  ,  int  width  ,  char  padChar  )  {  if  (  width  >  0  )  {  ensureCapacity  (  size  +  width  )  ;  String  str  =  (  obj  =  =  null  ?  getNullText  (  )  :  obj  .  toString  (  )  )  ;  [BUGGY]  int  strLen  =  str  .  length  (  )  ;  if  (  strLen  >  =  width  )  {  str  .  getChars  (  strLen  -  width  ,  strLen  ,  buffer  ,  size  )  ;  }  else  {  int  padLen  =  width  -  strLen  ;  for  (  int  i  =  0  ;  i  <  padLen  ;  i++  )  {  buffer[size  +  i]  =  padChar  ;  }  str  .  getChars  (  0  ,  strLen  ,  buffer  ,  size  +  padLen  )  ;  }  size  +  =  width  ;  }  return  this  ;  }  	Lang_47_StrBuilder_2_1	1186	0	src/java/org/apache/commons/lang/text/StrBuilder.java
2107	if  (str  ==  null)  {  str  =   " ";  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (   "Failed  to  invoke  appendFixedWidthPadLeft  correctly "  ,   "********** "  ,  sb  .  toString  (  )  )  ;  [METHOD]  appendFixedWidthPadRight  [TYPE]  StrBuilder  [PARAMETER]  Object  obj  int  width  char  padChar  [CLASS]  StrBuilder  [TYPE]  boolean  false  true  [TYPE]  char  padChar  [TYPE]  Object  obj  [TYPE]  String  newLine  nullText  str  [TYPE]  int  CAPACITY  i  mark  padLen  pos  size  strLen  width  [TYPE]  long  serialVersionUID  [TYPE]  char[]  buffer  [CONTEXT]  public  StrBuilder  appendFixedWidthPadRight  (  Object  obj  ,  int  width  ,  char  padChar  )  {  if  (  width  >  0  )  {  ensureCapacity  (  size  +  width  )  ;  String  str  =  (  obj  =  =  null  ?  getNullText  (  )  :  obj  .  toString  (  )  )  ;  [BUGGY]  int  strLen  =  str  .  length  (  )  ;  if  (  strLen  >  =  width  )  {  str  .  getChars  (  0  ,  width  ,  buffer  ,  size  )  ;  }  else  {  int  padLen  =  width  -  strLen  ;  str  .  getChars  (  0  ,  strLen  ,  buffer  ,  size  )  ;  for  (  int  i  =  0  ;  i  <  padLen  ;  i++  )  {  buffer[size  +  strLen  +  i]  =  padChar  ;  }  }  size  +  =  width  ;  }  return  this  ;  }  	Lang_47_StrBuilder_2_2	1230	0	src/java/org/apache/commons/lang/text/StrBuilder.java
2108	if  (lhs  instanceof  java.math.BigDecimal)  {  isEquals  =  (((java.math.BigDecimal)lhs).compareTo(rhs)  ==  0);  }  else  {  }  	[BUGGY]  [FE]  AssertionFailedError  assertTrue  (  new  EqualsBuilder  (  )  .  append  (  o1  ,  o2  )  .  isEquals  (  )  )  ;  [METHOD]  append  [TYPE]  EqualsBuilder  [PARAMETER]  Object  lhs  Object  rhs  [CLASS]  EqualsBuilder  [TYPE]  Object  lhs  rhs  [TYPE]  Class  lhsClass  [TYPE]  boolean  false  isEquals  true  [CONTEXT]  public  EqualsBuilder  append  (  Object  lhs  ,  Object  rhs  )  {  if  (  isEquals  =  =  false  )  {  return  this  ;  }  if  (  lhs  =  =  rhs  )  {  return  this  ;  }  if  (  lhs  =  =  null  ||  rhs  =  =  null  )  {  this  .  setEquals  (  false  )  ;  return  this  ;  }  Class  lhsClass  =  lhs  .  getClass  (  )  ;  if  (  !lhsClass  .  isArray  (  )  )  {  [BUGGY]  isEquals  =  lhs  .  equals  (  rhs  )  ;  }  else  if  (  lhs  .  getClass  (  )  !  =  rhs  .  getClass  (  )  )  {  this  .  setEquals  (  false  )  ;  }  	Lang_48_EqualsBuilder_1_1	380	0	src/java/org/apache/commons/lang/builder/EqualsBuilder.java
2109	if  (numerator  ==  0)  {  return  equals(ZERO)  ?  this  :  ZERO;  }  	[BUGGY]  [FE]  AssertionFailedError:  expected:<1>  but  was:<100>  assertSame  (  result  ,  Fraction  .  ZERO  )  ;  [METHOD]  reduce  [TYPE]  Fraction  [PARAMETER]  [CLASS]  Fraction  [TYPE]  Fraction  FOUR_FIFTHS  ONE  ONE_FIFTH  ONE_HALF  ONE_QUARTER  ONE_THIRD  THREE_FIFTHS  THREE_QUARTERS  TWO_FIFTHS  TWO_QUARTERS  TWO_THIRDS  ZERO  [TYPE]  String  toProperString  toString  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  denominator  gcd  hashCode  numerator  [CONTEXT]  public  Fraction  reduce  (  )  {  [BUGGY]  int  gcd  =  greatestCommonDivisor  (  Math  .  abs  (  numerator  )  ,  denominator  )  ;  if  (  gcd  =  =  1  )  {  return  this  ;  }  return  Fraction  .  getFraction  (  numerator  /  gcd  ,  denominator  /  gcd  )  ;  }  	Lang_49_Fraction_1_1	466	0	src/java/org/apache/commons/lang/math/Fraction.java
2110	if  (locale  ==  null)  {  locale  =  Locale.getDefault();  key  =  new  Pair(key,  locale);  	[BUGGY]  if  (  locale  !  =  null  )  {  key  =  new  Pair  (  key  ,  locale  )  ;  [FE]  AssertionFailedError:  expected  same:<de_DE>  was  not:<en_US>  assertTrue  (  format2  !  =  format3  )  ;  [METHOD]  getDateInstance  [TYPE]  FastDateFormat  [PARAMETER]  int  style  TimeZone  timeZone  Locale  locale  [CLASS]  FastDateFormat  [TYPE]  Locale  locale  mLocale  [TYPE]  TimeZoneNumberRule  INSTANCE_COLON  INSTANCE_NO_COLON  [TYPE]  TwoDigitYearField  INSTANCE  [TYPE]  FastDateFormat  format  [TYPE]  String  cDefaultPattern  mDaylight  mPattern  mStandard  mValue  pattern  [TYPE]  String[]  mValues  [TYPE]  UnpaddedNumberField  INSTANCE_YEAR  [TYPE]  long  serialVersionUID  [TYPE]  int  FULL  LONG  MEDIUM  SHORT  mField  mMaxLengthEstimate  mSize  mStyle  style  [TYPE]  Rule[]  mRules  [TYPE]  TimeZone  mTimeZone  timeZone  [TYPE]  boolean  false  mColon  mLocaleForced  mTimeZoneForced  true  [TYPE]  NumberRule  mRule  [TYPE]  ClassCastException  ex  [TYPE]  char  mValue  [TYPE]  TwoDigitMonthField  INSTANCE  [TYPE]  UnpaddedMonthField  INSTANCE  [TYPE]  Object  key  mObj1  mObj2  [TYPE]  Map  cDateInstanceCache  cDateTimeInstanceCache  cInstanceCache  cTimeInstanceCache  cTimeZoneDisplayCache  [TYPE]  SimpleDateFormat  formatter  [CONTEXT]  public  static  synchronized  FastDateFormat  getDateInstance  (  int  style  ,  TimeZone  timeZone  ,  Locale  locale  )  {  Object  key  =  new  Integer  (  style  )  ;  if  (  timeZone  !  =  null  )  {  key  =  new  Pair  (  key  ,  timeZone  )  ;  }  [BUGGY]  if  (  locale  !  =  null  )  {  key  =  new  Pair  (  key  ,  locale  )  ;  }  FastDateFormat  format  =  (  FastDateFormat  )  cDateInstanceCache  .  get  (  key  )  ;  if  (  format  =  =  null  )  {  if  (  locale  =  =  null  )  {  locale  =  Locale  .  getDefault  (  )  ;  }  try  {  SimpleDateFormat  formatter  =  (  SimpleDateFormat  )  DateFormat  .  getDateInstance  (  style  ,  locale  )  ;  String  pattern  =  formatter  .  toPattern  (  )  ;  format  =  getInstance  (  pattern  ,  timeZone  ,  locale  )  ;  cDateInstanceCache  .  put  (  key  ,  format  )  ;  }  catch  (  ClassCastException  ex  )  {  throw  new  IllegalArgumentException  (   "No  date  pattern  for  locale:   "  +  locale  )  ;  }  }  return  format  ;  }  	Lang_50_FastDateFormat_4_1	285	2	src/java/org/apache/commons/lang/time/FastDateFormat.java
2111		[BUGGY]  if  (  locale  =  =  null  )  {  locale  =  Locale  .  getDefault  (  )  ;  }  [FE]  AssertionFailedError:  expected  same:<de_DE>  was  not:<en_US>  assertTrue  (  format2  !  =  format3  )  ;  [METHOD]  getDateInstance  [TYPE]  FastDateFormat  [PARAMETER]  int  style  TimeZone  timeZone  Locale  locale  [CLASS]  FastDateFormat  [TYPE]  Locale  locale  mLocale  [TYPE]  TimeZoneNumberRule  INSTANCE_COLON  INSTANCE_NO_COLON  [TYPE]  TwoDigitYearField  INSTANCE  [TYPE]  FastDateFormat  format  [TYPE]  String  cDefaultPattern  mDaylight  mPattern  mStandard  mValue  pattern  [TYPE]  String[]  mValues  [TYPE]  UnpaddedNumberField  INSTANCE_YEAR  [TYPE]  long  serialVersionUID  [TYPE]  int  FULL  LONG  MEDIUM  SHORT  mField  mMaxLengthEstimate  mSize  mStyle  style  [TYPE]  Rule[]  mRules  [TYPE]  TimeZone  mTimeZone  timeZone  [TYPE]  boolean  false  mColon  mLocaleForced  mTimeZoneForced  true  [TYPE]  NumberRule  mRule  [TYPE]  ClassCastException  ex  [TYPE]  char  mValue  [TYPE]  TwoDigitMonthField  INSTANCE  [TYPE]  UnpaddedMonthField  INSTANCE  [TYPE]  Object  key  mObj1  mObj2  [TYPE]  Map  cDateInstanceCache  cDateTimeInstanceCache  cInstanceCache  cTimeInstanceCache  cTimeZoneDisplayCache  [TYPE]  SimpleDateFormat  formatter  [CONTEXT]  public  static  synchronized  FastDateFormat  getDateInstance  (  int  style  ,  TimeZone  timeZone  ,  Locale  locale  )  {  Object  key  =  new  Integer  (  style  )  ;  if  (  timeZone  !  =  null  )  {  key  =  new  Pair  (  key  ,  timeZone  )  ;  }  if  (  locale  !  =  null  )  {  key  =  new  Pair  (  key  ,  locale  )  ;  }  FastDateFormat  format  =  (  FastDateFormat  )  cDateInstanceCache  .  get  (  key  )  ;  if  (  format  =  =  null  )  {  [BUGGY]  if  (  locale  =  =  null  )  {  locale  =  Locale  .  getDefault  (  )  ;  }  try  {  SimpleDateFormat  formatter  =  (  SimpleDateFormat  )  DateFormat  .  getDateInstance  (  style  ,  locale  )  ;  String  pattern  =  formatter  .  toPattern  (  )  ;  format  =  getInstance  (  pattern  ,  timeZone  ,  locale  )  ;  cDateInstanceCache  .  put  (  key  ,  format  )  ;  }  catch  (  ClassCastException  ex  )  {  throw  new  IllegalArgumentException  (   "No  date  pattern  for  locale:   "  +  locale  )  ;  }  }  return  format  ;  }  	Lang_50_FastDateFormat_4_2	292	3	src/java/org/apache/commons/lang/time/FastDateFormat.java
2112	if  (locale  ==  null)  {  locale  =  Locale.getDefault();  key  =  new  Pair(key,  locale);  	[BUGGY]  if  (  locale  !  =  null  )  {  key  =  new  Pair  (  key  ,  locale  )  ;  [FE]  AssertionFailedError:  expected  same:<de_DE>  was  not:<en_US>  assertTrue  (  format2  !  =  format3  )  ;  [METHOD]  getDateTimeInstance  [TYPE]  FastDateFormat  [PARAMETER]  int  dateStyle  int  timeStyle  TimeZone  timeZone  Locale  locale  [CLASS]  FastDateFormat  [TYPE]  Locale  locale  mLocale  [TYPE]  TimeZoneNumberRule  INSTANCE_COLON  INSTANCE_NO_COLON  [TYPE]  TwoDigitYearField  INSTANCE  [TYPE]  FastDateFormat  format  [TYPE]  String  cDefaultPattern  mDaylight  mPattern  mStandard  mValue  pattern  [TYPE]  String[]  mValues  [TYPE]  UnpaddedNumberField  INSTANCE_YEAR  [TYPE]  long  serialVersionUID  [TYPE]  int  FULL  LONG  MEDIUM  SHORT  dateStyle  mField  mMaxLengthEstimate  mSize  mStyle  timeStyle  [TYPE]  Rule[]  mRules  [TYPE]  TimeZone  mTimeZone  timeZone  [TYPE]  boolean  false  mColon  mLocaleForced  mTimeZoneForced  true  [TYPE]  NumberRule  mRule  [TYPE]  ClassCastException  ex  [TYPE]  char  mValue  [TYPE]  TwoDigitMonthField  INSTANCE  [TYPE]  UnpaddedMonthField  INSTANCE  [TYPE]  Object  key  mObj1  mObj2  [TYPE]  Map  cDateInstanceCache  cDateTimeInstanceCache  cInstanceCache  cTimeInstanceCache  cTimeZoneDisplayCache  [TYPE]  SimpleDateFormat  formatter  [CONTEXT]  public  static  synchronized  FastDateFormat  getDateTimeInstance  (  int  dateStyle  ,  int  timeStyle  ,  TimeZone  timeZone  ,  Locale  locale  )  {  Object  key  =  new  Pair  (  new  Integer  (  dateStyle  )  ,  new  Integer  (  timeStyle  )  )  ;  if  (  timeZone  !  =  null  )  {  key  =  new  Pair  (  key  ,  timeZone  )  ;  }  [BUGGY]  if  (  locale  !  =  null  )  {  key  =  new  Pair  (  key  ,  locale  )  ;  }  FastDateFormat  format  =  (  FastDateFormat  )  cDateTimeInstanceCache  .  get  (  key  )  ;  if  (  format  =  =  null  )  {  if  (  locale  =  =  null  )  {  locale  =  Locale  .  getDefault  (  )  ;  }  try  {  SimpleDateFormat  formatter  =  (  SimpleDateFormat  )  DateFormat  .  getDateTimeInstance  (  dateStyle  ,  timeStyle  ,  locale  )  ;  String  pattern  =  formatter  .  toPattern  (  )  ;  format  =  getInstance  (  pattern  ,  timeZone  ,  locale  )  ;  cDateTimeInstanceCache  .  put  (  key  ,  format  )  ;  }  catch  (  ClassCastException  ex  )  {  throw  new  IllegalArgumentException  (   "No  date  time  pattern  for  locale:   "  +  locale  )  ;  }  }  return  format  ;  }  	Lang_50_FastDateFormat_4_3	465	2	src/java/org/apache/commons/lang/time/FastDateFormat.java
2113		[BUGGY]  if  (  locale  =  =  null  )  {  locale  =  Locale  .  getDefault  (  )  ;  }  [FE]  AssertionFailedError:  expected  same:<de_DE>  was  not:<en_US>  assertTrue  (  format2  !  =  format3  )  ;  [METHOD]  getDateTimeInstance  [TYPE]  FastDateFormat  [PARAMETER]  int  dateStyle  int  timeStyle  TimeZone  timeZone  Locale  locale  [CLASS]  FastDateFormat  [TYPE]  Locale  locale  mLocale  [TYPE]  TimeZoneNumberRule  INSTANCE_COLON  INSTANCE_NO_COLON  [TYPE]  TwoDigitYearField  INSTANCE  [TYPE]  FastDateFormat  format  [TYPE]  String  cDefaultPattern  mDaylight  mPattern  mStandard  mValue  pattern  [TYPE]  String[]  mValues  [TYPE]  UnpaddedNumberField  INSTANCE_YEAR  [TYPE]  long  serialVersionUID  [TYPE]  int  FULL  LONG  MEDIUM  SHORT  dateStyle  mField  mMaxLengthEstimate  mSize  mStyle  timeStyle  [TYPE]  Rule[]  mRules  [TYPE]  TimeZone  mTimeZone  timeZone  [TYPE]  boolean  false  mColon  mLocaleForced  mTimeZoneForced  true  [TYPE]  NumberRule  mRule  [TYPE]  ClassCastException  ex  [TYPE]  char  mValue  [TYPE]  TwoDigitMonthField  INSTANCE  [TYPE]  UnpaddedMonthField  INSTANCE  [TYPE]  Object  key  mObj1  mObj2  [TYPE]  Map  cDateInstanceCache  cDateTimeInstanceCache  cInstanceCache  cTimeInstanceCache  cTimeZoneDisplayCache  [TYPE]  SimpleDateFormat  formatter  [CONTEXT]  public  static  synchronized  FastDateFormat  getDateTimeInstance  (  int  dateStyle  ,  int  timeStyle  ,  TimeZone  timeZone  ,  Locale  locale  )  {  Object  key  =  new  Pair  (  new  Integer  (  dateStyle  )  ,  new  Integer  (  timeStyle  )  )  ;  if  (  timeZone  !  =  null  )  {  key  =  new  Pair  (  key  ,  timeZone  )  ;  }  if  (  locale  !  =  null  )  {  key  =  new  Pair  (  key  ,  locale  )  ;  }  FastDateFormat  format  =  (  FastDateFormat  )  cDateTimeInstanceCache  .  get  (  key  )  ;  if  (  format  =  =  null  )  {  [BUGGY]  if  (  locale  =  =  null  )  {  locale  =  Locale  .  getDefault  (  )  ;  }  try  {  SimpleDateFormat  formatter  =  (  SimpleDateFormat  )  DateFormat  .  getDateTimeInstance  (  dateStyle  ,  timeStyle  ,  locale  )  ;  String  pattern  =  formatter  .  toPattern  (  )  ;  format  =  getInstance  (  pattern  ,  timeZone  ,  locale  )  ;  cDateTimeInstanceCache  .  put  (  key  ,  format  )  ;  }  catch  (  ClassCastException  ex  )  {  throw  new  IllegalArgumentException  (   "No  date  time  pattern  for  locale:   "  +  locale  )  ;  }  }  return  format  ;  }  	Lang_50_FastDateFormat_4_4	471	3	src/java/org/apache/commons/lang/time/FastDateFormat.java
2114	return  false;  	[BUGGY]  [FE]  StringIndexOutOfBoundsException:  String  index  out  of  range:  3  assertEquals  (  false  ,  BooleanUtils  .  toBoolean  (   "N "  ,   "Y "  ,   "N "  )  )  ;  [METHOD]  toBoolean  [TYPE]  boolean  [PARAMETER]  String  str  [CLASS]  BooleanUtils  [TYPE]  boolean  false  true  [TYPE]  char  ch  ch0  ch1  [TYPE]  String  str  [CONTEXT]  return  true  ;  }  if  (  str  =  =  null  )  {  return  false  ;  }  switch  (  str  .  length  (  )  )  {  case  2:  {  char  ch0  =  str  .  charAt  (  0  )  ;  char  ch1  =  str  .  charAt  (  1  )  ;  return  (  ch0  =  =  'o'  ||  ch0  =  =  'O'  )  &&  (  ch1  =  =  'n'  ||  ch1  =  =  'N'  )  ;  }  case  3:  {  char  ch  =  str  .  charAt  (  0  )  ;  if  (  ch  =  =  'y'  )  {  return  (  str  .  charAt  (  1  )  =  =  'e'  ||  str  .  charAt  (  1  )  =  =  'E'  )  &&  (  str  .  charAt  (  2  )  =  =  's'  ||  str  .  charAt  (  2  )  =  =  'S'  )  ;  }  if  (  ch  =  =  'Y'  )  {  return  (  str  .  charAt  (  1  )  =  =  'E'  ||  str  .  charAt  (  1  )  =  =  'e'  )  &&  (  str  .  charAt  (  2  )  =  =  'S'  ||  str  .  charAt  (  2  )  =  =  's'  )  ;  }  [BUGGY]  }  case  4:  {  char  ch  =  str  .  charAt  (  0  )  ;  if  (  ch  =  =  't'  )  {  return  (  str  .  charAt  (  1  )  =  =  'r'  ||  str  .  charAt  (  1  )  =  =  'R'  )  &&  	Lang_51_BooleanUtils_1_1	682	0	src/java/org/apache/commons/lang/BooleanUtils.java
2115		[BUGGY]  [FE]  ComparisonFailure:  expected:<ipt>alert  (  assertEquals  (   "document  .  getElementById  (  \\\ "test\\\ "  )  .  value  =  \\'<script>alert  (  \\'aaa\\'  )  ;  <\\/script>\\'  ;   "  ,  [METHOD]  escapeJavaStyleString  [TYPE]  void  [PARAMETER]  Writer  out  String  str  boolean  escapeSingleQuote  [CLASS]  StringEscapeUtils  [TYPE]  boolean  escapeSingleQuote  false  true  [TYPE]  char  ch  [TYPE]  String  str  [TYPE]  Writer  out  [TYPE]  int  i  sz  [CONTEXT]  break  ;  default  :  if  (  ch  >  0xf  )  {  out  .  write  (   "\\u00 "  +  hex  (  ch  )  )  ;  }  else  {  out  .  write  (   "\\u000 "  +  hex  (  ch  )  )  ;  }  break  ;  }  }  else  {  switch  (  ch  )  {  case  '\'':  if  (  escapeSingleQuote  )  {  out  .  write  (  '\\'  )  ;  }  out  .  write  (  '\''  )  ;  break  ;  case  ' "':  out  .  write  (  '\\'  )  ;  out  .  write  (  ' "'  )  ;  break  ;  case  '\\':  out  .  write  (  '\\'  )  ;  out  .  write  (  '\\'  )  ;  break  ;  [BUGGY]  default  :  out  .  write  (  ch  )  ;  break  ;  }  }  }  	Lang_52_StringEscapeUtils_1_1	236	0	src/java/org/apache/commons/lang/StringEscapeUtils.java
2116	}  	[BUGGY]  }  [FE]  AssertionFailedError:  Minute  Round  Up  Failed  expected:<Mon  Jul  02  08:09:00  PDT  2007>  but  was:<Mon  Jul  02  08:01:00  PDT  2007>  assertEquals  (   "Hour  Round  Up  Failed "  ,  [METHOD]  modify  [TYPE]  void  [PARAMETER]  Calendar  val  int  field  boolean  round  [CLASS]  DateUtils  [TYPE]  TimeZone  UTC_TIME_ZONE  [TYPE]  int[][]  fields  [TYPE]  boolean  done  false  offsetSet  round  roundUp  true  [TYPE]  Calendar  endFinal  spot  val  [TYPE]  long  MILLIS_PER_DAY  MILLIS_PER_HOUR  MILLIS_PER_MINUTE  MILLIS_PER_SECOND  time  [TYPE]  int  MILLIS_IN_DAY  MILLIS_IN_HOUR  MILLIS_IN_MINUTE  MILLIS_IN_SECOND  RANGE_MONTH_MONDAY  RANGE_MONTH_SUNDAY  RANGE_WEEK_CENTER  RANGE_WEEK_MONDAY  RANGE_WEEK_RELATIVE  RANGE_WEEK_SUNDAY  SEMI_MONTH  field  i  j  max  millisecs  min  minutes  offset  seconds  [TYPE]  Date  date  [CONTEXT]  private  static  void  modify  (  Calendar  val  ,  int  field  ,  boolean  round  )  {  if  (  val  .  get  (  Calendar  .  YEAR  )  >  280000000  )  {  throw  new  ArithmeticException  (   "Calendar  value  too  large  for  accurate  calculations "  )  ;  }  if  (  field  =  =  Calendar  .  MILLISECOND  )  {  return  ;  }        Date  date  =  val  .  getTime  (  )  ;  long  time  =  date  .  getTime  (  )  ;  boolean  done  =  false  ;    int  millisecs  =  val  .  get  (  Calendar  .  MILLISECOND  )  ;  if  (  !round  ||  millisecs  <  500  )  {  time  =  time  -  millisecs  ;  [BUGGY]  if  (  field  =  =  Calendar  .  SECOND  )  {  done  =  true  ;  }  }  	Lang_53_DateUtils_2_1	643	1	src/java/org/apache/commons/lang/time/DateUtils.java
2118	 if (ch3 == '_') {    return new Locale(str.substring(0, 2), "", str.substring(4));  }  	[BUGGY]  [FE]  IllegalArgumentException:  Invalid  locale  format:  fr__POSIX  assertValidToLocale  (   "fr__POSIX "  ,   "fr "  ,   " "  ,   "POSIX "  )  ;  [METHOD]  toLocale  [TYPE]  Locale  [PARAMETER]  String  str  [CLASS]  LocaleUtils  [TYPE]  Set  cAvailableLocaleSet  [TYPE]  boolean  false  true  [TYPE]  char  ch0  ch1  ch3  ch4  [TYPE]  List  cAvailableLocaleList  [TYPE]  String  str  [TYPE]  Map  cCountriesByLanguage  cLanguagesByCountry  [TYPE]  int  len  [CONTEXT]  public  static  Locale  toLocale  (  String  str  )  {  if  (  str  =  =  null  )  {  return  null  ;  }  int  len  =  str  .  length  (  )  ;  if  (  len  !  =  2  &&  len  !  =  5  &&  len  <  7  )  {  throw  new  IllegalArgumentException  (   "Invalid  locale  format:   "  +  str  )  ;  }  char  ch0  =  str  .  charAt  (  0  )  ;  char  ch1  =  str  .  charAt  (  1  )  ;  if  (  ch0  <  'a'  ||  ch0  >  'z'  ||  ch1  <  'a'  ||  ch1  >  'z'  )  {  throw  new  IllegalArgumentException  (   "Invalid  locale  format:   "  +  str  )  ;  }  if  (  len  =  =  2  )  {  return  new  Locale  (  str  ,   " "  )  ;  }  else  {  if  (  str  .  charAt  (  2  )  !  =  '_'  )  {  throw  new  IllegalArgumentException  (   "Invalid  locale  format:   "  +  str  )  ;  }  char  ch3  =  str  .  charAt  (  3  )  ;  [BUGGY]  char  ch4  =  str  .  charAt  (  4  )  ;  if  (  ch3  <  'A'  ||  ch3  >  'Z'  ||  ch4  <  'A'  ||  ch4  >  'Z'  )  {  throw  new  IllegalArgumentException  (   "Invalid  locale  format:   "  +  str  )  ;  }  if  (  len  =  =  5  )  {  return  new  Locale  (  str  .  substring  (  0  ,  2  )  ,  str  .  substring  (  3  ,  5  )  )  ;  	Lang_54_LocaleUtils_1_1	114	0	src/java/org/apache/commons/lang/LocaleUtils.java
2119	if(this.runningState  ==  STATE_RUNNING)    	[BUGGY] [FE]  AssertionFailedError  assertTrue  (  suspendTime  =  =  totalTime  )  ;  [METHOD]  stop  [TYPE]  void  [PARAMETER]  [CLASS]  StopWatch  [TYPE]  int  STATE_RUNNING  STATE_SPLIT  STATE_STOPPED  STATE_SUSPENDED  STATE_UNSPLIT  STATE_UNSTARTED  runningState  splitState  [TYPE]  long  startTime  stopTime  [TYPE]  boolean  false  true  [CONTEXT]  public  void  stop  (  )  {  if  (  this  .  runningState  !  =  STATE_RUNNING  &&  this  .  runningState  !  =  STATE_SUSPENDED  )  {  throw  new  IllegalStateException  (   "Stopwatch  is  not  running  .   "  )  ;  }  [BUGGY]  stopTime  =  System  .  currentTimeMillis  (  )  ;  this  .  runningState  =  STATE_STOPPED  ;  }  	Lang_55_StopWatch_1_1	118	0	src/java/org/apache/commons/lang/time/StopWatch.java
2120	private  transient  Rule[]  mRules;  	[BUGGY]  private  Rule[]  mRules  ;  [FE]  commonslangSerializationException:  javaioNotSerializableException:  orgapachecommonslangtimeFastDateFormat$PaddedNumberField  [CLASS]  [CONTEXT]  	Lang_56_FastDateFormat_3_1	140	1	src/java/org/apache/commons/lang/time/FastDateFormat.java
2121	private  transient  int  mMaxLengthEstimate;  	[BUGGY]  private  int  mMaxLengthEstimate  ;  [FE]  commonslangSerializationException:  javaioNotSerializableException:  orgapachecommonslangtimeFastDateFormat$PaddedNumberField  [CLASS]  [CONTEXT]  	Lang_56_FastDateFormat_3_2	144	1	src/java/org/apache/commons/lang/time/FastDateFormat.java
2122	private  void  readObject(ObjectInputStream  in)  throws  IOException,  ClassNotFoundException  {  in.defaultReadObject();  init();  }  	[BUGGY]  [FE]  commonslangSerializationException:  javaioNotSerializableException:  orgapachecommonslangtimeFastDateFormat$PaddedNumberField  [CLASS]  [CONTEXT]  	Lang_56_FastDateFormat_3_3	1022	0	src/java/org/apache/commons/lang/time/FastDateFormat.java
2123	return  availableLocaleList().contains(locale);  	[BUGGY]  return  cAvailableLocaleSet  .  contains  (  locale  )  ;  [FE]  NullPointerException  assertEquals  (  jdkLocaleSet  ,  set  )  ;  [METHOD]  isAvailableLocale  [TYPE]  boolean  [PARAMETER]  Locale  locale  [CLASS]  LocaleUtils  [TYPE]  Locale  locale  [TYPE]  List  cAvailableLocaleList  [TYPE]  Set  cAvailableLocaleSet  [TYPE]  boolean  false  true  [TYPE]  Map  cCountriesByLanguage  cLanguagesByCountry  [CONTEXT]  public  static  boolean  isAvailableLocale  (  Locale  locale  )  {  [BUGGY]  return  cAvailableLocaleSet  .  contains  (  locale  )  ;  }  	Lang_57_LocaleUtils_1_1	223	1	src/java/org/apache/commons/lang/LocaleUtils.java
2124		[BUGGY]  &&  isDigits  (  numeric  .  substring  (  1  )  )  \n'  ,   "-            &&  (  numeric  .  charAt  (  0  )  =  =  '-'  ||  Character  .  isDigit  (  numeric  .  charAt  (  0  )  )  )  )  {\n "  ,   "+            &&  (  numeric  .  charAt  (  0  )  =  =  '-'  &&  isDigits  (  numeric  .  substring  (  1  )  )  ||  isDigits  (  numeric  )  )  )  {\n "  ,  '              try  {\n']  [FE]  NumberFormatException:  1l  is  not  a  valid  number  [METHOD]  createNumber  [TYPE]  Number  [PARAMETER]  String  str  [CLASS]  NumberUtils  [TYPE]  Integer  INTEGER_MINUS_ONE  INTEGER_ONE  INTEGER_ZERO  [TYPE]  Float  FLOAT_MINUS_ONE  FLOAT_ONE  FLOAT_ZERO  f  [TYPE]  boolean  allZeros  false  true  [TYPE]  Byte  BYTE_MINUS_ONE  BYTE_ONE  BYTE_ZERO  [TYPE]  Long  LONG_MINUS_ONE  LONG_ONE  LONG_ZERO  [TYPE]  char  lastChar  [TYPE]  NumberFormatException  e  nfe  [TYPE]  String  dec  exp  mant  numeric  str  [TYPE]  Double  DOUBLE_MINUS_ONE  DOUBLE_ONE  DOUBLE_ZERO  d  [TYPE]  Short  SHORT_MINUS_ONE  SHORT_ONE  SHORT_ZERO  [TYPE]  int  decPos  expPos  [CONTEXT]  dec  =  str  .  substring  (  decPos  +  1  )  ;  }  mant  =  str  .  substring  (  0  ,  decPos  )  ;  }  else  {  if  (  expPos  >  -1  )  {  mant  =  str  .  substring  (  0  ,  expPos  )  ;  }  else  {  mant  =  str  ;  }  dec  =  null  ;  }  if  (  !Character  .  isDigit  (  lastChar  )  )  {  if  (  expPos  >  -1  &&  expPos  <  str  .  length  (  )  -  1  )  {  exp  =  str  .  substring  (  expPos  +  1  ,  str  .  length  (  )  -  1  )  ;  }  else  {  exp  =  null  ;  }  String  numeric  =  str  .  substring  (  0  ,  str  .  length  (  )  -  1  )  ;  boolean  allZeros  =  isAllZeros  (  mant  )  &&  isAllZeros  (  exp  )  ;  switch  (  lastChar  )  {  case  'l'  :  case  'L'  :  if  (  dec  =  =  null  &&  exp  =  =  null  [BUGGY]  &&  isDigits  (  numeric  .  substring  (  1  )  )  &&  (  numeric  .  charAt  (  0  )  =  =  '-'  ||  Character  .  isDigit  (  numeric  .  charAt  (  0  )  )  )  )  {  try  {  return  createLong  (  numeric  )  ;  }  catch  (  NumberFormatException  nfe  )  {  	Lang_58_NumberUtils_1_1	454	1	src/java/org/apache/commons/lang/math/NumberUtils.java
2125	str.getChars(0,  width,  buffer,  size);  	[BUGGY]  str  .  getChars  (  0  ,  strLen  ,  buffer  ,  size  )  ;  [FE]  ArrayIndexOutOfBoundsException  assertEquals  (   "f "  ,  sb  .  toString  (  )  )  ;  [METHOD]  appendFixedWidthPadRight  [TYPE]  StrBuilder  [PARAMETER]  Object  obj  int  width  char  padChar  [CLASS]  StrBuilder  [TYPE]  boolean  false  true  [TYPE]  char  padChar  [TYPE]  Object  obj  [TYPE]  String  newLine  nullText  str  [TYPE]  int  CAPACITY  i  mark  padLen  pos  size  strLen  width  [TYPE]  long  serialVersionUID  [TYPE]  char[]  buffer  [CONTEXT]  public  StrBuilder  appendFixedWidthPadRight  (  Object  obj  ,  int  width  ,  char  padChar  )  {  if  (  width  >  0  )  {  ensureCapacity  (  size  +  width  )  ;  String  str  =  (  obj  =  =  null  ?  getNullText  (  )  :  obj  .  toString  (  )  )  ;  int  strLen  =  str  .  length  (  )  ;  if  (  strLen  >  =  width  )  {  [BUGGY]  str  .  getChars  (  0  ,  strLen  ,  buffer  ,  size  )  ;  }  else  {  int  padLen  =  width  -  strLen  ;  str  .  getChars  (  0  ,  strLen  ,  buffer  ,  size  )  ;  for  (  int  i  =  0  ;  i  <  padLen  ;  i++  )  {  buffer[size  +  strLen  +  i]  =  padChar  ;  }  }  size  +  =  width  ;  }  return  this  ;  }  	Lang_59_StrBuilder_1_1	884	1	src/java/org/apache/commons/lang/text/StrBuilder.java
2126	for  (int  i  =  0;  i  <  this.size;  i++)  {  	[BUGGY]  for  (  int  i  =  0  ;  i  <  thisBuf  .  length  ;  i++  )  {  [FE]  AssertionFailedError:  The  contains  (  char  )  method  is  looking  beyond  the  end  of  the  string  assertEquals  (   "The  indexOf  (  char  )  method  is  looking  beyond  the  end  of  the  string "  ,  -1  ,  sb  .  indexOf  (  'h'  )  )  ;  [METHOD]  contains  [TYPE]  boolean  [PARAMETER]  char  ch  [CLASS]  StrBuilder  [TYPE]  char  ch  [TYPE]  String  newLine  nullText  [TYPE]  boolean  false  true  [TYPE]  int  CAPACITY  i  mark  pos  size  [TYPE]  long  serialVersionUID  [TYPE]  char[]  buffer  thisBuf  [CONTEXT]  public  boolean  contains  (  char  ch  )  {  char[]  thisBuf  =  buffer  ;  [BUGGY]  for  (  int  i  =  0  ;  i  <  thisBuf  .  length  ;  i++  )  {  if  (  thisBuf[i]  =  =  ch  )  {  return  true  ;  }  }  return  false  ;  }  	Lang_60_StrBuilder_2_1	1673	1	src/java/org/apache/commons/lang/text/StrBuilder.java
2127	for  (int  i  =  startIndex;  i  <  size;  i++)  {  	[BUGGY]  for  (  int  i  =  startIndex  ;  i  <  thisBuf  .  length  ;  i++  )  {  [FE]  AssertionFailedError:  The  contains  (  char  )  method  is  looking  beyond  the  end  of  the  string  assertEquals  (   "The  indexOf  (  char  )  method  is  looking  beyond  the  end  of  the  string "  ,  -1  ,  sb  .  indexOf  (  'h'  )  )  ;  [METHOD]  indexOf  [TYPE]  int  [PARAMETER]  char  ch  int  startIndex  [CLASS]  StrBuilder  [TYPE]  char  ch  [TYPE]  String  newLine  nullText  [TYPE]  boolean  false  true  [TYPE]  int  CAPACITY  i  mark  pos  size  startIndex  [TYPE]  long  serialVersionUID  [TYPE]  char[]  buffer  thisBuf  [CONTEXT]  public  int  indexOf  (  char  ch  ,  int  startIndex  )  {  startIndex  =  (  startIndex  <  0  ?  0  :  startIndex  )  ;  if  (  startIndex  >  =  size  )  {  return  -1  ;  }  char[]  thisBuf  =  buffer  ;  [BUGGY]  for  (  int  i  =  startIndex  ;  i  <  thisBuf  .  length  ;  i++  )  {  if  (  thisBuf[i]  =  =  ch  )  {  return  i  ;  }  }  return  -1  ;  }  	Lang_60_StrBuilder_2_2	1730	1	src/java/org/apache/commons/lang/text/StrBuilder.java
2128	int  len  =  size  -  strLen  +  1;  	[BUGGY]  int  len  =  thisBuf  .  length  -  strLen  ;  [FE]  AssertionFailedError:  expected:<-1>  but  was:<6>  assertEquals  (  -1  ,  sb  .  indexOf  (   "three "  )  )  ;  [METHOD]  indexOf  [TYPE]  int  [PARAMETER]  String  str  int  startIndex  [CLASS]  StrBuilder  [TYPE]  String  newLine  nullText  str  [TYPE]  boolean  false  true  [TYPE]  int  CAPACITY  i  j  len  mark  pos  size  startIndex  strLen  [TYPE]  long  serialVersionUID  [TYPE]  char[]  buffer  thisBuf  [CONTEXT]  public  int  indexOf  (  String  str  ,  int  startIndex  )  {  startIndex  =  (  startIndex  <  0  ?  0  :  startIndex  )  ;  if  (  str  =  =  null  ||  startIndex  >  =  size  )  {  return  -1  ;  }  int  strLen  =  str  .  length  (  )  ;  if  (  strLen  =  =  1  )  {  return  indexOf  (  str  .  charAt  (  0  )  ,  startIndex  )  ;  }  if  (  strLen  =  =  0  )  {  return  startIndex  ;  }  if  (  strLen  >  size  )  {  return  -1  ;  }  char[]  thisBuf  =  buffer  ;  [BUGGY]  int  len  =  thisBuf  .  length  -  strLen  ;  outer:  for  (  int  i  =  startIndex  ;  i  <  len  ;  i++  )  {  for  (  int  j  =  0  ;  j  <  strLen  ;  j++  )  {  if  (  str  .  charAt  (  j  )  !  =  thisBuf[i  +  j]  )  {  continue  outer  ;  }  }  return  i  ;  }  return  -1  ;  }  	Lang_61_StrBuilder_1_1	1776	1	src/java/org/apache/commons/lang/text/StrBuilder.java
2129	if  (entityValue  >  0xFFFF)  {  entityValue  =  -1;  }  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[&#12345678  ;  ]>  but  was:<[  [METHOD]  unescape  [TYPE]  String  [PARAMETER]  String  str  [CLASS]  Entities  [TYPE]  String[][]  APOS_ARRAY  BASIC_ARRAY  HTML40_ARRAY  ISO8859_1_ARRAY  [TYPE]  NumberFormatException  ex  [TYPE]  int[]  values  [TYPE]  String[]  lookupTable  names  [TYPE]  String  entityName  str  [TYPE]  int  LOOKUP_TABLE_SIZE  amph  entityValue  firstAmp  growBy  i  semi  size  [TYPE]  Entities  HTML32  HTML40  XML  [TYPE]  IntHashMap  mapValueToName  [TYPE]  StringBuffer  buf  [TYPE]  boolean  false  true  [TYPE]  EntityMap  map  [TYPE]  char  ch  charAt1  [TYPE]  Map  mapNameToValue  mapValueToName  [CONTEXT]  if  (  semi  =  =  -1  )  {  buf  .  append  (  ch  )  ;  continue  ;  }  int  amph  =  str  .  indexOf  (  '&'  ,  i  +  1  )  ;  if  (  amph  !  =  -1  &&  amph  <  semi  )  {  buf  .  append  (  ch  )  ;  continue  ;  }  String  entityName  =  str  .  substring  (  i  +  1  ,  semi  )  ;  int  entityValue  ;  if  (  entityName  .  length  (  )  =  =  0  )  {  entityValue  =  -1  ;  }  else  if  (  entityName  .  charAt  (  0  )  =  =  '#'  )  {  if  (  entityName  .  length  (  )  =  =  1  )  {  entityValue  =  -1  ;  }  else  {  char  charAt1  =  entityName  .  charAt  (  1  )  ;  try  {  if  (  charAt1  =  =  'x'  ||  charAt1  =  =  'X'  )  {  entityValue  =  Integer  .  valueOf  (  entityName  .  substring  (  2  )  ,  16  )  .  intValue  (  )  ;  }  else  {  entityValue  =  Integer  .  parseInt  (  entityName  .  substring  (  1  )  )  ;  }  [BUGGY]  }  catch  (  NumberFormatException  ex  )  {  entityValue  =  -1  ;  }  }  }  else  {  entityValue  =  this  .  entityValue  (  entityName  )  ;  	Lang_62_Entities_3_1	850	0	src/java/org/apache/commons/lang/Entities.java
2130	break;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[&#12345678  ;  ]>  but  was:<[  [METHOD]  unescape  [TYPE]  void  [PARAMETER]  Writer  writer  String  string  [CLASS]  Entities  [TYPE]  String[][]  APOS_ARRAY  BASIC_ARRAY  HTML40_ARRAY  ISO8859_1_ARRAY  [TYPE]  NumberFormatException  e  [TYPE]  int[]  values  [TYPE]  String[]  lookupTable  names  [TYPE]  String  entityContent  string  [TYPE]  int  LOOKUP_TABLE_SIZE  amphersandIdx  entityContentLen  entityValue  firstAmp  growBy  i  len  nextIdx  semiColonIdx  size  [TYPE]  Entities  HTML32  HTML40  XML  [TYPE]  IntHashMap  mapValueToName  [TYPE]  boolean  false  true  [TYPE]  EntityMap  map  [TYPE]  char  c  isHexChar  [TYPE]  Map  mapNameToValue  mapValueToName  [TYPE]  Writer  writer  [CONTEXT]  if  (  c  =  =  '&'  )  {  int  nextIdx  =  i+1  ;  int  semiColonIdx  =  string  .  indexOf  (  '  ;  '  ,  nextIdx  )  ;  if  (  semiColonIdx  =  =  -1  )  {  writer  .  write  (  c  )  ;  continue  ;  }  int  amphersandIdx  =  string  .  indexOf  (  '&'  ,  i  +  1  )  ;  if  (  amphersandIdx  !  =  -1  &&  amphersandIdx  <  semiColonIdx  )  {  writer  .  write  (  c  )  ;  continue  ;  }  String  entityContent  =  string  .  substring  (  nextIdx  ,  semiColonIdx  )  ;  int  entityValue  =  -1  ;  int  entityContentLen  =  entityContent  .  length  (  )  ;  if  (  entityContentLen  >  0  )  {  if  (  entityContent  .  charAt  (  0  )  =  =  '#'  )  {  //escaped  value  content  is  an  integer  (  decimal  or  hexidecimal  )  if  (  entityContentLen  >  1  )  {  char  isHexChar  =  entityContent  .  charAt  (  1  )  ;  try  {  switch  (  isHexChar  )  {  case  'X'  :  case  'x'  :  {  entityValue  =  Integer  .  parseInt  (  entityContent  .  substring  (  2  )  ,  16  )  ;  [BUGGY]  }  default  :  {  entityValue  =  Integer  .  parseInt  (  entityContent  .  substring  (  1  )  ,  10  )  ;  }  }  }  catch  (  NumberFormatException  e  )  {  	Lang_62_Entities_3_2	920	0	src/java/org/apache/commons/lang/Entities.java
2131	if  (entityValue  >  0xFFFF)  {  entityValue  =  -1;  }  entityValue  =  -1;  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[&#12345678  ;  ]>  but  was:<[  [METHOD]  unescape  [TYPE]  void  [PARAMETER]  Writer  writer  String  string  [CLASS]  Entities  [TYPE]  String[][]  APOS_ARRAY  BASIC_ARRAY  HTML40_ARRAY  ISO8859_1_ARRAY  [TYPE]  NumberFormatException  e  [TYPE]  int[]  values  [TYPE]  String[]  lookupTable  names  [TYPE]  String  entityContent  string  [TYPE]  int  LOOKUP_TABLE_SIZE  amphersandIdx  entityContentLen  entityValue  firstAmp  growBy  i  len  nextIdx  semiColonIdx  size  [TYPE]  Entities  HTML32  HTML40  XML  [TYPE]  IntHashMap  mapValueToName  [TYPE]  boolean  false  true  [TYPE]  EntityMap  map  [TYPE]  char  c  isHexChar  [TYPE]  Map  mapNameToValue  mapValueToName  [TYPE]  Writer  writer  [CONTEXT]  continue  ;  }  int  amphersandIdx  =  string  .  indexOf  (  '&'  ,  i  +  1  )  ;  if  (  amphersandIdx  !  =  -1  &&  amphersandIdx  <  semiColonIdx  )  {  writer  .  write  (  c  )  ;  continue  ;  }  String  entityContent  =  string  .  substring  (  nextIdx  ,  semiColonIdx  )  ;  int  entityValue  =  -1  ;  int  entityContentLen  =  entityContent  .  length  (  )  ;  if  (  entityContentLen  >  0  )  {  if  (  entityContent  .  charAt  (  0  )  =  =  '#'  )  {  //escaped  value  content  is  an  integer  (  decimal  or  hexidecimal  )  if  (  entityContentLen  >  1  )  {  char  isHexChar  =  entityContent  .  charAt  (  1  )  ;  try  {  switch  (  isHexChar  )  {  case  'X'  :  case  'x'  :  {  entityValue  =  Integer  .  parseInt  (  entityContent  .  substring  (  2  )  ,  16  )  ;  }  default  :  {  entityValue  =  Integer  .  parseInt  (  entityContent  .  substring  (  1  )  ,  10  )  ;  }  }  [BUGGY]  }  catch  (  NumberFormatException  e  )  {  }  }  }  else  {  //escaped  value  content  is  an  entity  name  entityValue  =  this  .  entityValue  (  entityContent  )  ;  }  	Lang_62_Entities_3_3	925	0	src/java/org/apache/commons/lang/Entities.java
2132	end.add(Calendar.MONTH,  -1);  days  +=  end.getActualMaximum(Calendar.DAY_OF_MONTH);  	[BUGGY]  days  +  =  31  ;  [FE]  ComparisonFailure:  expected:<[09]>  but  was:<[-2]>  assertTrue  (   "Index   "  +  i  +   "  not  equal  ,   "  +  obj1[i]  +   "  vs   "  +  obj2  ,  obj1[i]  .  equals  (  obj2[i]  )  )  ;  [METHOD]  formatPeriod  [TYPE]  String  [PARAMETER]  long  startMillis  long  endMillis  String  format  boolean  padWithZeros  TimeZone  timezone  [CLASS]  DurationFormatUtils  [TYPE]  TimeZone  timezone  [TYPE]  boolean  false  padWithZeros  true  [TYPE]  Token[]  tokens  [TYPE]  Calendar  end  start  [TYPE]  Object  H  M  S  d  m  s  value  y  [TYPE]  String  ISO_EXTENDED_FORMAT_PATTERN  format  [TYPE]  int  count  days  hours  milliseconds  minutes  months  seconds  years  [TYPE]  long  endMillis  millis  startMillis  [CONTEXT]  int  seconds  =  end  .  get  (  Calendar  .  SECOND  )  -  start  .  get  (  Calendar  .  SECOND  )  ;  int  minutes  =  end  .  get  (  Calendar  .  MINUTE  )  -  start  .  get  (  Calendar  .  MINUTE  )  ;  int  hours  =  end  .  get  (  Calendar  .  HOUR_OF_DAY  )  -  start  .  get  (  Calendar  .  HOUR_OF_DAY  )  ;  int  days  =  end  .  get  (  Calendar  .  DAY_OF_MONTH  )  -  start  .  get  (  Calendar  .  DAY_OF_MONTH  )  ;  int  months  =  end  .  get  (  Calendar  .  MONTH  )  -  start  .  get  (  Calendar  .  MONTH  )  ;  int  years  =  end  .  get  (  Calendar  .  YEAR  )  -  start  .  get  (  Calendar  .  YEAR  )  ;    while  (  milliseconds  <  0  )  {  milliseconds  +  =  1000  ;  seconds  -  =  1  ;  }  while  (  seconds  <  0  )  {  seconds  +  =  60  ;  minutes  -  =  1  ;  }  while  (  minutes  <  0  )  {  minutes  +  =  60  ;  hours  -  =  1  ;  }  while  (  hours  <  0  )  {  hours  +  =  24  ;  days  -  =  1  ;  }  while  (  days  <  0  )  {  [BUGGY]  days  +  =  31  ;      	Lang_63_DurationFormatUtils_4_1	306	1	src/java/org/apache/commons/lang/time/DurationFormatUtils.java
2133	end.add(Calendar.MONTH,  1);  	[BUGGY]  [FE]  ComparisonFailure:  expected:<[09]>  but  was:<[-2]>  assertTrue  (   "Index   "  +  i  +   "  not  equal  ,   "  +  obj1[i]  +   "  vs   "  +  obj2  ,  obj1[i]  .  equals  (  obj2[i]  )  )  ;  [METHOD]  formatPeriod  [TYPE]  String  [PARAMETER]  long  startMillis  long  endMillis  String  format  boolean  padWithZeros  TimeZone  timezone  [CLASS]  DurationFormatUtils  [TYPE]  TimeZone  timezone  [TYPE]  boolean  false  padWithZeros  true  [TYPE]  Token[]  tokens  [TYPE]  Calendar  end  start  [TYPE]  Object  H  M  S  d  m  s  value  y  [TYPE]  String  ISO_EXTENDED_FORMAT_PATTERN  format  [TYPE]  int  count  days  hours  milliseconds  minutes  months  seconds  years  [TYPE]  long  endMillis  millis  startMillis  [CONTEXT]  while  (  milliseconds  <  0  )  {  milliseconds  +  =  1000  ;  seconds  -  =  1  ;  }  while  (  seconds  <  0  )  {  seconds  +  =  60  ;  minutes  -  =  1  ;  }  while  (  minutes  <  0  )  {  minutes  +  =  60  ;  hours  -  =  1  ;  }  while  (  hours  <  0  )  {  hours  +  =  24  ;  days  -  =  1  ;  }  while  (  days  <  0  )  {  days  +  =  31  ;      months  -  =  1  ;  [BUGGY]  }  while  (  months  <  0  )  {  months  +  =  12  ;  years  -  =  1  ;  }  milliseconds  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  MILLISECOND  ,  milliseconds  )  ;  	Lang_63_DurationFormatUtils_4_2	313	0	src/java/org/apache/commons/lang/time/DurationFormatUtils.java
2134		[BUGGY]  milliseconds  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  MILLISECOND  ,  milliseconds  )  ;  seconds  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  SECOND  ,  seconds  )  ;  minutes  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  MINUTE  ,  minutes  )  ;  hours  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  HOUR_OF_DAY  ,  hours  )  ;  days  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  DAY_OF_MONTH  ,  days  )  ;  months  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  MONTH  ,  months  )  ;  years  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  YEAR  ,  years  )  ;  [FE]  ComparisonFailure:  expected:<[09]>  but  was:<[-2]>  assertTrue  (   "Index   "  +  i  +   "  not  equal  ,   "  +  obj1[i]  +   "  vs   "  +  obj2  ,  obj1[i]  .  equals  (  obj2[i]  )  )  ;  [METHOD]  formatPeriod  [TYPE]  String  [PARAMETER]  long  startMillis  long  endMillis  String  format  boolean  padWithZeros  TimeZone  timezone  [CLASS]  DurationFormatUtils  [TYPE]  TimeZone  timezone  [TYPE]  boolean  false  padWithZeros  true  [TYPE]  Token[]  tokens  [TYPE]  Calendar  end  start  [TYPE]  Object  H  M  S  d  m  s  value  y  [TYPE]  String  ISO_EXTENDED_FORMAT_PATTERN  format  [TYPE]  int  count  days  hours  milliseconds  minutes  months  seconds  years  [TYPE]  long  endMillis  millis  startMillis  [CONTEXT]  while  (  seconds  <  0  )  {  seconds  +  =  60  ;  minutes  -  =  1  ;  }  while  (  minutes  <  0  )  {  minutes  +  =  60  ;  hours  -  =  1  ;  }  while  (  hours  <  0  )  {  hours  +  =  24  ;  days  -  =  1  ;  }  while  (  days  <  0  )  {  days  +  =  31  ;      months  -  =  1  ;  }  while  (  months  <  0  )  {  months  +  =  12  ;  years  -  =  1  ;  }  [BUGGY]  milliseconds  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  MILLISECOND  ,  milliseconds  )  ;  seconds  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  SECOND  ,  seconds  )  ;  minutes  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  MINUTE  ,  minutes  )  ;  hours  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  HOUR_OF_DAY  ,  hours  )  ;  days  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  DAY_OF_MONTH  ,  days  )  ;  months  -  =  reduceAndCorrect  (  start  ,  end  ,  Calendar  .  MONTH  ,  months  )  ;  	Lang_63_DurationFormatUtils_4_3	318	7	src/java/org/apache/commons/lang/time/DurationFormatUtils.java
2135		[BUGGY]  static  int  reduceAndCorrect  (  Calendar  start  ,  Calendar  end  ,  int  field  ,  int  difference  )  {  end  .  add  (  field  ,  -1  *  difference  )  ;  int  endValue  =  end  .  get  (  field  )  ;  int  startValue  =  start  .  get  (  field  )  ;  if  (  endValue  <  startValue  )  {  int  newdiff  =  startValue  -  endValue  ;  end  .  add  (  field  ,  newdiff  )  ;  return  newdiff  ;  }  else  {  return  0  ;  }  }  [FE]  ComparisonFailure:  expected:<[09]>  but  was:<[-2]>  assertTrue  (   "Index   "  +  i  +   "  not  equal  ,   "  +  obj1[i]  +   "  vs   "  +  obj2  ,  obj1[i]  .  equals  (  obj2[i]  )  )  ;  [CLASS]  [CONTEXT]  	Lang_63_DurationFormatUtils_4_4	432	12	src/java/org/apache/commons/lang/time/DurationFormatUtils.java
2136	if  (other  ==  this)  {  return  0;  }  if  (other.getClass()  !=  this.getClass())  {  if  (other.getClass().getName().equals(this.getClass().getName()))  {  return  iValue  -  getValueInOtherClassLoader(other);  }  throw  new  ClassCastException(   "Different  enum  class  \' "  +  ClassUtils.getShortClassName(other.getClass())  +   "\' ");  }  	[BUGGY]  [FE]  AssertionFailedError  [METHOD]  compareTo  [TYPE]  int  [PARAMETER]  Object  other  [CLASS]  ValuedEnum  [TYPE]  Object  other  [TYPE]  boolean  false  true  [TYPE]  long  serialVersionUID  [TYPE]  int  iValue  [CONTEXT]  public  int  compareTo  (  Object  other  )  {  [BUGGY]  return  iValue  -  (  (  ValuedEnum  )  other  )  .  iValue  ;  }  	Lang_64_ValuedEnum_2_1	183	0	src/java/org/apache/commons/lang/enums/ValuedEnum.java
2137	private  int  getValueInOtherClassLoader(Object  other)  {  try  {  Method  mth  =  other.getClass().getMethod( "getValue ",  null);  Integer  value  =  (Integer)  mth.invoke(other,  null);  return  value.intValue();  }  catch  (NoSuchMethodException  e)  {  }  catch  (IllegalAccessException  e)  {  }  catch  (InvocationTargetException  e)  {  }  throw  new  IllegalStateException( "This  should  not  happen ");  }  	[BUGGY]  [FE]  AssertionFailedError  [CLASS]  [CONTEXT]  	Lang_64_ValuedEnum_2_2	192	0	src/java/org/apache/commons/lang/enums/ValuedEnum.java
2138	protected  Object  readResolve()  {  	[BUGGY]  private  Object  readResolve  (  )  {  [FE]  AssertionFailedError:  expected:<3>  but  was:<0>  assertEquals  (  mk  .  hashCode  (  )  ,  mk2  .  hashCode  (  )  )  ;  [CLASS]  [CONTEXT]  	Collections_26_MultiKey_1_1	277	1	src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java
2139	private  void  readObject(ObjectInputStream  is)  throws  IOException,  ClassNotFoundException  {  is.defaultReadObject();  if  (clazz  !=  null  &&  !Collection.class.isAssignableFrom(clazz))  {  throw  new  UnsupportedOperationException();  }  }  	[BUGGY]  [FE]  AssertionFailedError:  unsafe  clazz  accepted  when  de-serializing  MultiValueMap  assertEquals  (  map1  ,  result  )  ;  [CLASS]  [CONTEXT]  	Collections_27_MultiValueMap_1_1	568	0	src/main/java/org/apache/commons/collections4/map/MultiValueMap.java
2140	@Override  public  void  clear()  {  Iterator<Map.Entry<K,  V>>  it  =  AbstractPatriciaTrie.this.entrySet().iterator();  Set<K>  currentKeys  =  keySet();  while  (it.hasNext())  {  if  (currentKeys.contains(it.next().getKey()))  {  it.remove();  }  }  }  	[BUGGY]  [FE]  NullPointerException  assertEquals  (  Arrays  .  asList  (  2  ,  3  ,  7  ,  1  )  ,  new  ArrayList<Integer>  (  trie  .  values  (  )  )  )  ;  [CLASS]  [CONTEXT]  	Collections_28_AbstractPatriciaTrie_1_1	2262	0	src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java