[PATCH]  private  final  boolean  isEncapsulating;	[BUG]  [BUGGY]  private    boolean  isEncapsulating;  [CONTEXT]              abstract  class  Lexer  {    [BUGGY]  privateboolean  isEncapsulating;  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  private  final  boolean  isEscaping;	[BUG]  [BUGGY]  private    boolean  isEscaping;  [CONTEXT]          abstract  class  Lexer  {    private  final  boolean  isEncapsulating;  [BUGGY]  privateboolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  private  final  char  encapsulator;        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  private  final  boolean  isCommentEnabled;	[BUG]  [BUGGY]  private    boolean  isCommentEnabled;  [CONTEXT]      abstract  class  Lexer  {    private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  [BUGGY]  privateboolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  private  final  char  delimiter;	[BUG]  [BUGGY]  private  final  int  delimiter;  [CONTEXT]    private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    [BUGGY]  private  final  int  delimiter;  private  final  char  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  private  final  char  escape;	[BUG]  [BUGGY]  private  final  int  escape;  [CONTEXT]  private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  [BUGGY]  private  final  int  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  private  final  char  escape;	[BUG]  [BUGGY]  private  final  String  escape;  [CONTEXT]  private  final  boolean  isEncapsulating;  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  [BUGGY]  private  final  String  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  private  final  char  encapsulator;	[BUG]  [BUGGY]  private  final  int  encapsulator;  [CONTEXT]  private  final  boolean  isEscaping;  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  [BUGGY]  private  final  int  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;          [CLASS]  Lexer      [VARIABLES]  
[PATCH]  private  final  char  commmentStart;	[BUG]  [BUGGY]  private  final  int  commmentStart;  [CONTEXT]  private  final  boolean  isCommentEnabled;    private  final  char  delimiter;  private  final  char  escape;  private  final  char  encapsulator;  [BUGGY]  private  final  int  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;    final  CSVFormat  format;        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  final  boolean  surroundingSpacesIgnored;	[BUG]  [BUGGY]  boolean  surroundingSpacesIgnored;  [CONTEXT]  private  final  char  delimiter;  private  final  char  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    [BUGGY]  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;    final  CSVFormat  format;              [CLASS]  Lexer      [VARIABLES]  
[PATCH]  final  boolean  emptyLinesIgnored;	[BUG]  [BUGGY]  boolean  emptyLinesIgnored;  [CONTEXT]  private  final  char  escape;  private  final  char  encapsulator;  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  [BUGGY]  boolean  emptyLinesIgnored;    final  CSVFormat  format;        final  ExtendedBufferedReader  in;        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  final  CSVFormat  format;	[BUG]  [BUGGY]  CSVFormat  format;  [CONTEXT]  private  final  char  commmentStart;    final  boolean  surroundingSpacesIgnored;  final  boolean  emptyLinesIgnored;    [BUGGY]  CSVFormat  format;        final  ExtendedBufferedReader  in;    Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {        [CLASS]  Lexer      [VARIABLES]  
[PATCH]  this.format  =  format;	[BUG]  [BUGGY]  this.format  =    null;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  this.format  =null;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.in  =  in;	[BUG]  [BUGGY]  this.in  =    null;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  [BUGGY]  this.in  =null;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =    null.isEncapsulating(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this.isEncapsulating  =null.isEncapsulating  ()  ;  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  );this.isEncapsulating  =  format.isEncapsulating(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.isEncapsulating  =  format.isEncapsulating(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  );this.isEncapsulating  =  format.isEncapsulating(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.isEncapsulating  =  format.isEncapsulating(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEncapsulating  =  format.isEncapsulating  (  )  ;	[BUG]  [BUGGY]  this  .isEscaping(  )  =  format  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  [BUGGY]  this  .isEscaping  ()=  format  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =    null.isEscaping(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  [BUGGY]  this.isEscaping  =null.isEscaping  ()  ;  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isEscaping  =  format.isEscaping  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  );this.isEscaping  =  format.isEscaping(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format  .getCommentStart(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.isCommentEnabled  =  format  .getCommentStart  ();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =    null.isCommentingEnabled(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  [BUGGY]  this.isCommentEnabled  =null.isCommentingEnabled  ()  ;  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.isCommentEnabled  =  format.isCommentingEnabled  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getCommentStart(  );this.isCommentEnabled  =  format.isCommentingEnabled(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =    null.getDelimiter(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.delimiter  =null.getDelimiter  ()  ;  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getCommentStart(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.delimiter  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.delimiter  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format  .getEscape(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  [BUGGY]  this.delimiter  =  format  .getEscape  ();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.escape  =    null.getEscape(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.escape  =null.getEscape  ()  ;  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getCommentStart(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  );this.escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format  .getEncapsulator(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.escape  =  format  .getEncapsulator  ();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.escape  =  format.getEscape  (  )  ;  this.encapsulator  =  format.getEncapsulator  (  )  ;  this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  [BUGGY]  this.escape  =  format.getEscape();                  [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =    null.getEncapsulator(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.encapsulator  =null.getEncapsulator  ()  ;  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.isEncapsulating  =  format.isEncapsulating(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format.getCommentStart(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  );this.encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.encapsulator  =  format.getEncapsulator  (  )  ;  this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  [BUGGY]  this.encapsulator  =  format.getEncapsulator();                [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =  format  .getEscape(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.commmentStart  =  format  .getEscape  ();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.commmentStart  =    null.getCommentStart(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.commmentStart  =null.getCommentStart  ()  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  );this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.encapsulator  =  format.getEncapsulator(  );this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  );this.commmentStart  =  format.getCommentStart(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.commmentStart  =  format.getCommentStart  (  )  ;  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  [BUGGY]  this.commmentStart  =  format.getCommentStart();              [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;	[BUG]  [BUGGY]  this.surroundingSpacesIgnored  =    null.isSurroundingSpacesIgnored(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  [BUGGY]  this.surroundingSpacesIgnored  =null.isSurroundingSpacesIgnored  ()  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored  (  )  ;  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();            [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =    null.isEmptyLinesIgnored(  );  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.emptyLinesIgnored  =null.isEmptyLinesIgnored  ()  ;  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.escape  =  format.getEscape(  );this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored(  );this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.isCommentEnabled  =  format.isCommentingEnabled(  );this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.isEscaping  =  format.isEscaping(  );this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.delimiter  =  format.getDelimiter(  );this.emptyLinesIgnored  =  format.isEmptyLinesIgnored(  );  [CONTEXT]        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  format  .isSurroundingSpacesIgnored(  )  ;  [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.emptyLinesIgnored  =  format  .isSurroundingSpacesIgnored  ();  }        [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  Lexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  this.format  =  format;  this.in  =  in;  this.isEncapsulating  =  format.isEncapsulating();  this.isEscaping  =  format.isEscaping();  this.isCommentEnabled  =  format.isCommentingEnabled();  this.delimiter  =  format.getDelimiter();  this.escape  =  format.getEscape();  this.encapsulator  =  format.getEncapsulator();  this.commmentStart  =  format.getCommentStart();  this.surroundingSpacesIgnored  =  format.isSurroundingSpacesIgnored();  [BUGGY]  this.emptyLinesIgnored  =  format.isEmptyLinesIgnored();          [CLASS]  Lexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  return  in.getLineNumber  (  )  ;	[BUG]  [BUGGY]  return  in.read(  );  [CONTEXT]  int  getLineNumber()  {  [BUGGY]  return  in.read  ()  ;  }        [CLASS]  Lexer    [METHOD]  getLineNumber  [RETURN_TYPE]  int      [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  return  in.getLineNumber  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  int  getLineNumber()  {  [BUGGY]  return  in.getLineNumber();          [CLASS]  Lexer    [METHOD]  getLineNumber  [RETURN_TYPE]  int      [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.lookAhead(  );  [CONTEXT]  int  readEscape(int  c)  throws  IOException  {      [BUGGY]  c  =  in.lookAhead  ()  ;  switch  (c)  {  case  'r':  return  '\r';  case  'n':  return  '\n';  case  't':  return  '\t';  case  'b':  return  '\b';  case  'f':  return  '\f';  default:  return  c;  }  }        [CLASS]  Lexer    [METHOD]  readEscape  [RETURN_TYPE]  int      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]  int  readEscape(int  c)  throws  IOException  {      [BUGGY]  c  ;  switch  (c)  {  case  'r':  return  '\r';  case  'n':  return  '\n';  case  't':  return  '\t';  case  'b':  return  '\b';  case  'f':  return  '\f';  default:  return  c;  }  }        [CLASS]  Lexer    [METHOD]  readEscape  [RETURN_TYPE]  int      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  int  readEscape(int  c)  throws  IOException  {      [BUGGY]  c  =  in.read();    switch  (c)  {  case  'r':  return  '\r';  case  'n':  return  '\n';  case  't':  return  '\t';  case  'b':  return  '\b';  case  'f':  return  '\f';  default:  return  c;  }        [CLASS]  Lexer    [METHOD]  readEscape  [RETURN_TYPE]  int      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  short    length  =  buffer.length(  );  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  shortlength  =  buffer.length  ()  ;  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  int  length  =  buffer.length()  +  9  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.length()  +  9  ;  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  int  length  =  buffer.setLength(  );  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.setLength  ()  ;  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  int  length  =  buffer  .setLength(  length)  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer  .setLength  (  length  );  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  if  (  length  !=  buffer.length(  ))  {  int  length  =  buffer.length(  );  }  [CONTEXT]        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]  int  length  =  buffer.length()  +  8  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.length()  +  8  ;  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  int  length  =  buffer.length  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  [BUGGY]  int  length  =  buffer.length();    while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  ||  Character.isWhitespace(  buffer.charAt(  length  -  1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  ||  Character.isWhitespace  (  buffer.charAt  (  length  -  1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >=  0  &&  Character.isWhitespace(  buffer.charAt(  length  -  1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >=  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length    &&    1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length&&1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length    >>    1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length>>1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  6  &&  Character.isWhitespace(  buffer.charAt(  length  -  1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  6  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  -  length)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  length  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length  )))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  buffer  >  0  &&  Character.isWhitespace(  length.charAt(  length  -  1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  buffer  >  0  &&  Character.isWhitespace  (  length.charAt  (  length  -  1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  length  =  length  -  1;	[BUG]  [BUGGY]  length  =  length  -  length;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  -  length;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  length  =  length  -  1;	[BUG]  [BUGGY]  length  =  length  -  0  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  -  0  ;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  length  =  length  -  1;	[BUG]  [BUGGY]  length  =  length    <    1;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length<1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  length  =  length  -  1;	[BUG]  [BUGGY]  length  =  length  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  [BUGGY]  length  =  length  ;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer  .setLength(  length)  ))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer  .setLength  (  length  )  )){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {  length  =  length  -  1;	[BUG]  [BUGGY]    [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {      }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  while  (  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length  -  1  )  )  )  {	[BUG]  [BUGGY]  while  (  length  >  0  &&  Character.isWhitespace(  buffer.charAt(  length    ==    1)))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  [BUGGY]  while(  length  >  0  &&  Character.isWhitespace  (  buffer.charAt  (  length==1  ))){  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  length  >=  buffer.length(  ))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  >=  buffer.length  ()){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  length  !=  buffer.length()  -  9  )  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  !=  buffer.length()  -  9){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  buffer  !=  length.length(  ))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  buffer  !=  length.length  ()){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  length  !=  buffer.setLength(  ))  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  !=  buffer.setLength  ()){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {  buffer.setLength  (  length  )  ;  }	[BUG]  [BUGGY]  buffer.setLength(length);  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if  (length  !=  buffer.length())  {    buffer.setLength(length);          [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {  buffer.setLength  (  length  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if  (length  !=  buffer.length())  {              [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  buffer.setLength  (  length  )  ;	[BUG]  [BUGGY]  buffer  .length(  )  ;  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  [BUGGY]  buffer  .length  ();  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  buffer.setLength  (  length  )  ;	[BUG]  [BUGGY]    [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  if  (length  !=  buffer.length())  {  [BUGGY]  buffer.setLength(length);    }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  length  !=  buffer.length()  +  0  )  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  !=  buffer.length()  +  0){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  if  (  length  !=  buffer.length  (  )  )  {	[BUG]  [BUGGY]  if  (  length  !=  buffer  .setLength(  length)  )  {  [CONTEXT]  void  trimTrailingSpaces(StringBuilder  buffer)  {  int  length  =  buffer.length();  while  (length  >  0  &&  Character.isWhitespace(buffer.charAt(length  -  1)))  {  length  =  length  -  1;  }  [BUGGY]  if(  length  !=  buffer  .setLength  (  length  )  ){  buffer.setLength(length);  }  }        [CLASS]  Lexer    [METHOD]  trimTrailingSpaces  [RETURN_TYPE]  void      StringBuilder  buffer  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    StringBuilder    buffer    int    length    
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  c  !=  format.getDelimiter(  ))  ||  Character.isWhitespace(  (  char)  c);  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  c  !=  format.getDelimiter  ())||  Character.isWhitespace  ((  char  )c  )  ;  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  c  ==  format.getDelimiter(  ))  &&  Character.isWhitespace(  (  char)  c);  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  c  ==  format.getDelimiter  ())&&  Character.isWhitespace  ((  char  )c  )  ;  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  format  !=  c.getDelimiter(  ))  &&  Character.isWhitespace(  (  char)  c);  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  format  !=  c.getDelimiter  ())&&  Character.isWhitespace  ((  char  )c  )  ;  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  c  !=  format.getEscape(  ))  &&  Character.isWhitespace(  (  char)  c);  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  c  !=  format.getEscape  ())&&  Character.isWhitespace  ((  char  )c  )  ;  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  return  (  c  !=  format.getDelimiter(  ))  &&  Character  .isWhitespace(  c)  ;  [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return(  c  !=  format.getDelimiter  ())&&  Character  .isWhitespace  (  c  );  }        [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  !=  format.getDelimiter  (  )  )  &&  Character.isWhitespace  (  (  char  )  c  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  boolean  isWhitespace(int  c)  {  [BUGGY]  return  (c  !=  format.getDelimiter())  &&  Character.isWhitespace((char)  c);          [CLASS]  Lexer    [METHOD]  isWhitespace  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  in.lookAhead(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  ==  '\r'  ||  in.lookAhead  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  <=  '\r'  &&  in.lookAhead(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  <=  '\r'  &&  in.lookAhead  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  &&  in.lookAhead(  )  >=  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  ==  '\r'  &&  in.lookAhead  ()>=  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  in  ==  '\r'  &&  c.lookAhead(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  in  ==  '\r'  &&  c.lookAhead  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'){  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  ==  '\r'  )  {      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (    in.lookAhead(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(in.lookAhead  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  &&  in.read(  )  ==  '\n')  {  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if(  c  ==  '\r'  &&  in.read  ()==  '\n'  ){      c  =  in.read();  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {  c  =  in.read  (  )  ;  }	[BUG]  [BUGGY]  c  =  in.read();  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {    c  =  in.read();      return  (c  ==  '\n'  ||  c  ==  '\r');        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  if  (  c  ==  '\r'  &&  in.lookAhead  (  )  ==  '\n'  )  {  c  =  in.read  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      [BUGGY]  if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {          return  (c  ==  '\n'  ||  c  ==  '\r');        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.lookAhead(  );  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      [BUGGY]  c  =  in.lookAhead  ()  ;  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      [BUGGY]  c=c  ;  }  return  (c  ==  '\n'  ||  c  ==  '\r');  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      [BUGGY]  c  =  in.read();    }  return  (c  ==  '\n'  ||  c  ==  '\r');        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUG]  [BUGGY]  return  (  c  ==  '\n'  &&  c  ==  '\r');  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      c  =  in.read();  }  [BUGGY]  return(  c  ==  '\n'  &&  c  ==  '\r'  )  ;  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUG]  [BUGGY]  return  (  c  !=  '\n'  ||  c  ==  '\r');  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      c  =  in.read();  }  [BUGGY]  return(  c  !=  '\n'  ||  c  ==  '\r'  )  ;  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUG]  [BUGGY]  return  (  c  ==  '\n'  ||  c  !=  '\r');  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      c  =  in.read();  }  [BUGGY]  return(  c  ==  '\n'  ||  c  !=  '\r'  )  ;  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  (  c  ==  '\n'  ||  c  ==  '\r'  )  ;	[BUG]  [BUGGY]  return  (  c  ;  [CONTEXT]  boolean  isEndOfLine(int  c)  throws  IOException  {      if  (c  ==  '\r'  &&  in.lookAhead()  ==  '\n')  {      c  =  in.read();  }  [BUGGY]  return(  c  ;  }        [CLASS]  Lexer    [METHOD]  isEndOfLine  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  c  ==  ExtendedBufferedReader.END_OF_STREAM;	[BUG]  [BUGGY]  return  c  >=  ExtendedBufferedReader.END_OF_STREAM;  [CONTEXT]  boolean  isEndOfFile(int  c)  {  [BUGGY]  return  c  >=  ExtendedBufferedReader.END_OF_STREAM;  }        [CLASS]  Lexer    [METHOD]  isEndOfFile  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  c  ==  ExtendedBufferedReader.END_OF_STREAM;	[BUG]  [BUGGY]  return  ExtendedBufferedReader.END_OF_STREAM  ==  c;  [CONTEXT]  boolean  isEndOfFile(int  c)  {  [BUGGY]  return  ExtendedBufferedReader.END_OF_STREAM  ==  c;  }        [CLASS]  Lexer    [METHOD]  isEndOfFile  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  c  ==  ExtendedBufferedReader.END_OF_STREAM;	[BUG]  [BUGGY]  return  c    ||    ExtendedBufferedReader.END_OF_STREAM;  [CONTEXT]  boolean  isEndOfFile(int  c)  {  [BUGGY]  return  c||ExtendedBufferedReader.END_OF_STREAM;  }        [CLASS]  Lexer    [METHOD]  isEndOfFile  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  c  ==  delimiter;	[BUG]  [BUGGY]  return  c  <  delimiter;  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  c  <  delimiter;  }        [CLASS]  Lexer    [METHOD]  isDelimiter  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  c  ==  delimiter;	[BUG]  [BUGGY]  return  c  ==  escape;  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isDelimiter  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  c  ==  delimiter;	[BUG]  [BUGGY]  return  delimiter  ==  c;  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  delimiter  ==  c;  }        [CLASS]  Lexer    [METHOD]  isDelimiter  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  c  ==  delimiter;	[BUG]  [BUGGY]  return  c    ||    delimiter;  [CONTEXT]  boolean  isDelimiter(int  c)  {  [BUGGY]  return  c||delimiter;  }        [CLASS]  Lexer    [METHOD]  isDelimiter  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  isEscaping  ||  c  ==  escape;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  ||  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  isEscaping  &&  c  !=  escape;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  &&  c  !=  escape;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  escape;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  isEscaping  &&  c  ==  encapsulator;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  isEscaping  &&  c  ==  encapsulator;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  c  &&  isEscaping  ==  escape;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  c  &&  isEscaping  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return  escape  &&  c  ==  isEscaping;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  escape  &&  c  ==  isEscaping;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEscaping  &&  c  ==  escape;	[BUG]  [BUGGY]  return      c  ;  [CONTEXT]  boolean  isEscape(int  c)  {  [BUGGY]  return  c  ;  }        [CLASS]  Lexer    [METHOD]  isEscape  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  ||  c  ==  encapsulator;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  ||  c  ==  encapsulator;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  &&  c  <=  encapsulator;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  &&  c  <=  encapsulator;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  encapsulator;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  encapsulator;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  &&  c  ==  escape;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  &&  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  &&  encapsulator  ==  c;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  &&  encapsulator  ==  c;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  encapsulator  &&  c  ==  isEncapsulating;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  encapsulator  &&  c  ==  isEncapsulating;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isEncapsulating  &&  c  ==  encapsulator;	[BUG]  [BUGGY]  return  isEncapsulating  ||  c  ;  [CONTEXT]  boolean  isEncapsulator(int  c)  {  [BUGGY]  return  isEncapsulating  ||  c  ;  }        [CLASS]  Lexer    [METHOD]  isEncapsulator  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  ||  c  ==  commmentStart;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  ||  c  ==  commmentStart;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  &&  c  <  commmentStart;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  &&  c  <  commmentStart;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  commmentStart;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  surroundingSpacesIgnored  &&  c  ==  commmentStart;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  &&  c  ==  escape;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  &&  c  ==  escape;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  &&  commmentStart  ==  c;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  &&  commmentStart  ==  c;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  commmentStart  &&  c  ==  isCommentEnabled;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  commmentStart  &&  c  ==  isCommentEnabled;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  return  isCommentEnabled  &&  c  ==  commmentStart;	[BUG]  [BUGGY]  return  isCommentEnabled  ||  c  ;  [CONTEXT]  boolean  isCommentStart(int  c)  {  [BUGGY]  return  isCommentEnabled  ||  c  ;  }        [CLASS]  Lexer    [METHOD]  isCommentStart  [RETURN_TYPE]  boolean      int  c  [VARIABLES]  char    commmentStart    delimiter    encapsulator    escape    ExtendedBufferedReader    in    CSVFormat    format    boolean    emptyLinesIgnored    isCommentEnabled    isEncapsulating    isEscaping    surroundingSpacesIgnored    int    c    
[PATCH]  private  static  final  String  CRLF  =   "\r\n ";	[BUG]  [BUGGY]  private  static  final  char  CRLF  =   "\r\n ";  [CONTEXT]          public  class  CSVFormat  implements  Serializable  {        [BUGGY]  private  static  final  char  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  static  final  String  CRLF  =   "\r\n ";	[BUG]  [BUGGY]  private  static  final  String  CRLF  =   "\r\nr ";  [CONTEXT]          public  class  CSVFormat  implements  Serializable  {        [BUGGY]  private  static  final  String  CRLF  =   "\r\nr ";    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  char  delimiter;	[BUG]  [BUGGY]  private  final  String  delimiter;  [CONTEXT]  public  class  CSVFormat  implements  Serializable  {        private  static  final  String  CRLF  =   "\r\n ";    [BUGGY]  private  final  String  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  char  delimiter;	[BUG]  [BUGGY]  private  final  int  delimiter;  [CONTEXT]  public  class  CSVFormat  implements  Serializable  {        private  static  final  String  CRLF  =   "\r\n ";    [BUGGY]  private  final  int  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  char  encapsulator;	[BUG]  [BUGGY]  private  final  int  encapsulator;  [CONTEXT]        private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  [BUGGY]  private  final  int  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  char  commentStart;	[BUG]  [BUGGY]  private  final  int  commentStart;  [CONTEXT]      private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  [BUGGY]  private  final  int  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  char  commentStart;	[BUG]  [BUGGY]  private  final  String  commentStart;  [CONTEXT]      private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  [BUGGY]  private  final  String  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  char  escape;	[BUG]  [BUGGY]  private  final  int  escape;  [CONTEXT]  private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  [BUGGY]  private  final  int  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;          [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  char  escape;	[BUG]  [BUGGY]  private  final  String  escape;  [CONTEXT]  private  static  final  String  CRLF  =   "\r\n ";    private  final  char  delimiter;  private  final  char  encapsulator;  private  final  char  commentStart;  [BUGGY]  private  final  String  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  private  final  String[]  header;          [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  String  lineSeparator;	[BUG]  [BUGGY]  private  final  char  lineSeparator;  [CONTEXT]  private  final  char  encapsulator;  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  [BUGGY]  private  final  char  lineSeparator;  private  final  String[]  header;                    [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  final  String[]  header;	[BUG]  [BUGGY]  private    String[]  header;  [CONTEXT]  private  final  char  commentStart;  private  final  char  escape;  private  final  boolean  surroundingSpacesIgnored;  //  Should  leading/trailing  spaces  be  ignored  around  values?  private  final  boolean  emptyLinesIgnored;  private  final  String  lineSeparator;  //  for  outputs  [BUGGY]  privateString[]  header;                        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  static  final  char  DISABLED  =  '\ufffe';	[BUG]  [BUGGY]  static  final  int  DISABLED  =  '\ufffe';  [CONTEXT]                      [BUGGY]  static  final  int  DISABLED  =  '\ufffe';                private  static  CSVFormat  PRISTINE  =  new  CSVFormat(DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null  )  ;	[BUG]  [BUGGY]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat(  DISABLED,  DISABLED,  DISABLED,  DISABLED,  true,  true,  null,  null);  [CONTEXT]  static  final  char  DISABLED  =  '\ufffe';                [BUGGY]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  true,  true,  null,  null  )  ;                          [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  private  static  CSVFormat  PRISTINE  =  new  CSVFormat  (  DISABLED,  DISABLED,  DISABLED,  DISABLED,  false,  false,  null,  null  )  ;	[BUG]  [BUGGY]  private  static  CSVFormat  PRISTINE  ;  [CONTEXT]  static  final  char  DISABLED  =  '\ufffe';                [BUGGY]  private  static  CSVFormat  PRISTINE  ;                          [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withEscape(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withEscape  (  ','  )  .withEncapsulator  (  ' "'  )        .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static    CSVFormat  DEFAULT  =  PRISTINE.  withDelimiter(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  staticCSVFormat  DEFAULT  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )        .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withEscape(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withEscape  (  ','  )  .withEncapsulator  (  ' "'  )        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public    final  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  publicfinal  CSVFormat  RFC4180  =  PRISTINE.  withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withEscape(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withEscape  (  ','  )  .withEncapsulator  (  ' "'  )        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public    final  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter(  ',').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  publicfinal  CSVFormat  EXCEL  =  PRISTINE  .withDelimiter  (  ','  )  .withEncapsulator  (  ' "'  )        .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  TDF  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  TDF  =  PRISTINE  .withEscape(  '\t').withEncapsulator(  ' "'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  TDF  =  PRISTINE  .withEscape  (  '\t'  )  .withEncapsulator  (  ' "'  )        .withSurroundingSpacesIgnored(true)  .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  TDF  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEncapsulator  (  ' "'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  TDF    =  null  ;  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  TDF=  null  ;        .withSurroundingSpacesIgnored(true)  .withEmptyLinesIgnored(true)  .withLineSeparator(CRLF);        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEscape  (  '\\'  )	[BUG]  [BUGGY]  public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withEscape(  '\t').withEscape(  '\\'  )  [CONTEXT]  [BUGGY]  public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withEscape  (  '\t'  )  .withEscape  (  '\\'  )        .withLineSeparator( "\n ");        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  public  static  final  CSVFormat  MYSQL  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEscape  (  '\\'  )	[BUG]  [BUGGY]  public  static    CSVFormat  MYSQL  =  PRISTINE  .withDelimiter(  '\t').withEscape(  '\\'  )  [CONTEXT]  [BUGGY]  public  staticCSVFormat  MYSQL  =  PRISTINE  .withDelimiter  (  '\t'  )  .withEscape  (  '\\'  )        .withLineSeparator( "\n ");        [CLASS]  CSVFormat      [VARIABLES]  
[PATCH]  this.delimiter  =  delimiter;	[BUG]  [BUGGY]  this.delimiter  =  encapsulator;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  [BUGGY]  this.delimiter  =  encapsulator;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.delimiter  =  delimiter;	[BUG]  [BUGGY]  this.delimiter  =    escape;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  [BUGGY]  this.delimiter  =escape;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.delimiter  =  delimiter;	[BUG]  [BUGGY]  this.header  =  header;this.delimiter  =  delimiter;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.encapsulator  =  encapsulator;	[BUG]  [BUGGY]  this.encapsulator  =  escape;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  [BUGGY]  this.encapsulator  =  escape;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.encapsulator  =  encapsulator;	[BUG]  [BUGGY]  this.escape  =  escape;this.encapsulator  =  encapsulator;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.encapsulator  =  encapsulator;	[BUG]  [BUGGY]  this.lineSeparator  =  lineSeparator;this.encapsulator  =  encapsulator;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.commentStart  =  commentStart;	[BUG]  [BUGGY]  this.commentStart  =  escape;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  [BUGGY]  this.commentStart  =  escape;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.escape  =  escape;	[BUG]  [BUGGY]  this.escape  =  encapsulator;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  [BUGGY]  this.escape  =  encapsulator;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.escape  =  escape;	[BUG]  [BUGGY]  this.encapsulator  =  encapsulator;this.escape  =  escape;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.escape  =  escape;	[BUG]  [BUGGY]  this.header  =  header;this.escape  =  escape;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUG]  [BUGGY]  this.surroundingSpacesIgnored  =  emptyLinesIgnored;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  [BUGGY]  this.surroundingSpacesIgnored  =  emptyLinesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  emptyLinesIgnored;this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.emptyLinesIgnored  =  emptyLinesIgnored;	[BUG]  [BUGGY]  this.emptyLinesIgnored  =  surroundingSpacesIgnored;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  [BUGGY]  this.emptyLinesIgnored  =  surroundingSpacesIgnored;  this.lineSeparator  =  lineSeparator;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.emptyLinesIgnored  =  emptyLinesIgnored;	[BUG]  [BUGGY]  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;this.emptyLinesIgnored  =  emptyLinesIgnored;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.lineSeparator  =  lineSeparator;	[BUG]  [BUGGY]  this.lineSeparator  =  CRLF;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  [BUGGY]  this.lineSeparator  =  CRLF;  this.header  =  header;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.lineSeparator  =  lineSeparator;	[BUG]  [BUGGY]  this.encapsulator  =  encapsulator;this.lineSeparator  =  lineSeparator;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.header  =  header;	[BUG]  [BUGGY]  this.header  =    null;  [CONTEXT]  CSVFormat(  char  delimiter,  char  encapsulator,  char  commentStart,  char  escape,  boolean  surroundingSpacesIgnored,  boolean  emptyLinesIgnored,  String  lineSeparator,  String[]  header)  {  this.delimiter  =  delimiter;  this.encapsulator  =  encapsulator;  this.commentStart  =  commentStart;  this.escape  =  escape;  this.surroundingSpacesIgnored  =  surroundingSpacesIgnored;  this.emptyLinesIgnored  =  emptyLinesIgnored;  this.lineSeparator  =  lineSeparator;  [BUGGY]  this.header  =null;  }        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.header  =  header;	[BUG]  [BUGGY]  this.escape  =  escape;this.header  =  header;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  this.header  =  header;	[BUG]  [BUGGY]  this.delimiter  =  delimiter;this.header  =  header;  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  <init>  [RETURN_TYPE]  String[])      char  delimiter  char  encapsulator  char  commentStart  char  escape  boolean  surroundingSpacesIgnored  boolean  emptyLinesIgnored  String  lineSeparator  String[]  header  [VARIABLES]  char    DISABLED    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUG]  [BUGGY]  return  c  ==  '\n'  &&  c  ==  '\r';  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  ==  '\n'  &&  c  ==  '\r';  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUG]  [BUGGY]  return  c  !=  '\n'  ||  c  ==  '\r';  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  !=  '\n'  ||  c  ==  '\r';  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUG]  [BUGGY]  return  escape  ==  '\n'  ||  c  ==  '\r';  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  escape  ==  '\n'  ||  c  ==  '\r';  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  c  ==  '\n'  ||  c  ==  '\r';	[BUG]  [BUGGY]  return  c  ;  [CONTEXT]  private  static  boolean  isLineBreak(char  c)  {  [BUGGY]  return  c  ;  }        [CLASS]  CSVFormat    [METHOD]  isLineBreak  [RETURN_TYPE]  boolean      char  c  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  delimiter  !=  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  delimiter  !=  encapsulator  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  escape  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  escape  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  delimiter  ==  escape  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  delimiter)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  encapsulator  ==  delimiter  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same(  \ " "  +(  encapsulator  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same(  \ " "  +  encapsulator  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  delimiter  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if(  isLineBreak  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same(\ " "  +(encapsulator))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (delimiter  ==  encapsulator)  {    throw  new  java.lang.IllegalArgumentException((( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (encapsulator))  +   "\ ") "));      if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  encapsulator  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  [BUGGY]  if  (delimiter  ==  encapsulator)  {          if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  ))+   "\ "  )   "  ))  ;  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delimiter  >  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  delimiter  >  escape  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  delimiter  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (  escape  ==  delimiter)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  escape  ==  delimiter  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(   "The  escape  character  and  the  delimiter  cannot  be  the  same(  \ " "  +(  escape  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(   "The  escape  character  and  the  delimiter  cannot  be  the  same(  \ " "  +  escape  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if(  delimiter  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  escape  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  escape  character  and  the  delimiter  cannot  be  the  same(\ " "  +(escape))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if  (delimiter  ==  escape)  {    throw  new  java.lang.IllegalArgumentException((( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (escape))  +   "\ ") "));      if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  escape  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    [BUGGY]  if  (delimiter  ==  escape)  {          if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  ))+   "\ "  )   "  ))  ;  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  delimiter  !=  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  delimiter  !=  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  delimiter  ==  escape  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  commentStart  ==  delimiter)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  commentStart  ==  delimiter  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  character  and  the  delimiter  cannot  be  the  same(  \ " "  +(  commentStart  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  character  and  the  delimiter  cannot  be  the  same(  \ " "  +  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  delimiter  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if(  isLineBreak  (  commentStart  )){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  delimiter  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if  (delimiter  ==  commentStart)  {    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));      if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  delimiter  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    [BUGGY]  if  (delimiter  ==  commentStart)  {          if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  ))+   "\ "  )   "  ))  ;  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  [BUGGY]  return  ;  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED  ||  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  ||  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  DISABLED  &&  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  ==  DISABLED  &&  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  >=  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  &&  encapsulator  >=  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  &&  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  escape  &&  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  escape  &&  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  commentStart  !=  DISABLED  &&  encapsulator  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  commentStart  !=  DISABLED  &&  encapsulator  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  commentStart  &&  encapsulator  ==  DISABLED)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  commentStart  &&  encapsulator  ==  DISABLED  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED){  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  )  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (    encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));      if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {          if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  escape  character  and  the  delimiter  cannot  be  the  same(  \ " "  +(  escape  ))+   "\ "  )   "  ))  ;  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [BUGGY]  return  ;  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  ||  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  ||  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  <=  DISABLED  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  <=  DISABLED  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  <=  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  &&  escape  <=  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED  &&  escape  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  &&  escape  ==  escape  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  DISABLED  !=  escape  &&  escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  DISABLED  !=  escape  &&  escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  commentStart  &&  escape  ==  DISABLED)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  commentStart  &&  escape  ==  DISABLED  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  commentStart  !=  DISABLED  &&  escape  ==  escape)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  commentStart  !=  DISABLED  &&  escape  ==  escape  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  escape  !=  DISABLED){  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  escape  !=  DISABLED  )  {  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (    escape  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(escape  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart)  +   "\ ") ")  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  and  the  escape  character  cannot  be  the  same(  \ " "  +(  commentStart  )+   "\ "  )   "  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(   "The  comment  start  and  the  escape  character  cannot  be  the  same(  \ " "  +  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (    escape  ==  encapsulator)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(escape  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if(  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException((( "The  comment  start  and  the  escape  character  cannot  be  the  same(\ " "  +(commentStart))  +   "\ ") "));  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {    throw  new  java.lang.IllegalArgumentException((( "The  comment  start  and  the  escape  character  cannot  be  the  same  (\ " "  +  (commentStart))  +   "\ ") "));          [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  escape  !=  DISABLED  &&  escape  ==  commentStart  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    [BUGGY]  if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {              [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "))    ;  [CONTEXT]  void  validate()  throws  IllegalArgumentException  {  if  (delimiter  ==  encapsulator)  {  throw  new  IllegalArgumentException( "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  encapsulator  +   "\ ") ");  }    if  (delimiter  ==  escape)  {  throw  new  IllegalArgumentException( "The  escape  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  escape  +   "\ ") ");  }    if  (delimiter  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  throw  new  IllegalArgumentException( "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (\ " "  +  commentStart  +   "\ ") ");  }    if  (escape  !=  DISABLED  &&  escape  ==  commentStart)  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (((   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same(  \ " "  +(  commentStart  ))+   "\ "  )   "  ))  ;  }  }        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  escape))  {          throw  new  IllegalArgumentException(  (  (   "The  escape  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  escape))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  encapsulator))  {          throw  new  IllegalArgumentException(  (  (   "The  encapsulator  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  encapsulator))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  delimiter)  ==  (  commentStart))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  delimiter  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  validate  [RETURN_TYPE]  void      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  delimiter;	[BUG]  [BUGGY]  return  escape;  [CONTEXT]  public  char  getDelimiter()  {  [BUGGY]  return  escape;  }        [CLASS]  CSVFormat    [METHOD]  getDelimiter  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if(  isLineBreak  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {	[BUG]  [BUGGY]  if  (  withEscape(  delimiter))  {  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if(  withEscape  (  delimiter  )){  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if(  isLineBreak  (  escape  )){  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if(  isLineBreak  (  commentStart  )){  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (isLineBreak(delimiter))  {    throw  new  java.lang.IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  delimiter  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  [BUGGY]  if  (isLineBreak(delimiter))  {          return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (   "The  escape  character  cannot  be  a  line  break "  )  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  [BUGGY]  return  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  surroundingSpacesIgnored,  escape,  commentStart,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  surroundingSpacesIgnored,  escape,  commentStart,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored);  [CONTEXT]  public  CSVFormat  withDelimiter(char  delimiter)  {  if  (isLineBreak(delimiter))  {  throw  new  IllegalArgumentException( "The  delimiter  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withDelimiter  [RETURN_TYPE]  CSVFormat      char  delimiter  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  encapsulator;	[BUG]  [BUGGY]  return  escape;  [CONTEXT]  public  char  getEncapsulator()  {  [BUGGY]  return  escape;  }        [CLASS]  CSVFormat    [METHOD]  getEncapsulator  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  encapsulator;	[BUG]  [BUGGY]  return  delimiter;  [CONTEXT]  public  char  getEncapsulator()  {  [BUGGY]  return  delimiter;  }        [CLASS]  CSVFormat    [METHOD]  getEncapsulator  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter))  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  isLineBreak  (  delimiter  )){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  withEscape(  encapsulator))  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  withEscape  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  isLineBreak  (  escape  )){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  encapsulator)  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  delimiter  ==  encapsulator  ){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if(  isLineBreak  (  commentStart  )){  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (isLineBreak(encapsulator))  {    throw  new  java.lang.IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  encapsulator  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  [BUGGY]  if  (isLineBreak(encapsulator))  {          return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (   "The  escape  character  cannot  be  a  line  break "  )  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  [BUGGY]  return  0;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored);  [CONTEXT]  public  CSVFormat  withEncapsulator(char  encapsulator)  {  if  (isLineBreak(encapsulator))  {  throw  new  IllegalArgumentException( "The  encapsulator  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEncapsulator  [RETURN_TYPE]  CSVFormat      char  encapsulator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  this.encapsulator  >=  DISABLED;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  this.encapsulator  >=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  escape  !=  DISABLED;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  escape  !=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  this.encapsulator  !=  encapsulator;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  this.encapsulator  !=  encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  DISABLED  !=  this.encapsulator;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  DISABLED  !=  this.encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.encapsulator  !=  DISABLED;	[BUG]  [BUGGY]  return  this.encapsulator    ;  [CONTEXT]  boolean  isEncapsulating()  {  [BUGGY]  return  this.encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  isEncapsulating  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  commentStart;	[BUG]  [BUGGY]  return  escape;  [CONTEXT]  public  char  getCommentStart()  {  [BUGGY]  return  escape;  }        [CLASS]  CSVFormat    [METHOD]  getCommentStart  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  isLineBreak  (  escape  )){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  withEscape(  commentStart))  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  withEscape  (  commentStart  )){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  isLineBreak  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  delimiter  ==  commentStart)  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  delimiter  ==  commentStart  ){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter))  {  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if(  isLineBreak  (  delimiter  )){  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (isLineBreak(commentStart))  {    throw  new  java.lang.IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  commentStart  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  [BUGGY]  if  (isLineBreak(commentStart))  {          return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ")    ;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (   "The  escape  character  cannot  be  a  line  break "  )  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  [BUGGY]  return  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withCommentStart(char  commentStart)  {  if  (isLineBreak(commentStart))  {  throw  new  IllegalArgumentException( "The  comment  start  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withCommentStart  [RETURN_TYPE]  CSVFormat      char  commentStart  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.commentStart  !=  DISABLED;	[BUG]  [BUGGY]  return  this.commentStart  >=  DISABLED;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  this.commentStart  >=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.commentStart  !=  DISABLED;	[BUG]  [BUGGY]  return  this.commentStart  !=  encapsulator;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  this.commentStart  !=  encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.commentStart  !=  DISABLED;	[BUG]  [BUGGY]  return  DISABLED  !=  this.commentStart;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  return  DISABLED  !=  this.commentStart;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.commentStart  !=  DISABLED;	[BUG]  [BUGGY]  returnescape    ;  [CONTEXT]  public  boolean  isCommentingEnabled()  {  [BUGGY]  returnescape;  }        [CLASS]  CSVFormat    [METHOD]  isCommentingEnabled  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  escape;	[BUG]  [BUGGY]  return  delimiter;  [CONTEXT]  public  char  getEscape()  {  [BUGGY]  return  delimiter;  }        [CLASS]  CSVFormat    [METHOD]  getEscape  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  escape;	[BUG]  [BUGGY]  return  encapsulator;  [CONTEXT]  public  char  getEscape()  {  [BUGGY]  return  encapsulator;  }        [CLASS]  CSVFormat    [METHOD]  getEscape  [RETURN_TYPE]  char      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  escape  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if(  isLineBreak  (  encapsulator  )){  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  escape  )  )  {	[BUG]  [BUGGY]  if  (  withEscape(  escape))  {  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if(  withEscape  (  escape  )){  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  escape  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter))  {  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if(  isLineBreak  (  delimiter  )){  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  escape  )  )  {	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if(  isLineBreak  (  commentStart  )){  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (isLineBreak(escape))  {    throw  new  java.lang.IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");      return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  if  (  isLineBreak  (  escape  )  )  {  throw  new  IllegalArgumentException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  [BUGGY]  if  (isLineBreak(escape))  {          return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  encapsulator))  {          throw  new  IllegalArgumentException(   "The  encapsulator  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  escape)  !=  (  DISABLED))  &&  (  (  escape)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  and  the  escape  character  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  delimiter))  {          throw  new  IllegalArgumentException(   "The  delimiter  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  encapsulator)  !=  (  DISABLED))  &&  (  (  encapsulator)  ==  (  commentStart)))  {          throw  new  IllegalArgumentException(  (  (   "The  comment  start  character  and  the  encapsulator  cannot  be  the  same  (  \ " "  +  (  commentStart))  +   "\ ") "));  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  throw  throw    new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ")    ;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  [BUGGY]  throw  thrownew  IllegalArgumentException  (   "The  comment  start  character  cannot  be  a  line  break "  )  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  escape))  {          throw  new  IllegalArgumentException(   "The  escape  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  throw  new  IllegalArgumentException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  [BUGGY]  return  ;  }    return  new  CSVFormat(delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isLineBreak(  commentStart))  {          throw  new  IllegalArgumentException(   "The  comment  start  character  cannot  be  a  line  break ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  lineSeparator,  emptyLinesIgnored,  surroundingSpacesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  emptyLinesIgnored,  surroundingSpacesIgnored,  escape,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  lineSeparator,  emptyLinesIgnored,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart);  [CONTEXT]  public  CSVFormat  withEscape(char  escape)  {  if  (isLineBreak(escape))  {  throw  new  IllegalArgumentException( "The  escape  character  cannot  be  a  line  break ");  }    [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEscape  [RETURN_TYPE]  CSVFormat      char  escape  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.escape  !=  DISABLED;	[BUG]  [BUGGY]  return  this.escape  ==  DISABLED;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  this.escape  ==  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.escape  !=  DISABLED;	[BUG]  [BUGGY]  return  escape  !=  DISABLED;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  escape  !=  DISABLED;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.escape  !=  DISABLED;	[BUG]  [BUGGY]  return  this.escape  !=  escape;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  this.escape  !=  escape;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.escape  !=  DISABLED;	[BUG]  [BUGGY]  return  DISABLED  !=  this.escape;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  DISABLED  !=  this.escape;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  this.escape  !=  DISABLED;	[BUG]  [BUGGY]  return  this.escape    ;  [CONTEXT]  boolean  isEscaping()  {  [BUGGY]  return  this.escape;  }        [CLASS]  CSVFormat    [METHOD]  isEscaping  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  surroundingSpacesIgnored;	[BUG]  [BUGGY]  return  emptyLinesIgnored;  [CONTEXT]  public  boolean  isSurroundingSpacesIgnored()  {  [BUGGY]  return  emptyLinesIgnored;  }        [CLASS]  CSVFormat    [METHOD]  isSurroundingSpacesIgnored  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  surroundingSpacesIgnored;	[BUG]  [BUGGY]  if  (  isSurroundingSpacesIgnored(  ))  {  return  surroundingSpacesIgnored;  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  isSurroundingSpacesIgnored  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  surroundingSpacesIgnored,  escape,  commentStart,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  surroundingSpacesIgnored,  escape,  commentStart,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart);  [CONTEXT]  public  CSVFormat  withSurroundingSpacesIgnored(boolean  surroundingSpacesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  header,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  commentStart  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withSurroundingSpacesIgnored  [RETURN_TYPE]  CSVFormat      boolean  surroundingSpacesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  emptyLinesIgnored;	[BUG]  [BUGGY]  return  surroundingSpacesIgnored;  [CONTEXT]  public  boolean  isEmptyLinesIgnored()  {  [BUGGY]  return  surroundingSpacesIgnored;  }        [CLASS]  CSVFormat    [METHOD]  isEmptyLinesIgnored  [RETURN_TYPE]  boolean      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  lineSeparator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  encapsulator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  emptyLinesIgnored,  commentStart,  escape,  surroundingSpacesIgnored,  encapsulator,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  emptyLinesIgnored,  commentStart,  escape,  surroundingSpacesIgnored,  encapsulator,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header);  [CONTEXT]  public  CSVFormat  withEmptyLinesIgnored(boolean  emptyLinesIgnored)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withEmptyLinesIgnored  [RETURN_TYPE]  CSVFormat      boolean  emptyLinesIgnored  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  lineSeparator;	[BUG]  [BUGGY]  return  CRLF;  [CONTEXT]  public  String  getLineSeparator()  {  [BUGGY]  return  CRLF;  }        [CLASS]  CSVFormat    [METHOD]  getLineSeparator  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  lineSeparator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  delimiter,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  delimiter,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  surroundingSpacesIgnored,  escape,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  lineSeparator,  surroundingSpacesIgnored,  emptyLinesIgnored,  escape,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  emptyLinesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  header,  lineSeparator,  emptyLinesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withLineSeparator(String  lineSeparator)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withLineSeparator  [RETURN_TYPE]  CSVFormat      String  lineSeparator  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  escape,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  surroundingSpacesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  CRLF,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(    encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,    commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,    escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,    surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,    emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,    lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,    header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  header,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  delimiter  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  commentStart,  encapsulator,  delimiter,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  header,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  encapsulator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  commentStart,  encapsulator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  escape,  commentStart,  encapsulator,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  surroundingSpacesIgnored,  encapsulator,  commentStart,  escape,  delimiter,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  emptyLinesIgnored,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  delimiter,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  lineSeparator,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  commentStart,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  delimiter,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  encapsulator,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  surroundingSpacesIgnored,  commentStart,  escape,  encapsulator,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  escape,  commentStart,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  header,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  escape  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  header,  emptyLinesIgnored,  lineSeparator,  surroundingSpacesIgnored  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  emptyLinesIgnored,  escape,  surroundingSpacesIgnored,  commentStart,  lineSeparator,  header  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  lineSeparator,  header  )  ;	[BUG]  [BUGGY]  return  new  CSVFormat(  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator);  [CONTEXT]  public  CSVFormat  withHeader(String...  header)  {  [BUGGY]  return  new  CSVFormat  (  delimiter,  encapsulator,  commentStart,  escape,  surroundingSpacesIgnored,  emptyLinesIgnored,  header,  lineSeparator  )  ;  }        [CLASS]  CSVFormat    [METHOD]  withHeader  [RETURN_TYPE]  CSVFormat        header  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVParser  (  in,  this  )  ;	[BUG]  [BUGGY]  return  return    new  CSVPrinter(  out,  this)  ;  [CONTEXT]  public  Iterable<CSVRecord>  parse(Reader  in)  throws  IOException  {  [BUGGY]  return  returnnew  CSVPrinter  (  out,  this  );  }        [CLASS]  CSVFormat    [METHOD]  parse  [RETURN_TYPE]  Iterable      Reader  in  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    Reader    in    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  return  new  CSVParser  (  in,  this  )  ;	[BUG]  [BUGGY]  return    new  CSVPrinter(  out,  this)  ;  [CONTEXT]  public  Iterable<CSVRecord>  parse(Reader  in)  throws  IOException  {  [BUGGY]  returnnew  CSVPrinter  (  out,  this  );  }        [CLASS]  CSVFormat    [METHOD]  parse  [RETURN_TYPE]  Iterable      Reader  in  [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    Reader    in    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    
[PATCH]  StringWriter  out  =  new  StringWriter  (  )  ;	[BUG]  [BUGGY]  StringWriter  out  =  new  StringBuilder(  )  ;  [CONTEXT]  public  String  format(String...  values)  {  [BUGGY]  StringWriter  out  =  new  StringBuilder  ();  try  {  new  CSVPrinter(out,  this).println(values);  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  StringWriter  out  =  new  StringWriter  (  )  ;	[BUG]  [BUGGY]  StringBuilder  sb  =  new  StringBuilder(  );StringWriter  out  =  new  StringWriter(  );  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVParser(  in,  this)  .println(  values);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVParser  (  in,  this  ).println  (  values  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(    this).println(  values);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (this  )  .println  (  values  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  out,  this).println(  header);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  out,  this  )  .println  (  header  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  values,  this).println(  out);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  values,  this  )  .println  (  out  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  out,  this).CSVPrinter(  values);  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  out,  this  )  .CSVPrinter  (  values  )  ;  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  out,  this)  .CSVPrinter(  out  ,  TDF)  ;  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  out,  this  ).CSVPrinter  (  out  ,  TDF  );  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter(out,  this).println(values);    }  catch  (IOException  e)  {      }    return  out.toString().trim();        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  new  CSVPrinter  (  out,  this  )  .println  (  values  )  ;	[BUG]  [BUGGY]  new  CSVPrinter(  out,  this)  .CSVPrinter(  out  ,  EXCEL)  ;  [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  [BUGGY]  new  CSVPrinter  (  out,  this  ).CSVPrinter  (  out  ,  EXCEL  );  }  catch  (IOException  e)  {      }    return  out.toString().trim();  }        [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  return  out.toString  (  )  .trim  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  format(String...  values)  {  StringWriter  out  =  new  StringWriter();  try  {  new  CSVPrinter(out,  this).println(values);  }  catch  (IOException  e)  {      }    [BUGGY]  return  out.toString().trim();          [CLASS]  CSVFormat    [METHOD]  format  [RETURN_TYPE]  String        values  [VARIABLES]  boolean    emptyLinesIgnored    surroundingSpacesIgnored    StringWriter    out    char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    String    CRLF    lineSeparator    String[]    header    values    IOException    e    
[PATCH]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUG]  [BUGGY]  StringBuilder  sb  =  new  StringWriter(  )  ;  [CONTEXT]  public  String  toString()  {  [BUGGY]  StringBuilder  sb  =  new  StringWriter  ();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  StringBuilder  sb  =  new  StringBuilder  (  )  ;	[BUG]  [BUGGY]  StringWriter  out  =  new  StringWriter(  );StringBuilder  sb  =  new  StringBuilder(  );  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Delimi ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append  (   "Delimi "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Delimiter=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append  (   "Delimiter=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb  .append(  CRLF  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb  .append  (  CRLF  )  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb  .append(  lineSeparator  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb  .append  (  lineSeparator  )  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append( "Delimiter=< ").append(delimiter).append('>');    if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Escape=< ").append(  escape).append(  '>');sb.append(   "Delimiter=< ").append(  delimiter).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');sb.append(   "Delimiter=< ").append(  delimiter).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');sb.append(   "Delimiter=< ").append(  delimiter).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "el ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append  (   "el "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Delimiter=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append  (   "Delimiter=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Delimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Delimiter=elimiter=< ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  [BUGGY]  sb.append  (   "Delimiter=elimiter=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEscaping  (  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulating(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  if(  isEncapsulating  ()){  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEscaping  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  if  (isEscaping())  {    sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');      if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEscaping  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  [BUGGY]  if  (isEscaping())  {          if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isCommentingEnabled(  ))  {          sb.append(  '  ');          sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEncapsulating(  ))  {          sb.append(  '  ');          sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (  '  '  )  ;	[BUG]  [BUGGY]  sb  .append(  lineSeparator)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  [BUGGY]  sb  .append  (  lineSeparator  );  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (  '  '  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  [BUGGY]  sb.append('  ');    sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Escape=<E ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Escape=<E "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Escape=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Escape=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb  .append(  lineSeparator  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb  .append  (  lineSeparator  )  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append( "Escape=< ").append(escape).append('>');    }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Delimiter=< ").append(  delimiter).append(  '>');sb.append(   "Escape=< ").append(  escape).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');sb.append(   "Escape=< ").append(  escape).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');sb.append(   "Escape=< ").append(  escape).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Es ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Es "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb  .append(  CRLF  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb  .append  (  CRLF  )  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "a ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "a "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (  '  '  )  ;	[BUG]  [BUGGY]  sb  .append(  CRLF)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  [BUGGY]  sb  .append  (  CRLF  );  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Esc ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Esc "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Escape=< ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Escape=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Esscape=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Esscape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Escape=< "  )  .append  (  escape  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "e ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  [BUGGY]  sb.append  (   "e "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEncapsulating  (  )  )  {	[BUG]  [BUGGY]  if  (  isEscaping(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  if(  isEscaping  ()){  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEncapsulating  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  if  (isEncapsulating())  {    sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');      if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEncapsulating  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  [BUGGY]  if  (isEncapsulating())  {          if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isCommentingEnabled(  ))  {          sb.append(  '  ');          sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEscaping(  ))  {          sb.append(  '  ');          sb.append(   "Escape=< ").append(  escape).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (  '  '  )  ;	[BUG]  [BUGGY]  sb  .append(  CRLF)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  [BUGGY]  sb  .append  (  CRLF  );  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (  '  '  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  [BUGGY]  sb.append('  ');    sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb  .append(  CRLF  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb  .append  (  CRLF  )  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb  .append(  lineSeparator  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb  .append  (  lineSeparator  )  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Encapsulator=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapsulator=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append( "Encapsulator=< ").append(encapsulator).append('>');    }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Delimiter=< ").append(  delimiter).append(  '>');sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Escape=< ").append(  escape).append(  '>');sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  if  (  encapsulator  !=  DISABLED  &&  encapsulator  ==  commentStart)  {  sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Encapsulator=<ncapsulator ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapsulator=<ncapsulator "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Encapsulator=< ").append(  delimiter).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapsulator=< "  )  .append  (  delimiter  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Encapsulator=<capsulato ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapsulator=<capsulato "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Encapsulator=<o ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "Encapsulator=<o "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "Encapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "ncapsulator=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  [BUGGY]  sb.append  (   "ncapsulator=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isCommentingEnabled  (  )  )  {	[BUG]  [BUGGY]  if  (  isEmptyLinesIgnored(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  if(  isEmptyLinesIgnored  ()){  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isCommentingEnabled  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  if  (isCommentingEnabled())  {    sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');      if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isCommentingEnabled  (  )  )  {  sb.append  (  '  '  )  ;  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  [BUGGY]  if  (isCommentingEnabled())  {          if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEscaping(  ))  {          sb.append(  '  ');          sb.append(   "Escape=< ").append(  escape).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEncapsulating(  ))  {          sb.append(  '  ');          sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (  '  '  )  ;	[BUG]  [BUGGY]  sb  .append(  lineSeparator)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  [BUGGY]  sb  .append  (  lineSeparator  );  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (  '  '  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  [BUGGY]  sb.append('  ');    sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "StartommentStart=< ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "StartommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "CommentStart=< ").append(  encapsulator).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CommentStart=< "  )  .append  (  encapsulator  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb  .append(  lineSeparator  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb  .append  (  lineSeparator  )  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "CommentStart=< ").append(  escape).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CommentStart=< "  )  .append  (  escape  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append( "CommentStart=< ").append(commentStart).append('>');    }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Delimiter=< ").append(  delimiter).append(  '>');sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Escape=< ").append(  escape).append(  '>');sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "Encapsulator=< ").append(  encapsulator).append(  '>');sb.append(   "CommentStart=< ").append(  commentStart).append(  '>');  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "CommentStart=<= ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CommentStart=<= "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "ntStommentStart=< ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "ntStommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb  .append(  CRLF  )  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb  .append  (  CRLF  )  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "ommentS ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "ommentS "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "CommentStart=<CommentSta ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "CommentStart=<CommentSta "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "CommentStart=< "  )  .append  (  commentStart  )  .append  (  '>'  )  ;	[BUG]  [BUGGY]  sb.append(   "mentStart ").append(  commentStart).append(  '>');  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  [BUGGY]  sb.append  (   "mentStart "  )  .append  (  commentStart  )  .append  (  '>'  )  ;  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEmptyLinesIgnored  (  )  )  {	[BUG]  [BUGGY]  if  (  isSurroundingSpacesIgnored(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  if(  isSurroundingSpacesIgnored  ()){  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEmptyLinesIgnored  (  )  )  {  sb.append  (   "  EmptyLines:ignored "  )  ;  }	[BUG]  [BUGGY]  sb.append( "  EmptyLines:ignored ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  if  (isEmptyLinesIgnored())  {    sb.append( "  EmptyLines:ignored ");    if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isEmptyLinesIgnored  (  )  )  {  sb.append  (   "  EmptyLines:ignored "  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  [BUGGY]  if  (isEmptyLinesIgnored())  {        if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isSurroundingSpacesIgnored(  ))  {          sb.append(   "  SurroundingSpaces:ignored ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  EmptyLines:ignored "  )  ;	[BUG]  [BUGGY]  sb.append(   "  EmptyLines:ignoredyLin ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  [BUGGY]  sb.append  (   "  EmptyLines:ignoredyLin "  )  ;  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  EmptyLines:ignored "  )  ;	[BUG]  [BUGGY]  sb  .append(  CRLF)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  [BUGGY]  sb  .append  (  CRLF  );  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  EmptyLines:ignored "  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  [BUGGY]  sb.append( "  EmptyLines:ignored ");    }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  EmptyLines:ignored "  )  ;	[BUG]  [BUGGY]  sb.append(   "  SurroundingSpaces:ignored ");sb.append(   "  EmptyLines:ignored ");  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  EmptyLines:ignored "  )  ;	[BUG]  [BUGGY]  sb.append(   "nore ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  [BUGGY]  sb.append  (   "nore "  )  ;  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isSurroundingSpacesIgnored  (  )  )  {	[BUG]  [BUGGY]  if  (  isEmptyLinesIgnored(  ))  {  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  if(  isEmptyLinesIgnored  ()){  sb.append( "  SurroundingSpaces:ignored ");  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb.append  (   "  SurroundingSpaces:ignored "  )  ;  }	[BUG]  [BUGGY]  sb.append( "  SurroundingSpaces:ignored ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  if  (isSurroundingSpacesIgnored())  {    sb.append( "  SurroundingSpaces:ignored ");    return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  if  (  isSurroundingSpacesIgnored  (  )  )  {  sb.append  (   "  SurroundingSpaces:ignored "  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  [BUGGY]  if  (isSurroundingSpacesIgnored())  {        return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEmptyLinesIgnored(  ))  {          sb.append(   "  EmptyLines:ignored ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUG]  [BUGGY]  sb.append(   "urroundingSpac ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  [BUGGY]  sb.append  (   "urroundingSpac "  )  ;  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUG]  [BUGGY]  sb  .append(  lineSeparator)  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  [BUGGY]  sb  .append  (  lineSeparator  );  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  [BUGGY]  sb.append( "  SurroundingSpaces:ignored ");    }  return  sb.toString();        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUG]  [BUGGY]  sb.append(   "  EmptyLines:ignored ");sb.append(   "  SurroundingSpaces:ignored ");  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUG]  [BUGGY]  if  (  isSurroundingSpacesIgnored(  ))  {  sb.append(   "  SurroundingSpaces:ignored ");  }  [CONTEXT]        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  sb.append  (   "  SurroundingSpaces:ignored "  )  ;	[BUG]  [BUGGY]  sb.append(   "  SurSurroundingSpaces:ignored ");  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  [BUGGY]  sb.append  (   "  SurSurroundingSpaces:ignored "  )  ;  }  return  sb.toString();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  return  sb.toString  (  )  ;	[BUG]  [BUGGY]  return  sb.append(  );  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  [BUGGY]  return  sb.append  ()  ;  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  return  sb.toString  (  )  ;	[BUG]  [BUGGY]  return  sb  .StringWriter(  )  ;  [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  [BUGGY]  return  sb  .StringWriter  ();  }        [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  return  sb.toString  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  StringBuilder  sb  =  new  StringBuilder();  sb.append( "Delimiter=< ").append(delimiter).append('>');  if  (isEscaping())  {  sb.append('  ');  sb.append( "Escape=< ").append(escape).append('>');  }  if  (isEncapsulating())  {  sb.append('  ');  sb.append( "Encapsulator=< ").append(encapsulator).append('>');  }  if  (isCommentingEnabled())  {  sb.append('  ');  sb.append( "CommentStart=< ").append(commentStart).append('>');  }  if  (isEmptyLinesIgnored())  {  sb.append( "  EmptyLines:ignored ");  }  if  (isSurroundingSpacesIgnored())  {  sb.append( "  SurroundingSpaces:ignored ");  }  [BUGGY]  return  sb.toString();          [CLASS]  CSVFormat    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  char    DISABLED    c    commentStart    delimiter    encapsulator    escape    CSVFormat    DEFAULT    EXCEL    MYSQL    PRISTINE    RFC4180    TDF    boolean    emptyLinesIgnored    surroundingSpacesIgnored    String    CRLF    lineSeparator    String[]    header    values    StringBuilder    sb    
[PATCH]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50;	[BUG]  [BUGGY]  private  static  final    short    INITIAL_TOKEN_LENGTH  =  50;  [CONTEXT]          class  Token  {        [BUGGY]  private  static  finalshortINITIAL_TOKEN_LENGTH  =  50;    enum  Type  {      INVALID,          [CLASS]  Token  Type      [VARIABLES]  
[PATCH]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50;	[BUG]  [BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  48;  [CONTEXT]          class  Token  {        [BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  48;    enum  Type  {      INVALID,          [CLASS]  Token  Type      [VARIABLES]  
[PATCH]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50;	[BUG]  [BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50L;  [CONTEXT]          class  Token  {        [BUGGY]  private  static  final  int  INITIAL_TOKEN_LENGTH  =  50L;    enum  Type  {      INVALID,          [CLASS]  Token  Type      [VARIABLES]  
[PATCH]  Token.Type  type  =  INVALID;	[BUG]  [BUGGY]  Token.Type  type  ;  [CONTEXT]      EORECORD  }        [BUGGY]  Token.Type  type  ;        StringBuilder  content  =  new  StringBuilder(INITIAL_TOKEN_LENGTH);              [CLASS]  Token  Type      [VARIABLES]  
[PATCH]  content.setLength  (  0  )  ;	[BUG]  [BUGGY]  content.setLength(  INITIAL_TOKEN_LENGTH);  [CONTEXT]  Token  reset()  {  [BUGGY]  content.setLength  (  INITIAL_TOKEN_LENGTH  )  ;  type  =  INVALID;  isReady  =  false;  return  this;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
[PATCH]  content.setLength  (  0  )  ;  type  =  INVALID;	[BUG]  [BUGGY]    [CONTEXT]  Token  reset()  {  [BUGGY]  content.setLength(0);      isReady  =  false;  return  this;        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
[PATCH]  type  =  INVALID;	[BUG]  [BUGGY]  type  =  type;  [CONTEXT]  Token  reset()  {  content.setLength(0);  [BUGGY]  type  =  type;  isReady  =  false;  return  this;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
[PATCH]  type  =  INVALID;	[BUG]  [BUGGY]  type    =  null  ;  [CONTEXT]  Token  reset()  {  content.setLength(0);  [BUGGY]  type=  null  ;  isReady  =  false;  return  this;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
[PATCH]  isReady  =  false;	[BUG]  [BUGGY]  isReady  =  true;  [CONTEXT]  Token  reset()  {  content.setLength(0);  type  =  INVALID;  [BUGGY]  isReady  =  true;  return  this;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
[PATCH]  return  this;	[BUG]  [BUGGY]  return  null;  [CONTEXT]  Token  reset()  {  content.setLength(0);  type  =  INVALID;  isReady  =  false;  [BUGGY]  return  null;  }        [CLASS]  Token  Type    [METHOD]  reset  [RETURN_TYPE]  Token      [VARIABLES]  Type    EOF    EORECORD    INVALID    TOKEN    type    boolean    isReady    StringBuilder    content    int    INITIAL_TOKEN_LENGTH    
[PATCH]  static  final  int  END_OF_STREAM  =  -1;	[BUG]  [BUGGY]  static  final    long    END_OF_STREAM  =  -1;  [CONTEXT]          class  ExtendedBufferedReader  extends  BufferedReader  {        [BUGGY]  static  finallongEND_OF_STREAM  =  -1;        static  final  int  UNDEFINED  =  -2;              [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  static  final  int  END_OF_STREAM  =  -1;	[BUG]  [BUGGY]  static  final    long    END_OF_STREAM  =  -3;  [CONTEXT]          class  ExtendedBufferedReader  extends  BufferedReader  {        [BUGGY]  static  finallongEND_OF_STREAM  =  -3;        static  final  int  UNDEFINED  =  -2;              [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  static  final  int  UNDEFINED  =  -2;	[BUG]  [BUGGY]  static  final    short    UNDEFINED  =  -2;  [CONTEXT]        static  final  int  END_OF_STREAM  =  -1;        [BUGGY]  static  finalshortUNDEFINED  =  -2;        private  int  lastChar  =  UNDEFINED;              [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  static  final  int  UNDEFINED  =  -2;	[BUG]  [BUGGY]  static  final  int  UNDEFINED  =  -11;  [CONTEXT]        static  final  int  END_OF_STREAM  =  -1;        [BUGGY]  static  final  int  UNDEFINED  =  -11;        private  int  lastChar  =  UNDEFINED;              [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  static  final  int  UNDEFINED  =  -2;	[BUG]  [BUGGY]  static  final  int  UNDEFINED    =  null  ;  [CONTEXT]        static  final  int  END_OF_STREAM  =  -1;        [BUGGY]  static  final  int  UNDEFINED=  null  ;        private  int  lastChar  =  UNDEFINED;              [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  private  int  lastChar  =  UNDEFINED;	[BUG]  [BUGGY]  private    short    lastChar  =  UNDEFINED;  [CONTEXT]        static  final  int  UNDEFINED  =  -2;        [BUGGY]  privateshortlastChar  =  UNDEFINED;        private  int  lineCounter  =  0;              [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  private  int  lastChar  =  UNDEFINED;	[BUG]  [BUGGY]  private    long    lastChar  =  UNDEFINED;  [CONTEXT]        static  final  int  UNDEFINED  =  -2;        [BUGGY]  privatelonglastChar  =  UNDEFINED;        private  int  lineCounter  =  0;              [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  private  int  lineCounter  =  0;	[BUG]  [BUGGY]  private    short    lineCounter  =  0;  [CONTEXT]        private  int  lastChar  =  UNDEFINED;        [BUGGY]  privateshortlineCounter  =  0;                ExtendedBufferedReader(Reader  r)  {        [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  private  int  lineCounter  =  0;	[BUG]  [BUGGY]  private  int  lineCounter  =  0  +  2;  [CONTEXT]        private  int  lastChar  =  UNDEFINED;        [BUGGY]  private  int  lineCounter  =  0  +  2;                ExtendedBufferedReader(Reader  r)  {        [CLASS]  ExtendedBufferedReader      [VARIABLES]  
[PATCH]  super  (  r  )  ;	[BUG]  [BUGGY]    [CONTEXT]  ExtendedBufferedReader(Reader  r)  {  [BUGGY]  super(r);          [CLASS]  ExtendedBufferedReader    [METHOD]  <init>  [RETURN_TYPE]  Reader)      Reader  r  [VARIABLES]  Reader    r    int    END_OF_STREAM    UNDEFINED    lastChar    lineCounter    boolean    
[PATCH]  super  (  r  )  ;	[BUG]  [BUGGY]  super.reset(  );super(  r);  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  <init>  [RETURN_TYPE]  Reader)      Reader  r  [VARIABLES]  Reader    r    int    END_OF_STREAM    UNDEFINED    lastChar    lineCounter    boolean    
[PATCH]  super  (  r  )  ;	[BUG]  [BUGGY]  super.mark(  1);super(  r);  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  <init>  [RETURN_TYPE]  Reader)      Reader  r  [VARIABLES]  Reader    r    int    END_OF_STREAM    UNDEFINED    lastChar    lineCounter    boolean    
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  long    current  =  super.read(  );  [CONTEXT]  public  int  read()  throws  IOException  {  [BUGGY]  longcurrent  =  super.read  ()  ;  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  current  =  super.mark(  );  [CONTEXT]  public  int  read()  throws  IOException  {  [BUGGY]  int  current  =  super.mark  ()  ;  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  String  line  =  super.readLine(  );int  current  =  super.read(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  super.read(  );int  current  =  super.read(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  int  current  =  super.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  int  read()  throws  IOException  {  [BUGGY]  int  current  =  super.read();    if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  &&  (  current  ==  '\n'  &&  lastChar  !=  '\r'))  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  current  ==  '\r'  &&(  current  ==  '\n'  &&  lastChar  !=  '\r'  )){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  >=  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'))  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  current  >=  '\r'  ||(  current  ==  '\n'  &&  lastChar  !=  '\r'  )){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  ||  lastChar  !=  '\r'))  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  current  ==  '\r'  ||(  current  ==  '\n'  ||  lastChar  !=  '\r'  )){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  <=  '\n'  &&  lastChar  !=  '\r'))  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  current  ==  '\r'  ||(  current  <=  '\n'  &&  lastChar  !=  '\r'  )){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  ==  '\r'))  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  current  ==  '\r'  ||(  current  ==  '\n'  &&  lastChar  ==  '\r'  )){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lineCounter  !=  '\r'))  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  current  ==  '\r'  ||(  current  ==  '\n'  &&  lineCounter  !=  '\r'  )){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  lastChar  ==  '\r'  ||  (  current  ==  '\n'  &&  current  !=  '\r'))  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  lastChar  ==  '\r'  ||(  current  ==  '\n'  &&  current  !=  '\r'  )){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\r'){  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  current  ==  '\r'  )  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (    (  current  ==  '\n'  &&  lastChar  !=  '\r'))  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  current  ==  '\n')  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  current  ==  '\n'  ){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  lastChar  !=  '\r')  {  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  lastChar  !=  '\r'  ){  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {	[BUG]  [BUGGY]  if  (  lineCounter  ==  '\r'){  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if(  lineCounter  ==  '\r'  )  {  lineCounter++;  }  lastChar  =  current;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  (lineCounter)++;  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {    (lineCounter)++;    lastChar  =  current;  return  lastChar;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  current  ==  '\r'  ||  (  current  ==  '\n'  &&  lastChar  !=  '\r'  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]    [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  [BUGGY]  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {        lastChar  =  current;  return  lastChar;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[(  i  -  1)]  :  lastChar))  {          (  lineCounter)++;  }  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  lastChar  =  current;	[BUG]  [BUGGY]  lastChar  =  lastChar;  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  [BUGGY]  lastChar  =  lastChar;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  lastChar  =  current;	[BUG]  [BUGGY]  lastChar  =    lineCounter;  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  [BUGGY]  lastChar  =lineCounter;  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  lastChar  =  current;	[BUG]  [BUGGY]  lastChar  =  END_OF_STREAM;lastChar  =  current;  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  return  lastChar;	[BUG]  [BUGGY]  return  current;  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  [BUGGY]  return  current;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  return  lastChar;	[BUG]  [BUGGY]  return  lineCounter;  [CONTEXT]  public  int  read()  throws  IOException  {  int  current  =  super.read();  if  (current  ==  '\r'  ||  (current  ==  '\n'  &&  lastChar  !=  '\r'))  {  lineCounter++;  }  lastChar  =  current;  [BUGGY]  return  lineCounter;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  return  lastChar;	[BUG]  [BUGGY]  return  lineCounter;  [CONTEXT]  int  readAgain()  {  [BUGGY]  return  lineCounter;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readAgain  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    lastChar    lineCounter    boolean    
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  length  <=  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if(  length  <=  0  ){  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  length  ==  -4)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if(  length  ==  -4  ){  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  length  ==  -8)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if(  length  ==  -8  ){  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  len  ==  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if(  len  ==  0  ){  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  length  ==  0  )  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if(  length  ==  0){  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  length  ==  0  )  {	[BUG]  [BUGGY]  if  (  len  >  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if(  len  >  0  ){  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  length  ==  0  )  {  return  0;  }	[BUG]  [BUGGY]  return  0;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if  (length  ==  0)  {    return  0;      int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  length  ==  0  )  {  return  0;  }	[BUG]  [BUGGY]    [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  [BUGGY]  if  (length  ==  0)  {          int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  return  0;	[BUG]  [BUGGY]  return  -2;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  [BUGGY]  return  -2;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  return  0;	[BUG]  [BUGGY]  return  2;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  [BUGGY]  return  2;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  return  0;	[BUG]  [BUGGY]  return  8;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  [BUGGY]  return  8;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  return  0;	[BUG]  [BUGGY]  return  0L;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  [BUGGY]  return  0L;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  short    len  =  super.read(  buf,  offset,  length);  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    [BUGGY]  shortlen  =  super.read  (  buf,  offset,  length  )  ;    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(    offset,  length);  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    [BUGGY]  int  len  =  super.read  (offset,  length  )  ;    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(  buf,    length);  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    [BUGGY]  int  len  =  super.read  (  buf,length  )  ;    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(  buf,  offset);  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    [BUGGY]  int  len  =  super.read  (  buf,  offset  )  ;    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  len  =  super  .read(  )  ;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    [BUGGY]  int  len  =  super  .read  ();    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]  int  c  =  super.read(  );int  len  =  super.read(  buf,  offset,  length);  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  int  len  =  super.read  (  buf,  offset,  length  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    [BUGGY]  int  len  =  super.read(buf,  offset,  length);      if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  <  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  len  <  0  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  >=  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  len  >=  0  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  >  lastChar)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  len  >  lastChar  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  >  len)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  len  >  len  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  length  >  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  length  >  0  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  i  <  offset  +  len)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  i  <  offset  +  len  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  offset  +  len)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  offset  +  len  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  ch  ==  '\n')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  ch  ==  '\n'  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  i  >  0  ?  buf[(i  -  1)]  :  lastChar)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  '\r'  !=  i  >  0  ?  buf[(i  -  1)]  :  lastChar  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  i  >  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  i  >  0  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  i  -  1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  i  -  1  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  ch  ==  '\r')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  ch  ==  '\r'  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  offset  +  len  -  1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  offset  +  len  -  1  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  ==  -1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  len  ==  -1  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  len  >  2)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  len  >  2  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  length  ==  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  length  ==  0  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  len  >  0  )  {	[BUG]  [BUGGY]  if  (  line  !=  null)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    [BUGGY]  if(  line  !=  null  ){    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  len  >  -1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if(  len  >  -1  ){  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  len  ==  -8)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if(  len  ==  -8  ){  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  length  ==  -1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if(  length  ==  -1  ){  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }    if  (  lineCounter  ==  -1L)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }if(  lineCounter  ==  -1L  ){  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  ==  '\r')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if(  ch  ==  '\r'  ){  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {  lastChar  =  END_OF_STREAM;  }	[BUG]  [BUGGY]  lastChar  =  org.apache.commons.csv.ExtendedBufferedReader.END_OF_STREAM;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if  (len  ==  -1)  {    lastChar  =  org.apache.commons.csv.ExtendedBufferedReader.END_OF_STREAM;      return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {  lastChar  =  END_OF_STREAM;  }	[BUG]  [BUGGY]    [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if  (len  ==  -1)  {          return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  lineCounter;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  lineCounter;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar    =    lastChar  ;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar=lastChar  ;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  current;lastChar  =  END_OF_STREAM;  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  1];lastChar  =  END_OF_STREAM;  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  len  ==  (  -1))  {          lastChar  =  END_OF_STREAM;  }  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  offset;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  offset;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  <=  '\n')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if(  ch  <=  '\n'  ){  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  >=  '\n')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if(  ch  >=  '\n'  ){  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  i  >  0  ?  buf[(i  -  1)]  :  lastChar)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if(  '\r'  !=  i  >  0  ?  buf[(i  -  1)]  :  lastChar  ){  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  >  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if(  i  >  0  ){  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  -  1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if(  i  -  1  ){  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  ==  '\r')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if(  ch  ==  '\r'  ){  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  if('\r'  !=(i  >  0  ?  buf[(i  -  1)]  :  lastChar))  {      (lineCounter)++;};  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (ch  ==  '\n')  {    if  ('\r'  !=  (i  >  0  ?  buf[(i  -  1)]  :  lastChar))  {(lineCounter)++;};      }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]    [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if  (ch  ==  '\n')  {          }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  !=  '\r')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if(  ch  !=  '\r'  ){  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  len  ==  -1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if(  len  ==  -1  ){  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {  lineCounter++;  }	[BUG]  [BUGGY]  (lineCounter)++;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if  (ch  ==  '\r')  {    (lineCounter)++;    }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {  lineCounter++;  }	[BUG]  [BUGGY]    [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if  (ch  ==  '\r')  {        }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  ==  (  i  >  0  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  ==(  i  >  0  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >=  0  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >=  0  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  i  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  i  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i--8]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  0  ?  buf[i--8]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  offset  >  0  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  offset  >  0  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  offset))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  0  ?  buf[i-1]:  offset  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  lastChar  >  0  ?  buf[i-1]:  i))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  lastChar  >  0  ?  buf[i-1]:  i  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  lastChar[i-1]:  buf))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  0  ?  lastChar[i-1]:  buf  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  i  >  0)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  i  >  0  ){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  i  -  1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  i  -  1  ){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  lineCounter  >  0  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  lineCounter  >  0  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]  (lineCounter)++;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {    (lineCounter)++;    }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {  lineCounter++;  }	[BUG]  [BUGGY]    [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {        }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  current  ==  '\r')  ||  (  (  current  ==  '\n')  &&  (  (  lastChar)  !=  '\r')))  {          (  lineCounter)++;  }  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  >=  (  i  >  0  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  >=(  i  >  0  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  ==  0  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  ==  0  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  current  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  current  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-offset]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  0  ?  buf[i-offset]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  length))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  0  ?  buf[i-1]:  length  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (    long    i  =  offset;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(longi  =  offset;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  offset;  i  <=  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  int  i  =  offset;  i  <=  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  len;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  int  i  =  len;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  lennt  i  =  offset;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  lennt  i  =  offset;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  offset;  i  <  offset  +  offset;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  int  i  =  offset;  i  <  offset  +  offset;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  lengthnt  i  =  offset;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  lengthnt  i  =  offset;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  >  '\n')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if(  ch  >  '\n'  ){  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  >=  '\r')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if(  ch  >=  '\r'  ){  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  2  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  2  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  buf  >  0  ?  i[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  buf  >  0  ?  i[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  lineCounter  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  lineCounter  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i--1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  0  ?  buf[i--1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  <=  '\r')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if(  ch  <=  '\r'  ){  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  char  ch  =  buf[i];	[BUG]  [BUGGY]  int  ch  =  buf[i];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  int  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len    !=    1];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset  +  len!=1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset    <    len  -  1];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset<len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  ];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset  +  len  -  ];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[lineCounter  +  len  -  1];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[lineCounter  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  lineCounter  -  1];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset  +  lineCounter  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  len[offset  +  buf  -  1];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  len[offset  +  buf  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  0];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset  +  len  -  0];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  END_OF_STREAM;lastChar  =  buf[offset  +  len  -  1];  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  lineCounter;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  int  i  =  lineCounter;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  ch  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  ch  !=  '\n')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  [BUGGY]  if(  ch  !=  '\n'  ){  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  <  0  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  <  0  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  -3  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  -3  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  0  ?  buf[i-]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  -7  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  -7  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  len  >=  -1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if(  len  >=  -1  ){  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  len  ==  -len)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if(  len  ==  -len  ){  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  len  ==  -1  )  {	[BUG]  [BUGGY]  }  else  if  (  offset  ==  -1)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    [BUGGY]  }  else  if(  offset  ==  -1  ){  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  length;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  =  length;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  ;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  [BUGGY]  lastChar  ;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for    >>  (  int  i  =  offset;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for>>(  int  i  =  offset;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  offsetnt  i  =  offset;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  offsetnt  i  =  offset;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  offsetnt  i  =  i;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  offsetnt  i  =  i;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  ch  >  '\r')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }  else  if(  ch  >  '\r'  ){  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  }  else  if  (  ch  ==  '\r'  )  {	[BUG]  [BUGGY]  }    if  (  ch  ==  '\r')  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  [BUGGY]  }if(  ch  ==  '\r'  ){  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  <=  (  i  >  0  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  <=(  i  >  0  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  9  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  9  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  len  ?  buf[i-1]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  len  ?  buf[i-1]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-1]:  lastChar  )  )  {	[BUG]  [BUGGY]  if  (  '\r'  !=  (  i  >  0  ?  buf[i-lineCounter]:  lastChar))  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  [BUGGY]  if(  '\r'  !=(  i  >  0  ?  buf[i-lineCounter]:  lastChar  )){  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  char  ch  =  buf[i];	[BUG]  [BUGGY]  String  ch  =  buf[i];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  [BUGGY]  String  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len    >=    1];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset  +  len>=1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  ];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset  +  len  ];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  lastChar  -  1];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset  +  lastChar  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  lastChar  =  buf[offset  +  len  -  1];	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  1  >>>  1];  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    [BUGGY]  lastChar  =  buf[offset  +  len  -  1  >>>  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  for  (  int  i  =  offset;  i  <  offset  +  len;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  length;  i  <  offset  +  len;  i++)  {  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    [BUGGY]  for(  int  i  =  length;  i  <  offset  +  len;  i++  ){  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  return  len;	[BUG]  [BUGGY]  return  lastChar;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    [BUGGY]  return  lastChar;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  return  len;	[BUG]  [BUGGY]  return  offset;  [CONTEXT]  public  int  read(char[]  buf,  int  offset,  int  length)  throws  IOException  {  if  (length  ==  0)  {  return  0;  }    int  len  =  super.read(buf,  offset,  length);    if  (len  >  0)  {    for  (int  i  =  offset;  i  <  offset  +  len;  i++)  {  char  ch  =  buf[i];  if  (ch  ==  '\n')  {  if  ('\r'  !=  (i  >  0  ?  buf[i-1]:  lastChar))  {  lineCounter++;  }  }  else  if  (ch  ==  '\r')  {  lineCounter++;  }  }    lastChar  =  buf[offset  +  len  -  1];    }  else  if  (len  ==  -1)  {  lastChar  =  END_OF_STREAM;  }    [BUGGY]  return  offset;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  read  [RETURN_TYPE]  int      char[]  buf  int  offset  int  length  [VARIABLES]  char    ch    boolean    int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    char[]    buf    
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  char  line  =  super.readLine(  );  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  char  line  =  super.readLine  ()  ;    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  String  line  =  super.mark(  );  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  String  line  =  super.mark  ()  ;    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  String  line  =  super  .read(  )  ;  [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  String  line  =  super  .read  ();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  int  current  =  super.read(  );String  line  =  super.readLine(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]  int  c  =  super.read(  );String  line  =  super.readLine(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  String  line  =  super.readLine  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  readLine()  throws  IOException  {  [BUGGY]  String  line  =  super.readLine();      if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  line  ==  null)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    [BUGGY]  if(  line  ==  null  ){  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  line.length()  >  0)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    [BUGGY]  if(  line.length()  >  0  ){  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  -  1)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    [BUGGY]  if(  line.length  ()-  1  ){  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  line  !=  false)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    [BUGGY]  if(  line  !=  false  ){  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line  !=  null  )  {	[BUG]  [BUGGY]  if  (  len  >  0)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    [BUGGY]  if(  len  >  0  ){  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line  !=  null  )  {  if  (  line.length  (  )  >  0  )  {  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;  }	[BUG]  [BUGGY]  if((line.length())  >  0)  {        lastChar  =  line.charAt(((line.length())  -  1));};(lineCounter)++;  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    [BUGGY]  if  (line  !=  null)  {    if  ((line.length())  >  0)  {lastChar  =  line.charAt(((line.length())  -  1));};  (lineCounter)++;      lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line  !=  null  )  {  if  (  line.length  (  )  >  0  )  {  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    [BUGGY]  if  (line  !=  null)  {          lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar    =    lastChar  ;  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  [BUGGY]  lastChar=lastChar  ;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  current;lastChar  =  END_OF_STREAM;  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  buf[offset  +  len  -  1];lastChar  =  END_OF_STREAM;  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  len  ==  (  -1))  {          lastChar  =  END_OF_STREAM;  }  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  >=  0)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.length  ()>=  0  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  >  offset)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.length  ()>  offset  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length()  -  6    >  0)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.length()  -  6>  0  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  -  1)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.length  ()-  1  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.charAt(  )  >  0)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.charAt  ()>  0  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;  }	[BUG]  [BUGGY]  lastChar  =  line.charAt(((line.length())  -  1));  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if  (line.length()  >  0)  {    lastChar  =  line.charAt(((line.length())  -  1));    lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if  (line.length()  >  0)  {        lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    >=    1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()  >=1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  offset);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()-  offset  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  5    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  -  5-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.charAt(  )  -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.charAt  ()-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  0  );  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()-  0)  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  line.length(  ))  >  0)  {          lastChar  =  line.charAt(  (  (  line.length(  ))  -  1));  }  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    >>    1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()  >>1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  );  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  6    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  +  6-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt(line.length()  -  1);    }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  9    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  +  9-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  8    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  +  8-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length()  +  9    >  0)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.length()  +  9>  0  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    &&    1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()  &&1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  9    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  -  9-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length(  )  >  len)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.length  ()>  len  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length()  -  3    >  0)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.length()  -  3>  0  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    <<    1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()  <<1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )  -  );  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()-)  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  0    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  +  0-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  1    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  +  1-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  7    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  +  7-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    <=    1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()  <=1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  1    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  -  1-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  END_OF_STREAM;	[BUG]  [BUGGY]  lastChar  =  len;  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  [BUGGY]  lastChar  =  len;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  if  (  line.length  (  )  >  0  )  {	[BUG]  [BUGGY]  if  (  line.length()  -  4    >  0)  {  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  [BUGGY]  if(  line.length()  -  4>  0  ){  lastChar  =  line.charAt(line.length()  -  1);  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length(  )    &    1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length  ()  &1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  -  2    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  -  2-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  lastChar  =  line.charAt  (  line.length  (  )  -  1  )  ;	[BUG]  [BUGGY]  lastChar  =  line.charAt(  line.length()  +  4    -  1);  [CONTEXT]  public  String  readLine()  throws  IOException  {  String  line  =  super.readLine();    if  (line  !=  null)  {  if  (line.length()  >  0)  {  [BUGGY]  lastChar  =  line.charAt  (  line.length()  +  4-  1  )  ;  }  lineCounter++;  }  else  {  lastChar  =  END_OF_STREAM;  }    return  line;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  readLine  [RETURN_TYPE]  String      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    current    i    lastChar    len    length    lineCounter    offset    String    line    boolean    
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  super.mark(  c);  [CONTEXT]  int  lookAhead()  throws  IOException  {  [BUGGY]  super.mark  (  c  )  ;  int  c  =  super.read();  super.reset();    return  c;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  super  .readLine(  )  ;  [CONTEXT]  int  lookAhead()  throws  IOException  {  [BUGGY]  super  .readLine  ();  int  c  =  super.read();  super.reset();    return  c;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]    [CONTEXT]  int  lookAhead()  throws  IOException  {  [BUGGY]  super.mark(1);    int  c  =  super.read();  super.reset();    return  c;        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  super.reset(  );super.mark(  1);  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.mark  (  1  )  ;	[BUG]  [BUGGY]  super(  r);super.mark(  1);  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  short    c  =  super.read(  );  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  shortc  =  super.read  ()  ;  super.reset();    return  c;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  super.mark(  );  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  int  c  =  super.mark  ()  ;  super.reset();    return  c;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  String  line  =  super.readLine(  );int  c  =  super.read(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  len  =  super.read(  buf,  offset,  length);int  c  =  super.read(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  int  current  =  super.read(  );int  c  =  super.read(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  int  c  =  super.read  (  )  ;  super.reset  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  [BUGGY]  int  c  =  super.read();        return  c;        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  int  c  =  super.read  (  )  ;	[BUG]  [BUGGY]  super.reset(  );int  c  =  super.read(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  super.mark(  );  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  super.mark  ()  ;    return  c;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  super  .read(  )  ;  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  super  .read  ();    return  c;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  [BUGGY]  super.reset();      return  c;        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  super(  r);super.reset(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  super.mark(  1);super.reset(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  super.reset  (  )  ;	[BUG]  [BUGGY]  int  c  =  super.read(  );super.reset(  );  [CONTEXT]        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  return  c;	[BUG]  [BUGGY]  return  lineCounter;  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  super.reset();    [BUGGY]  return  lineCounter;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  return  c;	[BUG]  [BUGGY]  return  len;  [CONTEXT]  int  lookAhead()  throws  IOException  {  super.mark(1);  int  c  =  super.read();  super.reset();    [BUGGY]  return  len;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  lookAhead  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  return  lineCounter;	[BUG]  [BUGGY]  return  offset;  [CONTEXT]  int  getLineNumber()  {  [BUGGY]  return  offset;  }        [CLASS]  ExtendedBufferedReader    [METHOD]  getLineNumber  [RETURN_TYPE]  int      [VARIABLES]  int    END_OF_STREAM    UNDEFINED    c    current    i    lastChar    len    length    lineCounter    offset    boolean    
[PATCH]  private  final  List<String>  record  =  new  ArrayList<String>  (  )  ;	[BUG]  [BUGGY]  private    List<String>  record  =  new  ArrayList<String>(  );  [CONTEXT]  private  final  Map<String,  Integer>  headerMapping;              [BUGGY]  privateList<String>  record  =  new  ArrayList<String>  ()  ;  private  final  Token  reusableToken  =  new  Token();                      [CLASS]  CSVParser  1      [VARIABLES]  
[PATCH]  private  final  Token  reusableToken  =  new  Token  (  )  ;	[BUG]  [BUGGY]  private    Token  reusableToken  =  new  Token(  );  [CONTEXT]              private  final  List<String>  record  =  new  ArrayList<String>();  [BUGGY]  privateToken  reusableToken  =  new  Token  ()  ;                          [CLASS]  CSVParser  1      [VARIABLES]  
[PATCH]  this  (  input,  CSVFormat.DEFAULT  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  CSVParser(Reader  input)  throws  IOException  {  [BUGGY]  this(input,  CSVFormat.DEFAULT);          [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  Reader)      Reader  input  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    Map    headerMapping    
[PATCH]  format.validate  (  )  ;	[BUG]  [BUGGY]  format  .getHeader(  )  ;  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  [BUGGY]  format  .getHeader  ();    this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));    this.headerMapping  =  initializeHeader(format);  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
[PATCH]  format.validate  (  )  ;  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;  this.headerMapping  =  initializeHeader  (  format  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  [BUGGY]  format.validate();                  [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
[PATCH]  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUG]  [BUGGY]  this.lexer  =  new  CSVLexer(    new  ExtendedBufferedReader(  input));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    [BUGGY]  this.lexer  =  new  CSVLexer  (new  ExtendedBufferedReader  (  input  ))  ;    this.headerMapping  =  initializeHeader(format);  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
[PATCH]  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUG]  [BUGGY]  this.lexer  =  new  CSVLexer(  input,  new  ExtendedBufferedReader(  format));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    [BUGGY]  this.lexer  =  new  CSVLexer  (  input,  new  ExtendedBufferedReader  (  format  ))  ;    this.headerMapping  =  initializeHeader(format);  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
[PATCH]  this.lexer  =  new  CSVLexer  (  format,  new  ExtendedBufferedReader  (  input  )  )  ;	[BUG]  [BUGGY]  this.lexer  =    new  CSVLexer(  null,  new  ExtendedBufferedReader(  input));  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    [BUGGY]  this.lexer  =new  CSVLexer  (  null,  new  ExtendedBufferedReader  (  input  ))  ;    this.headerMapping  =  initializeHeader(format);  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
[PATCH]  this.headerMapping  =  initializeHeader  (  format  )  ;	[BUG]  [BUGGY]  this.headerMapping  =    initializeHeader(  null);  [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));    [BUGGY]  this.headerMapping  =initializeHeader  (  null  )  ;  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
[PATCH]  this.headerMapping  =  initializeHeader  (  format  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVParser(Reader  input,  CSVFormat  format)  throws  IOException  {  format.validate();    this.lexer  =  new  CSVLexer(format,  new  ExtendedBufferedReader(input));    [BUGGY]  this.headerMapping  =  initializeHeader(format);          [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Reader  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    Reader    input    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    Map    headerMapping    
[PATCH]  this  (  new  StringReader  (  input  )  ,  format  )  ;	[BUG]  [BUGGY]  this(  new  StringReader(  input));  [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  this  (  new  StringReader  (  input  ))  ;  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      String  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    String    input    Map    headerMapping    
[PATCH]  this  (  new  StringReader  (  input  )  ,  format  )  ;	[BUG]  [BUGGY]  this(  new  StringReader(  format),  input);  [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  this  (  new  StringReader  (  format  )  ,  input  )  ;  }        [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      String  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    String    input    Map    headerMapping    
[PATCH]  this  (  new  StringReader  (  input  )  ,  format  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVParser(String  input,  CSVFormat  format)  throws  IOException{  [BUGGY]  this(new  StringReader(input),  format);          [CLASS]  CSVParser  1    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      String  input  CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    Token    reusableToken    CSVRecord    current    CSVFormat    format    String    input    Map    headerMapping    
[PATCH]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;	[BUG]  [BUGGY]  List<CSVRecord>  records  =  new    LinkedList  <CSVRecord>(  );  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  [BUGGY]  List<CSVRecord>  records  =  newLinkedList  <CSVRecord>  ()  ;  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  );List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  CSVRecord  rec;	[BUG]  [BUGGY]  CSVRecord  next  =  current;CSVRecord  rec;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUG]  [BUGGY]  while  (  (  rec  =  getRecord(  ))  ==  null)  {  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  rec  =  getRecord  ())==  null  ){  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUG]  [BUGGY]  while  (  (  current  =  getRecord(  ))  !=  null)  {  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  current  =  getRecord  ())!=  null  ){  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUG]  [BUGGY]  while  (  (  rec  =  toString(  ))  !=  null)  {  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  rec  =  toString  ())!=  null  ){  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  records.add  (  rec  )  ;	[BUG]  [BUGGY]  records.add(  current);  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  records.add  (  current  )  ;  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  records.add  (  rec  )  ;	[BUG]  [BUGGY]  records  .add(  rec)  ;  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  records  .add  (  rec  );  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  records.add  (  rec  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  while  ((rec  =  getRecord())  !=  null)  {  [BUGGY]  records.add(rec);    }  return  records;        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  records.add  (  rec  )  ;	[BUG]  [BUGGY]  record.clear(  );records.add(  rec);  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {	[BUG]  [BUGGY]  while  (  (  rec  ;  [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while((  rec  ;  records.add(rec);  }  return  records;  }        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  while  (  (  rec  =  getRecord  (  )  )  !=  null  )  {  records.add  (  rec  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  List<CSVRecord>  getRecords()  throws  IOException  {  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>();  CSVRecord  rec;  [BUGGY]  while  ((rec  =  getRecord())  !=  null)  {      }  return  records;        [CLASS]  CSVParser  1    [METHOD]  getRecords  [RETURN_TYPE]  List      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    boolean    Map    headerMapping    
[PATCH]  CSVRecord  result  =  new  CSVRecord  (  null,  headerMapping  )  ;	[BUG]  [BUGGY]  CSVRecord  result  =  new  CSVRecord(  null,  this);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  [BUGGY]  CSVRecord  result  =  new  CSVRecord  (  null,  this  )  ;  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.clear  (  )  ;	[BUG]  [BUGGY]  record.size(  );  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  record.size  ()  ;  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.clear  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  [BUGGY]  record.clear();    do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.clear  (  )  ;	[BUG]  [BUGGY]  records.add(  rec);record.clear(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.clear  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  );record.clear(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  if  (  reusableToken.isReady  )  {  record.add  (  reusableToken.content.toString  (  )  )  ;  }  else  {  result  =  null;  }	[BUG]  [BUGGY]  record.add(reusableToken.content.toString());  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  [BUGGY]  if  (reusableToken.isReady)  {    record.add(reusableToken.content.toString());        break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  if  (  reusableToken.isReady  )  {  record.add  (  reusableToken.content.toString  (  )  )  ;  }  else  {  result  =  null;  }	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  [BUGGY]  if  (reusableToken.isReady)  {            break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  null;	[BUG]  [BUGGY]  result  =  this;  [CONTEXT]  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  [BUGGY]  result  =  this;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  null;	[BUG]  [BUGGY]  current  =  null;result  =  null;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.size(  reusableToken.content.toString(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.size  (  reusableToken.content.toString  ())  ;  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content.getRecord(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.add  (  reusableToken.content.getRecord  ())  ;  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content  .getLineNumber(  )  );  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.add  (  reusableToken.content  .getLineNumber  ()  )  ;  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  [BUGGY]  record.add(reusableToken.content.toString());    }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  null;	[BUG]  [BUGGY]  result  =  false;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  [BUGGY]  result  =  false;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  null;	[BUG]  [BUGGY]  current  =  null;result  =  null;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;  ;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  throw  new  UnsupportedOperationException( "   ");  ;  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;throw  new  IOException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")    ;throw  new  IOException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")    ;throw  new  IOException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  reusableToken.reset  (  )  ;	[BUG]  [BUGGY]  reusableToken.Token(  );  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  [BUGGY]  reusableToken.Token  ()  ;  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  reusableToken.reset  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  [BUGGY]  reusableToken.reset();    lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  reusableToken.reset  (  )  ;	[BUG]  [BUGGY]  if  (  reusableToken.isReady)  {  reusableToken.reset(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  lexer.nextToken  (  reusableToken  )  ;	[BUG]  [BUGGY]  lexer.getLineNumber(  reusableToken);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  lexer.getLineNumber  (  reusableToken  )  ;  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  lexer.nextToken  (  reusableToken  )  ;	[BUG]  [BUGGY]  lexer  .getLineNumber(  )  ;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  lexer  .getLineNumber  ();  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  lexer.nextToken  (  reusableToken  )  ;	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  [BUGGY]  lexer.nextToken(reusableToken);    switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.size(  reusableToken.content.toString(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.size  (  reusableToken.content.toString  ())  ;  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content.getRecord(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.add  (  reusableToken.content.getRecord  ())  ;  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content  .getLineNumber(  )  );  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.add  (  reusableToken.content  .getLineNumber  ()  )  ;  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  [BUGGY]  record.add(reusableToken.content.toString());    break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.size(  reusableToken.content.toString(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  record.size  (  reusableToken.content.toString  ())  ;  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;	[BUG]  [BUGGY]  record.add(  reusableToken.content.getRecord(  ));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  record.add  (  reusableToken.content.getRecord  ())  ;  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  record.add  (  reusableToken.content.toString  (  )  )  ;  break;	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  [BUGGY]  record.add(reusableToken.content.toString());      case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  [BUGGY]  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");    }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  if  (  !record.isEmpty  (  )  )  {	[BUG]  [BUGGY]  if  (  !record.clear(  ))  {  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    [BUGGY]  if(  !record.clear  ()){  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  if  (  !record.isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;  }	[BUG]  [BUGGY]  result  =  new  org.apache.commons.csv.CSVRecord(record.toArray(new  java.lang.String[record.size()]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    [BUGGY]  if  (!record.isEmpty())  {    result  =  new  org.apache.commons.csv.CSVRecord(record.toArray(new  java.lang.String[record.size()]),  headerMapping);    return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  if  (  !record.isEmpty  (  )  )  {  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    [BUGGY]  if  (!record.isEmpty())  {        return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  1  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  +  1  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size(  )]));  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  ()  ]  ))  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  headerMapping.toArray(  new  String[record.size(  )]),  record);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  headerMapping.toArray  (  new  String[record.size  ()  ]  )  ,  record  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.clear(  new  String[record.size(  )]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.clear  (  new  String[record.size  ()  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.clear(  )]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.clear  ()  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  ;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !(  record.isEmpty(  )))  {          result  =  new  CSVRecord(  record.toArray(  new  size(  )]),  headerMapping);  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  6  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  +  6  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record  .add(  current)  ,  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record  .add  (  current  ),  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record  .isEmpty(  )  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record  .isEmpty  ()]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  9  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  +  9  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]    [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);    }  return  result;        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  0  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  +  0  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  7  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  +  7  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result    =    result  ;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result=result  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  6  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  -  6  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record  .add(  rec)  ,  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record  .add  (  rec  ),  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  +  8  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  +  8  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  record.toArray(  new  String[record.size()  -  9  ]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size()  -  9  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  result  =  new  CSVRecord  (  record.toArray  (  new  String[record.size  (  )  ]  )  ,  headerMapping  )  ;	[BUG]  [BUGGY]  result  =  new  CSVRecord(  4.toArray(  new  String[record.size(  )]),  headerMapping);  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  [BUGGY]  result  =  new  CSVRecord  (  4.toArray  (  new  String[record.size  ()  ]  )  ,  headerMapping  )  ;  }  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  return  result;	[BUG]  [BUGGY]  return  rec;  [CONTEXT]  CSVRecord  getRecord()  throws  IOException  {  CSVRecord  result  =  new  CSVRecord(null,  headerMapping);  record.clear();  do  {  reusableToken.reset();  lexer.nextToken(reusableToken);  switch  (reusableToken.type)  {  case  TOKEN:  record.add(reusableToken.content.toString());  break;  case  EORECORD:  record.add(reusableToken.content.toString());  break;  case  EOF:  if  (reusableToken.isReady)  {  record.add(reusableToken.content.toString());  }  else  {  result  =  null;  }  break;  case  INVALID:  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  parse  sequence ");  }  }  while  (reusableToken.type  ==  TOKEN);    if  (!record.isEmpty())  {  result  =  new  CSVRecord(record.toArray(new  String[record.size()]),  headerMapping);  }  [BUGGY]  return  rec;  }        [CLASS]  CSVParser  1    [METHOD]  getRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    boolean    Map    headerMapping    
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  )  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  format.getHeader  ()==  null  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  length  ==  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  length  ==  0  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  rec  !=  null  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  header  !=  null  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  i  <  header.length)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  i  <  header.length  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  format  .validate(  )    !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  format  .validate  ()  !=  null  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  )  !=  false)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  format.getHeader  ()!=  false  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  !=  null  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  ==  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  ==  0  ){  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  >=  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  >=  0  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  ==  i)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  ==  i  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  rec  !=  null  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format  .validate(  )  .length  ==  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format  .validate  ().length  ==  0  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  )  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()!=  null  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {  CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUG]  [BUGGY]  org.apache.commons.csv.CSVRecord  rec  =  getRecord();  if(rec  !=  null)  {        header  =  rec.values();};  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if  (format.getHeader().length  ==  0)  {    org.apache.commons.csv.CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {header  =  rec.values();};        }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {  CSVRecord  rec  =  getRecord  (  )  ;  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if  (format.getHeader().length  ==  0)  {            }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  format.getHeader  (  )  ;	[BUG]  [BUGGY]  header  =  format  .validate(  )  ;  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =  format  .validate  ();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  format.getHeader  (  )  ;	[BUG]  [BUGGY]  header  =    null.getHeader(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =null.getHeader  ()  ;  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  format.getHeader  (  )  ;	[BUG]  [BUGGY]  header  =  rec.values(  );header  =  format.getHeader(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  format.getHeader  (  )  ;	[BUG]  [BUGGY]  if  (  format.getHeader(  )  !=  null)  {  header  =  format.getHeader(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  format.getHeader  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  [BUGGY]  header  =  format.getHeader();            if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  rec  ==  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  result  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  result  !=  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  true)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  rec  !=  true  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  header  !=  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  current  ==  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  next  ==  null  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUG]  [BUGGY]  header  =  rec.values();  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if  (rec  !=  null)  {    header  =  rec.values();    }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {  header  =  rec.values  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if  (rec  !=  null)  {        }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  current)  ==  null)  {          current  =  getNextRecord(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  rec.values  (  )  ;	[BUG]  [BUGGY]  header  =  result.values(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  result.values  ()  ;  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  rec.values  (  )  ;	[BUG]  [BUGGY]  header  =    null.values(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =null.values  ()  ;  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  rec.values  (  )  ;	[BUG]  [BUGGY]  header  =  format.getHeader(  );header  =  rec.values(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  header  =  rec.values  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  [BUGGY]  header  =  rec.values();    }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  toString(  );  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      [BUGGY]  CSVRecord  rec  =  toString  ()  ;  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  List<CSVRecord>  records  =  new  ArrayList<CSVRecord>(  );CSVRecord  rec  =  getRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      [BUGGY]  CSVRecord  rec  =  getRecord();    if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  next  =  getNextRecord(  );CSVRecord  rec  =  getRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  current  =  getNextRecord(  );CSVRecord  rec  =  getRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  CSVRecord  rec  =  getRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  );CSVRecord  rec  =  getRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  rec  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  false)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  [BUGGY]  if(  rec  !=  false  ){  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  header  ==  null  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  i  <  header.length)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  i  <  header.length  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  true)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  header  !=  true  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  current  ==  null  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  rec  !=  null  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  next  ==  null  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {  for  (  int  i  =  0;  i  <  header.length;  i++  )  {  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;  }	[BUG]  [BUGGY]  for(int  i  =  0;  i  <(header.length);  i++)  {        hdrMap.put(header[i],  java.lang.Integer.valueOf(i));};  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if  (header  !=  null)  {    for  (int  i  =  0;  i  <  (header.length);  i++)  {hdrMap.put(header[i],  java.lang.Integer.valueOf(i));};      }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {  for  (  int  i  =  0;  i  <  header.length;  i++  )  {  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if  (header  !=  null)  {          }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (    long    i  =  0;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(longi  =  0;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <=  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  0;  i  <=  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  1;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  1;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  header.lengthnt  i  =  0;  i  <  i;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  header.lengthnt  i  =  0;  i  <  i;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  header.length.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  0;  i  <  header.length.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  header  !=  null)  {          for  (  int  i  =  0;  i  <  (  header.length);  i++)  {                  hdrMap.put(  header[i],  valueOf(  i));          }  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put(header[i],  Integer.valueOf(i));    }  }  }  return  hdrMap;        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  i;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  i;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (    short    i  =  0;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(shorti  =  0;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  5;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  5;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  headernt  i  =  0;  i  <  i.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  headernt  i  =  0;  i  <  i.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  hdrMap.put  (  header[i],  Integer.valueOf  (  i  )  )  ;	[BUG]  [BUGGY]  hdrMap.put(  i[i],  Integer.valueOf(  header));  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  [BUGGY]  hdrMap.put  (  i[i],  Integer.valueOf  (  header  ))  ;  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  hdrMap  =  new  HashMap<String,  Integer>  (  )  ;	[BUG]  [BUGGY]  hdrMap    =  null  ;  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  [BUGGY]  hdrMap=  null  ;    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  8;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  8;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  <=  0)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  <=  0  ){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  format.getHeader  (  )  .length  ==  0  )  {	[BUG]  [BUGGY]  if  (  format.getHeader(  ).length  ==  0  )  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  [BUGGY]  if(  format.getHeader  ()  .length  ==  0){      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  header  !=  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  false)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        [BUGGY]  if(  header  !=  false  ){  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  >  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  0;  i  >  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  -6;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  -6;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  -5;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  -5;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  hdrMap  =  new  HashMap<String,  Integer>  (  )  ;	[BUG]  [BUGGY]  hdrMap    =    hdrMap  ;  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  [BUGGY]  hdrMap=hdrMap  ;    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  for  (  int  i  =  0;  i  <  header.length;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  2;  i  <  header.length;  i++)  {  [CONTEXT]  private  Map<String,  Integer>  initializeHeader(CSVFormat  format)  throws  IOException  {  Map<String,  Integer>  hdrMap  =  null;  if  (format.getHeader()  !=  null)  {  hdrMap  =  new  HashMap<String,  Integer>();    String[]  header  =  null;  if  (format.getHeader().length  ==  0)  {      CSVRecord  rec  =  getRecord();  if  (rec  !=  null)  {  header  =  rec.values();  }  }  else  {  header  =  format.getHeader();  }        if  (header  !=  null)  {  [BUGGY]  for(  int  i  =  2;  i  <  header.length;  i++  ){  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }        [CLASS]  CSVParser  1    [METHOD]  initializeHeader  [RETURN_TYPE]  Map      CSVFormat  format  [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    rec    result    CSVFormat    format    String[]    header    Map    hdrMap    headerMapping    int    i    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  !=  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  current  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  result  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  true)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  current  ==  true  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  header  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  rec  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if(  next  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  current  =  getNextRecord();  [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {    current  =  getNextRecord();      return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {          return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  rec  !=  null)  {          header  =  rec.values(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  1(  );  [CONTEXT]  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  1  ()  ;  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current    =    current  ;  [CONTEXT]  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=current  ;  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  getNextRecord(  );current  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  getNextRecord();    }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  );current  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  );current  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  result  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  false)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  ==  false  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  header  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  current  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  rec  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {        throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};        }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {            }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  result  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  true)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  true  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  header  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  current  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  rec  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");    }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {        }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          next  =  getNextRecord(  );          if  (  next  ==  null)  {                  throw  new  NoSuchElementException(   "No  more  CSV  records  available ");          }  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  return  0;  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;throw  new  NoSuchElementException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")    ;throw  new  NoSuchElementException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")    ;throw  new  NoSuchElementException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  1(  );  [CONTEXT]    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  =  1  ()  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next    =    next  ;  [CONTEXT]    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next=next  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  getNextRecord(  );next  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  =  getNextRecord();    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  );next  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  );next  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  this)  {  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  this  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;  ;  [CONTEXT]  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException( "   ");  ;  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]  return  toString(  );  [CONTEXT]  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  toString  ()  ;  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }                          [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  getRecord();    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }                      [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  null;	[BUG]  [BUGGY]  current  =  this;  [CONTEXT]      public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  this;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  null;	[BUG]  [BUGGY]  result  =  null;current  =  null;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  current  =  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next    =  null  ;  [CONTEXT]    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next=  null  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  new  Iterator<CSVRecord>  (  )  {	[BUG]  [BUGGY]  return  new  Iterator;  [CONTEXT]      if  (header  !=  null)  {  for  (int  i  =  0;  i  <  header.length;  i++)  {  hdrMap.put(header[i],  Integer.valueOf(i));  }  }  }  return  hdrMap;  }                    public  Iterator<CSVRecord>  iterator()  {  [BUGGY]  return  new  Iterator;  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  current  ==  null;  [CONTEXT]  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ==  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  result  !=  null;  [CONTEXT]  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  result  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  result  ;  [CONTEXT]  }                    public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  result  ;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  next;	[BUG]  [BUGGY]  return  result;  [CONTEXT]  return  current  !=  null;  }    public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    [BUGGY]  return  result;  }    private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }    public  void  remove()  {  throw  new  UnsupportedOperationException();  }  };  }        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  CSVRecord  next  =  current;	[BUG]  [BUGGY]  CSVRecord  next  =  result;  [CONTEXT]          public  Iterator<CSVRecord>  iterator()  {  return  new  Iterator<CSVRecord>()  {  private  CSVRecord  current;    public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    return  current  !=  null;  }    public  CSVRecord  next()  {  [BUGGY]  CSVRecord  next  =  result;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }    private  CSVRecord  getNextRecord()  {  try  {        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  CSVRecord  next  =  current;	[BUG]  [BUGGY]  CSVRecord  rec;CSVRecord  next  =  current;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;throw  new  RuntimeException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")    ;throw  new  RuntimeException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")    ;throw  new  RuntimeException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")    ;throw  new  UnsupportedOperationException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")    ;throw  new  UnsupportedOperationException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")    ;throw  new  UnsupportedOperationException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  current  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  result  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  true)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  current  ==  true  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  header  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  rec  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  next  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  current  =  getNextRecord();  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {    current  =  getNextRecord();      return  current  !=  null;        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {          return  current  !=  null;        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  rec  !=  null)  {          header  =  rec.values(  );  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  1(  );  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  1  ()  ;  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current    =    current  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=current  ;  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  getNextRecord(  );current  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  getNextRecord();    }    return  current  !=  null;        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  );current  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  );current  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current    =  null  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=  null  ;  }    return  current  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  current  ==  null;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ==  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  result  !=  null;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  result  !=  null;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  returnresult  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  returnresult  ;  }        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  CSVRecord  next  =  current;	[BUG]  [BUGGY]  CSVRecord  next  =  result;  [CONTEXT]  public  CSVRecord  next()  {  [BUGGY]  CSVRecord  next  =  result;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  CSVRecord  next  =  current;	[BUG]  [BUGGY]  CSVRecord  rec;CSVRecord  next  =  current;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  null;	[BUG]  [BUGGY]  current  =  this;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  this;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  null;	[BUG]  [BUGGY]  result  =  null;current  =  null;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  current  =  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  result  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  false)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  ==  false  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  header  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  current  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  rec  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {        throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};        }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {            }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  result  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  result  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  false)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  false  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  header  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  header  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  current  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  rec  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  rec  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");    }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {        }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          next  =  getNextRecord(  );          if  (  next  ==  null)  {                  throw  new  NoSuchElementException(   "No  more  CSV  records  available ");          }  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;throw  new  NoSuchElementException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")    ;throw  new  NoSuchElementException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")    ;throw  new  NoSuchElementException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  1(  );  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  =  1  ()  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  getNextRecord(  );next  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  =  getNextRecord();    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  CSVRecord  rec  =  getRecord(  );next  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  );next  =  getNextRecord(  );  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  true)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  true  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException( "   ");  ;  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next    =    next  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next=next  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  return  next;	[BUG]  [BUGGY]  return  result;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    [BUGGY]  return  result;  }        [CLASS]  CSVParser  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]  return  toString(  );  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  toString  ()  ;  }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }  }        [CLASS]  CSVParser  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  getRecord();    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }        [CLASS]  CSVParser  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;  ;  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  UnsupportedOperationException( "   ");  ;  }  }        [CLASS]  CSVParser  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;throw  new  RuntimeException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")    ;throw  new  RuntimeException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")    ;throw  new  RuntimeException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  Lexer    lexer    boolean    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    IOException    e    Map    hdrMap    headerMapping    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")    ;throw  new  UnsupportedOperationException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  IOException  ( "   ")    ;throw  new  UnsupportedOperationException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")    ;throw  new  UnsupportedOperationException  ( "   ")    ;  [CONTEXT]        [CLASS]  CSVParser  1    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  return  lexer.getLineNumber  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  int  getLineNumber()  {  [BUGGY]  return  lexer.getLineNumber();          [CLASS]  CSVParser  1    [METHOD]  getLineNumber  [RETURN_TYPE]  int      [VARIABLES]  Lexer    lexer    List    record    records    Token    reusableToken    CSVRecord    current    next    rec    result    boolean    Map    hdrMap    headerMapping    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  !=  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  current  !=  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  true)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  current  ==  true  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  if  (  current  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  null)  {  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if(  next  ==  null  ){  current  =  getNextRecord();  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]  current  =  getNextRecord();  [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {    current  =  getNextRecord();      return  current  !=  null;        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  if  (  current  ==  null  )  {  current  =  getNextRecord  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  [BUGGY]  if  (current  ==  null)  {          return  current  !=  null;        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current    =    current  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current=current  ;  }    return  current  !=  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  =  getNextRecord(  );current  =  getNextRecord(  );  [CONTEXT]        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  [BUGGY]  current  =  getNextRecord();    }    return  current  !=  null;        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  current  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  );current  =  getNextRecord(  );  [CONTEXT]        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  current  ==  null;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ==  null;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  return  current  ;  [CONTEXT]  public  boolean  hasNext()  {  if  (current  ==  null)  {  current  =  getNextRecord();  }    [BUGGY]  return  current  ;  }        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  return  current  !=  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  return  current  !=  null;  }  [CONTEXT]        [CLASS]  1    [METHOD]  hasNext  [RETURN_TYPE]  boolean      [VARIABLES]  CSVRecord    current    boolean    
[PATCH]  current  =  null;	[BUG]  [BUGGY]  current  =  true;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  [BUGGY]  current  =  true;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  current  =  null;	[BUG]  [BUGGY]  if  (  current  ==  null)  {  current  =  null;  }  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  !=  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  current  ==  null  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  true)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if(  next  ==  true  ){      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  next  =  getNextRecord();  if(next  ==  null)  {        throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {    next  =  getNextRecord();  if  (next  ==  null)  {throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");};        }  }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {  next  =  getNextRecord  (  )  ;  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    [BUGGY]  if  (next  ==  null)  {            }  }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  !=  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  !=  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  null)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  current  ==  null  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  next  ==  true)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  next  ==  true  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {    throw  new  java.util.NoSuchElementException( "No  more  CSV  records  available ");    }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {  throw  new  NoSuchElementException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if  (next  ==  null)  {        }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          next  =  getNextRecord(  );          if  (  next  ==  null)  {                  throw  new  NoSuchElementException(   "No  more  CSV  records  available ");          }  }  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  next  ==  null)  {          throw  new  NoSuchElementException(   "No  more  CSV  records  available ");  }  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;throw  new  NoSuchElementException  ( "   ")    ;  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")    ;throw  new  NoSuchElementException  ( "   ")    ;  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next    =  null  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next=  null  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  current  =  getNextRecord(  );next  =  getNextRecord(  );  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  =  getNextRecord();    if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  return  getRecord(  );next  =  getNextRecord(  );  [CONTEXT]        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  if  (  next  ==  null  )  {	[BUG]  [BUGGY]  if  (  current  ==  false)  {  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  [BUGGY]  if(  current  ==  false  ){  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  throw  new  NoSuchElementException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  [BUGGY]  throw  new  UnsupportedOperationException( "   ");  ;  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  next  =  getNextRecord  (  )  ;	[BUG]  [BUGGY]  next  ;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      [BUGGY]  next  ;  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    return  next;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  return  next;	[BUG]  [BUGGY]  return  current;  [CONTEXT]  public  CSVRecord  next()  {  CSVRecord  next  =  current;  current  =  null;    if  (next  ==  null)  {      next  =  getNextRecord();  if  (next  ==  null)  {  throw  new  NoSuchElementException( "No  more  CSV  records  available ");  }  }    [BUGGY]  return  current;  }        [CLASS]  1    [METHOD]  next  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  return  getRecord  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  [BUGGY]  return  getRecord();    }  catch  (IOException  e)  {  throw  new  RuntimeException(e);  }        [CLASS]  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    IOException    e    boolean    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;  ;  [CONTEXT]  private  CSVRecord  getNextRecord()  {  try  {  return  getRecord();  }  catch  (IOException  e)  {  [BUGGY]  throw  new  UnsupportedOperationException( "   ");  ;  }  }        [CLASS]  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    IOException    e    boolean    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  UnsupportedOperationException  ( "   ")    ;throw  new  RuntimeException  ( "   ")    ;  [CONTEXT]        [CLASS]  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    IOException    e    boolean    
[PATCH]  throw  new  RuntimeException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")    ;throw  new  RuntimeException  ( "   ")    ;  [CONTEXT]        [CLASS]  1    [METHOD]  getNextRecord  [RETURN_TYPE]  CSVRecord      [VARIABLES]  CSVRecord    current    next    IOException    e    boolean    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  public  void  remove()  {  [BUGGY]  return  ;  }        [CLASS]  1    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  RuntimeException  ( "   ")    ;throw  new  UnsupportedOperationException  ( "   ")    ;  [CONTEXT]        [CLASS]  1    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  throw  new  UnsupportedOperationException  ( "   ")  ;	[BUG]  [BUGGY]  throw  new  NoSuchElementException  ( "   ")    ;throw  new  UnsupportedOperationException  ( "   ")    ;  [CONTEXT]        [CLASS]  1    [METHOD]  remove  [RETURN_TYPE]  void      [VARIABLES]  CSVRecord    current    next    boolean    
[PATCH]  super  (  format,  in  )  ;	[BUG]  [BUGGY]  super(    in);  [CONTEXT]  public  CSVLexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  super  (in  )  ;  }        [CLASS]  CSVLexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  boolean    ExtendedBufferedReader    in    CSVFormat    format    
[PATCH]  super  (  format,  in  )  ;	[BUG]  [BUGGY]  super(  format);  [CONTEXT]  public  CSVLexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  super  (  format  )  ;  }        [CLASS]  CSVLexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  boolean    ExtendedBufferedReader    in    CSVFormat    format    
[PATCH]  super  (  format,  in  )  ;	[BUG]  [BUGGY]  super(  in,  format);  [CONTEXT]  public  CSVLexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  super  (  in,  format  )  ;  }        [CLASS]  CSVLexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  boolean    ExtendedBufferedReader    in    CSVFormat    format    
[PATCH]  super  (  format,  in  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVLexer(CSVFormat  format,  ExtendedBufferedReader  in)  {  [BUGGY]  super(format,  in);          [CLASS]  CSVLexer    [METHOD]  <init>  [RETURN_TYPE]  ExtendedBufferedReader)      CSVFormat  format  ExtendedBufferedReader  in  [VARIABLES]  boolean    ExtendedBufferedReader    in    CSVFormat    format    
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  short    lastChar  =  in.readAgain(  );  [CONTEXT]  }                                        @Override  Token  nextToken(Token  tkn)  throws  IOException  {        [BUGGY]  shortlastChar  =  in.readAgain  ()  ;                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readLine(  );  [CONTEXT]  }                                        @Override  Token  nextToken(Token  tkn)  throws  IOException  {        [BUGGY]  int  lastChar  =  in.readLine  ()  ;                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );int  lastChar  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }                                        @Override  Token  nextToken(Token  tkn)  throws  IOException  {        [BUGGY]  int  lastChar  =  in.readAgain();                          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );int  lastChar  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  lastChar  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  );int  lastChar  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  short    c  =  in.read(  );  [CONTEXT]                  @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        [BUGGY]  shortc  =  in.read  ()  ;  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.readLine(  );  [CONTEXT]                  @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        [BUGGY]  int  c  =  in.readLine  ()  ;  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );int  c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  c  =  in.read  (  )  ;  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]                  @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        [BUGGY]  int  c  =  in.read();      c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );int  c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  );int  c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  int  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );int  c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  boolean  eol  =  isEndOfLine(  lastChar);  [CONTEXT]              @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  [BUGGY]  boolean  eol  =  isEndOfLine  (  lastChar  )  ;  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  boolean  eol  =  isEndOfFile(  c);  [CONTEXT]              @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  [BUGGY]  boolean  eol  =  isEndOfFile  (  c  )  ;  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  boolean  eol  =  isEndOfFile(  lastChar);  [CONTEXT]              @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  [BUGGY]  boolean  eol  =  isEndOfFile  (  lastChar  )  ;  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  boolean  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]              @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  [BUGGY]  boolean  eol  =  isEndOfLine(c);    c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readLine  ()  ;        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  c=c  ;        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  c);c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]          @Override  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readAgain();          if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  ||  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  ||(  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  &&  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  lastChar  ==  '\n'  &&  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  <=  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  lastChar  <=  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  >=  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  lastChar  ==  '\n'  ||  lastChar  >=  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  <=  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  <=  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  1)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  1  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  lastChar  &&  (  eol  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  lastChar  &&(  eol  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfLine(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfLine  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar))  {  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if(  isEndOfFile  (  lastChar  )){  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  c))  {  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if(  isEndOfLine  (  c  )){  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  lastChar))  {  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if(  isEndOfLine  (  lastChar  )){  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c))  {  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if(  isEscape  (  c  )){  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  tkn.type  =  EOF;  return  tkn;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  return  tkn;                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]    [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if  (isEndOfFile(c))  {                    [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEndOfFile(  c))  {          tkn.type  =  EOF;          tkn.isReady  =  true;  }else  {          simpleTokenLexer(  tkn,  c);  }  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  [BUGGY]  tkn.type=tkn.type  ;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  lastChar  =  c;	[BUG]  [BUGGY]  lastChar  =  lastChar;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      [BUGGY]  lastChar  =  lastChar;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  lastChar  =  c;	[BUG]  [BUGGY]  lastChar  =    null;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      [BUGGY]  lastChar  =null;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.read(  );  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  =  null.read  ()  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  =  in.readLine  ()  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c=  null  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  lastChar);  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine  (  lastChar  )  ;  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  c);  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile  (  c  )  ;  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );eol  =  isEndOfLine(  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readLine  ()  ;      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c=  null  ;      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  c);c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  0;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  0;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  ;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.readLine(  );  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  =  null.readLine  ()  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  =  in.read();    eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(c);    c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readAgain();        if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  ((eol  &&((lastChar  ==  '\n')  ||(lastChar  ==  '\r'))  ||(lastChar  ==  ExtendedBufferedReader.UNDEFINED)))  {  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        [BUGGY]  if(  (eol  &&  ((lastChar  ==  '\n')  ||  (lastChar  ==  '\r'))  ||  (lastChar  ==  ExtendedBufferedReader.UNDEFINED))  ){  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  (((lastChar  ==  '\n')  ||(lastChar  ==  '\r')  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED))  {  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        [BUGGY]  if(  ((lastChar  ==  '\n')  ||  (lastChar  ==  '\r')  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  ){  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  ((lastChar  ==  '\n'  ||  lastChar  ==  '\r'))  {  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        [BUGGY]  if(  (lastChar  ==  '\n'  ||  lastChar  ==  '\r')  ){  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  (  lastChar  ==  '\n')  {  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        [BUGGY]  if(  lastChar  ==  '\n'  ){  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  (  lastChar  ==  '\r')  {  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        [BUGGY]  if(  lastChar  ==  '\r'  ){  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  emptyLinesIgnored  )  {	[BUG]  [BUGGY]  if  (  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  {  [CONTEXT]  Token  nextToken(Token  tkn)  throws  IOException  {        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        [BUGGY]  if(  lastChar  ==  ExtendedBufferedReader.UNDEFINED  ){  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  !=  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  lastChar  !=  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  !=  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  lastChar  ==  '\n'  ||  lastChar  !=  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  eol  &&  (  lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  while  (  eol  &&  (  c  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)&&  !isEndOfFile(  lastChar))  {  [CONTEXT]        int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  [BUGGY]  while(  eol  &&(  c  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED  )  &&  !isEndOfFile  (  lastChar  )){          lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c=c  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  ;      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  =  in.read();      c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  lastChar);  [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile  (  lastChar  )  ;  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(c);          if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar))  {  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if(  isEndOfFile  (  lastChar  )){  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  c))  {  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if(  isEndOfLine  (  c  )){  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c))  {  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if(  isEscape  (  c  )){  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  tkn.type  =  EOF;  return  tkn;  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if  (isEndOfFile(c))  {    tkn.type  =  EOF;  return  tkn;          }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]    [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if  (isEndOfFile(c))  {              }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEndOfFile(  c))  {          tkn.type  =  EOF;          tkn.isReady  =  true;  }else  {          simpleTokenLexer(  tkn,  c);  }  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  ;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  lastChar  =  c;	[BUG]  [BUGGY]  lastChar  =  lastChar;  [CONTEXT]                      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      [BUGGY]  lastChar  =  lastChar;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  lastChar  =  c;	[BUG]  [BUGGY]  lastChar  =    null;  [CONTEXT]                      int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      [BUGGY]  lastChar  =null;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]                  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  =  in.readLine  ()  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]                  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  c);  [CONTEXT]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile  (  c  )  ;  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =    isEndOfLine(  lastChar);  [CONTEXT]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =isEndOfLine  (  lastChar  )  ;  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );eol  =  isEndOfLine(  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readLine  ()  ;      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  ;      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  c);c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  [BUGGY]  tkn.type=tkn.type  ;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  &&  !isEndOfFile(  c))  {  [CONTEXT]  int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  [BUGGY]  &&  !isEndOfFile  (  c  )){      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  &&  !isEndOfLine(  lastChar))  {  [CONTEXT]  int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  [BUGGY]  &&  !isEndOfLine  (  lastChar  )){      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  &&  !isEndOfFile  (  lastChar  )  )  {	[BUG]  [BUGGY]  &&  !isEndOfLine(  c))  {  [CONTEXT]  int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  [BUGGY]  &&  !isEndOfLine  (  c  )){      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  &&  !isEndOfFile  (  lastChar  )  )  {  lastChar  =  c;	[BUG]  [BUGGY]    [CONTEXT]  int  lastChar  =  in.readAgain();                        int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  [BUGGY]  &&  !isEndOfFile(lastChar))  {        c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  );  [CONTEXT]                  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  =  this.read  ()  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]                  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c  =  in.read();    eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(c);          if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  c  =  0.readAgain(  );  [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  0.readAgain  ()  ;      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]          int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  [BUGGY]  c  =  in.readAgain();        if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.readAgain  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.readAgain(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]                  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  [BUGGY]  c=  null  ;  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]              int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(c);    c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  lastChar))  {  [CONTEXT]  int  c  =  in.read();  boolean  eol  =  isEndOfLine(c);  c  =  in.readAgain();        if  (emptyLinesIgnored)  {  while  (eol  &&  (lastChar  ==  '\n'  ||  lastChar  ==  '\r'  ||  lastChar  ==  ExtendedBufferedReader.UNDEFINED)  &&  !isEndOfFile(lastChar))  {      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      [BUGGY]  if(  isEndOfLine  (  lastChar  )){  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  &&  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  isEndOfFile  (  lastChar  )&&(  !isDelimiter  (  lastChar  )&&  isEndOfFile  (  c  ))){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isDelimiter(  lastChar)  ||  isEndOfFile(  c)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  isEndOfFile  (  lastChar  )||(  !isDelimiter  (  lastChar  )||  isEndOfFile  (  c  ))){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  isEndOfFile  (  c  )||(  !isDelimiter  (  lastChar  )&&  isEndOfFile  (  c  ))){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  lastChar)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  isEndOfFile  (  lastChar  )||(  !isDelimiter  (  lastChar  )&&  isEndOfFile  (  lastChar  ))){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  c)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  lastChar)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  isEndOfFile  (  c  )||(  !isDelimiter  (  lastChar  )&&  isEndOfFile  (  lastChar  ))){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)){  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  isEndOfFile  (  lastChar  ))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (    (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  (  !isDelimiter  (  lastChar  )&&  isEndOfFile  (  c  ))){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  !(isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  !(isDelimiter(lastChar)  &&  isEndOfFile(c))  ){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  lastChar)  ||  (  !isDelimiter(  lastChar)  &&  isEndOfFile(  c)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  isEndOfLine  (  lastChar  )||(  !isDelimiter  (  lastChar  )&&  isEndOfFile  (  c  ))){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  lastChar)  ||  (  !isEscape(  lastChar)  &&  isEndOfFile(  c)))  {  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if(  isEndOfFile  (  lastChar  )||(  !isEscape  (  lastChar  )&&  isEndOfFile  (  c  ))){  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]  tkn.type  =  EOF;  return  tkn;  [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {    tkn.type  =  EOF;  return  tkn;                while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isEndOfFile  (  lastChar  )  ||  (  !isDelimiter  (  lastChar  )  &&  isEndOfFile  (  c  )  )  )  {  tkn.type  =  EOF;  return  tkn;  }	[BUG]  [BUGGY]    [CONTEXT]      lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        [BUGGY]  if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {                    while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  [BUGGY]  tkn.type=  null  ;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  lastChar  =  c;  c  =  in.read();  eol  =  isEndOfLine(c);  c  =  in.readAgain();      if  (isEndOfFile(c))  {  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  [BUGGY]  tkn.type  ;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  tkn.type  ==  INVALID  )  {	[BUG]  [BUGGY]  while  (  tkn.type  >=  INVALID)  {  [CONTEXT]  tkn.type  =  EOF;      return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        [BUGGY]  while(  tkn.type  >=  INVALID  ){      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUG]  [BUGGY]  while  (  isWhitespace(  c)  ||  !eol)  {  [CONTEXT]  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  [BUGGY]  while(  isWhitespace  (  c  )||  !eol  ){  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUG]  [BUGGY]  while  (  isWhitespace(  lastChar)  &&  !eol)  {  [CONTEXT]  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  [BUGGY]  while(  isWhitespace  (  lastChar  )&&  !eol  ){  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUG]  [BUGGY]  while  (  isEscape(  c)  &&  !eol)  {  [CONTEXT]  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  [BUGGY]  while(  isEscape  (  c  )&&  !eol  ){  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  surroundingSpacesIgnored)  {          while  (  (  isWhitespace(  c))  &&  (  !eol))  {                  c  =  in.read(  );                  eol  =  isEndOfLine(  c);          }    }  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  in.readLine  ()  ;  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c=c  ;  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  lastChar);  [CONTEXT]  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine  (  lastChar  )  ;  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  c);  [CONTEXT]  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile  (  c  )  ;  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );eol  =  isEndOfLine(  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  in.read();    eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =  isEndOfLine(c);    }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in.read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }	[BUG]  [BUGGY]  while((isWhitespace(c))  &&(!eol))  {        c  =  in.read();        eol  =  isEndOfLine(c);}  ;  [CONTEXT]  return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      [BUGGY]  if  (surroundingSpacesIgnored)  {    while  ((isWhitespace(c))  &&  (!eol))  {c  =  in.read();eol  =  isEndOfLine(c);}  ;        }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  surroundingSpacesIgnored  )  {  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in.read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  return  tkn;  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      [BUGGY]  if  (surroundingSpacesIgnored)  {            }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  in.read();      }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfFile(  lastChar);  [CONTEXT]  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =  isEndOfFile  (  lastChar  )  ;  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c=  null  ;  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  [BUGGY]  while  (isWhitespace(c)  &&  !eol)  {      eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isCommentStart(  lastChar))  {  [CONTEXT]      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [BUGGY]  if(  isCommentStart  (  lastChar  )){      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isWhitespace(  c))  {  [CONTEXT]      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [BUGGY]  if(  isWhitespace  (  c  )){      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c))  {  [CONTEXT]      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [BUGGY]  if(  isEscape  (  c  )){      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isDelimiter(  c))  {  [CONTEXT]      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [BUGGY]  if(  isDelimiter  (  c  )){      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  c))  {  [CONTEXT]      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [BUGGY]  if(  isEndOfLine  (  c  )){      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  c))  {  [CONTEXT]      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [BUGGY]  if(  isEndOfFile  (  c  )){      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  lastChar))  {  [CONTEXT]      while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  [BUGGY]  }  else  if(  isDelimiter  (  lastChar  )){      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]      while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  [BUGGY]  }  else  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c))  {  [CONTEXT]      while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  [BUGGY]  }  else  if(  isEscape  (  c  )){      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c))  {  [CONTEXT]      while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  [BUGGY]  }  else  if(  isEndOfFile  (  c  )){      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  eol  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  [BUGGY]  }  else  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEncapsulator(  lastChar))  {  [CONTEXT]  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  [BUGGY]  }  else  if(  isEncapsulator  (  lastChar  )){      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  [BUGGY]  }  else  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEncapsulator(  lastChar))  {  [CONTEXT]  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  [BUGGY]  }if(  isEncapsulator  (  lastChar  )){      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  [BUGGY]  }  else  if(  isDelimiter  (  c  )){      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c))  {  [CONTEXT]  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  [BUGGY]  }  else  if(  isEndOfFile  (  c  )){      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c))  {  [CONTEXT]  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  [BUGGY]  }  else  if(  isEscape  (  c  )){      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isWhitespace(  c))  {  [CONTEXT]  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  [BUGGY]  }  else  if(  !isWhitespace  (  c  )){      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  lastChar))  {  [CONTEXT]      if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  if(  isEndOfFile  (  lastChar  )){          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]      if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]      if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]      if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  if(  isDelimiter  (  c  )){          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEndOfFile(  c))  {          tkn.type  =  EOF;          return  tkn;  }  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  isEncapsulator(  c))  {          encapsulatedTokenLexer(  tkn,  c);  }else          if  (  isEndOfFile(  c))  {                  tkn.type  =  EOF;                  tkn.isReady  =  true;          }else  {                  simpleTokenLexer(  tkn,  c);          }  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  lastChar);  [CONTEXT]  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer  (  tkn,  lastChar  )  ;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(    c);  [CONTEXT]  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer  (c  )  ;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn);  [CONTEXT]  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer  (  tkn  )  ;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  c,  tkn);  [CONTEXT]  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer  (  c,  tkn  )  ;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  c);  [CONTEXT]  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  encapsulatedTokenLexer  (  tkn,  c  )  ;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer(tkn,  c);          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  c);simpleTokenLexer(  tkn,  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          [BUGGY]  tkn.type=tkn.type  ;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.isReady  =  false;  [CONTEXT]  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  false;  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  lastChar))  {  [CONTEXT]      if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }  else  if(  isEndOfLine  (  lastChar  )){          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  lastChar);  [CONTEXT]  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer  (  tkn,  lastChar  )  ;  }  }  return  tkn;  }                                                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(    c);  [CONTEXT]  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer  (c  )  ;  }  }  return  tkn;  }                                                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn);  [CONTEXT]  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer  (  tkn  )  ;  }  }  return  tkn;  }                                                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  c,  tkn);  [CONTEXT]  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer  (  c,  tkn  )  ;  }  }  return  tkn;  }                                                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  c);  [CONTEXT]  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  encapsulatedTokenLexer  (  tkn,  c  )  ;  }  }  return  tkn;  }                                                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  simpleTokenLexer(tkn,  c);    }  }  return  tkn;  }                                              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  c);simpleTokenLexer(  tkn,  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar);  [CONTEXT]        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      [BUGGY]  encapsulatedTokenLexer  (  tkn,  lastChar  )  ;  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(    c);  [CONTEXT]        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      [BUGGY]  encapsulatedTokenLexer  (c  )  ;  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn);  [CONTEXT]        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      [BUGGY]  encapsulatedTokenLexer  (  tkn  )  ;  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  c,  tkn);  [CONTEXT]        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      [BUGGY]  encapsulatedTokenLexer  (  c,  tkn  )  ;  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  c);  [CONTEXT]        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      [BUGGY]  simpleTokenLexer  (  tkn,  c  )  ;  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  lastChar);  [CONTEXT]        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      [BUGGY]  simpleTokenLexer  (  tkn,  lastChar  )  ;  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      [BUGGY]  encapsulatedTokenLexer(tkn,  c);    }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }          [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  encapsulatedTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  simpleTokenLexer(  tkn,  c);encapsulatedTokenLexer(  tkn,  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          [BUGGY]  tkn.type=tkn.type  ;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfFile(  lastChar))  {  [CONTEXT]      if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }if(  isEndOfFile  (  lastChar  )){          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  this;  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          [BUGGY]  tkn.type  =  this;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          [BUGGY]  tkn.type=  null  ;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar);  [CONTEXT]  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  encapsulatedTokenLexer  (  tkn,  lastChar  )  ;  }        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          [BUGGY]  tkn.type  ;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      [BUGGY]  tkn.type  ;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  eol  )  {	[BUG]  [BUGGY]  }    if  (  eol)  {  [CONTEXT]  if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  [BUGGY]  }if(  eol  ){          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  simpleTokenLexer  (  tkn,  c  )  ;	[BUG]  [BUGGY]  encapsulatedTokenLexer(  tkn,  lastChar);  [CONTEXT]  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          [BUGGY]  encapsulatedTokenLexer  (  tkn,  lastChar  )  ;  }  }  return  tkn;  }                                                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          [BUGGY]  tkn.type=  null  ;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  2;  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          [BUGGY]  tkn.type  =  2;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  1;  [CONTEXT]      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      [BUGGY]  tkn.type  =  1;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      [BUGGY]  tkn.type=  null  ;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn  =  nextToken  (  tkn.reset  (  )  )  ;	[BUG]  [BUGGY]  tkn  =    nextToken(  null.reset(  ));  [CONTEXT]        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  [BUGGY]  tkn  =nextToken  (  null.reset  ())  ;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  in.readAgain(  );  [CONTEXT]  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      [BUGGY]  in.readAgain  ()  ;  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      [BUGGY]  in.readLine();    tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );in.readLine(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );in.readLine(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  eol  =  isEndOfLine(  c);in.readLine(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  in.readLine  (  )  ;	[BUG]  [BUGGY]  c  =  in.read(  );in.readLine(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn  =  nextToken  (  tkn.reset  (  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  [BUGGY]  tkn  =  nextToken(tkn.reset());    }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  lastChar))  {  [CONTEXT]      if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }if(  isEndOfLine  (  lastChar  )){          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          [BUGGY]  tkn.type  ;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      [BUGGY]  tkn.type=tkn.type  ;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  );  [CONTEXT]  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  this.read  ()  ;  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  if  (  isCommentStart  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isWhitespace(  lastChar))  {  [CONTEXT]      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        [BUGGY]  if(  isWhitespace  (  lastChar  )){      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  4.read(  );  [CONTEXT]  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  4.read  ()  ;  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  eol  =  isEndOfLine  (  c  )  ;	[BUG]  [BUGGY]  eol  =    isEndOfLine(  null);  [CONTEXT]  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  [BUGGY]  eol  =isEndOfLine  (  null  )  ;  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  isWhitespace  (  c  )  &&  !eol  )  {	[BUG]  [BUGGY]  while  (  isEscape(  lastChar)  &&  !eol)  {  [CONTEXT]  }  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  [BUGGY]  while(  isEscape  (  lastChar  )&&  !eol  ){  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {            [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.read(  );  [CONTEXT]  }  }        if  (isEndOfFile(lastChar)  ||  (!isDelimiter(lastChar)  &&  isEndOfFile(c)))  {  tkn.type  =  EOF;      return  tkn;  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  [BUGGY]  c  =  null.read  ()  ;  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  4;  [CONTEXT]  in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {          [BUGGY]  tkn.type  =  4;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                              [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  in.readLine  (  )  ;  tkn  =  nextToken  (  tkn.reset  (  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }        while  (tkn.type  ==  INVALID)  {      if  (surroundingSpacesIgnored)  {  while  (isWhitespace(c)  &&  !eol)  {  c  =  in.read();  eol  =  isEndOfLine(c);  }  }        if  (isCommentStart(c))  {      [BUGGY]  in.readLine();      }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  }  else  if  (isEndOfFile(c))  {                [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  c))  {  [CONTEXT]      if  (isCommentStart(c))  {      in.readLine();  tkn  =  nextToken(tkn.reset());  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  }  else  if  (eol)  {          tkn.type  =  EORECORD;  }  else  if  (isEncapsulator(c))  {      encapsulatedTokenLexer(tkn,  c);  [BUGGY]  }if(  isEndOfLine  (  c  )){          tkn.type  =  EOF;  tkn.isReady  =  true;  //  there  is  data  at  EOF  }  else  {          simpleTokenLexer(tkn,  c);  }  }  return  tkn;  }                  [CLASS]  CSVLexer    [METHOD]  nextToken  [RETURN_TYPE]  Token      Token  tkn  [VARIABLES]  boolean    eol    Token    tkn    int    c    lastChar    
[PATCH]  while  (  true  )  {	[BUG]  [BUGGY]  while  (  false)  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  [BUGGY]  while(  false  ){  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfFile(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  [BUGGY]  if(  isEndOfFile  (  c  )){      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  [BUGGY]  if(  isEscape  (  c  )){      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  [BUGGY]  }  else  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  [BUGGY]  }  else  if(  isDelimiter  (  c  )){      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  [BUGGY]  }  else  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  [BUGGY]  }  else  if(  isEscape  (  c  )){      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEscape(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  [BUGGY]  }if(  isEscape  (  c  )){      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  [BUGGY]  }  else  if(  isEndOfFile  (  c  )){      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  [BUGGY]  }  else  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  readEscape(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  [BUGGY]  }  else  if(  readEscape  (  c  )){  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  readEscape(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  [BUGGY]  }if(  readEscape  (  c  )){  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn.content.append  (  (  char  )  c  )  ;  }	[BUG]  [BUGGY]  tkn.content.append(((char)(readEscape(c))));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  [BUGGY]  }  else  if  (isEscape(c))  {    tkn.content.append(((char)  (readEscape(c))));          c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEscape  (  c  )  )  {  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;  }  else  {  tkn.content.append  (  (  char  )  c  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  [BUGGY]  }  else  if  (isEscape(c))  {              c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  [BUGGY]  tkn.content.append((char)  c);          [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c));tkn.content.append(  (  char)  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  isEscape(  c));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  [BUGGY]  tkn.content.append  ((  char  )isEscape  (  c  ))  ;  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  [BUGGY]  tkn.content.append((char)  readEscape(c));    }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  int)  readEscape(  c));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  [BUGGY]  tkn.content.append  ((  int  )readEscape  (  c  ))  ;  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  [BUGGY]  tkn.content.append((char)  c);    }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c));tkn.content.append(  (  char)  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      [BUGGY]  tkn.type=  null  ;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  ;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.isReady  =  false;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  false;  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  3;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      [BUGGY]  tkn.type  =  3;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      [BUGGY]  tkn.type  ;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  String)  readEscape(  c));  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  [BUGGY]  tkn.content.append  ((  String  )readEscape  (  c  ))  ;  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  ;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      [BUGGY]  tkn.type=tkn.type  ;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    [BUGGY]  c  =  in.readLine  ()  ;  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    [BUGGY]  c=c  ;  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  1.read(  );  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    [BUGGY]  c  =  1.read  ()  ;  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    [BUGGY]  c  =  in.read();    }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  c))  {  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  [BUGGY]  }if(  isEndOfLine  (  c  )){      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type=tkn.type  ;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type=  null  ;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  null;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      [BUGGY]  tkn.type  =  null;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    [BUGGY]  c  ;  }    if  (surroundingSpacesIgnored)  {  trimTrailingSpaces(tkn.content);  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn.content  )  ;  }	[BUG]  [BUGGY]  trimTrailingSpaces(tkn.content);  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    [BUGGY]  if  (surroundingSpacesIgnored)  {    trimTrailingSpaces(tkn.content);      return  tkn;        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  if  (  surroundingSpacesIgnored  )  {  trimTrailingSpaces  (  tkn.content  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    [BUGGY]  if  (surroundingSpacesIgnored)  {          return  tkn;        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  trimTrailingSpaces  (  tkn.content  )  ;	[BUG]  [BUGGY]  isEncapsulator(  tkn.content);  [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  [BUGGY]  isEncapsulator  (  tkn.content  )  ;  }    return  tkn;  }        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  trimTrailingSpaces  (  tkn.content  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  Token  simpleTokenLexer(Token  tkn,  int  c)  throws  IOException  {  while  (true)  {  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  break;  }  else  if  (isEndOfFile(c))  {      tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  break;  }  else  if  (isDelimiter(c))  {      tkn.type  =  TOKEN;  break;  }  else  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  {  tkn.content.append((char)  c);  }    c  =  in.read();  }    if  (surroundingSpacesIgnored)  {  [BUGGY]  trimTrailingSpaces(tkn.content);    }    return  tkn;        [CLASS]  CSVLexer    [METHOD]  simpleTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    
[PATCH]  int  startLineNumber  =  getLineNumber  (  )  ;	[BUG]  [BUGGY]  short    startLineNumber  =  getLineNumber(  );  [CONTEXT]                                                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      [BUGGY]  shortstartLineNumber  =  getLineNumber  ()  ;          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  int  startLineNumber  =  getLineNumber  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]                                                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      [BUGGY]  int  startLineNumber  =  getLineNumber();            while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  while  (  true  )  {	[BUG]  [BUGGY]  while  (  false)  {  [CONTEXT]                                          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          [BUGGY]  while(  false  ){  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  while  (  true  )  {	[BUG]  [BUGGY]  while  (  false)  {  [CONTEXT]  int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      [BUGGY]  while(  false  ){  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isDelimiter(  startLineNumber))  {  [CONTEXT]      while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  [BUGGY]  if(  isDelimiter  (  startLineNumber  )){  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]      while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  [BUGGY]  if(   "  (  line   "  +  getLineNumber  ()  ){  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c))  {  [CONTEXT]      while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  [BUGGY]  if(  isEscape  (  c  )){  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(  isEndOfFile  (  startLineNumber  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(   "  (  line   "  +  getLineNumber  ()  ){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(  isDelimiter  (  c  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(  isEndOfLine  (  startLineNumber  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(   "  (  line   "  +  getLineNumber  ()  ){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(  isEndOfFile  (  c  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(  isDelimiter  (  c  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isWhitespace(  startLineNumber))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  !isWhitespace  (  startLineNumber  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(   "  (  line   "  +  getLineNumber  ()  ){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isEscape(  c))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  !isEscape  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  !isWhitespace(  startLineNumber))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }if(  !isWhitespace  (  startLineNumber  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isDelimiter  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isEndOfFile  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isEscape  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEncapsulator(  c))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isEncapsulator  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.io.IOException((( "(line   "  +(getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (!isWhitespace(c))  {    throw  new  java.io.IOException((( "(line   "  +  (getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));      }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (!isWhitespace(c))  {          }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  return  ;  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]    [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");    }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isEscape(  startLineNumber))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  !isEscape  (  startLineNumber  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type=tkn.type  ;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type=tkn.type  ;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.isReady  =  false;  [CONTEXT]  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  false;  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }if(  isEndOfLine  (  startLineNumber  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  ;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  ;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type=tkn.type  ;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  c))  {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }if(  isEndOfLine  (  c  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type=  null  ;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  false;  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  return  false;  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  in.readLine  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c=c  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  0;  [CONTEXT]  while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  0;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  ;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  in.read();    if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(  isEndOfFile  (  startLineNumber  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(   "  (  line   "  +  getLineNumber  ()  ){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ")  {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(   "  (  startline   "  +  startLineNumber  +   "  )EOF  reached  before  encapsulated  token  finished "  ){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  startline   "  +  startLineNumber)  {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(   "  (  startline   "  +  startLineNumber  ){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  readEscape(  c))  {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(  readEscape  (  c  )){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isDelimiter(  c))  {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(  isDelimiter  (  c  )){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEndOfLine(  c))  {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(  isEndOfLine  (  c  )){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isCommentStart(  c))  {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(  isCommentStart  (  c  )){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  startLineNumber))  {  [CONTEXT]      while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  [BUGGY]  if(  isEscape  (  startLineNumber  )){  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(   "  (  line   "  +  getLineNumber  ()  ){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ")  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(   "  (  startline   "  +  startLineNumber  +   "  )EOF  reached  before  encapsulated  token  finished "  ){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber)  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(   "  (  startline   "  +  startLineNumber  ){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  getLineNumber(  c))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(  getLineNumber  (  c  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEncapsulator(  c))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }if(  isEncapsulator  (  c  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(  isDelimiter  (  c  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(  isEndOfFile  (  c  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(  isEscape  (  c  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isWhitespace(  c))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(  !isWhitespace  (  c  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  startline   "  +  startLineNumber)  {  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if(   "  (  startline   "  +  startLineNumber  ){      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if(  isDelimiter  (  c  )){      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !(  isWhitespace(  c)))  {          throw  new  IOException(  (  (   "(  line   "  +  (  getLineNumber(  )))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));  }  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      [BUGGY]  tkn.content.append((char)  c);          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c));tkn.content.append(  (  char)  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [BUGGY]  return  ;  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if(  isEndOfFile  (  startLineNumber  )){      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      [BUGGY]  tkn.content.append((char)  c);    }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c));tkn.content.append(  (  char)  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }if(  isEndOfFile  (  startLineNumber  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type=  null  ;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  return  0;  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  4.read(  );  [CONTEXT]          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  4.read  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(  isEndOfLine  (  startLineNumber  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]                  private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if(   "  (  line   "  +  getLineNumber  ()  ){      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  getLineNumber(  in.lookAhead(  )))  {  [CONTEXT]                  private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if(  getLineNumber  (  in.lookAhead  ())){      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulator(  in.read(  )))  {  [CONTEXT]                  private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if(  isEncapsulator  (  in.read  ())){      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  while  (  true  )  {	[BUG]  [BUGGY]  while  (  false)  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      [BUGGY]  while(  false  ){  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isDelimiter(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  [BUGGY]  if(  isDelimiter  (  startLineNumber  )){  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  [BUGGY]  if(   "  (  line   "  +  getLineNumber  ()  ){  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  [BUGGY]  if(  isEscape  (  c  )){  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(  isEndOfFile  (  startLineNumber  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(   "  (  line   "  +  getLineNumber  ()  ){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(  isDelimiter  (  c  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(  isEndOfLine  (  startLineNumber  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(   "  (  line   "  +  getLineNumber  ()  ){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(  isEndOfFile  (  c  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(  isDelimiter  (  c  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isWhitespace(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  !isWhitespace  (  startLineNumber  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (   "(  line   "  +  getLineNumber(  ))    {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(   "  (  line   "  +  getLineNumber  ()  ){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isEscape(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  !isEscape  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  !isWhitespace(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }if(  !isWhitespace  (  startLineNumber  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isDelimiter(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isDelimiter  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isEndOfFile  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isEndOfLine  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEscape(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isEscape  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEncapsulator(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  isEncapsulator  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.io.IOException((( "(line   "  +(getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (!isWhitespace(c))  {    throw  new  java.io.IOException((( "(line   "  +  (getLineNumber()))  +   ")  invalid  char  between  encapsulated  token  and  delimiter "));      }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {  throw  new  IOException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if  (!isWhitespace(c))  {          }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]    [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");    }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type=  null  ;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EORECORD;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  EORECORD;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  return  ;  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type=tkn.type  ;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  EOF;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.isReady  =  false;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  [BUGGY]  tkn.isReady  =  false;  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.isReady  =  true;	[BUG]  [BUGGY]  tkn.type  =  TOKEN;tkn.isReady  =  true;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }if(  isEndOfFile  (  startLineNumber  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  !isEscape(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }  else  if(  !isEscape  (  startLineNumber  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  ;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  false;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  return  false;  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  ;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  1;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  =  1;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type=tkn.type  ;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }  else  if(  isEndOfFile  (  startLineNumber  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type    =    tkn.type  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type=tkn.type  ;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EORECORD;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  EOF;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.isReady  =  true;tkn.type  =  TOKEN;  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }if(  isEndOfLine  (  c  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  !isEscape(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }if(  !isEscape  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  in.readLine  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c=  null  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  ;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  in.read();    if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }  else  if(  isEndOfLine  (  startLineNumber  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }if(  isEndOfLine  (  startLineNumber  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  4;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  4;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type    =  null  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type=  null  ;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  this;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  this;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c  =  in.readLine  ()  ;  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c=c  ;  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c  =  in.read();      }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  [BUGGY]  tkn.content.append((char)  c);    }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  c  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  readEscape(  c));tkn.content.append(  (  char)  c);  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }if(  isEndOfFile  (  startLineNumber  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfFile(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }if(  isEndOfFile  (  c  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  this;  [CONTEXT]  while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  this;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  this;  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  this;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  null;  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  null;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c  =  in.read();    tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  2.read(  );  [CONTEXT]          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  2.read  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }if(  isEndOfLine  (  startLineNumber  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  !isEscape(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }if(  !isEscape  (  startLineNumber  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  null;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  null;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  true;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  return  true;  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  0.read(  );  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  0.read  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfFile(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }if(  isEndOfFile  (  startLineNumber  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.read(  );  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  null.read  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isDelimiter  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  startLineNumber))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  [BUGGY]  if(  isEscape  (  startLineNumber  )){  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  [BUGGY]  }if(  isEndOfLine  (  startLineNumber  )){  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {            [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  !isEscape(  c))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }if(  !isEscape  (  c  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEncapsulator(  startLineNumber))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }  else  if(  isEncapsulator  (  startLineNumber  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfFile  (  c  )  )  {	[BUG]  [BUGGY]  }  else  if  (  isEndOfLine(  startLineNumber))  {  [CONTEXT]  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  [BUGGY]  }  else  if(  isEndOfLine  (  startLineNumber  )){      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  char)  isEscape(  c));  [CONTEXT]                          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  [BUGGY]  tkn.content.append  ((  char  )isEscape  (  c  ))  ;  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]                          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  [BUGGY]  tkn.content.append((char)  readEscape(c));    }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  int)  readEscape(  c));  [CONTEXT]                          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  [BUGGY]  tkn.content.append  ((  int  )readEscape  (  c  ))  ;  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  startLineNumberhar)  readEscape(  c));  [CONTEXT]                          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  [BUGGY]  tkn.content.append  ((  startLineNumberhar  )readEscape  (  c  ))  ;  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEncapsulator  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  getLineNumber(  c))  {  [CONTEXT]                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  [BUGGY]  }if(  getLineNumber  (  c  )){  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c=  null  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  2;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  =  2;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  0;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  =  0;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c=c  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  return  0;  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  3;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  =  3;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c  ;  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  true;  [CONTEXT]  while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      [BUGGY]  return  true;  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  0;  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  =  0;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  2;  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  =  2;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulator(  2.lookAhead(  )))  {  [CONTEXT]                  private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if(  isEncapsulator  (  2.lookAhead  ())){      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  1.read(  );  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c  =  1.read  ()  ;  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  isEndOfLine  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  isEndOfFile(  c))  {  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  [BUGGY]  }if(  isEndOfFile  (  c  )){      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c=  null  ;  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  );  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c  =  this.read  ()  ;  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null  .readLine(  )  ;  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c  =  null  .readLine  ();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readLine(  );  [CONTEXT]                                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  [BUGGY]  c  =  in.readLine  ()  ;    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]                                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  [BUGGY]  c=  null  ;    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]                                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  [BUGGY]  c  =  in.read();      if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  lastChar  =  in.readAgain(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  int  c  =  in.read(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  in.readLine(  );c  =  in.read(  );  [CONTEXT]        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  isEscape(  startLineNumber))  {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(  isEscape  (  startLineNumber  )){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  );  [CONTEXT]          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  this.read  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  }  else  if  (  !isWhitespace  (  c  )  )  {	[BUG]  [BUGGY]  }    if  (  !isEscape(  startLineNumber))  {  [CONTEXT]  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  [BUGGY]  }if(  !isEscape  (  startLineNumber  )){      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }  }          [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  4;  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  =  4;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  2;  [CONTEXT]  if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  2;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulator(  null.lookAhead(  )))  {  [CONTEXT]                  private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if(  isEncapsulator  (  null.lookAhead  ())){      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  TOKEN;	[BUG]  [BUGGY]  tkn.type  =  1;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  [BUGGY]  tkn.type  =  1;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EOF;	[BUG]  [BUGGY]  tkn.type  =  2;  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  [BUGGY]  tkn.type  =  2;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  2.read(  );  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  2.read  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  null.read(  );  [CONTEXT]          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      [BUGGY]  c  =  null.read  ()  ;  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  startLineNumberhar)  isEscape(  c));  [CONTEXT]                          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  [BUGGY]  tkn.content.append  ((  startLineNumberhar  )isEscape  (  c  ))  ;  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  false;  [CONTEXT]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [BUGGY]  return  false;  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  throw  new  IOException  ( "   ")  ;	[BUG]  [BUGGY]  return  0;  [CONTEXT]  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      [BUGGY]  return  0;  }  else  {      tkn.content.append((char)  c);  }  }  }    }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  =  this.read(  );  [CONTEXT]  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  [BUGGY]  c  =  this.read  ()  ;  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      tkn.type  =  EORECORD;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEncapsulator  (  in.lookAhead  (  )  )  )  {	[BUG]  [BUGGY]  if  (  isEncapsulator(  4.lookAhead(  )))  {  [CONTEXT]                  private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  [BUGGY]  if(  isEncapsulator  (  4.lookAhead  ())){      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  c  =  in.read  (  )  ;	[BUG]  [BUGGY]  c  ;  [CONTEXT]                                      private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  [BUGGY]  c  ;    if  (isEscape(c))  {  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.type  =  EORECORD;	[BUG]  [BUGGY]  tkn.type  =  this;  [CONTEXT]  c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF  return  tkn;  }  else  if  (isEndOfLine(c))  {      [BUGGY]  tkn.type  =  this;  return  tkn;  }  else  if  (!isWhitespace(c))  {      throw  new  IOException( "(line   "  +  getLineNumber()  +   ")  invalid  char  between  encapsulated  token  and  delimiter ");  }  }  }  }  else  if  (isEndOfFile(c))  {      throw  new  IOException( "(startline   "  +  startLineNumber  +   ")  EOF  reached  before  encapsulated  token  finished ");  }  else  {      tkn.content.append((char)  c);  }  }        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  if  (  isEscape  (  c  )  )  {	[BUG]  [BUGGY]  if  (  readEscape(  startLineNumber))  {  [CONTEXT]                              private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    [BUGGY]  if(  readEscape  (  startLineNumber  )){  tkn.content.append((char)  readEscape(c));  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  tkn.content.append  (  (  char  )  readEscape  (  c  )  )  ;	[BUG]  [BUGGY]  tkn.content.append(  (  String)  readEscape(  c));  [CONTEXT]                          private  Token  encapsulatedTokenLexer(Token  tkn,  int  c)  throws  IOException  {      int  startLineNumber  =  getLineNumber();          while  (true)  {  c  =  in.read();    if  (isEscape(c))  {  [BUGGY]  tkn.content.append  ((  String  )readEscape  (  c  ))  ;  }  else  if  (isEncapsulator(c))  {  if  (isEncapsulator(in.lookAhead()))  {      c  =  in.read();  tkn.content.append((char)  c);  }  else  {      while  (true)  {  c  =  in.read();  if  (isDelimiter(c))  {  tkn.type  =  TOKEN;  return  tkn;  }  else  if  (isEndOfFile(c))  {  tkn.type  =  EOF;  tkn.isReady  =  true;  //  There  is  data  at  EOF        [CLASS]  CSVLexer    [METHOD]  encapsulatedTokenLexer  [RETURN_TYPE]  Token      Token  tkn  int  c  [VARIABLES]  boolean    Token    tkn    int    c    startLineNumber    
[PATCH]  private  final  Appendable  out;	[BUG]  [BUGGY]  private    Appendable  out;  [CONTEXT]          public  class  CSVPrinter  {        [BUGGY]  privateAppendable  out;  private  final  CSVFormat  format;        private  boolean  newLine  =  true;          [CLASS]  CSVPrinter      [VARIABLES]  
[PATCH]  private  final  CSVFormat  format;	[BUG]  [BUGGY]  private    CSVFormat  format;  [CONTEXT]      public  class  CSVPrinter  {        private  final  Appendable  out;  [BUGGY]  privateCSVFormat  format;        private  boolean  newLine  =  true;              [CLASS]  CSVPrinter      [VARIABLES]  
[PATCH]  private  boolean  newLine  =  true;	[BUG]  [BUGGY]  private  boolean  newLine  =  false;  [CONTEXT]      private  final  Appendable  out;  private  final  CSVFormat  format;        [BUGGY]  private  boolean  newLine  =  false;                          [CLASS]  CSVPrinter      [VARIABLES]  
[PATCH]  private  boolean  newLine  =  true;	[BUG]  [BUGGY]  private  boolean  newLine    =  null  ;  [CONTEXT]      private  final  Appendable  out;  private  final  CSVFormat  format;        [BUGGY]  private  boolean  newLine=  null  ;                          [CLASS]  CSVPrinter      [VARIABLES]  
[PATCH]  this.out  =  out;	[BUG]  [BUGGY]  this.out  =    null;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  [BUGGY]  this.out  =null;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUG]  [BUGGY]  this.format  =  format  !=  null  ?  CSVFormat.DEFAULT  :  format;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format  !=  null  ?  CSVFormat.DEFAULT  :  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUG]  [BUGGY]  this.format  =  CSVFormat.DEFAULT  ==  null  ?  format  :  format;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  CSVFormat.DEFAULT  ==  null  ?  format  :  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUG]  [BUGGY]  this.format  =  format(  format;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format  (  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;	[BUG]  [BUGGY]  this.format  =  format  ==  true  ?  CSVFormat.DEFAULT  :  format;  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  [BUGGY]  this.format  =  format  ==  true  ?  CSVFormat.DEFAULT  :  format;    this.format.validate();  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  this.format.validate  (  )  ;	[BUG]  [BUGGY]  this.format.getEscape(  );  [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;    [BUGGY]  this.format.getEscape  ()  ;  }        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  this.format.validate  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  CSVPrinter(Appendable  out,  CSVFormat  format)  {  this.out  =  out;  this.format  =  format  ==  null  ?  CSVFormat.DEFAULT  :  format;    [BUGGY]  this.format.validate();          [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  this.format.validate  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getDelimiter(  );this.format.validate(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  <init>  [RETURN_TYPE]  CSVFormat)      Appendable  out  CSVFormat  format  [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getEncapsulator(  ));  [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append  (  format.getEncapsulator  ())  ;  newLine  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;  newLine  =  true;  }	[BUG]  [BUGGY]    [CONTEXT]  public  void  println()  throws  IOException  {  [BUGGY]  out.append(format.getLineSeparator());            [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  ));out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getLineSeparator  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  format.getLineSeparator(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  newLine  =  true;	[BUG]  [BUGGY]  newLine  =  false;  [CONTEXT]  public  void  println()  throws  IOException  {  out.append(format.getLineSeparator());  [BUGGY]  newLine  =  false;  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  newLine  =  true;	[BUG]  [BUGGY]  newLine  =  false;newLine  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  newLine  =  true;	[BUG]  [BUGGY]  quote  =  true;newLine  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  if  (  out  instanceof  Flushable  )  {	[BUG]  [BUGGY]  if  (  out    >>    Flushable)  {  [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  if(  out>>Flushable  ){  ((Flushable)  out).flush();  }  }        [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  if  (  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )  .flush  (  )  ;  }	[BUG]  [BUGGY]  ((java.io.Flushable)(out)).flush();  [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  if  (out  instanceof  Flushable)  {    ((java.io.Flushable)  (out)).flush();          [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  if  (  out  instanceof  Flushable  )  {  (  (  Flushable  )  out  )  .flush  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  void  flush()  throws  IOException  {  [BUGGY]  if  (out  instanceof  Flushable)  {              [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  (  (  Flushable  )  out  )  .flush  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  flush()  throws  IOException  {  if  (out  instanceof  Flushable)  {  [BUGGY]  ((Flushable)  out).flush();    }        [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  (  (  Flushable  )  out  )  .flush  (  )  ;	[BUG]  [BUGGY]  (  (  Flushable)  out)  .flush(  )  ;  [CONTEXT]  public  void  flush()  throws  IOException  {  if  (out  instanceof  Flushable)  {  [BUGGY]  ((  Flushable  )out  ).flush  ();  }  }        [CLASS]  CSVPrinter    [METHOD]  flush  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  for  (  String  value  :  values  )  {	[BUG]  [BUGGY]  for  (  char  value  :  values)  {  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  [BUGGY]  for(  char  value  :  values  ){  print(value);  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  println(  value);  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  println  (  value  )  ;  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  [BUGGY]  print(value);    }  println();        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  print(  value,  true);print(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  println(  );print(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  out.append(  value);print(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  print  (  value  )  ;	[BUG]  [BUGGY]  printSep(  );print(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  );  [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  print(value);  }  [BUGGY]  printSep  ()  ;  }        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  println(String...  values)  throws  IOException  {  for  (String  value  :  values)  {  print(value);  }  [BUGGY]  println();          [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  print(  value);println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  );println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  println  [RETURN_TYPE]  void        values  [VARIABLES]  CSVFormat    format    boolean    newLine    String[]    values    String    value    Appendable    out    
[PATCH]  if  (  !format.isCommentingEnabled  (  )  )  {	[BUG]  [BUGGY]  if  (  !format.getCommentStart(  ))  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if(  !format.getCommentStart  ()){  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  !format.isCommentingEnabled  (  )  )  {	[BUG]  [BUGGY]  if  (  format.isEncapsulating(  ))  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if(  format.isEncapsulating  ()){  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  !format.isCommentingEnabled  (  )  )  {  return;  }	[BUG]  [BUGGY]  return  ;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if  (!format.isCommentingEnabled())  {    return  ;    if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  !format.isCommentingEnabled  (  )  )  {  return;  }	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  [BUGGY]  if  (!format.isCommentingEnabled())  {        if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !(  format.isCommentingEnabled(  )))  {          return  ;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  !newLine  )  {	[BUG]  [BUGGY]  if  (  newLine)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if(  newLine  ){  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  !newLine  )  {	[BUG]  [BUGGY]  if  (  !quote)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if(  !quote  ){  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  !newLine  )  {  println  (  )  ;  }	[BUG]  [BUGGY]  println();  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if  (!newLine)  {    println();    out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  !newLine  )  {  println  (  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  [BUGGY]  if  (!newLine)  {        out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  );  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  [BUGGY]  printSep  ()  ;  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  [BUGGY]  println();    }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  print(  value);println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  );println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getEscape(  ));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  [BUGGY]  out.append  (  format.getEscape  ())  ;  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  [BUGGY]  out.append('  ');    for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  c);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length(  )  ||  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length  ()||  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <=  comment.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <=  comment.length  ()&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i    !=    1  <  comment.length(  )  &&  comment.charAt(  i    !=    1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i!=1  <  comment.length  ()&&  comment.charAt  (  i!=1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length(  )  &&  comment.charAt(  i  +  1)  >=  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length  ()&&  comment.charAt  (  i  +  1  )>=  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i    &&    1  <  comment.length(  )  &&  comment.charAt(  i    &&    1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i&&1  <  comment.length  ()&&  comment.charAt  (  i&&1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +    <  comment.length(  )  &&  comment.charAt(  i  +  )  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +<  comment.length  ()&&  comment.charAt  (  i  +)==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i    <  comment.length(  )  &&  comment.charAt(  i  )  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i<  comment.length  ()&&  comment.charAt  (  i)==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  +  1    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  +  1&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  comment  +  1  <  i.length(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  comment  +  1  <  i.length  ()&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length(  )){  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length  ())  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (    comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  comment.charAt(  (  i  +  1))  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  comment.charAt  ((  i  +  1  ))==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.charAt(  )  &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.charAt  ()&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  0    <  comment.length(  )){  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  0<  comment.length  ())  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {  i++;  }	[BUG]  [BUGGY]  i++;  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {    i++;        case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {  i++;  }	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {            case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (    long    i  =  0;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(longi  =  0;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <=  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <=  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for    ==  (  int  i  =  0;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for==(  int  i  =  0;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for    &&  (  int  i  =  0;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for&&(  int  i  =  0;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  i;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  i;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  5  ;  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <  comment.length()  -  5  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  commentnt  i  =  0;  i  <  i.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  commentnt  i  =  0;  i  <  i.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  cnt  i  =  0;  i  <  iomment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  cnt  i  =  0;  i  <  iomment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  comment.charAt(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <  comment.charAt  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i    &    1  <  comment.length(  )  &&  comment.charAt(  i    &    1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i&1  <  comment.length  ()&&  comment.charAt  (  i&1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length(  )  &&  comment.charAt(  i  +  1)  !=  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length  ()&&  comment.charAt  (  i  +  1  )!=  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i      instanceof      1  <  comment.length(  )  &&  comment.charAt(  i      instanceof      1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  instanceof  1  <  comment.length  ()&&  comment.charAt  (  i  instanceof  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  i  <  comment.length(  )  &&  comment.charAt(  i  +  i)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  i  <  comment.length  ()&&  comment.charAt  (  i  +  i  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  -  7    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  -  7&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  0    <  comment.length(  )  &&  comment.charAt(  i  +  0  )  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  0<  comment.length  ()&&  comment.charAt  (  i  +  0)==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  int  c  =  comment.charAt(  i);  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  int  c  =  comment.charAt  (  i  )  ;  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  char  c  =  i.charAt(  comment);  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  char  c  =  i.charAt  (  comment  )  ;  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEscape(  );char  c  =  comment.charAt(  i);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos);char  c  =  comment.charAt(  i);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  [BUGGY]  char  c  =  comment.charAt(i);    switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  char  c  =  comment.charAt  (  i  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  pos);char  c  =  comment.charAt(  i);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  +  9    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  +  9&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  -  1    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  -  1&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  );  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  [BUGGY]  printSep  ()  ;  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  [BUGGY]  println();      out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  print(  value);println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  );println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getEscape(  ));  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  [BUGGY]  out.append  (  format.getEscape  ())  ;  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  format.getCommentStart  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  format.getCommentStart(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;  break;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append('  ');      default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  c);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  '  ');  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  c  )  ;  break;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  [BUGGY]  out.append(c);      }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (    short    i  =  0;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(shorti  =  0;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  7;  i  <  comment.length(  );  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  7;  i  <  comment.length  ()  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  3  ;  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <  comment.length()  -  3  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  for  (  int  i  =  0;  i  <  comment.length  (  )  ;  i++  )  {	[BUG]  [BUGGY]  for  (  int  i  =  0;  i  <  comment.length()  -  4  ;  i++)  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  [BUGGY]  for(  int  i  =  0;  i  <  comment.length()  -  4  ;  i++  ){  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  i  +  1  <  comment.length  (  )  &&  comment.charAt  (  i  +  1  )  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  i  +  1  <  comment.length()  +  7    &&  comment.charAt(  i  +  1)  ==  '\n')  {  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  [BUGGY]  if(  i  +  1  <  comment.length()  +  7&&  comment.charAt  (  i  +  1  )==  '\n'  ){  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  [BUGGY]  println();    out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  out.append  (  '  '  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  [BUGGY]  out.append('  ');    break;  default:  out.append(c);  break;  }  }  println();        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  );  [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  [BUGGY]  printSep  ()  ;  }        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  printComment(String  comment)  throws  IOException  {  if  (!format.isCommentingEnabled())  {  return;  }  if  (!newLine)  {  println();  }  out.append(format.getCommentStart());  out.append('  ');  for  (int  i  =  0;  i  <  comment.length();  i++)  {  char  c  =  comment.charAt(i);  switch  (c)  {  case  '\r':  if  (i  +  1  <  comment.length()  &&  comment.charAt(i  +  1)  ==  '\n')  {  i++;  }      case  '\n':  println();  out.append(format.getCommentStart());  out.append('  ');  break;  default:  out.append(c);  break;  }  }  [BUGGY]  println();          [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  print(  value);println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  println  (  )  ;	[BUG]  [BUGGY]  printSep(  );println(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printComment  [RETURN_TYPE]  void      String  comment  [VARIABLES]  char    c    CSVFormat    format    boolean    newLine    String    comment    int    i    Appendable    out    
[PATCH]  if  (  format.isEncapsulating  (  )  )  {	[BUG]  [BUGGY]  if  (  format.isEscaping(  ))  {  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  if(  format.isEscaping  ()){  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  format.isEscaping(  ))  {          printAndEscape(  value,  offset,  len);  }else  {          printSep(  );          out.append(  value,  offset,  (  offset  +  len));  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {	[BUG]  [BUGGY]  }  else  if  (  format.isEncapsulating(  ))  {  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  if(  format.isEncapsulating  ()){  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {	[BUG]  [BUGGY]  }    if  (  format.isEncapsulating(  ))  {  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }if(  format.isEncapsulating  ()){  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {  printAndEscape  (  value,  offset,  len  )  ;  }  else  {  printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;  }	[BUG]  [BUGGY]  printAndEscape(value,  offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  if  (format.isEscaping())  {    printAndEscape(value,  offset,  len);        }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  }  else  if  (  format.isEscaping  (  )  )  {  printAndEscape  (  value,  offset,  len  )  ;  }  else  {  printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  [BUGGY]  }  else  if  (format.isEscaping())  {            }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  format.isEncapsulating(  ))  {          printAndEncapsulate(  value,  offset,  len);  }else          if  (  format.isEscaping(  ))  {                  printAndEscape(  value,  offset,  len);          }else  {                  printSep(  );                  out.append(  value,  offset,  (  offset  +  len));          }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  );  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  println  ()  ;  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printSep  (  )  ;  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  printSep();      }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  );printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  print(  value);printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset    <    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset<len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(    offset,  offset  +  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (offset,  offset  +  len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,    offset  +  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,offset  +  len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  len,  offset,  offset  +  value);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  len,  offset,  offset  +  value  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  len,  offset  +  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  len,  offset  +  offset  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out  .append(  value)  ;  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out  .append  (  value  );  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset  +  offset  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append(value,  offset,  offset  +  len);    }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  value,  offset,  offset  +  len);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  value,  offset,  offset  +  len);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  len);out.append(  value,  offset,  offset  +  len);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  value,  offset,  offset  +  len);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(    offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (offset,  len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,  offset  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  len,  offset,  value);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  len,  offset,  value  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  len,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,  len,  offset  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEncapsulate  (  value,  offset,  len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape(value,  offset,  len);    }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);printAndEscape(  value,  offset,  len);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  print(  value,  true);printAndEscape(  value,  offset,  len);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  offset,  len);printAndEscape(  value,  offset,  len);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len);printAndEscape(  value,  offset,  len);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  offset,  value,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  offset,  value,  len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  [BUGGY]  printSep();    out.append(value,  offset,  offset  +  len);  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset    ==    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset==len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  offset,  value,  offset  +  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  offset,  value,  offset  +  len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(    offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (offset,  len  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  value,len  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  value,  offset  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  len,  offset,  value);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  len,  offset,  value  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  len,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate  (  value,  len,  offset  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEscape  (  value,  offset,  len  )  ;  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEncapsulate  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]    [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  [BUGGY]  printAndEncapsulate(value,  offset,  len);    }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset    >    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset>len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  len,  len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,  len,  len  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEscape  (  value,  offset,  offset  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  printAndEscape  (  value,  offset,  len  )  ;	[BUG]  [BUGGY]  printAndEncapsulate(  value,  offset,  offset);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  [BUGGY]  printAndEncapsulate  (  value,  offset,  offset  )  ;  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  out.append  (  value,  offset,  offset  +  len  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset    !=    len);  [CONTEXT]  private  void  print(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  if  (format.isEncapsulating())  {  printAndEncapsulate(value,  offset,  len);  }  else  if  (format.isEscaping())  {  printAndEscape(value,  offset,  len);  }  else  {  printSep();  [BUGGY]  out.append  (  value,  offset,  offset!=len  )  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    CSVFormat    format    boolean    newLine    int    len    offset    Appendable    out    
[PATCH]  if  (  newLine  )  {	[BUG]  [BUGGY]  if  (  !newLine)  {  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if(  !newLine  ){  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  if  (  newLine  )  {	[BUG]  [BUGGY]  if  (  !quote)  {  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if(  !quote  ){  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  if  (  newLine  )  {  newLine  =  false;  }  else  {  out.append  (  format.getDelimiter  (  )  )  ;  }	[BUG]  [BUGGY]  newLine  =  false;  [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if  (newLine)  {    newLine  =  false;              [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  if  (  newLine  )  {  newLine  =  false;  }  else  {  out.append  (  format.getDelimiter  (  )  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  void  printSep()  throws  IOException  {  [BUGGY]  if  (newLine)  {                  [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getEscape(  ));  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append  (  format.getEscape  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  [BUGGY]  out.append(format.getDelimiter());            [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  format.getDelimiter(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  ));out.append(  format.getDelimiter(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getDelimiter(  );out.append(  format.getDelimiter(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  format.getDelimiter(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  out.append  (  format.getDelimiter  (  )  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  format.getDelimiter(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  newLine  =  false;	[BUG]  [BUGGY]  newLine  =  true;  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  [BUGGY]  newLine  =  true;  }  else  {  out.append(format.getDelimiter());  }  }        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  newLine  =  false;	[BUG]  [BUGGY]  newLine  =  true;newLine  =  false;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printSep  [RETURN_TYPE]  void      [VARIABLES]  CSVFormat    format    boolean    newLine    Appendable    out    
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  long    start  =  offset;  [CONTEXT]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  longstart  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  start  =  pos;  [CONTEXT]  }  else  {  printSep();  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  int  start  =  pos;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  pos  =  offset;int  start  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  end  =  offset  +  len;int  start  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  short    pos  =  offset;  [CONTEXT]  printSep();  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  [BUGGY]  shortpos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  pos  =  start;  [CONTEXT]  printSep();  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  [BUGGY]  int  pos  =  start;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  start  =  offset;int  pos  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  end  =  offset  +  len;int  pos  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  short    end  =  offset  +  len;  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  shortend  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  offset  +  start;  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  start;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  len  +  offset;  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  len  +  offset;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  start  +  len;  [CONTEXT]  out.append(value,  offset,  offset  +  len);  }  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  start  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  pos  =  offset;int  end  =  offset  +  len;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  start  =  offset;int  end  =  offset  +  len;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  );  [CONTEXT]  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    [BUGGY]  println  ()  ;    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }    void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    [BUGGY]  printSep();      char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  );printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  print(  value);printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  int  delim  =  format.getDelimiter(  );  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    [BUGGY]  int  delim  =  format.getDelimiter  ()  ;  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getEscape(  );  [CONTEXT]  void  printSep()  throws  IOException  {  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    [BUGGY]  char  delim  =  format.getEscape  ()  ;  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEscape(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.format.validate(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  int  escape  =  format.getEscape(  );  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  int  escape  =  format.getEscape  ()  ;    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.isEscaping(  );  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  char  escape  =  format.isEscaping  ()  ;    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getDelimiter(  );char  escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i);char  escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  );char  escape  =  format.getEscape(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  escape  =  format.getEscape  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format  .getEncapsulator(  )  ;  [CONTEXT]  if  (newLine)  {  newLine  =  false;  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  char  escape  =  format  .getEncapsulator  ();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <=  end)  {  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    [BUGGY]  while(  pos  <=  end  ){  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  start  <  end)  {  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    [BUGGY]  while(  start  <  end  ){  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  start)  {  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    [BUGGY]  while(  pos  <  start  ){  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  end  <  pos)  {  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    [BUGGY]  while(  end  <  pos  ){  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  offset  <  end)  {  [CONTEXT]  }  else  {  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    [BUGGY]  while(  offset  <  end  ){  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  &&  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  &&  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  !=  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  !=  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  >=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  >=  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  <=  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  <=  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  >=  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  >=  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  <=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  <=  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  c  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  c  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  escape  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  c  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'){  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  )  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (    c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\r')  ||(c  ==  '\n')  ||  c  ==  delim))  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  ((c  ==  '\r')  ||  (c  ==  '\n')  ||  c  ==  delim)  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  ((c  ==  '\r'  ||  c  ==  '\n'))  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  (c  ==  '\r'  ||  c  ==  '\n')  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  pos  >  start)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  pos  >  start  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  pos  +  1)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  pos  +  1  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (    c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\n'  ||  c  ==  escape  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  if(pos  >  start)  {        out.append(value,  start,  pos);};  if(c  ==  '\n')  {        c  =  'n';}else        if(c  ==  '\r')  {                c  =  'r';        };  out.append(escape);  out.append(c);  start  =  pos  +  1;  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {    if  (pos  >  start)  {out.append(value,  start,  pos);};  if  (c  ==  '\n')  {c  =  'n';}elseif  (c  ==  '\r')  {c  =  'r';};  out.append(escape);  out.append(c);  start  =  pos  +  1;        if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {            if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >=  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  >=  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  offset  >  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  offset  >  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >  pos)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  >  pos  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  start  >  pos)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  start  >  pos  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  out.append(value,  start,  pos);  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if  (pos  >  start)  {    out.append(value,  start,  pos);    if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if  (pos  >  start)  {        if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {          out.append(  value,  start,  (  pos  +  1));          start  =  pos;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !quote)  {          out.append(  value,  start,  end);          return  ;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  offset,  pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  start);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start,  start  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(    start,  pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (start,  pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,    pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  pos,  start,  value);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  pos,  start,  value  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  start);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  pos,  start  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out  .append(  value)  ;  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out  .append  (  value  );  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  offset);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start,  offset  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append(value,  start,  pos);    }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  print(  value,  true);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  pos  >  start)  {          out.append(  value,  start,  pos);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  >=  '\n')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  c  >=  '\n'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  !=  '\n')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  c  !=  '\n'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  escape  ==  '\n')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  escape  ==  '\n'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  c  ==  '\r'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  )  {  c  =  'n';  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUG]  [BUGGY]  c  =  'n';  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (c  ==  '\n')  {    c  =  'n';          out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  )  {  c  =  'n';  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUG]  [BUGGY]    [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if  (c  ==  '\n')  {              out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  <=  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  <=  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  escape  ==  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  escape  ==  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUG]  [BUGGY]  c  =  'r';  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (c  ==  '\r')  {    c  =  'r';      out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {  c  =  'r';  }	[BUG]  [BUGGY]    [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if  (c  ==  '\r')  {          out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  value  ==  null)  {          value  =   " ";  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  'r';	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]  printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c=c  ;  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  'r';	[BUG]  [BUGGY]  c  =  'n';c  =  'r';  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  'n';	[BUG]  [BUGGY]  c    =    c  ;  [CONTEXT]  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c=c  ;  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  'n';	[BUG]  [BUGGY]  c  =  'r';c  =  'n';  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  >=  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  >=  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  ;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  ;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  start  +  1;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  start  +  1;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  +  0;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  0;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos;start  =  pos  +  1;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  pos,  pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  delim);  [CONTEXT]  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    [BUGGY]  out.append  (  delim  )  ;  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;  out.append  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    [BUGGY]  out.append(escape);        start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  c);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  escape);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  escape);  [CONTEXT]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  [BUGGY]  out.append  (  escape  )  ;    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]    [CONTEXT]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  [BUGGY]  out.append(c);      start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  c);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  <  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  <  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  start  >  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  start  >  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  start,  value,  pos);  [CONTEXT]  void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  [BUGGY]  out.append  (  start,  value,  pos  )  ;  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  !=  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  !=  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }    if  (  escape  ==  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }if(  escape  ==  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  'r';	[BUG]  [BUGGY]  c  ;  [CONTEXT]  printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c  ;  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  'r';	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]  printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  [BUGGY]  c=  null  ;  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  'n';	[BUG]  [BUGGY]  c  ;  [CONTEXT]  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c  ;  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  'n';	[BUG]  [BUGGY]  c    =  null  ;  [CONTEXT]  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  [BUGGY]  c=  null  ;  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  +  1  /  3;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  1  /  3;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  int  c  =  value.charAt(  pos);  [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  int  c  =  value.charAt  (  pos  )  ;  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  start);  [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt  (  start  )  ;  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  pos.charAt(  value);  [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  char  c  =  pos.charAt  (  value  )  ;  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  offset);  [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt  (  offset  )  ;  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i);char  c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]  out.append(format.getDelimiter());  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(pos);    if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  pos);char  c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out  .append(  value  ,  len  ,  offset)  ;  [CONTEXT]  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    [BUGGY]  out  .append  (  value  ,  len  ,  offset  );  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]    [CONTEXT]  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    [BUGGY]  out.append(escape);    out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  !=  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  !=  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  !=  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  !=  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  !=  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  !=  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  escape  ||  c  ==  delim  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  }    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  ==  start)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  ==  start  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >  offset)  {  [CONTEXT]    void  printAndEscape(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      [BUGGY]  if(  pos  >  offset  ){  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  >  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  >  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  +  len;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  len;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  )  {	[BUG]  [BUGGY]  if  (  c  <  '\n')  {  [CONTEXT]  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  [BUGGY]  if(  c  <  '\n'  ){  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }              [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  ==  '\r'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  <  '\r')  {  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  [BUGGY]  }  else  if(  c  <  '\r'  ){  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos  +  1;	[BUG]  [BUGGY]  start  =  pos  +  start;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    [BUGGY]  start  =  pos  +  start;  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  escape  )  ;	[BUG]  [BUGGY]  out  .append(  value  ,  offset  ,  len)  ;  [CONTEXT]  char  escape  =  format.getEscape();    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    [BUGGY]  out  .append  (  value  ,  offset  ,  len  );  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  c  )  ;	[BUG]  [BUGGY]  out  .append(  value  ,  pos  ,  len)  ;  [CONTEXT]    while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  if  (c  ==  '\n')  {  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  [BUGGY]  out  .append  (  value  ,  pos  ,  len  );    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >=  start)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  pos  >=  start  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  offset  >  start)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  offset  >  start  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  pos  >  offset)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  pos  >  offset  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {	[BUG]  [BUGGY]  if  (  start  >  pos)  {  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if(  start  >  pos  ){  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]  out.append(value,  start,  pos);  [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if  (pos  >  start)  {    out.append(value,  start,  pos);    }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  pos  >  start  )  {  out.append  (  value,  start,  pos  )  ;  }	[BUG]  [BUGGY]    [CONTEXT]  c  =  'n';  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        [BUGGY]  if  (pos  >  start)  {        }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {          out.append(  value,  start,  (  pos  +  1));          start  =  pos;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !quote)  {          out.append(  value,  start,  end);          return  ;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  pos);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  offset,  pos  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  start);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start,  start  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(    start,  pos);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (start,  pos  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,    pos);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,pos  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  start);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  pos,  start  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out  .append(  value)  ;  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out  .append  (  value  );  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  offset);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  value,  start,  offset  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append(value,  start,  pos);    }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  print(  value,  true);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  pos  >  start)  {          out.append(  value,  start,  pos);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  pos,  start,  value);  [CONTEXT]  }  else  if  (c  ==  '\r')  {  c  =  'r';  }    out.append(escape);  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  [BUGGY]  out.append  (  pos,  start,  value  )  ;  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();          [CLASS]  CSVPrinter    [METHOD]  printAndEscape  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    escape    CSVFormat    format    boolean    newLine    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  boolean  first  =  newLine;	[BUG]  [BUGGY]  boolean  first  =  quote;  [CONTEXT]  out.append(c);    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  [BUGGY]  boolean  first  =  quote;  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  boolean  first  =  newLine;	[BUG]  [BUGGY]  boolean  quote  =  false;boolean  first  =  newLine;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  boolean  quote  =  false;	[BUG]  [BUGGY]  boolean  quote  =  true;  [CONTEXT]    start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  [BUGGY]  boolean  quote  =  true;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  boolean  quote  =  false;	[BUG]  [BUGGY]  boolean  first  =  newLine;boolean  quote  =  false;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  long    start  =  offset;  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  [BUGGY]  longstart  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  start  =  pos;  [CONTEXT]  start  =  pos  +  1;  //  start  on  the  current  char  after  this  one  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  [BUGGY]  int  start  =  pos;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  pos  =  offset;int  start  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  start  =  offset;	[BUG]  [BUGGY]  int  end  =  offset  +  len;int  start  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  short    pos  =  offset;  [CONTEXT]  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  [BUGGY]  shortpos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  pos  =  start;  [CONTEXT]  }    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  [BUGGY]  int  pos  =  start;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  start  =  offset;int  pos  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  pos  =  offset;	[BUG]  [BUGGY]  int  end  =  offset  +  len;int  pos  =  offset;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  short    end  =  offset  +  len;  [CONTEXT]    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  shortend  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  start  +  len;  [CONTEXT]    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  start  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  offset  +  start;  [CONTEXT]    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  offset  +  start;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  end  =  len  +  offset;  [CONTEXT]    pos++;  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  [BUGGY]  int  end  =  len  +  offset;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  pos  =  offset;int  end  =  offset  +  len;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  int  end  =  offset  +  len;	[BUG]  [BUGGY]  int  start  =  offset;int  end  =  offset  +  len;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  );  [CONTEXT]  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    [BUGGY]  println  ()  ;    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }        if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    [BUGGY]  printSep();      char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  );printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  print(  value);printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  int  delim  =  format.getDelimiter(  );  [CONTEXT]      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    [BUGGY]  int  delim  =  format.getDelimiter  ()  ;  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getEscape(  );  [CONTEXT]      if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    [BUGGY]  char  delim  =  format.getEscape  ()  ;  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEscape(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  char  encapsulator  =  format.getEncapsulator(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  this.format.validate(  );char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  delim  =  format.getDelimiter  (  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));char  delim  =  format.getDelimiter(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  int  encapsulator  =  format.getEncapsulator(  );  [CONTEXT]  if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  int  encapsulator  =  format.getEncapsulator  ()  ;    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  char  encapsulator  =  format.isEncapsulating(  );  [CONTEXT]  if  (pos  >  start)  {  out.append(value,  start,  pos);  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  [BUGGY]  char  encapsulator  =  format.isEncapsulating  ()  ;    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  char  delim  =  format.getDelimiter(  );char  encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  encapsulator  =  format.getEncapsulator  (  )  ;	[BUG]  [BUGGY]  char  escape  =  format.getEscape(  );char  encapsulator  =  format.getEncapsulator(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  ==  end)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  ==  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  start  <  end)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  start  <  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  start)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <  start  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  end  <  pos)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  end  <  pos  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  (  c  ==  '\n')  ||  (  c  ==  '\r'))  ||  (  c  ==  encapsulator))  ||  (  c  ==  delim))  {          quote  =  true;          break;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  >=  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  >=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'){  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  )  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (    c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  (c  ==  '\n'  ||  c  ==  '\r')  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUG]  [BUGGY]  quote  =  true;  break;  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    quote  =  true;  break;      pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUG]  [BUGGY]    [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {          pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;  [CONTEXT]  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  false;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  start);  [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt  (  start  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  pos.charAt(  value);  [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  pos.charAt  (  value  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =    null.charAt(  pos);  [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =null.charAt  (  pos  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(pos);    if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos);c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i);c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  len  <  0)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  len  <  0  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  len  <=  5)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  len  <=  5  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  pos  <=  0)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  pos  <=  0  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  first  &&(((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a')))  ||(c  >  'z'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  first  &&  (((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A')))  ||  ((c  >  'Z')  &&  (c  <  'a')))  ||  (c  >  'z')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a'))  ||  c  >  'z'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A')))  ||  ((c  >  'Z')  &&  (c  <  'a'))  ||  c  >  'z')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (((c  <  '0')  ||((c  >  '9')  &&(c  <  'A'))  ||(c  >  'Z')  &&(c  <  'a')))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  ((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A'))  ||  (c  >  'Z')  &&  (c  <  'a'))  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((c  <  '0'  ||(c  >  '9')  &&(c  <  'A')))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (c  <  '0'  ||  (c  >  '9')  &&  (c  <  'A'))  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <  '0')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <  '0'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((c  >  '9'  &&  c  <  'A'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (c  >  '9'  &&  c  <  'A')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  >  '9')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  >  '9'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <  'A')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <  'A'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((c  >  'Z'  &&  c  <  'a'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (c  >  'Z'  &&  c  <  'a')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  >  'Z')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  >  'Z'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <  'a')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <  'a'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  >  'z')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  >  'z'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <=  '#')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <=  '#'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  pos  <  end)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  pos  <  end  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r'))  ||  (c  ==  encapsulator)  ||  c  ==  delim  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  (c  ==  '\n'  ||  c  ==  '\r')  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  ==  '\n'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  ==  '\r'  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  ==  encapsulator  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  ==  delim  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  end  -  1)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  end  -  1  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  c  <=  '  '  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  len  <=  0  )  {	[BUG]  [BUGGY]  if  (  len  <=  1)  {  [CONTEXT]  }  }    void  printAndEncapsulate(CharSequence  value,  int  offset,  int  len)  throws  IOException  {  boolean  first  =  newLine;//  is  this  the  first  value  on  this  line?  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    [BUGGY]  if(  len  <=  1  ){                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <=  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  ||  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  ||(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  &&  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  &&(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <=  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <=  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >=  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >=  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <=  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <=  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  ==  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  ==  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <=  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <=  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  encapsulator  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  encapsulator  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((((c  <  '0')  ||((c  >  '9')  &&(c  <  'A')))  ||((c  >  'Z')  &&(c  <  'a'))  ||  c  >  'z')  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A')))  ||  ((c  >  'Z')  &&  (c  <  'a'))  ||  c  >  'z')  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (((c  <  '0')  ||((c  >  '9')  &&(c  <  'A'))  ||(c  >  'Z')  &&(c  <  'a'))  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  ((c  <  '0')  ||  ((c  >  '9')  &&  (c  <  'A'))  ||  (c  >  'Z')  &&  (c  <  'a'))  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((c  <  '0'  ||(c  >  '9')  &&(c  <  'A'))  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (c  <  '0'  ||  (c  >  '9')  &&  (c  <  'A'))  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <  '0'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <  '0'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((c  >  '9'  &&  c  <  'A')  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (c  >  '9'  &&  c  <  'A')  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  >  '9'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  >  '9'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <  'A'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <  'A'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((c  >  'Z'  &&  c  <  'a')  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (c  >  'Z'  &&  c  <  'a')  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  >  'Z'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  >  'Z'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  >  'z'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  >  'z'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <=  '#'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <=  '#'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  pos  <  end  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  pos  <  end  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r'))  ||  (c  ==  encapsulator)  ||  c  ==  delim  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator)  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r')  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  (c  ==  '\n'  ||  c  ==  '\r')  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  ==  '\n'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  ==  '\n'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  ==  '\r'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  ==  '\r'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  ==  encapsulator  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  ==  encapsulator  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  ==  delim  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  ==  delim  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  end  -  1  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  end  -  1  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  c  <=  '  '  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  c  <=  '  '  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  newLine  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  newLine  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <=  end)  {  [CONTEXT]        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <=  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  >  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  >  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  <  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  <  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  delim  <=  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  delim  <=  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  pos  <  end)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  pos  <  end  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (((c  ==  '\n')  ||(c  ==  '\r'))  ||(c  ==  encapsulator)  ||  c  ==  delim)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  ((c  ==  '\n')  ||  (c  ==  '\r'))  ||  (c  ==  encapsulator)  ||  c  ==  delim  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  (c  ==  '\n'  ||  c  ==  '\r')  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  '\n')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  '\n'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  '\r')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  '\r'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  encapsulator)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  encapsulator  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  delim)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  delim  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  end  -  1)  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  end  -  1  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  <=  '  ')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  <=  '  '  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  encapsulator  <=  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  encapsulator  <=  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  ==  end)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  ==  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  start  <  end)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  start  <  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  start)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <  start  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  end  <  pos)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  end  <  pos  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  pos)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <  pos  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  (  (  c  ==  '\n')  ||  (  c  ==  '\r'))  ||  (  c  ==  encapsulator))  ||  (  c  ==  delim))  {          quote  =  true;          break;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  &&  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  <=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  >=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  >=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  <=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  <  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  delim  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'){  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  )  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (    c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (((c  ==  '\n')  ||(c  ==  '\r')  ||  c  ==  encapsulator))  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  ((c  ==  '\n')  ||  (c  ==  '\r')  ||  c  ==  encapsulator)  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  ((c  ==  '\n'  ||  c  ==  '\r'))  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  (c  ==  '\n'  ||  c  ==  '\r')  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\r'  ||  c  ==  '\n'  ||  c  ==  delim  ||  c  ==  escape  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUG]  [BUGGY]  quote  =  true;  break;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {    quote  =  true;  break;      pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {  quote  =  true;  break;  }	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {          pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [BUGGY]  quote  =  false;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  start);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt  (  start  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  pos.charAt(  value);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  pos.charAt  (  value  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =    null.charAt(  pos);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =null.charAt  (  pos  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt(pos);    if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos);c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i);c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  >=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  <  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  <  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (    c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  c  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  !newLine)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  !newLine  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  c  <=  '  '  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  newLine)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  newLine  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  first)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  first  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  <  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  <  '  '  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  encapsulator  <=  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  encapsulator  <=  '  '  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  len  <=  0)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  len  <=  0  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  ==  '\n'  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUG]  [BUGGY]  quote  =  true;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if  (c  <=  '  ')  {    quote  =  true;    }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if  (c  <=  '  ')  {        }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  first)  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  value  ==  null)  {          value  =   " ";  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {          c  =  'r';  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  [BUGGY]  quote  =  false;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    &&    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end&&1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  ;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  ;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  pos  -  1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  pos  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  %  0;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  %  0;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  start);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt  (  start  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  pos.charAt(  value);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  pos.charAt  (  value  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =    null.charAt(  pos);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =null.charAt  (  pos  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt(pos);                if  (c  <=  '  ')  {  quote  =  true;  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos);c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i);c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    |    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end|1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  len;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  len;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  start  -  1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  start  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  0;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  0;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  offset);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt  (  offset  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;  [CONTEXT]  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              [BUGGY]  quote  =  false;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);                [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  c  <=  '  '  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  quote)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  quote  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  newLine)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  newLine  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  !newLine)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  !newLine  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  first)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  first  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  <  '  ')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  <  '  '  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  encapsulator  <=  '  ')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  encapsulator  <=  '  '  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  len  <=  0)  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  len  <=  0  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  ==  '\n'  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUG]  [BUGGY]  quote  =  true;  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if  (c  <=  '  ')  {    quote  =  true;    }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {  quote  =  true;  }	[BUG]  [BUGGY]    [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if  (c  <=  '  ')  {        }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  first)  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  value  ==  null)  {          value  =   " ";  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {          c  =  'r';  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;  [CONTEXT]  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  [BUGGY]  quote  =  false;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);              [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    ==    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end==1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  offset;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  offset;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  start  -  1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  start  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  -  1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  start);  [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt  (  start  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  pos.charAt(  value);  [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  pos.charAt  (  value  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =    null.charAt(  pos);  [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =null.charAt  (  pos  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  offset);  [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt  (  offset  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]          quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt(pos);                if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  pos);c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i);c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  offset);  [CONTEXT]      if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  [BUGGY]  c  =  value.charAt  (  offset  )  ;  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    <    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end<1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  ;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  ;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  pos  -  1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  pos  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1L;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1L;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;  [CONTEXT]              if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  [BUGGY]  quote  =  false;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <=  end)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  <=  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  !=  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  !=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (    c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  quote)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    [BUGGY]  if(  quote  ){  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    >=    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end>=1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  start;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  start;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  *  1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  *  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  offset);  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  [BUGGY]  c  =  value.charAt  (  offset  )  ;              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  ==  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  ==  '  '  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  3;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  3;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  <=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  !=  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    >    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end>1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  >>  4;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  >>  4;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  >  '  ')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  >  '  '  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    <<    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end<<1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  1  +  4;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  1  +  4;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  int  c  =  value.charAt(  pos);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  int  c  =  value.charAt  (  pos  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  offset);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  value.charAt  (  offset  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  pos.charAt(  value);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  pos.charAt  (  value  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  start);  [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  value.charAt  (  start  )  ;        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i);char  c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  [BUGGY]  char  c  =  value.charAt(pos);          if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  pos);char  c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  )  {	[BUG]  [BUGGY]  if  (  quote)  {  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  [BUGGY]  if(  quote  ){  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {            [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  )  {	[BUG]  [BUGGY]  if  (  !quote)  {  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  [BUGGY]  if(  !quote  ){  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {            [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  )  {  quote  =  true;  }	[BUG]  [BUGGY]  quote  =  true;  [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  [BUGGY]  if  (first)  {    quote  =  true;    }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  )  {  quote  =  true;  }	[BUG]  [BUGGY]    [CONTEXT]  boolean  quote  =  false;  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  [BUGGY]  if  (first)  {        }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  quote  =  false;  [CONTEXT]  int  start  =  offset;  int  pos  =  offset;  int  end  =  offset  +  len;    printSep();    char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  [BUGGY]  quote  =  false;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {                [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  quote  =  true;	[BUG]  [BUGGY]  newLine  =  true;quote  =  true;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  <  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  <  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >=  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >=  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  ==  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  ==  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  c  ==  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  c  ==  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  first  &&  (  c  <  '0'  ||  (  c  >  '9'  &&  c  <  'A'  )  ||  (  c  >  'Z'  &&  c  <  'a'  )	[BUG]  [BUGGY]  if  (  first  &&  (  delim  <  '0'  ||  (  c  >  '9'  &&  c  <  'A')||  (  c  >  'Z'  &&  c  <  'a'  )  [CONTEXT]  char  delim  =  format.getDelimiter();  char  encapsulator  =  format.getEncapsulator();    if  (len  <=  0)  {                  if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        [BUGGY]  if(  first  &&(  delim  <  '0'  ||(  c  >  '9'  &&  c  <  'A'  )  ||(  c  >  'Z'  &&  c  <  'a'  )        ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  c  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (    c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [CONTEXT]  if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }    if  (  delim  <=  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }if(  delim  <=  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  >  end)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  [BUGGY]  while(  pos  >  end  ){  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  >  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  >  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (    c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  encapsulator  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  !=  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    <    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end<1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  2;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  2;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    !=    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end!=1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  start;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  start;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  4;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  4;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  ==  '  ')  {  [CONTEXT]  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  ==  '  '  ){  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  0;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  0;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  }  else  if  (  c  <=  '#'  )  {	[BUG]  [BUGGY]  }  else  if  (  c  ==  '#')  {  [CONTEXT]      if  (first)  {  quote  =  true;  }  }  else  {  char  c  =  value.charAt(pos);        if  (first  &&  (c  <  '0'  ||  (c  >  '9'  &&  c  <  'A')  ||  (c  >  'Z'  &&  c  <  'a')  ||  (c  >  'z')))  {  quote  =  true;      [BUGGY]  }  else  if(  c  ==  '#'  ){              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  '\n'){  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  '\n'  )  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim  )  {	[BUG]  [BUGGY]  if  (  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim)  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  '\n'  ||  c  ==  '\r'  ||  c  >=  encapsulator  ||  c  ==  delim  ){  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  end;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  end;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  <=  '  '  )  {	[BUG]  [BUGGY]  if  (  c  >  '  ')  {  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              [BUGGY]  if(  c  >  '  '  ){  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    &    1;  [CONTEXT]  }  else  if  (c  <=  '#')  {              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end&1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end    &    1;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end&1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  pos;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  pos;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  ;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  ;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  pos  =  end  -  1;	[BUG]  [BUGGY]  pos  =  end  -  3;  [CONTEXT]              quote  =  true;  }  else  {  while  (pos  <  end)  {  c  =  value.charAt(pos);  if  (c  ==  '\n'  ||  c  ==  '\r'  ||  c  ==  encapsulator  ||  c  ==  delim)  {  quote  =  true;  break;  }  pos++;  }    if  (!quote)  {  [BUGGY]  pos  =  end  -  3;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  !newLine)  {  [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if(  !newLine  ){      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {              [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  newLine)  {  [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if(  newLine  ){      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {              [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {	[BUG]  [BUGGY]  if  (  first)  {  [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if(  first  ){      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {              [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {  out.append  (  value,  start,  end  )  ;  return;  }	[BUG]  [BUGGY]  out.append(value,  start,  end);  return  ;  [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if  (!quote)  {    out.append(value,  start,  end);  return  ;              out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  !quote  )  {  out.append  (  value,  start,  end  )  ;  return;  }	[BUG]  [BUGGY]    [CONTEXT]  }    if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    [BUGGY]  if  (!quote)  {                  out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  end);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  pos,  end  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  start,  pos  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(    start,  end);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (start,  end  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,    end);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,end  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  start);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  start  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  end,  start,  value);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  end,  start,  value  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  end,  start);  [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append  (  value,  end,  start  )  ;  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;  return;	[BUG]  [BUGGY]    [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append(value,  start,  end);      }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  print(  value,  true);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  ));out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  len);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  value,  start,  end);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  end  )  ;	[BUG]  [BUGGY]    [CONTEXT]  if  (!quote)  {  pos  =  end  -  1;  c  =  value.charAt(pos);              if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      [BUGGY]  out.append(value,  start,  end);    return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  delim);  [CONTEXT]      if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [BUGGY]  out.append  (  delim  )  ;            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]    [CONTEXT]      if  (c  <=  '  ')  {  quote  =  true;  }  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        [BUGGY]  out.append(encapsulator);              while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  c);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {  out.append(  encapsulator);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <=  end)  {  [CONTEXT]  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            [BUGGY]  while(  pos  <=  end  ){  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  pos)  {  [CONTEXT]  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            [BUGGY]  while(  pos  <  pos  ){  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  while  (  pos  <  end  )  {	[BUG]  [BUGGY]  while  (  pos  <  start)  {  [CONTEXT]  }  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            [BUGGY]  while(  pos  <  start  ){  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  c  !=  encapsulator)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  !=  encapsulator  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  delim  ==  encapsulator)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  delim  ==  encapsulator  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  c  ==  delim)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  ==  delim  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  encapsulator  ==  c)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  encapsulator  ==  c  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  pos  +  1)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  pos  +  1  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  pos  >  start)  {          out.append(  value,  start,  pos);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  !quote)  {          out.append(  value,  start,  end);          return  ;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos;	[BUG]  [BUGGY]  start  =  start;  [CONTEXT]        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          [BUGGY]  start  =  start;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos;	[BUG]  [BUGGY]  start  =    offset;  [CONTEXT]        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          [BUGGY]  start  =offset;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  start  =  pos;	[BUG]  [BUGGY]  start  =  pos  +  1;start  =  pos;  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos      instanceof      1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos  instanceof  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  );  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos  +)  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  offset,  pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  offset  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  offset  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(    start,  pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (start,  pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,    pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  start  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  pos,  start  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out  .append(  value)  ;  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out  .append  (  value  );          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  pos,  pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]    [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append(value,  start,  pos  +  1);            start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                  [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  value,  start,  pos  +  1);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  ));out.append(  value,  start,  pos  +  1);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  value,  start,  pos  +  1);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  value,  start,  pos  +  1);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  value,  start,  pos  +  1);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len);out.append(  value,  start,  pos  +  1);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  value,  start,  pos  +  1);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  value,  start,  pos  +  1);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  String  c  =  value.charAt(  pos);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  String  c  =  value.charAt  (  pos  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  start);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt  (  start  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  pos.charAt(  value);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  char  c  =  pos.charAt  (  value  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  comment.charAt(  i);char  c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  char  c  =  value.charAt(  offset);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt  (  offset  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  char  c  =  value.charAt(pos);    if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  c  =  value.charAt(  pos);char  c  =  value.charAt(  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos    |    1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos|1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  start);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos  +  start  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  start,  value,  pos  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  start,  value,  pos  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  c  ==  encapsulator  )  {	[BUG]  [BUGGY]  if  (  c  <=  encapsulator)  {  [CONTEXT]  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  [BUGGY]  if(  c  <=  encapsulator  ){            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos    ==    1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos==1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  offset);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos  +  offset  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  start  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  start  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  char  c  =  value.charAt  (  pos  )  ;	[BUG]  [BUGGY]  int  c  =  value.charAt(  pos);  [CONTEXT]  }  }    if  (!quote)  {      out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  [BUGGY]  int  c  =  value.charAt  (  pos  )  ;  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  end);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  value,  start,  pos  +  end  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  +  1  )  ;	[BUG]  [BUGGY]  out.append(  pos,  start,  value  +  1);  [CONTEXT]  out.append(value,  start,  end);  return;  }        out.append(encapsulator);            while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            [BUGGY]  out.append  (  pos,  start,  value  +  1  )  ;          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  out.append(encapsulator);  }                      [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  pos);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,  offset,  pos  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  offset);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,  start,  offset  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(    start,  pos);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (start,  pos  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,    pos);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,pos  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,  start  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  start,  value,  pos);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  start,  value,  pos  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  pos,  start);  [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append  (  value,  pos,  start  )  ;  out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]    [CONTEXT]  while  (pos  <  end)  {  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        [BUGGY]  out.append(value,  start,  pos);    out.append(encapsulator);  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  print(  value,  true);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getCommentStart(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getLineSeparator(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  offset,  offset  +  len);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  format.getDelimiter(  ));out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  value,  start,  pos  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  value,  start,  pos);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  delim);  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  [BUGGY]  out.append  (  delim  )  ;  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out  .append(  value  ,  len  ,  offset)  ;  [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  [BUGGY]  out  .append  (  value  ,  len  ,  offset  );  }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]    [CONTEXT]  char  c  =  value.charAt(pos);  if  (c  ==  encapsulator)  {            out.append(value,  start,  pos  +  1);          start  =  pos;  }  pos++;  }        out.append(value,  start,  pos);  [BUGGY]  out.append(encapsulator);    }                            public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }          [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  c);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  encapsulator);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  out.append  (  encapsulator  )  ;	[BUG]  [BUGGY]  if  (  c  ==  encapsulator)  {  out.append(  encapsulator);  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  printAndEncapsulate  [RETURN_TYPE]  void      CharSequence  value  int  offset  int  len  [VARIABLES]  CharSequence    value    char    c    delim    encapsulator    CSVFormat    format    boolean    first    newLine    quote    int    end    len    offset    pos    start    Appendable    out    
[PATCH]  if  (  value  ==  null  )  {	[BUG]  [BUGGY]  if  (  value  !=  null)  {  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if(  value  !=  null  ){      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  if  (  value  ==  null  )  {	[BUG]  [BUGGY]  if  (  value  ==  true)  {  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if(  value  ==  true  ){      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  if  (  value  ==  null  )  {  value  =   " ";  }	[BUG]  [BUGGY]  value  =   " ";  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if  (value  ==  null)  {    value  =   " ";        if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  if  (  value  ==  null  )  {  value  =   " ";  }	[BUG]  [BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  [BUGGY]  if  (value  ==  null)  {            if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  <=  '  ')  {          quote  =  true;  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  c  ==  '\r')  {          c  =  'r';  }  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  value  =   " ";	[BUG]  [BUGGY]  value    =    value  ;  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      [BUGGY]  value=value  ;  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  if  (  !checkForEscape  )  {	[BUG]  [BUGGY]  if  (  !quote)  {  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    [BUGGY]  if(  !quote  ){      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  if  (  !checkForEscape  )  {	[BUG]  [BUGGY]  if  (  checkForEscape)  {  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    [BUGGY]  if(  checkForEscape  ){      printSep();  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  -3,  value.length(  ));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  -3,  value.length  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.length()  +  8  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.length()  +  8)  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  0,  value.length(  ));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  printAndEscape  (  value,  0,  value.length  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.charAt(  ));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.charAt  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print(value,  0,  value.length());    }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  true);print(  value,  0,  value.length(  ));  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.length()  -  8  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.length()  -  8)  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      [BUGGY]  println  ()  ;  out.append(value);  }  else  {  print(value,  0,  value.length());  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      [BUGGY]  printSep();    out.append(value);  }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  println(  );printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  printSep  (  )  ;	[BUG]  [BUGGY]  print(  value);printSep(  );  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  [BUGGY]  out.append(value);    }  else  {  print(value,  0,  value.length());  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);out.append(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);out.append(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  c);out.append(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  print(  value);out.append(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  encapsulator);out.append(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos  +  1);out.append(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  '  ');out.append(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  out.append  (  value  )  ;	[BUG]  [BUGGY]  out.append(  escape);out.append(  value);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  6,  value.length(  ));  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  6,  value.length  ())  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  0,  value.length  (  )  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.length()  +  9  );  [CONTEXT]  public  void  print(String  value,  boolean  checkForEscape)  throws  IOException  {  if  (value  ==  null)  {      value  =   " ";  }    if  (!checkForEscape)  {      printSep();  out.append(value);  }  else  {  [BUGGY]  print  (  value,  0,  value.length()  +  9)  ;  }  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  boolean  checkForEscape  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  print(  value,  false);  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  print  (  value,  false  )  ;  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  CSVPrinter(  value,  true);  [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  CSVPrinter  (  value,  true  )  ;  }        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  void  print(String  value)  throws  IOException  {  [BUGGY]  print(value,  true);          [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  end);print(  value,  true);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  print(  value,  0,  value.length(  ));print(  value,  true);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  out.append(  value,  start,  pos);print(  value,  true);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  print(  value);print(  value,  true);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  print  (  value,  true  )  ;	[BUG]  [BUGGY]  printAndEscape(  value,  offset,  len);print(  value,  true);  [CONTEXT]        [CLASS]  CSVPrinter    [METHOD]  print  [RETURN_TYPE]  void      String  value  [VARIABLES]  CSVFormat    format    boolean    checkForEscape    first    newLine    quote    String    value    Appendable    out    
[PATCH]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[0];	[BUG]  [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[4];  [CONTEXT]              public  class  CSVRecord  implements  Serializable,  Iterable<String>  {    [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[4];        private  final  String[]  values;              [CLASS]  CSVRecord      [VARIABLES]  
[PATCH]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[0];	[BUG]  [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[1];  [CONTEXT]              public  class  CSVRecord  implements  Serializable,  Iterable<String>  {    [BUGGY]  private  static  final  String[]  EMPTY_STRING_ARRAY  =  new  String[1];        private  final  String[]  values;              [CLASS]  CSVRecord      [VARIABLES]  
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values  =  values  ==  null  ?  values  :  EMPTY_STRING_ARRAY;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  values  ==  null  ?  values  :  EMPTY_STRING_ARRAY;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values  =  EMPTY_STRING_ARRAY  !=  null  ?  values  :  values;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  EMPTY_STRING_ARRAY  !=  null  ?  values  :  values;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values    =    EMPTY_STRING_ARRAY;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values=EMPTY_STRING_ARRAY;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values    =    values  ;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values=values  ;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;	[BUG]  [BUGGY]  this.values  =  values  !=  false  ?  values  :  EMPTY_STRING_ARRAY;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  [BUGGY]  this.values  =  values  !=  false  ?  values  :  EMPTY_STRING_ARRAY;  this.mapping  =  mapping;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  this.mapping  =  mapping;	[BUG]  [BUGGY]  this.mapping  =    null;  [CONTEXT]  CSVRecord(String[]  values,  Map<String,  Integer>  mapping)  {  this.values  =  values  !=  null  ?  values  :  EMPTY_STRING_ARRAY;  [BUGGY]  this.mapping  =null;  }        [CLASS]  CSVRecord    [METHOD]  <init>  [RETURN_TYPE]  Map)      String[]  values  Integer>  mapping  [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  values[i];	[BUG]  [BUGGY]  return  EMPTY_STRING_ARRAY[i];  [CONTEXT]  public  String  get(int  i)  {  [BUGGY]  return  EMPTY_STRING_ARRAY[i];  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      int  i  [VARIABLES]  String[]    EMPTY_STRING_ARRAY    values    boolean    Map    mapping    int    i    
[PATCH]  if  (  mapping  ==  null  )  {	[BUG]  [BUGGY]  if  (  mapping  !=  null)  {  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if(  mapping  !=  null  ){  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  if  (  mapping  ==  null  )  {	[BUG]  [BUGGY]  if  (  null  ==  null)  {  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if(  null  ==  null  ){  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  if  (  mapping  ==  null  )  {	[BUG]  [BUGGY]  if  (  mapping  ==  true)  {  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if(  mapping  ==  true  ){  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  if  (  mapping  ==  null  )  {  throw  new  IllegalStateException  ( "   ")  ;  }	[BUG]  [BUGGY]  throw  new  java.lang.IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if  (mapping  ==  null)  {    throw  new  java.lang.IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");      Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  if  (  mapping  ==  null  )  {  throw  new  IllegalStateException  ( "   ")  ;  }	[BUG]  [BUGGY]    [CONTEXT]  public  String  get(String  name)  {  [BUGGY]  if  (mapping  ==  null)  {          Integer  index  =  mapping.get(name);    return  index  !=  null  ?  values[index.intValue()]  :  null;        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  [Delete]	[BUG]  [BUGGY]  if  (  (  mapping)  ==  null)  {          throw  new  IllegalStateException(   "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }  [CONTEXT]        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  Integer  index  =  mapping.get  (  name  )  ;	[BUG]  [BUGGY]  Integer  index  =  name.get(  mapping);  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    [BUGGY]  Integer  index  =  name.get  (  mapping  )  ;    return  index  !=  null  ?  values[index.intValue()]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  Integer  index  =  mapping.get  (  name  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    [BUGGY]  Integer  index  =  mapping.get(name);      return  index  !=  null  ?  values[index.intValue()]  :  null;        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  ==  null  ?  values[index.intValue(  )]  :  null;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  ==  null  ?  values[index.intValue  ()  ]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  !=  null  ?  EMPTY_STRING_ARRAY[index.intValue(  )]  :  null;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  !=  null  ?  EMPTY_STRING_ARRAY[index.intValue  ()  ]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  values  !=  null  ?  index[index.intValue(  )]  :  null;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  values  !=  null  ?  index[index.intValue  ()  ]  :  null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  !  =    null;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  !  =null;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index  !  =    values[index.intValue(  )]  ;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  !  =values[index.intValue  ()  ]  ;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]  return  index    =    values[index.intValue(  )]  ;  [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index=values[index.intValue  ()  ]  ;  }        [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  return  index  !=  null  ?  values[index.intValue  (  )  ]  :  null;	[BUG]  [BUGGY]    [CONTEXT]  public  String  get(String  name)  {  if  (mapping  ==  null)  {  throw  new  IllegalStateException( "No  header  was  specified,  the  record  values  can't  be  accessed  by  name ");  }    Integer  index  =  mapping.get(name);    [BUGGY]  return  index  !=  null  ?  values[index.intValue()]  :  null;          [CLASS]  CSVRecord    [METHOD]  get  [RETURN_TYPE]  String      String  name  [VARIABLES]  Integer    index    String[]    EMPTY_STRING_ARRAY    values    String    name    boolean    Map    mapping    
[PATCH]  return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUG]  [BUGGY]  return  Arrays.asList(  EMPTY_STRING_ARRAY).iterator(  );  [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays.asList  (  EMPTY_STRING_ARRAY  )  .iterator  ()  ;  }        [CLASS]  CSVRecord    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUG]  [BUGGY]  return  Arrays.asList(  values)  .iterator(  )  ;  [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays.asList  (  values  ).iterator  ();  }        [CLASS]  CSVRecord    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  Arrays.asList  (  values  )  .iterator  (  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  Iterator<String>  iterator()  {  [BUGGY]  return  Arrays.asList(values).iterator();          [CLASS]  CSVRecord    [METHOD]  iterator  [RETURN_TYPE]  Iterator      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  values;	[BUG]  [BUGGY]  return  EMPTY_STRING_ARRAY;  [CONTEXT]  String[]  values()  {  [BUGGY]  return  EMPTY_STRING_ARRAY;  }        [CLASS]  CSVRecord    [METHOD]  values  [RETURN_TYPE]  String[]      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  values.length;	[BUG]  [BUGGY]  return  EMPTY_STRING_ARRAY.length;  [CONTEXT]  public  int  size()  {  [BUGGY]  return  EMPTY_STRING_ARRAY.length;  }        [CLASS]  CSVRecord    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  values.length;	[BUG]  [BUGGY]  return  values;  [CONTEXT]  public  int  size()  {  [BUGGY]  return  values;  }        [CLASS]  CSVRecord    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  values.length;	[BUG]  [BUGGY]  return  values.length.length;  [CONTEXT]  public  int  size()  {  [BUGGY]  return  values.length.length;  }        [CLASS]  CSVRecord    [METHOD]  size  [RETURN_TYPE]  int      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  Arrays.toString  (  values  )  ;	[BUG]  [BUGGY]  return  Arrays.toString(  EMPTY_STRING_ARRAY);  [CONTEXT]  public  String  toString()  {  [BUGGY]  return  Arrays.toString  (  EMPTY_STRING_ARRAY  )  ;  }        [CLASS]  CSVRecord    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
[PATCH]  return  Arrays.toString  (  values  )  ;	[BUG]  [BUGGY]    [CONTEXT]  public  String  toString()  {  [BUGGY]  return  Arrays.toString(values);          [CLASS]  CSVRecord    [METHOD]  toString  [RETURN_TYPE]  String      [VARIABLES]  Map    mapping    String[]    EMPTY_STRING_ARRAY    values    boolean    
