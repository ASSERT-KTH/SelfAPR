[REPLACE]  private  ArrayList  tokens  =  new  ArrayList  (  )  ; 	[BUGGY] private ArrayList tokens  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] GnuParser  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^31^^^^^^^
[REPLACE]  tokens  .  clear  (  )  ; 	[BUGGY] tokens . ArrayList ( ) ; [CE] cannot find symbol  [METHOD]  init [TYPE] void [PARAMETER] [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] boolean false true  [CONTEXT]  private void init ( ) { [BUGGY] tokens . ArrayList ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^39^^^^^37^40^
[REPLACE]  init  (  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { [BUGGY] tokens . add (   "--  " )  ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^64^^^^^63^172^
[REPLACE]  boolean  eatTheRest  =  false; 	[BUGGY] boolean eatTheRest = true ; [FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  [BUGGY] boolean eatTheRest = true ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^66^^^^^63^172^
[REPLACE]  Option  currentOption  =  null; 	[BUGGY] Option currentOption = false ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; [BUGGY] Option currentOption = false ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^67^^^^^63^172^
[REPLACE]  if  (    "--  "  .  equals  (  arguments[i]  )  )  { 	[BUGGY] else if (   "-  " . equals ( arguments[i] ) )[CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { [BUGGY] else if (   "-  " . equals ( arguments[i] ) )  eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^71^72^^^^63^172^
[REPLACE]  else  if  (    "-  "  .  equals  (  arguments[i]  )  )  { 	[BUGGY] if (   "-  " . equals ( arguments[i] ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } [BUGGY] if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^76^77^^^^63^172^
[ADD]  else  if  (    "-  "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (    "-  "  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } [BUGGY]   else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^76^77^78^79^^63^172^
[REPLACE]  else  if  (  arguments[i]  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( arguments[i] . startsWith (   "-  " ) ) {[FE]  String index out of range: 2 assertTrue(   "Confirm -a is set  " , cl.hasOption(  "a  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } [BUGGY] if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^80^81^^^^63^172^
[ADD]  else  if  (  arguments[i]  .  startsWith  (    "-  "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } [BUGGY]    if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^80^81^82^^^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( arguments[i] ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { [BUGGY] tokens . toArray ( arguments[i] )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^159^^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if (specialOption ! = null ) {[CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( specialOption ! = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^80^160^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = null ) ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^85^155^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[ADD]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY]   currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^121^122^123^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = this ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = this ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^85^155^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( arguments[i] ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( arguments[i] )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^145^154^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^145^154^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( arguments[i] ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] tokens . toArray ( arguments[i] )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( null )  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( null ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^145^154^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^119^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^119^154^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( arguments[i] ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( arguments[i] )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^130^139^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^119^154^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . toArray ( this ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[REMOVE]   	[BUGGY] options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . add ( arguments[i] ) ;  options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^119^154^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^130^139^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = false ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = false ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^121^139^
[ADD]  currentOption  =  null; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^121^139^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^119^154^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^132^133^134^119^154^
[ADD]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( null )  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . toArray ( null ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = this ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = this ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^119^154^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( specialOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( specialOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^85^155^
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY]   else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^123^124^125^85^155^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( specialOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( this ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( true )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . toArray ( true ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^130^139^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^85^155^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = true ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = true ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^121^139^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( arguments[i] ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . toArray ( arguments[i] )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] tokens . toArray ( null ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[ADD]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = true ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = true ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^85^155^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 0L , 2 ) ) ; [CE] no suitable method found for substring(long , int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . toArray ( arguments[i] . substring ( 0L , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 1 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( i , i )  ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( i , i )  )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 1 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 1 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( ( currentOption = = null ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( ( currentOption = = null ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^85^155^
[ADD]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] tokens . toArray ( this ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^85^155^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^147^148^149^85^155^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( )  ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( currentOption . hasArgs ( )  ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^119^154^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = this ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = this ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^121^139^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^119^154^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 0 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . toArray ( 0 ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( false )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( false ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = false ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = false ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^119^154^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^85^155^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^85^155^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^^^^^85^155^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " )  ;  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^130^139^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^132^133^134^85^155^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = option ;  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = option ;  ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^121^139^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( true )  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( true ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[REMOVE]   	[BUGGY] options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[ADD]  else  if  (  currentOption  !=  null  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^143^144^^85^155^
[REPLACE]  currentOption  =  option; 	[BUGGY] currentOption = null ;  ; [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { [BUGGY] currentOption = null ;  ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^108^^^^^85^155^
[ADD]  currentOption  =  option; 	[BUGGY] [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { [BUGGY]   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^108^^^^^85^155^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = option ;  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = option ;  ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^85^155^
[ADD]  currentOption  =  null; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = true ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^85^155^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( null )  ; [FE] NullPointerException assertTrue(   "Confirm -a is set  " , cl.hasOption(  "a  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( null ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^103^^^^^96^104^
[ADD]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [FE]  Confirm size of extra args assertTrue(   "Confirm -a is set  " , cl.hasOption(  "a  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^103^^^^^96^104^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^96^104^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 1 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 3 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 * 3 ) ) ; [FE]  AssertionFailedError  expected:<[prop]erty> but was:<[]erty> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 * 3 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] [FE]  Unexpected exception:Missing argument for option:D assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 - 0 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 - 0 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( arguments[i] ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( arguments[i] )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^103^^^^^96^104^
[REMOVE]   	[BUGGY] options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^103^^^^^96^104^
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY]  } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^99^^^^96^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 4 , 2 ) ) ; [FE]  String index out of range: -2 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 4 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if (option = = null ) {[FE]  Unexpected exception: Unrecognized option: -e assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( option = = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^80^160^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^80^160^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 4 , 2 ) ) ; [FE]  String index out of range: -2 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 4 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 , 2 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 2 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 2 * 2 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 2 * 2 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2L ) ) ; [CE] no suitable method found for substring(long)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2L ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^80^160^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = null ) && ( option ! = null ) ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) && ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^80^160^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( ( currentOption = = null ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( ( currentOption = = null ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( currentOption = = null ) {[FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( currentOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^80^160^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^^^^^80^160^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^80^160^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 1 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( 1 ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^119^154^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( false )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . toArray ( false ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArgs ( ) )  tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( null )  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( null ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[ADD]  currentOption  =  null; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^119^154^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^80^160^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^80^160^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^80^160^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^80^160^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^132^133^134^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[ADD]  else  if  (  currentOption  !=  null  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^143^144^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^80^160^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^147^148^149^80^160^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = this ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = this ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^80^160^
[ADD]  currentOption  =  null; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 2 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 >> 4 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 >> 4 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REMOVE]   	[BUGGY] tokens . add ( arguments[i] ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;  tokens . add ( arguments[i] )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 + 0 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 + 0 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 5 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 5 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " )  ;  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^80^160^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArg ( )  ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^119^154^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^^^^^119^154^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = true ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = true ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^119^154^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^119^154^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( specialOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( specialOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^80^160^
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^128^129^^80^160^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^80^160^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( specialOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[REPLACE]  currentOption  =  option; 	[BUGGY] currentOption = null ;  ; [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { [BUGGY] currentOption = null ;  ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^108^^^^^80^160^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = true ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = true ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^80^160^
[REPLACE]  Option  option  =  options  .  getOption  (  arguments[i]  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [CE] cannot find symbol option  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^82^^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( i )  ) ; [FE]  String index out of range: -1 assertTrue(   "Confirm -a is set  " , cl.hasOption(  "a  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( i )  )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = specialOption ) {[CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = specialOption ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^63^172^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = false ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = false ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if (specialOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REMOVE]   	[BUGGY] options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( specialOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^128^129^^119^154^
[ADD]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArgs ( ) )  tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^128^129^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( specialOption = = null ) {[FE]  Confirm -c is set assertTrue(   "Confirm -c is set  " , cl.hasOption(  "c  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^85^155^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " )  ;  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 3 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( current   ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( current ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( specialOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( specialOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^119^154^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " )  ;  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^119^154^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = option ;  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = option ;  ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^119^154^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = specialOption ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = specialOption ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( true )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( true ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[REMOVE]   	[BUGGY] options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] tokens . add ( arguments[i] ) ;  options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = this ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = this ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^85^155^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " )  ;  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 * 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 * 1 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if (option = = null ) {[FE]  Unexpected exception: Unrecognized option: -e assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( option = = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 4 ) ) ; [FE]  AssertionFailedError  expected:<[pr]operty> but was:<[]operty> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 4 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REMOVE]   	[BUGGY] tokens . add ( arguments[i] ) ; [FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 ) ) ;  tokens . add ( arguments[i] )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( this ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^103^^^^^96^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) ) ; [FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = null ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^63^172^
[ADD]  if  (  specialOption  !=  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^93^94^95^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^63^172^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^^^^^63^172^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^63^172^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( i )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( i )  )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 + 3 ) ) ; [FE]  AssertionFailedError  expected:<p[rop]erty> but was:<p[]erty> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 + 3 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 ) ) ; [FE]  AssertionFailedError  expected:<[]property> but was:<[-D]property> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 0 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^63^172^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = null ) && ( option ! = null ) ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) && ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^63^172^
[ADD]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY]   else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^116^117^118^63^172^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = null ) && currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^63^172^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( specialOption = = null ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^63^172^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^63^172^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^147^148^149^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( false )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( false ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^63^172^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^63^172^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^63^172^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^63^172^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^^^^^63^172^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^132^133^134^63^172^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^63^172^
[ADD]  else  if  (  currentOption  !=  null  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^143^144^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^63^172^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " )  ;  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^145^154^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = this ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = this ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 0 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( specialOption = = null ) ) {[FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( specialOption = = null ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^63^172^
[ADD]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY]   currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^121^122^123^63^172^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if (specialOption = = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = false ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^63^172^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^^^^^63^172^
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY]   else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^123^124^125^119^154^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( specialOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( specialOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^63^172^
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY]   else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^123^124^125^63^172^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^63^172^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^63^172^
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^128^129^^63^172^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^63^172^
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [FE] NullPointerException assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY]  } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^99^^^^63^172^
[REPLACE]  currentOption  =  option; 	[BUGGY] currentOption = null ;  ; [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { [BUGGY] currentOption = null ;  ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^108^^^^^63^172^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = option ;  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = option ;  ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^63^172^
[ADD]  currentOption  =  null; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^63^172^
[REPLACE]  Option  option  =  options  .  getOption  (  arguments[i]  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [CE] cannot find symbol option  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^82^^^^^63^172^
[ADD]  Option  option  =  options  .  getOption  (  arguments[i]  )  ; 	[BUGGY] [CE] cannot find symbol option  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { [BUGGY]   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^82^^^^^63^172^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^63^172^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( i )  ) ; [FE]  String index out of range: -1 assertTrue(   "Confirm -a is set  " , cl.hasOption(  "a  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( i )  )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^63^172^
[REPLACE]  tokens  .  add  (    "-  "  )  ; 	[BUGGY] tokens . toArray (   "-  " ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if (   "-  " . equals ( arguments[i] ) ) { [BUGGY] tokens . toArray (   "-  " )  ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^78^^^^^76^160^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { [BUGGY] tokens . toArray ( null ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^159^^^^^80^160^
[ADD]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^159^^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = false ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^80^160^
[REMOVE]   	[BUGGY] if ( arguments[i] . startsWith (   "-  " ) ) {   Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {     Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;     if ( specialOption ! = null ) {       tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;       tokens . add ( arguments[i] . substring ( 2 ) ) ;     }else       if ( stopAtNonOption ) {         eatTheRest = true ;         tokens . add ( arguments[i] ) ;       }else {         tokens . add ( arguments[i] ) ;       }       }else {     currentOption = option ;     Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;     if ( ( specialOption ! = null ) && ( option = = null ) ) {       tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;       tokens . add ( arguments[i] . substring ( 2 ) ) ;     }else       if ( ( currentOption ! = null ) && ( currentOption . hasArg ( ) ) ) {         if ( currentOption . hasArg ( ) ) {           tokens . add ( arguments[i] ) ;           currentOption = null ;         }else           if ( currentOption . hasArgs ( ) ) {             tokens . add ( arguments[i] ) ;           }else             if ( stopAtNonOption ) {               eatTheRest = true ;               tokens . add (   "--  " ) ;               tokens . add ( arguments[i] ) ;             }else {               tokens . add ( arguments[i] ) ;             }                          }else         if ( currentOption ! = null ) {           tokens . add ( arguments[i] ) ;         }else           if ( stopAtNonOption ) {             eatTheRest = true ;             tokens . add (   "--  " ) ;             tokens . add ( arguments[i] ) ;           }else {             tokens . add ( arguments[i] ) ;           }                      } }else {   tokens . add ( arguments[i] ) ; }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option = = null )  if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] )  ; if ( option = = null ) { Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; }}else { currentOption = option ; Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) )  ; }else if ( ( currentOption ! = null ) && ( currentOption . hasArg ( ) ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] )  ; currentOption = null ; }else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " )  ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; } }else if ( currentOption ! = null ) { tokens . add ( arguments[i] )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " )  ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; }} }else { tokens . add ( arguments[i] )  ; }{  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^^^^^80^160^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( (true ) && ( option ! = null ) ) {[FE]  Unexpected exception:Unrecognized option: -b assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( true ) && ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 0 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( 0 ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 - 4 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 - 4 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 2 - 4 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 2 - 4 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REMOVE]   	[BUGGY] tokens . add ( arguments[i] ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 ) ) ;  tokens . add ( arguments[i] )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( ( currentOption = = null ) && currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( ( currentOption = = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( currentOption = = null ) {[FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( currentOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 4 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 4 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = null ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^85^155^
[ADD]  if  (  specialOption  !=  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^93^94^95^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 % 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 % 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REMOVE]   	[BUGGY] tokens . add ( arguments[i] ) ; [FE]  AssertionFailedError  expected:<[]property> but was:<[-D]property> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;  tokens . add ( arguments[i] )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( i , i )  ) ; [FE]  AssertionFailedError  expected:<[property]> but was:<[]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( i , i )  )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [FE] NullPointerException assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY]  } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^99^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = null ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 1 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( 1 ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^103^^^^^96^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 3 ) ) ; [FE]  AssertionFailedError  expected:<[p]roperty> but was:<[]roperty> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 3 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 4 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 4 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY]   else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^98^99^100^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( false )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( false ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^103^^^^^96^104^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = null ) ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^80^160^
[ADD]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY]   else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^116^117^118^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = true ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . toArray ( this ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 4 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 4 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = null ) && currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if (specialOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( specialOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 1 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( 1 ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^138^^^^^130^139^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^80^160^
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [FE] NullPointerException assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY]  } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^99^^^^80^160^
[ADD]  currentOption  =  option; 	[BUGGY] [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { [BUGGY]   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^108^^^^^80^160^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = false ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = false ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^80^160^
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = false ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^63^172^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( (true ) ) {[FE]  Unexpected exception:Unrecognized option: -b assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( true ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^85^155^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( ( specialOption = = true ) && currentOption . hasArg ( ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( ( specialOption = = true ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if (specialOption = = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( specialOption = = true ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( true )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] tokens . toArray ( true ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( specialOption . hasArg ( )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( specialOption . hasArg ( )  ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( specialOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( specialOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( false )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] tokens . toArray ( false ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( i )  ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( i )  )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 5 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 5 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = false ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 % 0 , 2 ) ) ; [FE]  / by zero assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 % 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 1 ) ) ; [FE]  AssertionFailedError  expected:<[]property> but was:<[D]property> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 1 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 / 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 / 1 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = option ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = option ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 * 0 ) ) ; [FE]  AssertionFailedError  expected:<[]property> but was:<[-D]property> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 * 0 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = false ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = false ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^63^172^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( true ( ) ) {[CE] ')' expected  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( true ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^63^172^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^63^172^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^63^172^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( specialOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^119^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( specialOption . hasArgs ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " )  ;  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( this ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 / 4 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 / 4 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 % 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 % 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 3 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^63^172^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( specialOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( specialOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^63^172^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] tokens . add (   "--  " ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " )  ;  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^63^172^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArgs ( ) )  tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^63^172^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = true ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = true ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^63^172^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >>> 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >>> 0 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^63^172^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if (   "--  " . equals ( arguments[i] ) ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^73^^^^^71^160^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if (   "--  " . equals ( arguments[i] ) ) { [BUGGY] tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^73^^^^^71^160^
[REPLACE]  else  if  (  arguments[i]  .  startsWith  (    "-  "  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } [BUGGY] else { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^80^81^^^^63^172^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = null ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^80^160^
[ADD]  if  (  option  ==  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY]    if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^88^89^80^160^
[ADD]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY]   else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^116^117^118^85^155^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^119^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 - 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 - 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 % 3 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 % 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( true ( ) ) {[CE] ')' expected  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( true ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( currentOption = = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( currentOption = = true ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( specialOption . hasArgs ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 * 4 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 * 4 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if (option = = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( option = = false ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^85^155^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY]   else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^98^99^100^85^155^
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . add ( arguments[i] ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] tokens . add ( arguments[i] )  ;  } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^99^^^^96^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 / 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 / 2 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0L , 2 ) ) ; [CE] no suitable method found for substring(long , int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0L , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[ADD]  if  (  specialOption  !=  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^93^94^95^80^160^
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 2 ) )  ;  } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^94^^^^91^104^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( stopAtNonOption ) && ( option ! = null ) ) {[FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( stopAtNonOption ) && ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = false ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 % 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 % 2 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[ADD]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY]   currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^121^122^123^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = specialOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = specialOption ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY]   else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^123^124^125^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 + 3 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 + 3 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = true ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^63^172^
[ADD]  if  (  option  ==  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY]    if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^88^89^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0L , 2 ) ) ; [CE] no suitable method found for substring(long , int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0L , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = this ) && currentOption . hasArg ( ) ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = this ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 1 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] tokens . toArray ( 1 ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = false ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 * 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 * 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 >>> 1 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 >>> 1 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = this ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = this ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 2 , 2 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . toArray ( arguments[i] . substring ( 2 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY]   else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^98^99^100^63^172^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = this ) && ( option ! = this ) ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = this ) && ( option ! = this ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^63^172^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if (specialOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^63^172^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArg ( )  ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^63^172^
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 2 ) )  ;  } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^117^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 4 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 4 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( ( specialOption = = null ) && currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( ( specialOption = = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^63^172^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if (specialOption = = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( specialOption = = true ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^63^172^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( specialOption . hasArg ( )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( specialOption . hasArg ( )  ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^63^172^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( specialOption = = this ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( specialOption = = this ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^63^172^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 << 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 << 1 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^63^172^
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^63^172^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 4 , 2 ) ) ; [FE]  String index out of range: -2 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 4 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^63^172^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = true ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^80^160^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = this ) && ( option ! = this ) ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = this ) && ( option ! = this ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^85^155^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = null ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = null ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = false ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 - 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 - 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY]  } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^117^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 4 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . toArray ( arguments[i] . substring ( 4 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if (specialOption = = null ) {[FE]  Confirm -c is set assertTrue(   "Confirm -c is set  " , cl.hasOption(  "c  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 1 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . toArray ( 1 ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^128^^^^^126^139^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0L , 2 ) ) ; [CE] no suitable method found for substring(long , int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0L , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 * 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 * 2 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 - 1 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 - 1 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 - 1 ) ) ; [FE]  AssertionFailedError  expected:<[]property> but was:<[D]property> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 - 1 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( specialOption = = this ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = this ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 0 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( 0 ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^80^160^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( )  ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( currentOption . hasArgs ( )  ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^80^160^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 * 0 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 * 0 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = null ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = null ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^80^160^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^^^^^80^160^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = option ;  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = option ;  ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^80^160^
[ADD]  Option  option  =  options  .  getOption  (  arguments[i]  )  ; 	[BUGGY] [CE] cannot find symbol option  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { [BUGGY]   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^82^^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) ) ; [FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if (specialOption ! = null ) {[CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( specialOption ! = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^63^172^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if (  ( option ! = null ) ) {[FE]  Unexpected exception:Unrecognized option: -b assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if (  ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^85^155^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2L ) ) ; [CE] no suitable method found for substring(long)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2L ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 2 - 3 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 2 - 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 - 1 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 - 1 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( option = = null ) {[FE]  Unexpected exception: Unrecognized option: -e assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( option = = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 4 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . toArray ( arguments[i] . substring ( 4 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >>> 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >>> 2 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 >> 0 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 >> 0 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if (  ( option ! = null ) ) {[FE]  Unexpected exception:Unrecognized option: -b assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if (  ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^63^172^
[REMOVE]   	[BUGGY] if ( arguments[i] . startsWith (   "-  " ) ) {   Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {     Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;     if ( specialOption ! = null ) {       tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;       tokens . add ( arguments[i] . substring ( 2 ) ) ;     }else       if ( stopAtNonOption ) {         eatTheRest = true ;         tokens . add ( arguments[i] ) ;       }else {         tokens . add ( arguments[i] ) ;       }       }else {     currentOption = option ;     Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;     if ( ( specialOption ! = null ) && ( option = = null ) ) {       tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;       tokens . add ( arguments[i] . substring ( 2 ) ) ;     }else       if ( ( currentOption ! = null ) && ( currentOption . hasArg ( ) ) ) {         if ( currentOption . hasArg ( ) ) {           tokens . add ( arguments[i] ) ;           currentOption = null ;         }else           if ( currentOption . hasArgs ( ) ) {             tokens . add ( arguments[i] ) ;           }else             if ( stopAtNonOption ) {               eatTheRest = true ;               tokens . add (   "--  " ) ;               tokens . add ( arguments[i] ) ;             }else {               tokens . add ( arguments[i] ) ;             }                          }else         if ( currentOption ! = null ) {           tokens . add ( arguments[i] ) ;         }else           if ( stopAtNonOption ) {             eatTheRest = true ;             tokens . add (   "--  " ) ;             tokens . add ( arguments[i] ) ;           }else {             tokens . add ( arguments[i] ) ;           }                      } }else {   tokens . add ( arguments[i] ) ; }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) && ( option = = null ) )  if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] )  ; if ( option = = null ) { Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; }}else { currentOption = option ; Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) )  ; }else if ( ( currentOption ! = null ) && ( currentOption . hasArg ( ) ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] )  ; currentOption = null ; }else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " )  ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; } }else if ( currentOption ! = null ) { tokens . add ( arguments[i] )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " )  ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; }} }else { tokens . add ( arguments[i] )  ; }{ tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^^^^^63^172^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( ( currentOption = = null ) && currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( ( currentOption = = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^63^172^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 / 3 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 / 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^63^172^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^63^172^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( specialOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^63^172^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^63^172^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = specialOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = specialOption ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^63^172^
[REPLACE]  if  (  eatTheRest  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^162^163^^^^63^172^
[REPLACE]  for  (  i++;  i  <  arguments  .  length;  i++  )  { 	[BUGGY] for ( i++ ; i < arguments . length - 4 ; i++ ) {[FE] NullPointerException assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( eatTheRest ) { [BUGGY] for ( i++ ; i < arguments . length - 4 ; i++ ) { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^164^165^^^^162^168^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( arguments[i] ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { [BUGGY] tokens . toArray ( arguments[i] )  ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^166^^^^^162^168^
[REPLACE]  for  (  int  i  =  0;  i  <  arguments  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < arguments . length ( ) ; i++ ) {[CE] cannot find symbol  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  [BUGGY] for ( int i = 0 ; i < arguments . length ( )  ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^69^70^^^^63^172^
[REPLACE]  if  (    "--  "  .  equals  (  arguments[i]  )  )  { 	[BUGGY] else if (   "-  " . equals ( arguments[i] ) )[CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { [BUGGY] else if (   "-  " . equals ( arguments[i] ) )  eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^71^72^^^^69^169^
[REPLACE]  else  if  (    "-  "  .  equals  (  arguments[i]  )  )  { 	[BUGGY] else if (   "-  " . equals ( arguments[i] ) )[CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } [BUGGY] else if (   "-  " . equals ( arguments[i] ) )  tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^76^77^^^^69^169^
[REPLACE]  else  if  (  arguments[i]  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( arguments[i] . startsWith (   "-  " ) ) {[FE]  String index out of range: 2 assertTrue(   "Confirm -a is set  " , cl.hasOption(  "a  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } [BUGGY] if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^80^81^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 1 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { [BUGGY] tokens . toArray ( 1 ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^159^^^^^80^160^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = null ) && ( option ! = null ) ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) && ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^85^155^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( specialOption = = this ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = this ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 0 % 2 , 2 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . toArray ( arguments[i] . substring ( 0 % 2 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 2 + 4 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . toArray ( arguments[i] . substring ( 2 + 4 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 2L ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 2L ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if (  ( option ! = null ) ) {[FE]  Unexpected exception:Unrecognized option: -b assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if (  ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { [BUGGY] options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^153^^^^^145^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArg ( )  ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( currentOption = = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( currentOption = = false ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 / 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 / 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 3 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . toArray ( arguments[i] . substring ( 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^80^160^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^119^154^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >> 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >> 3 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^80^160^
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = true ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^69^169^
[ADD]  if  (  option  ==  null  )  {  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY]    if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^88^89^69^169^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = false ) && ( option ! = false ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = false ) && ( option ! = false ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 * 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 * 1 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 4 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 4 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = option ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = option ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 + 4 , 2 ) ) ; [FE]  String index out of range: -2 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 + 4 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 2 >> 2 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 2 >> 2 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 5 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 5 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 << 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 << 0 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( option = = null ) {[FE]  Unexpected exception: Unrecognized option: -e assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( option = = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^69^169^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^69^169^
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . add ( arguments[i] ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add ( arguments[i] )  ;  } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^99^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^69^169^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY]   else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^98^99^100^69^169^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if (  ( option ! = null ) ) {[FE]  Unexpected exception:Unrecognized option: -b assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if (  ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^69^169^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = null ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = null ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^69^169^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( currentOption = = null ) {[FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( currentOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^69^169^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^69^169^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^147^148^149^69^169^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( specialOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( specialOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^69^169^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^69^169^
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^128^129^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^69^169^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^69^169^
[ADD]  else  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY]   } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^132^133^134^69^169^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^69^169^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^^^^^69^169^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^69^169^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = true ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = true ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 - 3 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 - 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 >>> 3 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 >>> 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( ( currentOption = = true ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( ( currentOption = = true ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^69^169^
[ADD]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  {  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY]   currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^121^122^123^69^169^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( currentOption = = specialOption ) {[FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( currentOption = = specialOption ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^69^169^
[ADD]  else  if  (  currentOption  !=  null  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^143^144^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^69^169^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^^^^^69^169^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( )  ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( currentOption . hasArgs ( )  ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^69^169^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^69^169^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^69^169^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^147^148^^^^69^169^
[REPLACE]  currentOption  =  option; 	[BUGGY] currentOption = null ;  ; [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { [BUGGY] currentOption = null ;  ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^108^^^^^69^169^
[REPLACE]  Option  option  =  options  .  getOption  (  arguments[i]  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ; [CE] cannot find symbol option  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^82^^^^^69^169^
[ADD]  Option  option  =  options  .  getOption  (  arguments[i]  )  ; 	[BUGGY] [CE] cannot find symbol option  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { [BUGGY]   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^82^^^^^69^169^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 / 0 , 2 ) ) ; [FE]  / by zero assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 / 0 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^69^169^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0L , 2 ) ) ; [CE] no suitable method found for substring(long , int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0L , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^69^169^
[REPLACE]  tokens  .  add  (    "-  "  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if (   "-  " . equals ( arguments[i] ) ) { [BUGGY] tokens . toArray ( this ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^78^^^^^76^160^
[ADD]  tokens  .  add  (    "-  "  )  ; 	[BUGGY] [FE]  org.apache.commons.cli.MissingArgumentException: Missing argument for option:b assertTrue(   "Confirm -a is set  " , cl.hasOption(  "a  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if (   "-  " . equals ( arguments[i] ) ) { [BUGGY] } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^78^^^^^76^160^
[REPLACE]  else  if  (  arguments[i]  .  startsWith  (    "-  "  )  )  { 	[BUGGY] else if ( arguments[i] . startsWith (   "-  " ) )[CE] not a statement  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } [BUGGY] else if ( arguments[i] . startsWith (   "-  " ) )  Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^80^81^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { [BUGGY] tokens . toArray ( this ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^159^^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = option ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = option ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if ( currentOption = = this ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( currentOption = = this ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 2 , 2 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . toArray ( arguments[i] . substring ( 2 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 2 + 4 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 2 + 4 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( ( currentOption = = true ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( ( currentOption = = true ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 >> 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 >> 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 >> 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 >> 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(GnuParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . toArray ( this ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 + 3 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 + 3 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( true ( ) ) {[CE] ')' expected  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( true ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^80^160^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] else if (specialOption = = null ) {[FE]  Confirm -c is set assertTrue(   "Confirm -c is set  " , cl.hasOption(  "c  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] else if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( i )  ) ; [FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( i )  )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if (specialOption ! = null ) {[CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( specialOption ! = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 * 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 * 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0L , 2 ) ) ; [CE] no suitable method found for substring(long , int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0L , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 5 ) ) ; [FE]  AssertionFailedError  expected:<p[rop]erty> but was:<p[]erty> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 5 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 0 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 0 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( i )  ) ; [FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( i )  )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^^^^^69^169^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 - 3 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 - 3 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( true )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { [BUGGY] tokens . toArray ( true ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^103^^^^^96^104^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = null ) && ( option ! = null ) ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) && ( option ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^69^169^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^130^131^^^^69^169^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if (specialOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^69^169^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = false ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = false ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^69^169^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { [BUGGY]  tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^132^133^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 >>> 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 >>> 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 2 << 0 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 2 << 0 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^69^169^
[REMOVE]   	[BUGGY] if ( eatTheRest ) {   for ( i++ ; i < ( arguments . length ) ; i++ ) {     tokens . add ( arguments[i] ) ;   } }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] else if ( stopAtNonOption )  if ( eatTheRest ) { for ( i++ ; i < ( arguments . length )  ; i++ ) { tokens . add ( arguments[i] )  ; } }{ eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^^^^^69^169^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^69^169^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( specialOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^69^169^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( specialOption = = null ) {[FE]  Unexpected exception:Missing argument for option:buildfile assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^69^169^
[ADD]  currentOption  =  option; 	[BUGGY] [FE]  exec option not found assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { [BUGGY]   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^108^^^^^69^169^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = option ;  ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] currentOption = option ;  ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^69^169^
[ADD]  currentOption  =  null; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; [BUGGY] } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^124^^^^^69^169^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) ) ; [FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^69^169^
[ADD]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] [CE] cannot find symbol specialOption  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^69^169^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^69^169^
[ADD]  eatTheRest  =  true;  tokens  .  add  (    "--  "  )  ; 	[BUGGY] [FE]  Confirm -b is not set assertTrue(   "Confirm -c is set  " , cl.hasOption(  "c  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if (   "--  " . equals ( arguments[i] ) ) { [BUGGY]  } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^73^74^^^^71^160^
[REPLACE]  else  if  (    "-  "  .  equals  (  arguments[i]  )  )  { 	[BUGGY] if (   "-  " . equals ( arguments[i] ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } [BUGGY] if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^76^77^^^^69^169^
[ADD]  else  if  (    "-  "  .  equals  (  arguments[i]  )  )  {  tokens  .  add  (    "-  "  )  ;  } 	[BUGGY] [FE]  String index out of range: 2 assertTrue(   "Confirm -a is set  " , cl.hasOption(  "a  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } [BUGGY]   else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^76^77^78^79^^69^169^
[ADD]  else  if  (  arguments[i]  .  startsWith  (    "-  "  )  )  {  Option  option  =  options  .  getOption  (  arguments[i]  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } [BUGGY]    if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^80^81^82^^^69^169^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = this ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = this ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^80^160^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( specialOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 << 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 << 1 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >>> 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >>> 1 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . add ( arguments[i] ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY] tokens . add ( arguments[i] )  ;  } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^99^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 3 , 2 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . toArray ( arguments[i] . substring ( 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 - 3 , 2 ) ) ; [FE]  String index out of range: -3 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 - 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[ADD]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY]  } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^94^^^^91^104^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = false ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = false ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^145^146^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 2 - 4 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . toArray ( arguments[i] . substring ( 2 - 4 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 4 , 2 ) ) ; [FE]  String index out of range: -2 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 4 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^80^160^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = null ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^69^169^
[REMOVE]   	[BUGGY] if ( arguments[i] . startsWith (   "-  " ) ) {   Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {     Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;     if ( specialOption ! = null ) {       tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;       tokens . add ( arguments[i] . substring ( 2 ) ) ;     }else       if ( stopAtNonOption ) {         eatTheRest = true ;         tokens . add ( arguments[i] ) ;       }else {         tokens . add ( arguments[i] ) ;       }       }else {     currentOption = option ;     Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;     if ( ( specialOption ! = null ) && ( option = = null ) ) {       tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;       tokens . add ( arguments[i] . substring ( 2 ) ) ;     }else       if ( ( currentOption ! = null ) && ( currentOption . hasArg ( ) ) ) {         if ( currentOption . hasArg ( ) ) {           tokens . add ( arguments[i] ) ;           currentOption = null ;         }else           if ( currentOption . hasArgs ( ) ) {             tokens . add ( arguments[i] ) ;           }else             if ( stopAtNonOption ) {               eatTheRest = true ;               tokens . add (   "--  " ) ;               tokens . add ( arguments[i] ) ;             }else {               tokens . add ( arguments[i] ) ;             }                          }else         if ( currentOption ! = null ) {           tokens . add ( arguments[i] ) ;         }else           if ( stopAtNonOption ) {             eatTheRest = true ;             tokens . add (   "--  " ) ;             tokens . add ( arguments[i] ) ;           }else {             tokens . add ( arguments[i] ) ;           }                      } }else {   tokens . add ( arguments[i] ) ; }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option = = null )  if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] )  ; if ( option = = null ) { Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; }}else { currentOption = option ; Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) )  ; }else if ( ( currentOption ! = null ) && ( currentOption . hasArg ( ) ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] )  ; currentOption = null ; }else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " )  ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; } }else if ( currentOption ! = null ) { tokens . add ( arguments[i] )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " )  ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; }} }else { tokens . add ( arguments[i] )  ; }{  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 - 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 - 1 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( 0 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( currentOption ! = null ) { [BUGGY] tokens . toArray ( 0 ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^143^^^^^141^154^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if (option = = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( option = = true ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 / 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 / 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = true ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = true ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^69^169^
[ADD]  if  (  specialOption  !=  null  )  {  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ;  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY]   else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^93^94^95^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( true ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^69^169^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = true ) && ( option ! = true ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = true ) && ( option ! = true ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 * 3 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 * 3 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( currentOption . hasArg ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^69^169^
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  arguments[i]  )  ;  currentOption  =  null;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY]   else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^123^124^125^69^169^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) ) ; [FE]  String index out of range: -1 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 3 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^69^169^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >>> 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 >>> 2 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^69^169^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if (option ! = null ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   [BUGGY] if ( option ! = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^85^86^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 >> 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 >> 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArg ( )  ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArg ( )  ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 * 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 * 2 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . equals ( 1 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . equals ( 1 ) )  ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 1 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = false ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^80^160^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] else if ( stopAtNonOption )  eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^80^160^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 0 + 0 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { [BUGGY] tokens . add ( arguments[i] . substring ( 0 + 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^93^^^^^91^104^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . toArray ( false )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . toArray ( false ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^94^^^^^91^104^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if (  ( option ! = false ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if (  ( option ! = false ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^80^160^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = this ) ) {[CE] incomparable types: Option and GnuParser  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = this ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^80^160^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( specialOption . hasArgs ( ) ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^80^160^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = false ) && currentOption . hasArg ( ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = false ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^80^160^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 / 0 , 2 ) ) ; [FE]  / by zero assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 / 0 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^80^160^
[REMOVE]   	[BUGGY] if ( arguments[i] . startsWith (   "-  " ) ) {   Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {     Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;     if ( specialOption ! = null ) {       tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;       tokens . add ( arguments[i] . substring ( 2 ) ) ;     }else       if ( stopAtNonOption ) {         eatTheRest = true ;         tokens . add ( arguments[i] ) ;       }else {         tokens . add ( arguments[i] ) ;       }       }else {     currentOption = option ;     Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;     if ( ( specialOption ! = null ) && ( option = = null ) ) {       tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ;       tokens . add ( arguments[i] . substring ( 2 ) ) ;     }else       if ( ( currentOption ! = null ) && ( currentOption . hasArg ( ) ) ) {         if ( currentOption . hasArg ( ) ) {           tokens . add ( arguments[i] ) ;           currentOption = null ;         }else           if ( currentOption . hasArgs ( ) ) {             tokens . add ( arguments[i] ) ;           }else             if ( stopAtNonOption ) {               eatTheRest = true ;               tokens . add (   "--  " ) ;               tokens . add ( arguments[i] ) ;             }else {               tokens . add ( arguments[i] ) ;             }                          }else         if ( currentOption ! = null ) {           tokens . add ( arguments[i] ) ;         }else           if ( stopAtNonOption ) {             eatTheRest = true ;             tokens . add (   "--  " ) ;             tokens . add ( arguments[i] ) ;           }else {             tokens . add ( arguments[i] ) ;           }                      } }else {   tokens . add ( arguments[i] ) ; }[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) && ( option = = null ) )  if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] )  ; if ( option = = null ) { Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; }}else { currentOption = option ; Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) )  ; if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) )  ; }else if ( ( currentOption ! = null ) && ( currentOption . hasArg ( ) ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] )  ; currentOption = null ; }else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " )  ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; } }else if ( currentOption ! = null ) { tokens . add ( arguments[i] )  ; }else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " )  ; tokens . add ( arguments[i] )  ; }else { tokens . add ( arguments[i] )  ; }} }else { tokens . add ( arguments[i] )  ; }{ tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^^^^^85^155^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] tokens . toArray ( arguments[i] . substring ( 1 , 2 ) ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { [BUGGY] tokens . toArray ( arguments[i] . substring ( 1 , 2 ) )  ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^116^^^^^114^154^
[REPLACE]  tokens  .  add  (  arguments[i]  .  substring  (  2  )  )  ; 	[BUGGY] tokens . add ( arguments[i] . substring ( 2 - 4 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; [BUGGY] tokens . add ( arguments[i] . substring ( 2 - 4 ) )  ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^117^^^^^114^154^
[REPLACE]  else  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = true ) && currentOption . hasArg ( ) ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( ( currentOption = = true ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^119^120^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 % 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 % 2 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^85^155^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 - 3 , 2 ) ) ; [FE]  String index out of range: -3 assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0 - 3 , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^85^155^
[REPLACE]  if  (  specialOption  !=  null  )  { 	[BUGGY] if ( specialOption = = null ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( specialOption = = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^91^92^^^^69^169^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE]  AssertionFailedError  expected:<[property1]> but was:<[-Dproperty]> assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } [BUGGY] if ( true ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^96^97^^^^69^169^
[ADD]  eatTheRest  =  true;  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] [FE] NullPointerException assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { [BUGGY]  } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^98^99^^^^69^169^
[REPLACE]  if  (  (  specialOption  !=  null  )  &&  (  option  ==  null  )  )  { 	[BUGGY] if ( ( specialOption ! = null ) ) {[FE]  AssertionFailedError  expected:<[]> but was:<[value]> assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  [BUGGY] if ( ( specialOption ! = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^114^115^^^^69^169^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( specialOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] if ( specialOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^121^122^^^^69^169^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) )[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArgs ( ) )  tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^126^127^^^^69^169^
[REPLACE]  else  if  (  currentOption  !=  null  )  { 	[BUGGY] if ( currentOption = = false ) {[CE] incomparable types: Option and boolean  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } [BUGGY] if ( currentOption = = false ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^141^142^^^^69^169^
[REPLACE]  if  (  eatTheRest  )  { 	[BUGGY] if ( true ) {[FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } [BUGGY] if ( true ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^162^163^^^^69^169^
[REPLACE]  for  (  i++;  i  <  arguments  .  length;  i++  )  { 	[BUGGY] for ( i++ ; i < arguments . length ( ) ; i++ ) {[CE] cannot find symbol  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( eatTheRest ) { [BUGGY] for ( i++ ; i < arguments . length ( )  ; i++ ) { tokens . add ( arguments[i] ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^164^165^^^^162^168^
[ADD]  for  (  i++;  i  <  arguments  .  length;  i++  )  {  tokens  .  add  (  arguments[i]  )  ;  } 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  if ( eatTheRest ) { [BUGGY]   }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^164^165^166^167^^162^168^
[REPLACE]  for  (  i++;  i  <  arguments  .  length;  i++  )  { 	[BUGGY] for ( i++ ; i < arguments . length - 2 ; i++ ) {[FE] NullPointerException assertTrue( cmd.hasOption(  "exec_opt1  ") )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { [BUGGY] for ( i++ ; i < arguments . length - 2 ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^164^165^^^^69^169^
[REPLACE]  tokens  .  add  (  arguments[i]  )  ; 	[BUGGY] tokens . toArray ( arguments[i] ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( i++ ; i < arguments . length ; i++ ) { [BUGGY] tokens . toArray ( arguments[i] )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^166^^^^^164^167^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^73^^^^^69^169^
[ADD]  eatTheRest  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { [BUGGY] tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^73^^^^^69^169^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0L , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 0L , 2 ) )  ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^88^89^^^^69^169^
[REPLACE]  Option  specialOption  =  options  .  getOption  (  arguments[i]  .  substring  (  0,  2  )  )  ; 	[BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) ) ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   [BUGGY] Option specialOption = options . getOption ( arguments[i] . substring ( 2 , 2 ) )  ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^111^112^^^^69^169^
[REPLACE]  for  (  i++;  i  <  arguments  .  length;  i++  )  { 	[BUGGY] for ( i++ ; i < arguments . length ( ) ; i++ ) {[CE] cannot find symbol  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { [BUGGY] for ( i++ ; i < arguments . length ( )  ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^164^165^^^^63^172^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^73^^^^^63^172^
[REPLACE]  for  (  int  i  =  0;  i  <  arguments  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < arguments . length ; i++ ) {[NO-ERROR]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  [BUGGY] for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^69^70^^^^63^172^
[REPLACE]  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {  }  )  ; 	[BUGGY] return ( String[] ) tokens . ArrayList ( new String[] { } ) ; [CE] cannot find symbol  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] GnuParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption option specialOption [TYPE] String[] arguments [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] int i  [CONTEXT]  { init ( ) ;  boolean eatTheRest = false ; Option currentOption = null ;  for ( int i = 0 ; i < arguments . length ; i++ ) { if (   "--  " . equals ( arguments[i] ) ) { eatTheRest = true ; tokens . add (   "--  " ) ; } else if (   "-  " . equals ( arguments[i] ) ) { tokens . add (   "-  " ) ; } else if ( arguments[i] . startsWith (   "-  " ) ) { Option option = options . getOption ( arguments[i] ) ;   if ( option = = null ) {  Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( specialOption ! = null ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else { currentOption = option ;   Option specialOption = options . getOption ( arguments[i] . substring ( 0 , 2 ) ) ;  if ( ( specialOption ! = null ) && ( option = = null ) ) { tokens . add ( arguments[i] . substring ( 0 , 2 ) ) ; tokens . add ( arguments[i] . substring ( 2 ) ) ; } else if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( arguments[i] ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } else if ( currentOption ! = null ) { tokens . add ( arguments[i] ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( arguments[i] ) ; } else { tokens . add ( arguments[i] ) ; } } } else { tokens . add ( arguments[i] ) ; } if ( eatTheRest ) { for ( i++ ; i < arguments . length ; i++ ) { tokens . add ( arguments[i] ) ; } } } [BUGGY] return ( String[] ) tokens . ArrayList ( new String[] {} )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/GnuParser.java^171^^^^^63^172^
[REPLACE]  private  static  String  longopt; 	[BUGGY] private String longopt ; [CE] non-static variable longopt cannot be referenced from a static context  [CONTEXT]    [CLASS] OptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^31^^^^^^^
[REPLACE]  private  static  String  argName; 	[BUGGY] private static boolean argName ; [CE] incompatible types  [CONTEXT]    [CLASS] OptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^37^^^^^^^
[REPLACE]  private  static  boolean  required; 	[BUGGY] private boolean required ; [CE] non-static variable required cannot be referenced from a static context  [CONTEXT]    [CLASS] OptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^40^^^^^^^
[REPLACE]  private  static  int  numberOfArgs  =  Option  .  UNINITIALIZED; 	[BUGGY] private static int numberOfArgs ; [NO-ERROR]  [CONTEXT]    [CLASS] OptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^43^^^^^^^
[REPLACE]  private  static  boolean  optionalArg; 	[BUGGY] private boolean optionalArg ; [CE] non-static variable optionalArg cannot be referenced from a static context  [CONTEXT]    [CLASS] OptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^49^^^^^^^
[REPLACE]  private  static  char  valuesep; 	[BUGGY] private static String valuesep ; [CE] incompatible types  [CONTEXT]    [CLASS] OptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^52^^^^^^^
[REPLACE]  private  static  OptionBuilder  instance  =  new  OptionBuilder  (  )  ; 	[BUGGY] private static OptionBuilder instance  = null ; [NO-ERROR]  [CONTEXT]    [CLASS] OptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^55^^^^^^^
[REPLACE]  description  =  null; 	[BUGGY] description = false ; [CE] incompatible types  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { [BUGGY] description = false ; argName =   "arg  " ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ;   optionalArg = false ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^70^^^^^68^81^
[ADD]  description  =  null; 	[BUGGY] [NO-ERROR]  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { [BUGGY] argName =   "arg  " ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ;   optionalArg = false ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^70^^^^^68^81^
[REPLACE]  argName  =    "arg  "; 	[BUGGY] argName  =  argName ; [FE]  expected:<usage: dir assertEquals(  "usage: dir  "+eol+  " -d <arg>  dir  "+eol , bytes.toString())   [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { description = null ; [BUGGY] argName = argName ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ;   optionalArg = false ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^71^^^^^68^81^
[REPLACE]  longopt  =  null; 	[BUGGY] longopt = true ; [CE] incompatible types  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { description = null ; argName =   "arg  " ; [BUGGY] longopt = true ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ;   optionalArg = false ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^72^^^^^68^81^
[REPLACE]  type  =  null; 	[BUGGY] type = true ; [FE]  Expected: <null> but was: true assertEquals(   "s  " , simple.getOpt() )   [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { description = null ; argName =   "arg  " ; longopt = null ; [BUGGY] type = true ; required = false ; numberOfArgs = Option . UNINITIALIZED ;   optionalArg = false ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^73^^^^^68^81^
[REPLACE]  required  =  false; 	[BUGGY] required = true ; [FE] NullPointerException assertEquals(   "s  " , simple.getOpt() )   [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { description = null ; argName =   "arg  " ; longopt = null ; type = null ; [BUGGY] required = true ; numberOfArgs = Option . UNINITIALIZED ;   optionalArg = false ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^74^^^^^68^81^
[REPLACE]  numberOfArgs  =  Option  .  UNINITIALIZED; 	[BUGGY] numberOfArgs  = null ; [CE] incompatible types  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { description = null ; argName =   "arg  " ; longopt = null ; type = null ; required = false ; [BUGGY] numberOfArgs = null ;   optionalArg = false ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^75^^^^^68^81^
[ADD]  numberOfArgs  =  Option  .  UNINITIALIZED; 	[BUGGY] [FE]  assertTrue( cmd.hasOption(   "verbose  " ) )   [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { description = null ; argName =   "arg  " ; longopt = null ; type = null ; required = false ; [BUGGY]   optionalArg = false ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^75^^^^^68^81^
[REPLACE]  optionalArg  =  false; 	[BUGGY] optionalArg = true ; [FE]  assertTrue( exp ! = null )   [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { description = null ; argName =   "arg  " ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ;   [BUGGY] optionalArg = true ; valuesep =  ( char ) 0 ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^79^^^^^68^81^
[REPLACE]  valuesep  =  (  char  )  0; 	[BUGGY] OptionBuilder . required = newRequired ;  ; [CE] cannot find symbol newRequired  [METHOD]  reset [TYPE] void [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt [TYPE] int numberOfArgs  [CONTEXT]  private static void reset ( ) { description = null ; argName =   "arg  " ; longopt = null ; type = null ; required = false ; numberOfArgs = Option . UNINITIALIZED ;   optionalArg = false ; [BUGGY] OptionBuilder . required = newRequired ;  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^80^^^^^68^81^
[REPLACE]  OptionBuilder  .  longopt  =  newLongopt; 	[BUGGY] OptionBuilder . longopt =  description ; [FE]  must specify longopt assertTrue( line.hasOption(   "block-size  " ) )   [METHOD]  withLongOpt [TYPE] OptionBuilder [PARAMETER] String newLongopt [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withLongOpt ( String newLongopt ) { [BUGGY] OptionBuilder . longopt = description ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^91^^^^^89^94^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  withLongOpt [TYPE] OptionBuilder [PARAMETER] String newLongopt [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withLongOpt ( String newLongopt ) { OptionBuilder . longopt = newLongopt ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^93^^^^^89^94^
[REPLACE]  OptionBuilder  .  numberOfArgs  =  1; 	[BUGGY] OptionBuilder . numberOfArgs = 1 << 0 ; [NO-ERROR]  [METHOD]  hasArg [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder hasArg ( ) { [BUGGY] OptionBuilder . numberOfArgs = 1 << 0 ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^103^^^^^101^106^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  hasArg [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder hasArg ( ) { OptionBuilder . numberOfArgs = 1 ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^105^^^^^101^106^
[REPLACE]  OptionBuilder  .  numberOfArgs  =  (  hasArg  ==  true  )  ?  1  :  Option  .  UNINITIALIZED; 	[BUGGY] OptionBuilder . numberOfArgs =  ( hasArg ! =  true ) ? 1 : Option . UNINITIALIZED ; [FE]  Missing argument for option:c assertEquals(  "flag a  " ,   "foo  " , line.getOptionValue(  "a  "))   [METHOD]  hasArg [TYPE] OptionBuilder [PARAMETER] boolean hasArg [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder hasArg ( boolean hasArg ) { [BUGGY] OptionBuilder . numberOfArgs = ( hasArg! = true ) ? 1 : Option . UNINITIALIZED ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^117^^^^^115^120^
[ADD]  OptionBuilder  .  numberOfArgs  =  (  hasArg  ==  true  )  ?  1  :  Option  .  UNINITIALIZED; 	[BUGGY] [FE]  AssertionFailedError  flag a expected:<foo> but was:<null> assertEquals(  "flag a  " ,   "foo  " , line.getOptionValue(  "a  "))   [METHOD]  hasArg [TYPE] OptionBuilder [PARAMETER] boolean hasArg [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder hasArg ( boolean hasArg ) { [BUGGY]  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^117^^^^^115^120^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  hasArg [TYPE] OptionBuilder [PARAMETER] boolean hasArg [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder hasArg ( boolean hasArg ) { OptionBuilder . numberOfArgs =  ( hasArg = = true ) ? 1 : Option . UNINITIALIZED ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^119^^^^^115^120^
[REPLACE]  OptionBuilder  .  argName  =  name; 	[BUGGY] OptionBuilder . argName =  newLongopt ; [CE] cannot find symbol newLongopt  [METHOD]  withArgName [TYPE] OptionBuilder [PARAMETER] String name [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withArgName ( String name ) { [BUGGY] OptionBuilder . argName = newLongopt ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^131^^^^^129^134^
[ADD]  OptionBuilder  .  argName  =  name; 	[BUGGY] [NO-ERROR]  [METHOD]  withArgName [TYPE] OptionBuilder [PARAMETER] String name [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withArgName ( String name ) { [BUGGY]  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^131^^^^^129^134^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  withArgName [TYPE] OptionBuilder [PARAMETER] String name [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withArgName ( String name ) { OptionBuilder . argName = name ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^133^^^^^129^134^
[REPLACE]  OptionBuilder  .  required  =  true; 	[BUGGY] OptionBuilder . required = false ; [FE] NullPointerException assertEquals(   "s  " , simple.getOpt() )   [METHOD]  isRequired [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder isRequired ( ) { [BUGGY] OptionBuilder . required = false ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^143^^^^^141^146^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  isRequired [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder isRequired ( ) { OptionBuilder . required = true ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^145^^^^^141^146^
[REPLACE]  OptionBuilder  .  valuesep  =  sep; 	[BUGGY] OptionBuilder . valuesep = ' = ' ;  ; [FE]  AssertionFailedError  expected:<file1[:file2:file3]> but was:<file1[]> assertEquals( values[0] ,   "JAVA_HOME  " )   [METHOD]  withValueSeparator [TYPE] OptionBuilder [PARAMETER] char sep [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withValueSeparator ( char sep ) { [BUGGY] OptionBuilder . valuesep = ' = ' ;  ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^168^^^^^166^171^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  withValueSeparator [TYPE] OptionBuilder [PARAMETER] char sep [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withValueSeparator ( char sep ) { OptionBuilder . valuesep = sep ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^170^^^^^166^171^
[REPLACE]  OptionBuilder  .  valuesep  =  '='; 	[BUGGY] OptionBuilder . valuesep = sep ;  ; [CE] cannot find symbol sep  [METHOD]  withValueSeparator [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withValueSeparator ( ) { [BUGGY] OptionBuilder . valuesep = sep ;  ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^191^^^^^189^194^
[ADD]  OptionBuilder  .  valuesep  =  '='; 	[BUGGY] [FE]  AssertionFailedError  expected:<property[]> but was:<property[ = value]> assertEquals(   "property  " , opts[0] )   [METHOD]  withValueSeparator [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withValueSeparator ( ) { [BUGGY]  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^191^^^^^189^194^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  withValueSeparator [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder withValueSeparator ( ) { OptionBuilder . valuesep = ' = ' ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^193^^^^^189^194^
[REPLACE]  OptionBuilder  .  required  =  newRequired; 	[BUGGY] OptionBuilder . required = true ;  ; [FE]  d assertEquals(  "flag a  " ,   "foo  " , line.getOptionValue(  "a  "))   [METHOD]  isRequired [TYPE] OptionBuilder [PARAMETER] boolean newRequired [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder isRequired ( boolean newRequired ) { [BUGGY] OptionBuilder . required = true ;  ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^205^^^^^203^208^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  isRequired [TYPE] OptionBuilder [PARAMETER] boolean newRequired [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder isRequired ( boolean newRequired ) { OptionBuilder . required = newRequired ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^207^^^^^203^208^
[REPLACE]  OptionBuilder  .  numberOfArgs  =  Option  .  UNLIMITED_VALUES; 	[BUGGY] OptionBuilder . numberOfArgs  =  OptionBuilder . numberOfArgs ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  hasArgs [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder hasArgs ( ) { [BUGGY] OptionBuilder . numberOfArgs = OptionBuilder . numberOfArgs ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^217^^^^^215^220^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  hasArgs [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int numberOfArgs  [CONTEXT]  public static OptionBuilder hasArgs ( ) { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^219^^^^^215^220^
[REPLACE]  OptionBuilder  .  numberOfArgs  =  num; 	[BUGGY] OptionBuilder . numberOfArgs = numArgs ;  ; [CE] cannot find symbol numArgs  [METHOD]  hasArgs [TYPE] OptionBuilder [PARAMETER] int num [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasArgs ( int num ) { [BUGGY] OptionBuilder . numberOfArgs = numArgs ;  ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^231^^^^^229^234^
[ADD]  OptionBuilder  .  numberOfArgs  =  num; 	[BUGGY] [FE]  AssertionFailedError  expected:<2> but was:<-1> assertEquals( 2 , opt.getArgs() )   [METHOD]  hasArgs [TYPE] OptionBuilder [PARAMETER] int num [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasArgs ( int num ) { [BUGGY]  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^231^^^^^229^234^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  hasArgs [TYPE] OptionBuilder [PARAMETER] int num [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasArgs ( int num ) { OptionBuilder . numberOfArgs = num ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^233^^^^^229^234^
[REPLACE]  OptionBuilder  .  numberOfArgs  =  1; 	[BUGGY] OptionBuilder . numberOfArgs = 1 << 3 ; [NO-ERROR]  [METHOD]  hasOptionalArg [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArg ( ) { [BUGGY] OptionBuilder . numberOfArgs = 1 << 3 ; OptionBuilder . optionalArg = true ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^243^^^^^241^247^
[REPLACE]  OptionBuilder  .  optionalArg  =  true; 	[BUGGY] OptionBuilder . optionalArg = false ; [NO-ERROR]  [METHOD]  hasOptionalArg [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArg ( ) { OptionBuilder . numberOfArgs = 1 ; [BUGGY] OptionBuilder . optionalArg = false ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^244^^^^^241^247^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  hasOptionalArg [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArg ( ) { OptionBuilder . numberOfArgs = 1 ; OptionBuilder . optionalArg = true ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^246^^^^^241^247^
[REPLACE]  OptionBuilder  .  numberOfArgs  =  Option  .  UNLIMITED_VALUES; 	[BUGGY] OptionBuilder . numberOfArgs ; [CE] not a statement  [METHOD]  hasOptionalArgs [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArgs ( ) { [BUGGY] OptionBuilder . numberOfArgs ; OptionBuilder . optionalArg = true ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^257^^^^^255^261^
[REPLACE]  OptionBuilder  .  optionalArg  =  true; 	[BUGGY] OptionBuilder . optionalArg = false ; [NO-ERROR]  [METHOD]  hasOptionalArgs [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArgs ( ) { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; [BUGGY] OptionBuilder . optionalArg = false ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^258^^^^^255^261^
[ADD]  OptionBuilder  .  optionalArg  =  true; 	[BUGGY] [NO-ERROR]  [METHOD]  hasOptionalArgs [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArgs ( ) { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; [BUGGY]  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^258^^^^^255^261^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  hasOptionalArgs [TYPE] OptionBuilder [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArgs ( ) { OptionBuilder . numberOfArgs = Option . UNLIMITED_VALUES ; OptionBuilder . optionalArg = true ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^260^^^^^255^261^
[REPLACE]  OptionBuilder  .  numberOfArgs  =  numArgs; 	[BUGGY] OptionBuilder . numberOfArgs = num ;  ; [CE] cannot find symbol num  [METHOD]  hasOptionalArgs [TYPE] OptionBuilder [PARAMETER] int numArgs [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArgs ( int numArgs ) { [BUGGY] OptionBuilder . numberOfArgs = num ;  ; OptionBuilder . optionalArg = true ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^273^^^^^271^277^
[REPLACE]  OptionBuilder  .  optionalArg  =  true; 	[BUGGY] OptionBuilder . optionalArg = false ; [NO-ERROR]  [METHOD]  hasOptionalArgs [TYPE] OptionBuilder [PARAMETER] int numArgs [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArgs ( int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; [BUGGY] OptionBuilder . optionalArg = false ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^274^^^^^271^277^
[REPLACE]  return  instance; 	[BUGGY] return option ; [NO-ERROR]  [METHOD]  hasOptionalArgs [TYPE] OptionBuilder [PARAMETER] int numArgs [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longopt name newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static OptionBuilder hasOptionalArgs ( int numArgs ) { OptionBuilder . numberOfArgs = numArgs ; OptionBuilder . optionalArg = true ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^276^^^^^271^277^
[REPLACE]  OptionBuilder  .  type  =  newType; 	[BUGGY] OptionBuilder . type =  null ; [FE] NullPointerException assertEquals(   "s  " , simple.getOpt() )   [METHOD]  withType [TYPE] OptionBuilder [PARAMETER] Object newType [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static OptionBuilder withType ( Object newType ) { [BUGGY] OptionBuilder . type = null ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^288^^^^^286^291^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  withType [TYPE] OptionBuilder [PARAMETER] Object newType [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static OptionBuilder withType ( Object newType ) { OptionBuilder . type = newType ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^290^^^^^286^291^
[REPLACE]  OptionBuilder  .  description  =  newDescription; 	[BUGGY] OptionBuilder . description =  newLongopt ; [CE] cannot find symbol newLongopt  [METHOD]  withDescription [TYPE] OptionBuilder [PARAMETER] String newDescription [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newDescription newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static OptionBuilder withDescription ( String newDescription ) { [BUGGY] OptionBuilder . description = newLongopt ;  return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^301^^^^^299^304^
[REPLACE]  return  instance; 	[BUGGY] return option ; [CE] cannot find symbol option  [METHOD]  withDescription [TYPE] OptionBuilder [PARAMETER] String newDescription [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newDescription newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static OptionBuilder withDescription ( String newDescription ) { OptionBuilder . description = newDescription ;  [BUGGY] return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^303^^^^^299^304^
[REPLACE]  return  create  (  String  .  valueOf  (  opt  )  )  ; 	[BUGGY] return create ( null ) ; [FE]  Unexpected exception:Unrecognized option: -Dproperty = value assertEquals(   "property  " , opts[0] )   [METHOD]  create [TYPE] Option [PARAMETER] char opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newDescription newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( char opt ) throws IllegalArgumentException { [BUGGY] return create ( null )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^318^^^^^315^319^
[REPLACE]  if  (  longopt  ==  null  )  { 	[BUGGY] if ( longopt ! = newLongopt ) {[CE] cannot find symbol newLongopt  [METHOD]  create [TYPE] Option [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newDescription newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( ) throws IllegalArgumentException { [BUGGY] if ( longopt ! = newLongopt ) { throw new IllegalArgumentException (   "must specify longopt  " ) ; } return create ( null ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^331^332^^^^328^337^
[REPLACE]  throw  new  IllegalArgumentException  (  "    ")  ; 	[BUGGY] return ; [CE] missing return value  [METHOD]  create [TYPE] Option [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newDescription newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( ) throws IllegalArgumentException { if ( longopt = = null ) { [BUGGY] return ; } return create ( null ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^333^^^^^328^337^
[ADD]  throw  new  IllegalArgumentException  (  "    ")  ; 	[BUGGY] [NO-ERROR]  [METHOD]  create [TYPE] Option [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newDescription newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( ) throws IllegalArgumentException { if ( longopt = = null ) { [BUGGY] } return create ( null ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^333^^^^^328^337^
[REPLACE]  return  create  (  null  )  ; 	[BUGGY] return create ( false ) ; [CE] no suitable method found for create(boolean)  [METHOD]  create [TYPE] Option [PARAMETER] [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] String argName description longopt name newDescription newLongopt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( ) throws IllegalArgumentException { if ( longopt = = null ) { throw new IllegalArgumentException (   "must specify longopt  " ) ; } [BUGGY] return create ( false )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^336^^^^^328^337^
[REPLACE]  Option  option  =  new  Option  (  opt,  description  )  ; 	[BUGGY] Option newLongoption = new Option ( opt , description ) ; [CE] cannot find symbol option  [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  [BUGGY] Option newLongoption = new Option ( opt , description )  ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^353^^^^^349^371^
[ADD]  Option  option  =  new  Option  (  opt,  description  )  ; 	[BUGGY] [CE] cannot find symbol option  [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  [BUGGY]   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^353^^^^^349^371^
[REPLACE]  option  .  setLongOpt  (  longopt  )  ; 	[BUGGY] option . setArgName ( longopt ) ; [FE]  Unexpected exception:Unrecognized option: --block-size assertTrue( line.hasOption(   "block-size  " ) )   [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   [BUGGY] option . setArgName ( longopt )  ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^357^^^^^349^371^
[REPLACE]  option  .  setRequired  (  required  )  ; 	[BUGGY] option . setOptionalArg ( required ) ; [FE] NullPointerException assertEquals(   "s  " , simple.getOpt() )   [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; [BUGGY] option . setOptionalArg ( required )  ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^358^^^^^349^371^
[REPLACE]  option  .  setOptionalArg  (  optionalArg  )  ; 	[BUGGY] option . setRequired ( optionalArg ) ; [FE]  Unexpected Exception: Missing argument for option:a assertEquals( cmd.getOptionValue( 'b' ) ,   "value  " )   [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; [BUGGY] option . setRequired ( optionalArg )  ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^359^^^^^349^371^
[REPLACE]  option  .  setArgs  (  numberOfArgs  )  ; 	[BUGGY] option . setRequired ( numberOfArgs ) ; [CE] method setRequired in class Option cannot be applied to given types ;  [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; [BUGGY] option . setRequired ( numberOfArgs )  ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^360^^^^^349^371^
[REPLACE]  option  .  setType  (  type  )  ; 	[BUGGY] option . setArgs ( num )  ; [CE] cannot find symbol num  [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; [BUGGY] option . setArgs ( num ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^361^^^^^349^371^
[ADD]  option  .  setType  (  type  )  ;  option  .  setValueSeparator  (  valuesep  )  ; 	[BUGGY] option . setValueSeparator ( valuesep ) ; [FE] NullPointerException assertEquals(   "s  " , simple.getOpt() )   [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; [BUGGY] option . setValueSeparator ( valuesep )  ;  option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^361^362^^^^349^371^
[REPLACE]  option  .  setValueSeparator  (  valuesep  )  ; 	[BUGGY] option . setRequired ( valuesep ) ; [CE] method setRequired in class Option cannot be applied to given types ;  [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; [BUGGY] option . setRequired ( valuesep )  ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^362^^^^^349^371^
[ADD]  option  .  setValueSeparator  (  valuesep  )  ; 	[BUGGY] [FE]  AssertionFailedError  expected:<property[]> but was:<property[ = value]> assertEquals(   "property  " , opts[0] )   [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; [BUGGY] option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^362^^^^^349^371^
[REPLACE]  option  .  setArgName  (  argName  )  ; 	[BUGGY] option . setLongOpt ( argName ) ; [FE]  Unexpected exception:Unrecognized option: --block-size assertTrue( line.hasOption(   "block-size  " ) )   [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; [BUGGY] option . setLongOpt ( argName )  ;   OptionBuilder . reset ( ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^363^^^^^349^371^
[REPLACE]  OptionBuilder  .  reset  (  )  ; 	[BUGGY] OptionBuilder . create ( opt )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   [BUGGY] OptionBuilder . create ( opt ) ;   return option ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^367^^^^^349^371^
[REPLACE]  return  option; 	[BUGGY] return create ( null ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  create [TYPE] Option [PARAMETER] String opt [CLASS] OptionBuilder  [TYPE] boolean false hasArg newRequired optionalArg required true [TYPE] OptionBuilder instance [TYPE] char opt sep valuesep [TYPE] Object newType type [TYPE] Option option [TYPE] String argName description longopt name newDescription newLongopt opt [TYPE] int num numArgs numberOfArgs  [CONTEXT]  public static Option create ( String opt ) throws IllegalArgumentException {  Option option = new Option ( opt , description ) ;   option . setLongOpt ( longopt ) ; option . setRequired ( required ) ; option . setOptionalArg ( optionalArg ) ; option . setArgs ( numberOfArgs ) ; option . setType ( type ) ; option . setValueSeparator ( valuesep ) ; option . setArgName ( argName ) ;   OptionBuilder . reset ( ) ;   [BUGGY] return create ( null )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionBuilder.java^370^^^^^349^371^
[REPLACE]  if  (  str  .  startsWith  (    "--  "  )  )  { 	[BUGGY] if ( str . endsWith (   "\  "  " ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingHyphens [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingHyphens ( String str ) { [BUGGY] if ( str . endsWith (   "\  "  " ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith (   "-  " ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^35^36^^^^33^45^
[ADD]  if  (  str  .  startsWith  (    "--  "  )  )  {  return  str  .  substring  (  2,  str  .  length  (  )  )  ;  } 	[BUGGY] [CE]  [METHOD]  stripLeadingHyphens [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingHyphens ( String str ) { [BUGGY]   else if ( str . startsWith (   "-  " ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^35^36^37^38^^33^45^
[REPLACE]  else  if  (  str  .  startsWith  (    "-  "  )  )  { 	[BUGGY] else if ( str . endsWith ( str )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingHyphens [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingHyphens ( String str ) { if ( str . startsWith (   "--  " ) ) { return str . substring ( 2 , str . length ( ) ) ; } [BUGGY] else if ( str . endsWith ( str )  ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^39^40^^^^33^45^
[REPLACE]  return  str  .  substring  (  1,  str  .  length  (  )  )  ; 	[BUGGY] return str . substring ( 2 , str . length ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingHyphens [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingHyphens ( String str ) { if ( str . startsWith (   "--  " ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith (   "-  " ) ) { [BUGGY] return str . substring ( 2 , str . length ( ) )  ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^41^^^^^33^45^
[REPLACE]  return  str  .  substring  (  1,  str  .  length  (  )  )  ; 	[BUGGY] return str . substring ( 0 , str . length ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingHyphens [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingHyphens ( String str ) { if ( str . startsWith (   "--  " ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith (   "-  " ) ) { [BUGGY] return str . substring ( 0 , str . length ( ) )  ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^41^^^^^33^45^
[REPLACE]  return  str  .  substring  (  2,  str  .  length  (  )  )  ; 	[BUGGY] return str . substring ( 0 , str . length ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingHyphens [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingHyphens ( String str ) { if ( str . startsWith (   "--  " ) ) { [BUGGY] return str . substring ( 0 , str . length ( ) )  ; } else if ( str . startsWith (   "-  " ) ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^37^^^^^33^45^
[REPLACE]  else  if  (  str  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( str . endsWith ( str )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingHyphens [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingHyphens ( String str ) { if ( str . startsWith (   "--  " ) ) { return str . substring ( 2 , str . length ( ) ) ; } [BUGGY] if ( str . endsWith ( str )  ) { return str . substring ( 1 , str . length ( ) ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^39^40^^^^33^45^
[REPLACE]  return  str; 	[BUGGY] return str . substring ( 1 , str . length ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingHyphens [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingHyphens ( String str ) { if ( str . startsWith (   "--  " ) ) { return str . substring ( 2 , str . length ( ) ) ; } else if ( str . startsWith (   "-  " ) ) { return str . substring ( 1 , str . length ( ) ) ; } [BUGGY] return str . substring ( 1 , str . length ( ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^44^^^^^33^45^
[REPLACE]  if  (  str  .  startsWith  (    "\  "  "  )  )  { 	[BUGGY] if ( str . endsWith (   "\  "  " ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingAndTrailingQuotes [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingAndTrailingQuotes ( String str ) { [BUGGY] if ( str . endsWith (   "\  "  " ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith (   "\  "  " ) ) { str = str . substring ( 0 , str . length ( ) -1 ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^58^^^^^56^65^
[REPLACE]  str  =  str  .  substring  (  1,  str  .  length  (  )  )  ; 	[BUGGY] str = str . substring ( 0 , str . length ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingAndTrailingQuotes [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith (   "\  "  " ) ) { [BUGGY] str = str . substring ( 0 , str . length ( ) )  ; } if ( str . endsWith (   "\  "  " ) ) { str = str . substring ( 0 , str . length ( ) -1 ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^59^^^^^56^65^
[REPLACE]  str  =  str  .  substring  (  1,  str  .  length  (  )  )  ; 	[BUGGY] str = str . substring ( 0 , str . length ( ) -1 ) ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingAndTrailingQuotes [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith (   "\  "  " ) ) { [BUGGY] str = str . substring ( 0 , str . length ( ) -1 )  ;  ; } if ( str . endsWith (   "\  "  " ) ) { str = str . substring ( 0 , str . length ( ) -1 ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^59^^^^^56^65^
[REPLACE]  if  (  str  .  endsWith  (    "\  "  "  )  )  { 	[BUGGY] if ( str . startsWith (   "--  " ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingAndTrailingQuotes [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith (   "\  "  " ) ) { str = str . substring ( 1 , str . length ( ) ) ; } [BUGGY] if ( str . startsWith (   "--  " ) ) { str = str . substring ( 0 , str . length ( ) -1 ) ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^61^^^^^56^65^
[REPLACE]  str  =  str  .  substring  (  0,  str  .  length  (  )  -1  )  ; 	[BUGGY] str = str . substring ( 0 , str . length ( ) * 0 . 5 -1 ) ; [CE] no suitable method found for substring(int , double)  [METHOD]  stripLeadingAndTrailingQuotes [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith (   "\  "  " ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith (   "\  "  " ) ) { [BUGGY] str = str . substring ( 0 , str . length ( ) *0 . 5 -1 )  ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^62^^^^^56^65^
[REPLACE]  str  =  str  .  substring  (  0,  str  .  length  (  )  -1  )  ; 	[BUGGY] str = str . substring ( 0 , str . size ( ) -1 ) ; [CE] cannot find symbol  [METHOD]  stripLeadingAndTrailingQuotes [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith (   "\  "  " ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith (   "\  "  " ) ) { [BUGGY] str = str . substring ( 0 , str . size ( ) -1 )  ; } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^62^^^^^56^65^
[ADD]  str  =  str  .  substring  (  0,  str  .  length  (  )  -1  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingAndTrailingQuotes [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith (   "\  "  " ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith (   "\  "  " ) ) { [BUGGY] } return str ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^62^^^^^56^65^
[REPLACE]  return  str; 	[BUGGY] return str . substring ( 1 , str . length ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  stripLeadingAndTrailingQuotes [TYPE] String [PARAMETER] String str [CLASS] Util  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  static String stripLeadingAndTrailingQuotes ( String str ) { if ( str . startsWith (   "\  "  " ) ) { str = str . substring ( 1 , str . length ( ) ) ; } if ( str . endsWith (   "\  "  " ) ) { str = str . substring ( 0 , str . length ( ) -1 ) ; } [BUGGY] return str . substring ( 1 , str . length ( ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Util.java^64^^^^^56^65^
[REPLACE]  public  static  final  Class  STRING_VALUE  =  java  .  lang  .  String  .  class; 	[BUGGY] public static final Class STRING_VALUE ; [CE] variable STRING_VALUE might not have been initialized  [CONTEXT]    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^50^^^^^^^
[REPLACE]  public  static  final  Class  OBJECT_VALUE  =  java  .  lang  .  Object  .  class; 	[BUGGY] public static final Class OBJECT_VALUE  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^53^^^^^^^
[REPLACE]  public  static  final  Class  NUMBER_VALUE  =  java  .  lang  .  Number  .  class; 	[BUGGY] public static final Class NUMBER_VALUE  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^56^^^^^^^
[REPLACE]  public  static  final  Class  DATE_VALUE  =  java  .  util  .  Date  .  class; 	[BUGGY] public static final Class DATE_VALUE ; [CE] variable DATE_VALUE might not have been initialized  [CONTEXT]    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^59^^^^^^^
[REPLACE]  public  static  final  Class  CLASS_VALUE  =  java  .  lang  .  Class  .  class; 	[BUGGY] public static Class CLASS_VALUE = java . lang . Class . class ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^62^^^^^^^
[REPLACE]  public  static  final  Class  EXISTING_FILE_VALUE  =  java  .  io  .  FileInputStream  .  class; 	[BUGGY] public final Class EXISTING_FILE_VALUE = java . io . FileInputStream . class ; [CE] non-static variable EXISTING_FILE_VALUE cannot be referenced from a static context  [CONTEXT]  [BUGGY] publicfinal Class EXISTING_FILE_VALUE = java . io . FileInputStream . class ;    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^69^70^^^^69^70^
[REPLACE]  public  static  final  Class  FILE_VALUE  =  java  .  io  .  File  .  class; 	[BUGGY] public final Class FILE_VALUE = java . io . File . class ; [CE] non-static variable FILE_VALUE cannot be referenced from a static context  [CONTEXT]    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^73^^^^^^^
[REPLACE]  public  static  final  Class  FILES_VALUE  =  java  .  io  .  File[]  .  class; 	[BUGGY] public static final Class FILES_VALUE  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^76^^^^^^^
[REPLACE]  public  static  final  Class  URL_VALUE  =  java  .  net  .  URL  .  class; 	[BUGGY] public static final Class URL_VALUE ; [CE] variable URL_VALUE might not have been initialized  [CONTEXT]    [CLASS] PatternOptionBuilder  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^79^^^^^^^
[REPLACE]  if  (  ch  ==  '@'  )  { 	[BUGGY] if ( ch || '@' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { [BUGGY] if ( ch||'@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^89^90^^^^88^127^
[REPLACE]  else  if  (  ch  ==  ':'  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } [BUGGY] else { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^93^94^^^^88^127^
[ADD]  else  if  (  ch  ==  ':'  )  {  return  PatternOptionBuilder  .  STRING_VALUE;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } [BUGGY]   else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^93^94^95^96^^88^127^
[REPLACE]  else  if  (  ch  ==  '%'  )  { 	[BUGGY] else if ( ch ! =  '%' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } [BUGGY] else if ( ch! = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^97^98^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '+'  )  { 	[BUGGY] else if ( ch || '+' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } [BUGGY] else if ( ch||'+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^101^102^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '#'  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY] else { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^106^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '<'  )  { 	[BUGGY] else if ( ch || '<' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY] else if ( ch||'<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^110^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '>'  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY] else { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^114^^^^88^127^
[ADD]  else  if  (  ch  ==  '>'  )  {  return  PatternOptionBuilder  .  FILE_VALUE;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY]   else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^114^115^116^^88^127^
[REPLACE]  else  if  (  ch  ==  '*'  )  { 	[BUGGY] else if ( ch && '*' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY] else if ( ch&&'*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^118^^^^88^127^
[REMOVE]   	[BUGGY] if ( ch = = '>' ) {   return FILE_VALUE ; }else   if ( ch = = '*' ) {     return FILES_VALUE ;   }else     if ( ch = = '/' ) {       return URL_VALUE ;     }[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY] else if ( ch = = '*' )  if ( ch = = '>' ) { return FILE_VALUE ; }else if ( ch = = '*' ) { return FILES_VALUE ; }else if ( ch = = '/' ) { return URL_VALUE ; }{ return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '/'  )  { 	[BUGGY] if ( ch && '/' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY] if ( ch&&'/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^122^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  URL_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  else if ( ch = = '/' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^123^^^^^121^124^
[REPLACE]  return  PatternOptionBuilder  .  URL_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^123^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  FILES_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  else if ( ch = = '*' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^119^^^^^117^124^
[REPLACE]  else  if  (  ch  ==  '/'  )  { 	[BUGGY] else {[CE] unreachable statement  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY] else { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^122^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  FILES_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^119^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  FILE_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  else if ( ch = = '>' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^115^^^^^113^124^
[REPLACE]  else  if  (  ch  ==  '*'  )  { 	[BUGGY] if ( ch || '*' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY] if ( ch||'*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^118^^^^88^127^
[ADD]  else  if  (  ch  ==  '/'  )  {  return  PatternOptionBuilder  .  URL_VALUE;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY]   return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^122^123^124^^88^127^
[REPLACE]  else  if  (  ch  ==  '/'  )  { 	[BUGGY] if ( ch || '/' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY] if ( ch||'/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^122^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  FILE_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^115^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE; 	[BUGGY] return PatternOptionBuilder . STRING_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  else if ( ch = = '<' ) { [BUGGY] return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^111^^^^^109^124^
[REPLACE]  else  if  (  ch  ==  '>'  )  { 	[BUGGY] if ( ch || '>' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY] if ( ch||'>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^114^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '*'  )  { 	[BUGGY] if ( ch && '*' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY] if ( ch&&'*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^118^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '*'  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY] else { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^118^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '/'  )  { 	[BUGGY] else if ( ch && '/' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY] else if ( ch&&'/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^122^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE; 	[BUGGY] return PatternOptionBuilder . STRING_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { [BUGGY] return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^111^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  DATE_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  else if ( ch = = '#' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^107^^^^^105^124^
[REPLACE]  else  if  (  ch  ==  '<'  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY] else { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^110^^^^88^127^
[ADD]  else  if  (  ch  ==  '<'  )  {  return  PatternOptionBuilder  .  EXISTING_FILE_VALUE;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY]   else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^110^111^112^^88^127^
[REMOVE]   	[BUGGY] if ( ch = = '*' ) {   return FILES_VALUE ; }else   if ( ch = = '/' ) {     return URL_VALUE ;   }[CE] unreachable statement  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY] else if ( ch = = '/' )  if ( ch = = '*' ) { return FILES_VALUE ; }else if ( ch = = '/' ) { return URL_VALUE ; }{ return PatternOptionBuilder . URL_VALUE ; } return null ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '/'  )  { 	[BUGGY] if ( ch ! =  '/' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY] if ( ch! = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^122^^^^88^127^
[ADD]  else  if  (  ch  ==  '*'  )  {  return  PatternOptionBuilder  .  FILES_VALUE;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY]   else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^118^119^120^^88^127^
[REPLACE]  else  if  (  ch  ==  '/'  )  { 	[BUGGY] else if ( ch ! =  '/' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY] else if ( ch! = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^122^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  DATE_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^107^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  CLASS_VALUE; 	[BUGGY] return PatternOptionBuilder . FILES_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  else if ( ch = = '+' ) { [BUGGY] return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^103^^^^^101^124^
[REPLACE]  else  if  (  ch  ==  '*'  )  { 	[BUGGY] if ( ch ! =  '*' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY] if ( ch! = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^118^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '<'  )  { 	[BUGGY] else if ( ch && '<' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY] else if ( ch&&'<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^110^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '*'  )  { 	[BUGGY] else if ( ch ! =  '*' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY] else if ( ch! = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^118^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '/'  )  { 	[BUGGY] else if ( ch || '/' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } [BUGGY] else if ( ch||'/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^121^122^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  CLASS_VALUE; 	[BUGGY] return PatternOptionBuilder . FILES_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { [BUGGY] return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^103^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  NUMBER_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  else if ( ch = = '%' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^99^^^^^97^124^
[REPLACE]  else  if  (  ch  ==  '+'  )  { 	[BUGGY] if ( ch && '+' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } [BUGGY] if ( ch&&'+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^101^102^^^^88^127^
[REMOVE]   	[BUGGY] if ( ch = = '+' ) {   return CLASS_VALUE ; }else   if ( ch = = '#' ) {     return DATE_VALUE ;   }else     if ( ch = = '<' ) {       return EXISTING_FILE_VALUE ;     }else       if ( ch = = '>' ) {         return FILE_VALUE ;       }else         if ( ch = = '*' ) {           return FILES_VALUE ;         }else           if ( ch = = '/' ) {             return URL_VALUE ;           }[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY] else if ( ch = = '#' )  if ( ch = = '+' ) { return CLASS_VALUE ; }else if ( ch = = '#' ) { return DATE_VALUE ; }else if ( ch = = '<' ) { return EXISTING_FILE_VALUE ; }else if ( ch = = '>' ) { return FILE_VALUE ; }else if ( ch = = '*' ) { return FILES_VALUE ; }else if ( ch = = '/' ) { return URL_VALUE ; }{ return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '<'  )  { 	[BUGGY] if ( ch && '<' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY] if ( ch&&'<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^110^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '>'  )  { 	[BUGGY] if ( ch ! =  '>' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY] if ( ch! = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^114^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '*'  )  { 	[BUGGY] else if ( ch || '*' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } [BUGGY] else if ( ch||'*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^117^118^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '<'  )  { 	[BUGGY] if ( ch || '<' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY] if ( ch||'<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^110^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '>'  )  { 	[BUGGY] if ( ch && '>' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY] if ( ch&&'>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^114^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '#'  )  { 	[BUGGY] else if ( ch && '#' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY] else if ( ch&&'#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^106^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  NUMBER_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^99^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  STRING_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  else if ( ch = = ':' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^95^^^^^93^124^
[REPLACE]  else  if  (  ch  ==  '%'  )  { 	[BUGGY] if ( ch || '%' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } [BUGGY] if ( ch||'%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^97^98^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '+'  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } [BUGGY] else { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^101^102^^^^88^127^
[ADD]  else  if  (  ch  ==  '+'  )  {  return  PatternOptionBuilder  .  CLASS_VALUE;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } [BUGGY]   else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^101^102^103^104^^88^127^
[REPLACE]  else  if  (  ch  ==  '#'  )  { 	[BUGGY] else if ( ch ! =  '#' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY] else if ( ch! = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^106^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '<'  )  { 	[BUGGY] else if ( ch ! =  '<' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY] else if ( ch! = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^110^^^^88^127^
[REMOVE]   	[BUGGY] if ( ch = = '*' ) {   return FILES_VALUE ; }else   if ( ch = = '/' ) {     return URL_VALUE ;   }[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY] else if ( ch = = '>' )  if ( ch = = '*' ) { return FILES_VALUE ; }else if ( ch = = '/' ) { return URL_VALUE ; }{ return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '#'  )  { 	[BUGGY] if ( ch ! =  '#' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY] if ( ch! = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^106^^^^88^127^
[ADD]  else  if  (  ch  ==  '#'  )  {  return  PatternOptionBuilder  .  DATE_VALUE;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY]   else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^106^107^108^^88^127^
[REMOVE]   	[BUGGY] if ( ch = = '*' ) {   return FILES_VALUE ; }else   if ( ch = = '/' ) {     return URL_VALUE ;   }[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY] else if ( ch = = '<' )  if ( ch = = '*' ) { return FILES_VALUE ; }else if ( ch = = '/' ) { return URL_VALUE ; }{ return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '>'  )  { 	[BUGGY] else if ( ch || '>' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY] else if ( ch||'>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^114^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '>'  )  { 	[BUGGY] else if ( ch ! =  '>' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY] else if ( ch! = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^114^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '#'  )  { 	[BUGGY] if ( ch || '#' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY] if ( ch||'#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^106^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  STRING_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^95^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  OBJECT_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  if ( ch = = '@' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^91^^^^^89^124^
[REPLACE]  else  if  (  ch  ==  ':'  )  { 	[BUGGY] if ( ch || ':' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } [BUGGY] if ( ch||':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^93^94^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '%'  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } [BUGGY] else { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^97^98^^^^88^127^
[ADD]  else  if  (  ch  ==  '%'  )  {  return  PatternOptionBuilder  .  NUMBER_VALUE;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } [BUGGY]   else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^97^98^99^100^^88^127^
[REPLACE]  else  if  (  ch  ==  '#'  )  { 	[BUGGY] else if ( ch || '#' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY] else if ( ch||'#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^106^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '>'  )  { 	[BUGGY] else if ( ch && '>' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } [BUGGY] else if ( ch&&'>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^113^114^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '<'  )  { 	[BUGGY] if ( ch ! =  '<' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } [BUGGY] if ( ch! = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^109^110^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '%'  )  { 	[BUGGY] else if ( ch || '%' ) {[CE] bad operand types for binary operator '||'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } [BUGGY] else if ( ch||'%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^97^98^^^^88^127^
[REPLACE]  else  if  (  ch  ==  '#'  )  { 	[BUGGY] if ( ch && '#' ) {[CE] bad operand types for binary operator '&&'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } [BUGGY] if ( ch&&'#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^105^106^^^^88^127^
[REMOVE]   	[BUGGY] if ( ch = = '#' ) {   return DATE_VALUE ; }else   if ( ch = = '<' ) {     return EXISTING_FILE_VALUE ;   }else     if ( ch = = '>' ) {       return FILE_VALUE ;     }else       if ( ch = = '*' ) {         return FILES_VALUE ;       }else         if ( ch = = '/' ) {           return URL_VALUE ;         }[CE] 'else' without 'if'  [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } [BUGGY] else if ( ch = = '+' )  if ( ch = = '#' ) { return DATE_VALUE ; }else if ( ch = = '<' ) { return EXISTING_FILE_VALUE ; }else if ( ch = = '>' ) { return FILE_VALUE ; }else if ( ch = = '*' ) { return FILES_VALUE ; }else if ( ch = = '/' ) { return URL_VALUE ; }{ return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^101^^^^^88^127^
[REPLACE]  return  PatternOptionBuilder  .  OBJECT_VALUE; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^91^^^^^88^127^
[REPLACE]  return  null; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getValueClass [TYPE] Object [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  { if ( ch = = '@' ) { return PatternOptionBuilder . OBJECT_VALUE ; } else if ( ch = = ':' ) { return PatternOptionBuilder . STRING_VALUE ; } else if ( ch = = '%' ) { return PatternOptionBuilder . NUMBER_VALUE ; } else if ( ch = = '+' ) { return PatternOptionBuilder . CLASS_VALUE ; } else if ( ch = = '#' ) { return PatternOptionBuilder . DATE_VALUE ; } else if ( ch = = '<' ) { return PatternOptionBuilder . EXISTING_FILE_VALUE ; } else if ( ch = = '>' ) { return PatternOptionBuilder . FILE_VALUE ; } else if ( ch = = '*' ) { return PatternOptionBuilder . FILES_VALUE ; } else if ( ch = = '/' ) { return PatternOptionBuilder . URL_VALUE ; } [BUGGY] return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^126^^^^^88^127^
[REPLACE]  if  (  (  ch  !=  '@'  )  &&  (  ch  !=  ':'  )  &&  (  ch  !=  '%'  )  &&  (  ch  !=  '+'  )  &&  (  ch  !=  '#'  )  &&  (  ch  !=  '<'  )  &&  (  ch  !=  '>'  )  &&  (  ch  !=  '*'  )  &&  (  ch  !=  '/'  )  &&  (  ch  !=  '!'  )  )  { 	[BUGGY] if ( ( ch ! = '@' ) || ( ch ! = ':' ) || ( ch ! = '%' ) || ( ch ! = '+' ) || ( ch ! = '#' ) || ( ch ! = '<' ) || ( ch ! = '>' ) || ( ch ! = '*' ) || ( ch ! = '/' ) || ( ch ! = '!' ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  isValueCode [TYPE] boolean [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  public static boolean isValueCode ( char ch ) { [BUGGY] if ( ( ch ! = '@' ) || ( ch ! = ':' ) || ( ch ! = '%' ) || ( ch ! = '+' ) || ( ch ! = '#' ) || ( ch ! = '<' ) || ( ch ! = '>' ) || ( ch ! = '*' ) || ( ch ! = '/' ) || ( ch ! = '!' ) ) {  return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^138^139^140^141^^136^146^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  isValueCode [TYPE] boolean [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  public static boolean isValueCode ( char ch ) { if ( ( ch ! = '@' ) && ( ch ! = ':' ) && ( ch ! = '%' ) && ( ch ! = '+' ) && ( ch ! = '#' ) && ( ch ! = '<' ) && ( ch ! = '>' ) && ( ch ! = '*' ) && ( ch ! = '/' ) && ( ch ! = '!' ) ) { [BUGGY] return true ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^142^^^^^136^146^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  isValueCode [TYPE] boolean [PARAMETER] char ch [CLASS] PatternOptionBuilder  [TYPE] char ch [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] boolean false true  [CONTEXT]  public static boolean isValueCode ( char ch ) { if ( ( ch ! = '@' ) && ( ch ! = ':' ) && ( ch ! = '%' ) && ( ch ! = '+' ) && ( ch ! = '#' ) && ( ch ! = '<' ) && ( ch ! = '>' ) && ( ch ! = '*' ) && ( ch ! = '/' ) && ( ch ! = '!' ) ) { return false ; } [BUGGY] return false ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^145^^^^^136^146^
[REPLACE]  int  sz  =  pattern  .  length  (  )  ; 	[BUGGY] Options options = new Options ( ) ; [CE] variable options is already defined in method parsePattern(String)  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { [BUGGY] Options options = new Options ( )  ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^157^^^^^156^210^
[REPLACE]  char  opt  =  '  '; 	[BUGGY] char ch = ' ' ; [CE] variable ch is already defined in method parsePattern(String)  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  [BUGGY] char ch = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^159^^^^^156^210^
[REPLACE]  char  ch  =  '  '; 	[BUGGY] char opt = ' ' ; [CE] variable opt is already defined in method parsePattern(String)  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; [BUGGY] char opt = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^160^^^^^156^210^
[ADD]  char  ch  =  '  '; 	[BUGGY] [CE] cannot find symbol ch  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; [BUGGY] boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^160^^^^^156^210^
[REPLACE]  boolean  required  =  false; 	[BUGGY] boolean required = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; [BUGGY] boolean required = true ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^161^^^^^156^210^
[REPLACE]  Object  type  =  null; 	[BUGGY] Object type = this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; [BUGGY] Object type = this ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^162^^^^^156^210^
[REPLACE]  Options  options  =  new  Options  (  )  ; 	[BUGGY] int sz = pattern . length ( ) ; [CE] variable sz is already defined in method parsePattern(String)  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  [BUGGY] int sz = pattern . length ( )  ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^164^^^^^156^210^
[REPLACE]  if  (  !isValueCode  (  ch  )  )  { 	[BUGGY] if ( isValueCode ( ch ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    [BUGGY] if ( isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^172^173^^^^156^210^
[REMOVE]   	[BUGGY] if ( ch = = '+' ) {   return CLASS_VALUE ; }else   if ( ch = = '#' ) {     return DATE_VALUE ;   }else     if ( ch = = '<' ) {       return EXISTING_FILE_VALUE ;     }else       if ( ch = = '>' ) {         return FILE_VALUE ;       }else         if ( ch = = '*' ) {           return FILES_VALUE ;         }else           if ( ch = = '/' ) {             return URL_VALUE ;           }[CE] 'else' without 'if'  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    [BUGGY] if ( !isValueCode ( ch ) )  if ( ch = = '+' ) { return CLASS_VALUE ; }else if ( ch = = '#' ) { return DATE_VALUE ; }else if ( ch = = '<' ) { return EXISTING_FILE_VALUE ; }else if ( ch = = '>' ) { return FILE_VALUE ; }else if ( ch = = '*' ) { return FILES_VALUE ; }else if ( ch = = '/' ) { return URL_VALUE ; }{ if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^172^^^^^156^210^
[REPLACE]  else  if  (  ch  ==  '!'  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } [BUGGY] else { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^189^190^^^^156^210^
[REPLACE]  type  =  getValueClass  (  ch  )  ; 	[BUGGY] type =  getValueClass ( null ) ; [CE] method getValueClass in class PatternOptionBuilder cannot be applied to given types ;  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  else if ( ch = = '!' ) { required = true ; } else { [BUGGY] type = getValueClass ( null )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^195^^^^^189^196^
[REPLACE]  required  =  true; 	[BUGGY] required = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  else if ( ch = = '!' ) { [BUGGY] required = false ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^191^^^^^189^196^
[REPLACE]  required  =  true; 	[BUGGY] required = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { [BUGGY] required = false ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^191^^^^^156^210^
[REPLACE]  type  =  getValueClass  (  ch  )  ; 	[BUGGY] type =  getValueClass ( null ) ; [CE] method getValueClass in class PatternOptionBuilder cannot be applied to given types ;  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { [BUGGY] type = getValueClass ( null )  ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^195^^^^^156^210^
[REPLACE]  if  (  opt  !=  '  '  )  { 	[BUGGY] if ( opt  = =  ' ' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { [BUGGY] if ( opt = = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^174^175^^^^172^196^
[REPLACE]  required  =  false; 	[BUGGY] required = true ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; [BUGGY] required = true ;  ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^182^^^^^172^196^
[ADD]  required  =  false; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; [BUGGY] type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^182^^^^^172^196^
[REPLACE]  type  =  null; 	[BUGGY] type = this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY] type = this ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^^^^^172^196^
[REPLACE]  opt  =  '  '; 	[BUGGY] opt  =  opt ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; [BUGGY] opt = opt ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^184^^^^^172^196^
[REPLACE]  required  =  false; 	[BUGGY] required = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; [BUGGY] required = true ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^182^^^^^172^196^
[REPLACE]  type  =  null; 	[BUGGY] type = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY] type = false ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^^^^^172^196^
[REPLACE]  opt  =  ch; 	[BUGGY] opt =  null ; [CE] incompatible types  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } [BUGGY] opt = null ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^187^^^^^172^196^
[ADD]  opt  =  ch; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } [BUGGY] } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^187^^^^^172^196^
[REPLACE]  if  (  opt  !=  '  '  )  { 	[BUGGY] if ( opt  = =  ' ' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { [BUGGY] if ( opt = = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^174^175^^^^156^210^
[REPLACE]  required  =  false; 	[BUGGY] required = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; [BUGGY] required = true ; type = null ; opt = ' ' ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^182^^^^^174^185^
[REPLACE]  type  =  null; 	[BUGGY] type = this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY] type = this ; opt = ' ' ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^^^^^174^185^
[ADD]  type  =  null; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY] opt = ' ' ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^^^^^174^185^
[REPLACE]  opt  =  '  '; 	[BUGGY] opt  = null ; [CE] incompatible types  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; [BUGGY] opt = null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^184^^^^^174^185^
[REPLACE]  else  if  (  ch  ==  '!'  )  { 	[BUGGY] if ( ch = = '' ) {[CE] empty character literal  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } [BUGGY] if ( ch = = '' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^189^190^^^^156^210^
[REPLACE]  for  (  int  i  =  0;  i  <  sz;  i++  )  { 	[BUGGY] for ( int i = 0 ; i ! =  sz ; i++ ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  [BUGGY] for ( int i = 0 ; i! = sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^166^167^^^^156^210^
[REPLACE]  if  (  !isValueCode  (  ch  )  )  { 	[BUGGY] if ( isValueCode ( ch ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    [BUGGY] if ( isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^172^173^^^^166^197^
[ADD]  if  (  !isValueCode  (  ch  )  )  {  if  (  opt  !=  '  '  )  {  OptionBuilder  .  hasArg  (  type  !=  null  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    [BUGGY]   OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^172^173^174^175^176^166^197^
[REPLACE]  else  if  (  ch  ==  '!'  )  { 	[BUGGY] if ( ch = = '' ) {[CE] empty character literal  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } [BUGGY] if ( ch = = '' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^189^190^^^^166^197^
[ADD]  else  if  (  ch  ==  '!'  )  {  required  =  true;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } [BUGGY]   else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^189^190^191^192^^166^197^
[REPLACE]  required  =  true; 	[BUGGY] required = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { [BUGGY] required = false ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^191^^^^^166^197^
[REPLACE]  type  =  getValueClass  (  ch  )  ; 	[BUGGY] type =  getValueClass ( null ) ; [CE] method getValueClass in class PatternOptionBuilder cannot be applied to given types ;  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { [BUGGY] type = getValueClass ( null )  ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^195^^^^^166^197^
[ADD]  required  =  false;  type  =  null; 	[BUGGY] type = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; [BUGGY] type = null ;  opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^182^183^^^^172^196^
[ADD]  type  =  null;  opt  =  '  '; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY]  } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^184^^^^172^196^
[REPLACE]  type  =  null; 	[BUGGY] type = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY] type = true ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^^^^^172^196^
[REPLACE]  if  (  opt  !=  '  '  )  { 	[BUGGY] if ( opt  = =  ' ' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { [BUGGY] if ( opt = = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^174^175^^^^166^197^
[REPLACE]  type  =  null; 	[BUGGY] type = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY] type = true ; opt = ' ' ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^^^^^174^185^
[REPLACE]  ch  =  pattern  .  charAt  (  i  )  ; 	[BUGGY] ch =  null . charAt ( i ) ; [CE] <null> cannot be dereferenced  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { [BUGGY] ch = null . charAt ( i )  ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^168^^^^^166^197^
[REPLACE]  required  =  false; 	[BUGGY] required = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; [BUGGY] required = true ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^182^^^^^166^197^
[REPLACE]  type  =  null; 	[BUGGY] type = this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY] type = this ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^^^^^166^197^
[REPLACE]  opt  =  '  '; 	[BUGGY] opt  =  opt ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; [BUGGY] opt = opt ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^184^^^^^166^197^
[REPLACE]  opt  =  ch; 	[BUGGY] opt =  null ; [CE] incompatible types  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } [BUGGY] opt = null ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^187^^^^^166^197^
[ADD]  required  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { [BUGGY] } else { type = getValueClass ( ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^191^^^^^166^197^
[ADD]  type  =  getValueClass  (  ch  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { [BUGGY] } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^195^^^^^166^197^
[REPLACE]  ch  =  pattern  .  charAt  (  i  )  ; 	[BUGGY] ch =  null . charAt ( i ) ; [CE] <null> cannot be dereferenced  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { [BUGGY] ch = null . charAt ( i )  ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^168^^^^^156^210^
[REPLACE]  required  =  false; 	[BUGGY] required = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; [BUGGY] required = true ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^182^^^^^156^210^
[REPLACE]  type  =  null; 	[BUGGY] type = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; [BUGGY] type = false ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^183^^^^^156^210^
[REPLACE]  opt  =  '  '; 	[BUGGY] opt ; [CE] not a statement  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; [BUGGY] opt ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^184^^^^^156^210^
[REPLACE]  opt  =  ch; 	[BUGGY] opt =  null ; [CE] incompatible types  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } [BUGGY] opt = null ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^187^^^^^156^210^
[REPLACE]  for  (  int  i  =  0;  i  <  sz;  i++  )  { 	[BUGGY] for ( int i = 0L ; i < sz ; i++ ) {[CE] possible loss of precision  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  [BUGGY] for ( int i = 0L ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^166^167^^^^156^210^
[REPLACE]  if  (  opt  !=  '  '  )  { 	[BUGGY] if ( opt  = =  ' ' ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } [BUGGY] if ( opt = = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } return options ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^199^200^^^^156^210^
[REPLACE]  OptionBuilder  .  hasArg  (  type  !=  null  )  ; 	[BUGGY] OptionBuilder . hasArg ( type = = null ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { [BUGGY] OptionBuilder . hasArg ( type = = null )  ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^201^^^^^199^207^
[REPLACE]  OptionBuilder  .  isRequired  (  required  )  ; 	[BUGGY] OptionBuilder . isRequired ( true ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; [BUGGY] OptionBuilder . isRequired ( true )  ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^202^^^^^199^207^
[REMOVE]   	[BUGGY] OptionBuilder . withType ( type ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; [BUGGY] OptionBuilder . isRequired ( required ) ;  OptionBuilder . withType ( type )  ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^202^^^^^199^207^
[REPLACE]  OptionBuilder  .  withType  (  type  )  ; 	[BUGGY] OptionBuilder . create ( ch )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; [BUGGY] OptionBuilder . create ( ch ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^203^^^^^199^207^
[REPLACE]  options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ; 	[BUGGY] OptionBuilder . withType ( type ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   [BUGGY] OptionBuilder . withType ( type )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^206^^^^^199^207^
[REPLACE]  options  .  addOption  (  OptionBuilder  .  create  (  opt  )  )  ; 	[BUGGY] options . addOption ( OptionBuilder . hasArg ( opt ) ) ; [CE] no suitable method found for hasArg(char)  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   [BUGGY] options . addOption ( OptionBuilder . hasArg ( opt ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^206^^^^^199^207^
[REPLACE]  return  options; 	[BUGGY] return PatternOptionBuilder . CLASS_VALUE ; [CE] incompatible types  [METHOD]  parsePattern [TYPE] Options [PARAMETER] String pattern [CLASS] PatternOptionBuilder  [TYPE] Options options [TYPE] boolean false required true [TYPE] char ch opt [TYPE] Class CLASS_VALUE DATE_VALUE EXISTING_FILE_VALUE FILES_VALUE FILE_VALUE NUMBER_VALUE OBJECT_VALUE STRING_VALUE URL_VALUE [TYPE] Object type [TYPE] String pattern [TYPE] int i sz  [CONTEXT]  { int sz = pattern . length ( ) ;  char opt = ' ' ; char ch = ' ' ; boolean required = false ; Object type = null ;  Options options = new Options ( ) ;  for ( int i = 0 ; i < sz ; i++ ) { ch = pattern . charAt ( i ) ;    if ( !isValueCode ( ch ) ) { if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; required = false ; type = null ; opt = ' ' ; } opt = ch ; } else if ( ch = = '!' ) { required = true ; } else { type = getValueClass ( ch ) ; } } if ( opt ! = ' ' ) { OptionBuilder . hasArg ( type ! = null ) ; OptionBuilder . isRequired ( required ) ; OptionBuilder . withType ( type ) ;   options . addOption ( OptionBuilder . create ( opt ) ) ; } [BUGGY] return PatternOptionBuilder . CLASS_VALUE ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PatternOptionBuilder.java^209^^^^^156^210^
[REPLACE]  public  static  final  int  DEFAULT_WIDTH  =  74; 	[BUGGY] public static int DEFAULT_WIDTH = 74 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^37^^^^^^^
[REPLACE]  public  static  final  int  DEFAULT_LEFT_PAD  =  1; 	[BUGGY] public static final int DEFAULT_LEFT_PAD  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^40^^^^^^^
[REPLACE]  public  static  final  int  DEFAULT_DESC_PAD  =  3; 	[BUGGY] public static final int DEFAULT_DESC_PAD  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^43^^^^^^^
[REPLACE]  public  static  final  String  DEFAULT_SYNTAX_PREFIX  =    "usage:    "; 	[BUGGY] public static final String DEFAULT_SYNTAX_PREFIX ; [CE] variable DEFAULT_SYNTAX_PREFIX might not have been initialized  [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^46^^^^^^^
[REPLACE]  public  static  final  String  DEFAULT_OPT_PREFIX  =    "-  "; 	[BUGGY] public static final String DEFAULT_OPT_PREFIX  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^49^^^^^^^
[REPLACE]  public  static  final  String  DEFAULT_LONG_OPT_PREFIX  =    "--  "; 	[BUGGY] public static final String DEFAULT_LONG_OPT_PREFIX ; [CE] variable DEFAULT_LONG_OPT_PREFIX might not have been initialized  [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^52^^^^^^^
[REPLACE]  public  static  final  String  DEFAULT_ARG_NAME  =    "arg  "; 	[BUGGY] public static  double DEFAULT_ARG_NAME =   "arg  " ; [CE] incompatible types  [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^55^^^^^^^
[REPLACE]  private  int  defaultWidth  =  DEFAULT_WIDTH; 	[BUGGY] private int defaultWidth ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^60^^^^^^^
[REPLACE]  private  int  defaultLeftPad  =  DEFAULT_LEFT_PAD; 	[BUGGY] private int defaultLeftPad  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^63^^^^^^^
[REPLACE]  private  int  defaultDescPad  =  DEFAULT_DESC_PAD; 	[BUGGY] private int defaultDescPad  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^66^^^^^^^
[REPLACE]  private  String  defaultSyntaxPrefix  =  DEFAULT_SYNTAX_PREFIX; 	[BUGGY] private String defaultSyntaxPrefix ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^69^^^^^^^
[REPLACE]  private  String  defaultNewLine  =  System  .  getProperty  (    "line  .  separator  "  )  ; 	[BUGGY] private String defaultNewLine  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^72^^^^^^^
[REPLACE]  private  String  defaultOptPrefix  =  DEFAULT_OPT_PREFIX; 	[BUGGY] private String defaultOptPrefix ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^75^^^^^^^
[REPLACE]  private  String  defaultLongOptPrefix  =  DEFAULT_LONG_OPT_PREFIX; 	[BUGGY] private String defaultLongOptPrefix ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^78^^^^^^^
[REPLACE]  private  String  defaultArgName  =  DEFAULT_ARG_NAME; 	[BUGGY] private String defaultArgName ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] HelpFormatter OptionComparator  	None^81^^^^^^^
[REPLACE]  this  .  defaultWidth  =  width; 	[BUGGY] this . defaultWidth =  null ; [CE] incompatible types  [METHOD]  setWidth [TYPE] void [PARAMETER] int width [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix [TYPE] boolean false true  [CONTEXT]  public void setWidth ( int width ) { [BUGGY] this . defaultWidth = null ; }  	None^90^^^^^88^91^
[ADD]  this  .  defaultWidth  =  width; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setWidth [TYPE] void [PARAMETER] int width [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix [TYPE] boolean false true  [CONTEXT]  public void setWidth ( int width ) { [BUGGY] }  	None^90^^^^^88^91^
[REPLACE]  return  this  .  defaultWidth; 	[BUGGY] return sb ; [CE] cannot find symbol sb  [METHOD]  getWidth [TYPE] int [PARAMETER] [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix [TYPE] boolean false true  [CONTEXT]  public int getWidth ( ) { [BUGGY] return sb ; }  	None^100^^^^^98^101^
[REPLACE]  this  .  defaultLeftPad  =  padding; 	[BUGGY] this . defaultDescPad = padding ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setLeftPadding [TYPE] void [PARAMETER] int padding [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix [TYPE] boolean false true  [CONTEXT]  public void setLeftPadding ( int padding ) { [BUGGY] this . defaultDescPad = padding ;  ; }  	None^110^^^^^108^111^
[REPLACE]  return  this  .  defaultLeftPad; 	[BUGGY] return this . defaultDescPad ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getLeftPadding [TYPE] int [PARAMETER] [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix [TYPE] boolean false true  [CONTEXT]  public int getLeftPadding ( ) { [BUGGY] return this . defaultDescPad ; }  	None^120^^^^^118^121^
[REPLACE]  this  .  defaultDescPad  =  padding; 	[BUGGY] this . defaultLeftPad = padding ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setDescPadding [TYPE] void [PARAMETER] int padding [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix [TYPE] boolean false true  [CONTEXT]  public void setDescPadding ( int padding ) { [BUGGY] this . defaultLeftPad = padding ;  ; }  	None^130^^^^^128^131^
[ADD]  this  .  defaultDescPad  =  padding; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setDescPadding [TYPE] void [PARAMETER] int padding [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix [TYPE] boolean false true  [CONTEXT]  public void setDescPadding ( int padding ) { [BUGGY] }  	None^130^^^^^128^131^
[REPLACE]  return  this  .  defaultDescPad; 	[BUGGY] return this . defaultLeftPad ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getDescPadding [TYPE] int [PARAMETER] [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix [TYPE] boolean false true  [CONTEXT]  public int getDescPadding ( ) { [BUGGY] return this . defaultLeftPad ; }  	None^140^^^^^138^141^
[REPLACE]  this  .  defaultSyntaxPrefix  =  prefix; 	[BUGGY] this . defaultLongOptPrefix = prefix ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setSyntaxPrefix [TYPE] void [PARAMETER] String prefix [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix prefix [TYPE] boolean false true  [CONTEXT]  public void setSyntaxPrefix ( String prefix ) { [BUGGY] this . defaultLongOptPrefix = prefix ;  ; }  	None^150^^^^^148^151^
[ADD]  this  .  defaultSyntaxPrefix  =  prefix; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setSyntaxPrefix [TYPE] void [PARAMETER] String prefix [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix prefix [TYPE] boolean false true  [CONTEXT]  public void setSyntaxPrefix ( String prefix ) { [BUGGY] }  	None^150^^^^^148^151^
[REPLACE]  return  this  .  defaultSyntaxPrefix; 	[BUGGY] return this . defaultOptPrefix ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getSyntaxPrefix [TYPE] String [PARAMETER] [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix prefix [TYPE] boolean false true  [CONTEXT]  public String getSyntaxPrefix ( ) { [BUGGY] return this . defaultOptPrefix ; }  	None^160^^^^^158^161^
[REPLACE]  this  .  defaultNewLine  =  newline; 	[BUGGY] this . defaultNewLine =  prefix ; [CE] cannot find symbol prefix  [METHOD]  setNewLine [TYPE] void [PARAMETER] String newline [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix newline prefix [TYPE] boolean false true  [CONTEXT]  public void setNewLine ( String newline ) { [BUGGY] this . defaultNewLine = prefix ; }  	None^170^^^^^168^171^
[ADD]  this  .  defaultNewLine  =  newline; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setNewLine [TYPE] void [PARAMETER] String newline [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix newline prefix [TYPE] boolean false true  [CONTEXT]  public void setNewLine ( String newline ) { [BUGGY] }  	None^170^^^^^168^171^
[REPLACE]  return  this  .  defaultNewLine; 	[BUGGY] return sb ; [CE] cannot find symbol sb  [METHOD]  getNewLine [TYPE] String [PARAMETER] [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix newline prefix [TYPE] boolean false true  [CONTEXT]  public String getNewLine ( ) { [BUGGY] return sb ; }  	None^180^^^^^178^181^
[REPLACE]  this  .  defaultOptPrefix  =  prefix; 	[BUGGY] this . defaultLongOptPrefix = prefix ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setOptPrefix [TYPE] void [PARAMETER] String prefix [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix newline prefix [TYPE] boolean false true  [CONTEXT]  public void setOptPrefix ( String prefix ) { [BUGGY] this . defaultLongOptPrefix = prefix ;  ; }  	None^190^^^^^188^191^
[REPLACE]  return  this  .  defaultOptPrefix; 	[BUGGY] return this . defaultSyntaxPrefix ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptPrefix [TYPE] String [PARAMETER] [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix newline prefix [TYPE] boolean false true  [CONTEXT]  public String getOptPrefix ( ) { [BUGGY] return this . defaultSyntaxPrefix ; }  	None^200^^^^^198^201^
[REPLACE]  this  .  defaultLongOptPrefix  =  prefix; 	[BUGGY] this . defaultOptPrefix = prefix ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setLongOptPrefix [TYPE] void [PARAMETER] String prefix [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix newline prefix [TYPE] boolean false true  [CONTEXT]  public void setLongOptPrefix ( String prefix ) { [BUGGY] this . defaultOptPrefix = prefix ;  ; }  	None^210^^^^^208^211^
[REPLACE]  return  this  .  defaultLongOptPrefix; 	[BUGGY] return this . defaultOptPrefix ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getLongOptPrefix [TYPE] String [PARAMETER] [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix newline prefix [TYPE] boolean false true  [CONTEXT]  public String getLongOptPrefix ( ) { [BUGGY] return this . defaultOptPrefix ; }  	None^220^^^^^218^221^
[REPLACE]  this  .  defaultArgName  =  name; 	[BUGGY] this . defaultArgName =  null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setArgName [TYPE] void [PARAMETER] String name [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix name newline prefix [TYPE] boolean false true  [CONTEXT]  public void setArgName ( String name ) { [BUGGY] this . defaultArgName = null ; }  	None^230^^^^^228^231^
[ADD]  this  .  defaultArgName  =  name; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setArgName [TYPE] void [PARAMETER] String name [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix name newline prefix [TYPE] boolean false true  [CONTEXT]  public void setArgName ( String name ) { [BUGGY] }  	None^230^^^^^228^231^
[REPLACE]  return  this  .  defaultArgName; 	[BUGGY] return sb ; [CE] cannot find symbol sb  [METHOD]  getArgName [TYPE] String [PARAMETER] [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix name newline prefix [TYPE] boolean false true  [CONTEXT]  public String getArgName ( ) { [BUGGY] return sb ; }  	None^240^^^^^238^241^
[REPLACE]  printHelp  (  defaultWidth,  cmdLineSyntax,  null,  options,  null,  false  )  ; 	[BUGGY] printHelp ( defaultWidth , cmdLineSyntax , false , options , false , false ) ; [CE] no suitable method found for printHelp(int , String , boolean , Options , boolean , boolean)  [METHOD]  printHelp [TYPE] void [PARAMETER] String cmdLineSyntax Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width  [CONTEXT]  public void printHelp ( String cmdLineSyntax , Options options ) { [BUGGY] printHelp ( defaultWidth , cmdLineSyntax , false , options , false , false )  ; }  	None^256^^^^^254^257^
[REPLACE]  printHelp  (  defaultWidth,  cmdLineSyntax,  null,  options,  null,  autoUsage  )  ; 	[BUGGY] printHelp ( defaultWidth , cmdLineSyntax , this , options , this , autoUsage ) ; [CE] no suitable method found for printHelp(int , String , HelpFormatter , Options , HelpFormatter , boolean)  [METHOD]  printHelp [TYPE] void [PARAMETER] String cmdLineSyntax Options options boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width  [CONTEXT]  public void printHelp ( String cmdLineSyntax , Options options , boolean autoUsage ) { [BUGGY] printHelp ( defaultWidth , cmdLineSyntax , this , options , this , autoUsage )  ; }  	None^272^^^^^269^273^
[ADD]  printHelp  (  defaultWidth,  cmdLineSyntax,  null,  options,  null,  autoUsage  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] String cmdLineSyntax Options options boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width  [CONTEXT]  public void printHelp ( String cmdLineSyntax , Options options , boolean autoUsage ) { [BUGGY] }  	None^272^^^^^269^273^
[REPLACE]  printHelp  (  cmdLineSyntax,  header,  options,  footer,  false  )  ; 	[BUGGY] printHelp ( cmdLineSyntax , header , options , footer , true ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] String cmdLineSyntax String header Options options String footer [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width  [CONTEXT]  public void printHelp ( String cmdLineSyntax , String header , Options options , String footer ) { [BUGGY] printHelp ( cmdLineSyntax , header , options , footer , true )  ; }  	None^288^^^^^285^289^
[REPLACE]  printHelp  (  defaultWidth,  cmdLineSyntax,  header,  options,  footer,  autoUsage  )  ; 	[BUGGY] printHelp ( defaultWidth , cmdLineSyntax , newline , options , footer , autoUsage ) ; [CE] cannot find symbol newline  [METHOD]  printHelp [TYPE] void [PARAMETER] String cmdLineSyntax String header Options options String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width  [CONTEXT]  public void printHelp ( String cmdLineSyntax , String header , Options options , String footer , boolean autoUsage ) { [BUGGY] printHelp ( defaultWidth , cmdLineSyntax , newline , options , footer , autoUsage )  ;  }  	None^306^307^^^^303^308^
[ADD]  printHelp  (  defaultWidth,  cmdLineSyntax,  header,  options,  footer,  autoUsage  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] String cmdLineSyntax String header Options options String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width  [CONTEXT]  public void printHelp ( String cmdLineSyntax , String header , Options options , String footer , boolean autoUsage ) { [BUGGY]  }  	None^306^307^^^^303^308^
[REPLACE]  printHelp  (  width,  cmdLineSyntax,  header,  options,  footer,  false  )  ; 	[BUGGY] printHelp ( width , cmdLineSyntax , header , options , footer , true ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] int width String cmdLineSyntax String header Options options String footer [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width  [CONTEXT]  public void printHelp ( int width , String cmdLineSyntax , String header , Options options , String footer ) { [BUGGY] printHelp ( width , cmdLineSyntax , header , options , footer , true )  ; }  	None^324^^^^^321^325^
[REPLACE]  PrintWriter  pw  =  new  PrintWriter  (  System  .  out  )  ; 	[BUGGY] StringBuffer sb = new StringBuffer ( len ) ; [CE] cannot find symbol len  [METHOD]  printHelp [TYPE] void [PARAMETER] int width String cmdLineSyntax String header Options options String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printHelp ( int width , String cmdLineSyntax , String header , Options options , String footer , boolean autoUsage ) { [BUGGY] StringBuffer sb = new StringBuffer ( len )  ;  printHelp ( pw , width , cmdLineSyntax , header , options , defaultLeftPad , defaultDescPad , footer , autoUsage ) ; pw . flush ( ) ; }  	None^343^^^^^340^348^
[REPLACE]  printHelp  (  pw,  width,  cmdLineSyntax,  header,  options,  defaultLeftPad,  defaultDescPad,  footer,  autoUsage  )  ; 	[BUGGY] printHelp ( pw , width , cmdLineSyntax , defaultSyntaxPrefix , options , defaultLeftPad , defaultDescPad , footer , autoUsage ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] int width String cmdLineSyntax String header Options options String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printHelp ( int width , String cmdLineSyntax , String header , Options options , String footer , boolean autoUsage ) { PrintWriter pw = new PrintWriter ( System . out ) ;  [BUGGY] printHelp ( pw , width , cmdLineSyntax , defaultSyntaxPrefix , options , defaultLeftPad , defaultDescPad , footer , autoUsage )  ;  pw . flush ( ) ; }  	None^345^346^^^^340^348^
[ADD]  printHelp  (  pw,  width,  cmdLineSyntax,  header,  options,  defaultLeftPad,  defaultDescPad,  footer,  autoUsage  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] int width String cmdLineSyntax String header Options options String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printHelp ( int width , String cmdLineSyntax , String header , Options options , String footer , boolean autoUsage ) { PrintWriter pw = new PrintWriter ( System . out ) ;  [BUGGY]  pw . flush ( ) ; }  	None^345^346^^^^340^348^
[REPLACE]  pw  .  flush  (  )  ; 	[BUGGY] optBuf . append ( dpad ) ; [CE] cannot find symbol dpad  [METHOD]  printHelp [TYPE] void [PARAMETER] int width String cmdLineSyntax String header Options options String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printHelp ( int width , String cmdLineSyntax , String header , Options options , String footer , boolean autoUsage ) { PrintWriter pw = new PrintWriter ( System . out ) ;  printHelp ( pw , width , cmdLineSyntax , header , options , defaultLeftPad , defaultDescPad , footer , autoUsage ) ; [BUGGY] optBuf . append ( dpad )  ; }  	None^347^^^^^340^348^
[ADD]  pw  .  flush  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] int width String cmdLineSyntax String header Options options String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printHelp ( int width , String cmdLineSyntax , String header , Options options , String footer , boolean autoUsage ) { PrintWriter pw = new PrintWriter ( System . out ) ;  printHelp ( pw , width , cmdLineSyntax , header , options , defaultLeftPad , defaultDescPad , footer , autoUsage ) ; [BUGGY] }  	None^347^^^^^340^348^
[REPLACE]  printHelp  (  pw,  width,  cmdLineSyntax,  header,  options,  leftPad,  descPad,  footer,  false  )  ; 	[BUGGY] printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , true ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printHelp ( PrintWriter pw , int width , String cmdLineSyntax , String header , Options options , int leftPad , int descPad , String footer ) { [BUGGY] printHelp ( pw , width , cmdLineSyntax , header , options , leftPad , descPad , footer , true )  ;  }  	None^369^370^^^^365^371^
[REPLACE]  if  (  (  cmdLineSyntax  ==  null  )  ||  (  cmdLineSyntax  .  length  (  )  ==  0  )  )  { 	[BUGGY] if ( ( cmdLineSyntax = = false ) || ( cmdLineSyntax . size ( )  = = 0 ) ) {[CE] incomparable types: String and boolean  [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  { [BUGGY] if ( ( cmdLineSyntax = = false ) || ( cmdLineSyntax . size ( ) = = 0 ) ) { throw new IllegalArgumentException (   "cmdLineSyntax not provided  " ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header ! = null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;  if ( ( footer ! = null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }  	None^395^396^^^^394^420^
[REPLACE]  throw  new  IllegalArgumentException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( ( cmdLineSyntax = = null ) || ( cmdLineSyntax . length ( )  = = 0 ) ) { [BUGGY] return ; }  	None^397^^^^^395^398^
[ADD]  throw  new  IllegalArgumentException  (  "    ")  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( ( cmdLineSyntax = = null ) || ( cmdLineSyntax . length ( )  = = 0 ) ) { [BUGGY] }  	None^397^^^^^395^398^
[REPLACE]  throw  new  IllegalArgumentException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  { if ( ( cmdLineSyntax = = null ) || ( cmdLineSyntax . length ( )  = = 0 ) ) { [BUGGY] return ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header ! = null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;  if ( ( footer ! = null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }  	None^397^^^^^394^420^
[ADD]  throw  new  IllegalArgumentException  (  "    ")  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  { if ( ( cmdLineSyntax = = null ) || ( cmdLineSyntax . length ( )  = = 0 ) ) { [BUGGY] } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header ! = null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;  if ( ( footer ! = null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }  	None^397^^^^^394^420^
[REPLACE]  if  (  autoUsage  )  { 	[BUGGY] if ( group ! = null ) {[CE] cannot find symbol group  [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  { if ( ( cmdLineSyntax = = null ) || ( cmdLineSyntax . length ( )  = = 0 ) ) { throw new IllegalArgumentException (   "cmdLineSyntax not provided  " ) ; } [BUGGY] if ( group ! = null ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header ! = null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;  if ( ( footer ! = null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }  	None^400^401^^^^394^420^
[REPLACE]  printUsage  (  pw,  width,  cmdLineSyntax  )  ; 	[BUGGY] printUsage ( pw , width , prefix ) ; [CE] cannot find symbol prefix  [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { [BUGGY] printUsage ( pw , width , prefix )  ; }  	None^406^^^^^400^407^
[REPLACE]  printUsage  (  pw,  width,  cmdLineSyntax,  options  )  ; 	[BUGGY] printUsage ( pw , width , cmdLineSyntax ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( autoUsage ) { [BUGGY] printUsage ( pw , width , cmdLineSyntax )  ; } else { printUsage ( pw , width , cmdLineSyntax ) ; }  	None^402^^^^^400^407^
[REPLACE]  if  (  (  header  !=  null  )  &&  (  header  .  trim  (  )    .  length  (  )  >  0  )  )  { 	[BUGGY] if ( ( header ! = null ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  { if ( ( cmdLineSyntax = = null ) || ( cmdLineSyntax . length ( )  = = 0 ) ) { throw new IllegalArgumentException (   "cmdLineSyntax not provided  " ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } [BUGGY] if ( ( header ! = null ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;  if ( ( footer ! = null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }  	None^409^410^^^^394^420^
[REPLACE]  printWrapped  (  pw,  width,  header  )  ; 	[BUGGY] printWrapped ( pw , width , defaultNewLine ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( ( header ! = null ) && ( header . trim ( ) . length ( ) > 0 ) ) { [BUGGY] printWrapped ( pw , width , defaultNewLine )  ; }  	None^411^^^^^409^412^
[REPLACE]  printOptions  (  pw,  width,  options,  leftPad,  descPad  )  ; 	[BUGGY] renderOptions ( sb , width , options , leftPad , descPad ) ; [CE] cannot find symbol sb  [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  { if ( ( cmdLineSyntax = = null ) || ( cmdLineSyntax . length ( )  = = 0 ) ) { throw new IllegalArgumentException (   "cmdLineSyntax not provided  " ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header ! = null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } [BUGGY] renderOptions ( sb , width , options , leftPad , descPad )  ;  if ( ( footer ! = null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , footer ) ; } }  	None^414^^^^^394^420^
[REPLACE]  if  (  (  footer  !=  null  )  &&  (  footer  .  trim  (  )    .  length  (  )  >  0  )  )  { 	[BUGGY] if ( ( footer ! = false ) ) {[CE] incomparable types: String and boolean  [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  { if ( ( cmdLineSyntax = = null ) || ( cmdLineSyntax . length ( )  = = 0 ) ) { throw new IllegalArgumentException (   "cmdLineSyntax not provided  " ) ; } if ( autoUsage ) { printUsage ( pw , width , cmdLineSyntax , options ) ; } else { printUsage ( pw , width , cmdLineSyntax ) ; } if ( ( header ! = null ) && ( header . trim ( ) . length ( ) > 0 ) ) { printWrapped ( pw , width , header ) ; } printOptions ( pw , width , options , leftPad , descPad ) ;  [BUGGY] if ( ( footer ! = false ) ) { printWrapped ( pw , width , footer ) ; } }  	None^416^417^^^^394^420^
[REPLACE]  printWrapped  (  pw,  width,  footer  )  ; 	[BUGGY] printWrapped ( pw , width , 0 , text ) ; [CE] cannot find symbol text  [METHOD]  printHelp [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax String header Options options int leftPad int descPad String footer boolean autoUsage [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean autoUsage false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( ( footer ! = null ) && ( footer . trim ( ) . length ( ) > 0 ) ) { [BUGGY] printWrapped ( pw , width , 0 , text )  ; }  	None^418^^^^^416^419^
[REPLACE]  StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )    .  append  (  app  )    .  append  (    "    "  )  ; 	[BUGGY] StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( name ) . append (   "   " ) ; [CE] cannot find symbol name  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  [BUGGY] StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix )  . append ( name )  . append (   "   " )  ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^435^436^^^^433^487^
[ADD]  StringBuffer  buff  =  new  StringBuffer  (  defaultSyntaxPrefix  )    .  append  (  app  )    .  append  (    "    "  )  ; 	[BUGGY] [CE] cannot find symbol buff  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  [BUGGY]   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^435^436^^^^433^487^
[REPLACE]  final  Collection  processedGroups  =  new  ArrayList  (  )  ; 	[BUGGY] List prefixList = new ArrayList ( ) ; [CE] cannot find symbol processedGroups  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   [BUGGY] List prefixList = new ArrayList ( )  ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^439^^^^^433^487^
[REPLACE]  Option  option; 	[BUGGY] Option opt1 =  ( Option ) o1 ; [CE] cannot find symbol o1  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   [BUGGY] Option opt1 = ( Option ) o1 ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^442^^^^^433^487^
[REPLACE]  if  (  group  !=  null  )  { 	[BUGGY] if ( group = = this ) {[CE] incomparable types: OptionGroup and HelpFormatter  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   [BUGGY] if ( group = = this ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^454^455^^^^433^487^
[REPLACE]  appendOption  (  buff,  option,  option  .  isRequired  (  )  )  ; 	[BUGGY] renderOptions ( sb , width , options , leftPad , descPad ) ; [CE] cannot find symbol sb  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { [BUGGY] renderOptions ( sb , width , options , leftPad , descPad )  ; }  	None^474^^^^^454^475^
[REPLACE]  appendOption  (  buff,  option,  option  .  isRequired  (  )  )  ; 	[BUGGY] appendOption ( buff , option , option . getKey ( )  ) ; [CE] method appendOption in class HelpFormatter cannot be applied to given types ;  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { [BUGGY] appendOption ( buff , option , option . getKey ( )  )  ; }  	None^474^^^^^454^475^
[ADD]  appendOption  (  buff,  option,  option  .  isRequired  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { [BUGGY] }  	None^474^^^^^454^475^
[REPLACE]  if  (  !processedGroups  .  contains  (  group  )  )  { 	[BUGGY] if ( group ! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  [BUGGY] if ( group ! = null ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; }  	None^457^458^^^^454^475^
[ADD]  if  (  !processedGroups  .  contains  (  group  )  )  {  processedGroups  .  add  (  group  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  [BUGGY]     appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; }  	None^457^458^^460^^454^475^
[REPLACE]  processedGroups  .  add  (  group  )  ; 	[BUGGY] processedGroups . iterator ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  [BUGGY] processedGroups . iterator ( ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; }  	None^460^^^^^454^475^
[ADD]  processedGroups  .  add  (  group  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  [BUGGY]   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; }  	None^460^^^^^454^475^
[REPLACE]  appendOptionGroup  (  buff,  group  )  ; 	[BUGGY] if ( option . getOpt ( ) ! = null ) {[CE] illegal start of expression  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   [BUGGY] if ( option . getOpt ( ) ! = null ) { }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; }  	None^464^^^^^454^475^
[REPLACE]  if  (  !processedGroups  .  contains  (  group  )  )  { 	[BUGGY] if ( !processedGroups . add ( group ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  [BUGGY] if ( !processedGroups . add ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^457^458^^^^433^487^
[REPLACE]  processedGroups  .  add  (  group  )  ; 	[BUGGY] processedGroups . contains ( group ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( !processedGroups . contains ( group ) ) {  [BUGGY] processedGroups . contains ( group )  ;   appendOptionGroup ( buff , group ) ; }  	None^460^^^^^457^465^
[REPLACE]  appendOptionGroup  (  buff,  group  )  ; 	[BUGGY] if ( option . getOpt ( ) ! = null ) {[CE] illegal start of expression  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   [BUGGY] if ( option . getOpt ( ) ! = null ) { }  	None^464^^^^^457^465^
[REPLACE]  if  (  i  .  hasNext  (  )  )  { 	[BUGGY] if ( group ! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } [BUGGY] if ( group ! = null ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^477^478^^^^433^487^
[ADD]  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (    "    "  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } [BUGGY]   }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^477^478^479^480^^433^487^
[REPLACE]  buff  .  append  (    "    "  )  ; 	[BUGGY] buff . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( i . hasNext ( ) ) { [BUGGY] buff . toString ( ) ; }  	None^479^^^^^477^480^
[REPLACE]  for  (  Iterator  i  =  options  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = options . getOptions ( ) . add ( ) ; i . hasNext ( ) ; ) {[CE] method add in interface Collection<E> cannot be applied to given types ;  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   [BUGGY] for ( Iterator i = options . getOptions ( )  . add ( )  ; i . hasNext ( )  ;  ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^445^446^^^^433^487^
[REPLACE]  if  (  group  !=  null  )  { 	[BUGGY] if ( group = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   [BUGGY] if ( group = = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }  	None^454^455^^^^445^481^
[REPLACE]  appendOption  (  buff,  option,  option  .  isRequired  (  )  )  ; 	[BUGGY] appendOption ( buff , option , option . getKey ( ) ) ; [CE] method appendOption in class HelpFormatter cannot be applied to given types ;  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { [BUGGY] appendOption ( buff , option , option . getKey ( ) )  ; }  	None^474^^^^^454^475^
[REPLACE]  if  (  !processedGroups  .  contains  (  group  )  )  { 	[BUGGY] if ( processedGroups . contains ( group ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  [BUGGY] if ( processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; }  	None^457^458^^^^454^475^
[REPLACE]  processedGroups  .  add  (  group  )  ; 	[BUGGY] processedGroups . contains ( group ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  [BUGGY] processedGroups . contains ( group )  ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; }  	None^460^^^^^454^475^
[REPLACE]  if  (  !processedGroups  .  contains  (  group  )  )  { 	[BUGGY] if ( processedGroups . contains ( group ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  [BUGGY] if ( processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }  	None^457^458^^^^445^481^
[ADD]  processedGroups  .  add  (  group  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( !processedGroups . contains ( group ) ) {  [BUGGY]   appendOptionGroup ( buff , group ) ; }  	None^460^^^^^457^465^
[ADD]  appendOptionGroup  (  buff,  group  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   [BUGGY] }  	None^464^^^^^457^465^
[REPLACE]  if  (  i  .  hasNext  (  )  )  { 	[BUGGY] if ( i . next ( )  ) {[CE] incompatible types  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } [BUGGY] if ( i . next ( )  ) { buff . append (   "   " ) ; } }  	None^477^478^^^^445^481^
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ; 	[BUGGY] option =  ( Optnullon ) null . next ( ) ; [CE] cannot find symbol  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  [BUGGY] option =  ( Optnullon ) null . next ( )  ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }  	None^448^^^^^445^481^
[ADD]  option  =  (  Option  )  i  .  next  (  )  ; 	[BUGGY] [CE] variable option might not have been initialized  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  [BUGGY]   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }  	None^448^^^^^445^481^
[REPLACE]  OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ; 	[BUGGY] OptionGroup group = options . getOptions ( )  ; [CE] incompatible types  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   [BUGGY] OptionGroup group = options . getOptions ( ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }  	None^451^^^^^445^481^
[ADD]  OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ; 	[BUGGY] [CE] cannot find symbol group  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   [BUGGY]   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }  	None^451^^^^^445^481^
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ; 	[BUGGY] option =  ( Optnullon ) null . next ( ) ; [CE] cannot find symbol  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  [BUGGY] option =  ( Optnullon ) null . next ( )  ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^448^^^^^433^487^
[REPLACE]  for  (  Iterator  i  =  options  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = options . helpOptions ( )  . iterator ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   [BUGGY] for ( Iterator i = options . helpOptions ( ) . iterator ( )  ; i . hasNext ( )  ;  ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^445^446^^^^433^487^
[ADD]  for  (  Iterator  i  =  options  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =  (  Option  )  i  .  next  (  )  ; 	[BUGGY] [CE] invalid method declaration ; return type required  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   [BUGGY]     OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^445^446^^448^^433^487^
[REPLACE]  OptionGroup  group  =  options  .  getOptionGroup  (  option  )  ; 	[BUGGY] OptionGroup group = options . getOptions ( )  ; [CE] incompatible types  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   [BUGGY] OptionGroup group = options . getOptions ( ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; }  	None^451^^^^^433^487^
[REPLACE]  printWrapped  (  pw,  width,  buff  .  toString  (  )    .  indexOf  (  '  '  )  +  1,  buff  .  toString  (  )  )  ; 	[BUGGY] printWrapped ( pw , padding , buff . StringBuffer ( ) . indexOf ( ' ' )  < 1 , buff . toString ( ) ) ; [CE] cannot find symbol padding  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   [BUGGY] printWrapped ( pw , padding , buff . StringBuffer ( )  . indexOf ( ' ' ) <1 , buff . toString ( ) )  ;  }  	None^485^486^^^^433^487^
[REPLACE]  printWrapped  (  pw,  width,  buff  .  toString  (  )    .  indexOf  (  '  '  )  +  1,  buff  .  toString  (  )  )  ; 	[BUGGY] printWrapped ( pw , width , buff . toString ( )  . indexOf ( DEFAULT_WIDTH , DEFAULT_LEFT_PAD )  + 1 , buff . toString ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   [BUGGY] printWrapped ( pw , width , buff . toString ( ) . indexOf ( DEFAULT_WIDTH , DEFAULT_LEFT_PAD ) + 1 , buff . toString ( ) )  ;  }  	None^485^486^^^^433^487^
[ADD]  printWrapped  (  pw,  width,  buff  .  toString  (  )    .  indexOf  (  '  '  )  +  1,  buff  .  toString  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   [BUGGY]  }  	None^485^486^^^^433^487^
[REPLACE]  printWrapped  (  pw,  width,  buff  .  toString  (  )    .  indexOf  (  '  '  )  +  1,  buff  .  toString  (  )  )  ; 	[BUGGY] printWrapped ( pw , width , buff . StringBuffer ( ) . indexOf ( ' ' ) + 1 , buff . toString ( ) ) ; [CE] cannot find symbol  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   [BUGGY] printWrapped ( pw , width , buff . StringBuffer ( )  . indexOf ( ' ' ) + 1 , buff . toString ( ) )  ;  }  	None^485^486^^^^433^487^
[REPLACE]  buff  .  toString  (  )  )  ; 	[BUGGY] buff . StringBuffer ( ) ) ; [CE] cannot find symbol  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String app Options options [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer buff [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Collection processedGroups [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  {  StringBuffer buff = new StringBuffer ( defaultSyntaxPrefix ) . append ( app )  . append (   "   " ) ;   final Collection processedGroups = new ArrayList ( ) ;   Option option ;   for ( Iterator i = options . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  option =  ( Option ) i . next ( ) ;   OptionGroup group = options . getOptionGroup ( option ) ;   if ( group ! = null ) {  if ( !processedGroups . contains ( group ) ) {  processedGroups . add ( group ) ;   appendOptionGroup ( buff , group ) ; }   }  else { appendOption ( buff , option , option . isRequired ( ) ) ; } if ( i . hasNext ( ) ) { buff . append (   "   " ) ; } }   printWrapped ( pw , width , buff . toString ( ) . indexOf ( ' ' ) + 1 , [BUGGY] buff . StringBuffer ( ) )  ; }  	None^486^^^^^433^487^
[REPLACE]  if  (  !group  .  isRequired  (  )  )  { 	[BUGGY] if ( group . isRequired ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { [BUGGY] if ( group . isRequired ( ) ) { buff . append (   "[  " ) ; }  for ( Iterator i = group . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  if ( i . hasNext ( ) ) { buff . append (   " |   " ) ; } } if ( !group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^500^501^^^^497^521^
[ADD]  if  (  !group  .  isRequired  (  )  )  {  buff  .  append  (    "[  "  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { [BUGGY]    for ( Iterator i = group . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  if ( i . hasNext ( ) ) { buff . append (   " |   " ) ; } } if ( !group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^500^501^502^503^^497^521^
[REPLACE]  buff  .  append  (    "[  "  )  ; 	[BUGGY] buff . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { if ( !group . isRequired ( ) ) { [BUGGY] buff . toString ( ) ; }  for ( Iterator i = group . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  if ( i . hasNext ( ) ) { buff . append (   " |   " ) ; } } if ( !group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^502^^^^^497^521^
[REPLACE]  if  (  i  .  hasNext  (  )  )  { 	[BUGGY] if ( i . next ( ) ) {[CE] incompatible types  [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { if ( !group . isRequired ( ) ) { buff . append (   "[  " ) ; }  for ( Iterator i = group . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  [BUGGY] if ( i . next ( ) ) { buff . append (   " |   " ) ; } } if ( !group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^511^512^^^^497^521^
[ADD]  if  (  i  .  hasNext  (  )  )  {  buff  .  append  (    "  |    "  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { if ( !group . isRequired ( ) ) { buff . append (   "[  " ) ; }  for ( Iterator i = group . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  [BUGGY]   } if ( !group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^511^512^513^514^^497^521^
[REPLACE]  buff  .  append  (    "  |    "  )  ; 	[BUGGY] buff . StringBuffer (   " |   " ) ; [CE] cannot find symbol  [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { if ( !group . isRequired ( ) ) { buff . append (   "[  " ) ; }  for ( Iterator i = group . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  if ( i . hasNext ( ) ) { [BUGGY] buff . StringBuffer (   " |   " )  ; } } if ( !group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^513^^^^^497^521^
[REPLACE]  for  (  Iterator  i  =  group  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = group . getOptions ( )  . contains ( false )  ; i . hasNext ( ) ; ) {[CE] incompatible types  [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { if ( !group . isRequired ( ) ) { buff . append (   "[  " ) ; }  [BUGGY] for ( Iterator i = group . getOptions ( ) . contains ( false ) ; i . hasNext ( )  ;  ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  if ( i . hasNext ( ) ) { buff . append (   " |   " ) ; } } if ( !group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^506^507^^^^497^521^
[REPLACE]  for  (  Iterator  i  =  group  .  getOptions  (  )    .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = group . getOptions ( ) . add ( ) ; i . hasNext ( ) ; ) {[CE] method add in interface Collection<E> cannot be applied to given types ;  [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { if ( !group . isRequired ( ) ) { buff . append (   "[  " ) ; }  [BUGGY] for ( Iterator i = group . getOptions ( )  . add ( )  ; i . hasNext ( )  ;  ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  if ( i . hasNext ( ) ) { buff . append (   " |   " ) ; } } if ( !group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^506^507^^^^497^521^
[REPLACE]  if  (  !group  .  isRequired  (  )  )  { 	[BUGGY] if ( group . isRequired ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { if ( !group . isRequired ( ) ) { buff . append (   "[  " ) ; }  for ( Iterator i = group . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  if ( i . hasNext ( ) ) { buff . append (   " |   " ) ; } } [BUGGY] if ( group . isRequired ( ) ) { buff . append (   "]  " ) ; } }  	None^517^518^^^^497^521^
[REPLACE]  buff  .  append  (    "]  "  )  ; 	[BUGGY] buff . StringBuffer (   "]  " ) ; [CE] cannot find symbol  [METHOD]  appendOptionGroup [TYPE] void [PARAMETER] StringBuffer buff OptionGroup group [CLASS] HelpFormatter OptionComparator  [TYPE] Iterator i [TYPE] StringBuffer buff [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  private static void appendOptionGroup ( final StringBuffer buff , final OptionGroup group ) { if ( !group . isRequired ( ) ) { buff . append (   "[  " ) ; }  for ( Iterator i = group . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {  appendOption ( buff ,  ( Option ) i . next ( ) , true ) ;  if ( i . hasNext ( ) ) { buff . append (   " |   " ) ; } } if ( !group . isRequired ( ) ) { [BUGGY] buff . StringBuffer (   "]  " )  ; } }  	None^519^^^^^497^521^
[REPLACE]  if  (  !required  )  { 	[BUGGY] if ( !true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  { [BUGGY] if ( !true ) { buff . append (   "[  " ) ; } if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ; }  if ( option . hasArg ( ) && ( option . getArgName ( ) ! = null ) ) { buff . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; }  if ( !required ) { buff . append (   "]  " ) ; } }  	None^534^535^^^^533^559^
[REPLACE]  buff  .  append  (    "[  "  )  ; 	[BUGGY] buff . StringBuffer (   "[  " ) ; [CE] cannot find symbol  [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( !required ) { [BUGGY] buff . StringBuffer (   "[  " )  ; }  	None^536^^^^^534^537^
[REPLACE]  if  (  option  .  getOpt  (  )  !=  null  )  { 	[BUGGY] if ( option . getOpt ( )  = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  { if ( !required ) { buff . append (   "[  " ) ; } [BUGGY] if ( option . getOpt ( ) = = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ; }  if ( option . hasArg ( ) && ( option . getArgName ( ) ! = null ) ) { buff . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; }  if ( !required ) { buff . append (   "]  " ) ; } }  	None^539^540^^^^533^559^
[REPLACE]  buff  .  append  (    "--  "  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] buff . StringBuffer (   "--  " ) . append ( option . getLongOpt ( ) ) ; [CE] cannot find symbol  [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { [BUGGY] buff . StringBuffer (   "--  " )  . append ( option . getLongOpt ( ) )  ; }  	None^545^^^^^539^546^
[REMOVE]   	[BUGGY] optBuf . append ( lpad ) . append (   "    " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [CE] non-static variable defaultLongOptPrefix cannot be referenced from a static context  [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { [BUGGY] buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ;   	None^545^^^^^539^546^
[REPLACE]  buff  .  append  (    "--  "  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] buff . toString ( )[CE] ' ; ' expected  [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { [BUGGY] buff . toString ( ) }  	None^545^^^^^539^546^
[REPLACE]  buff  .  append  (    "--  "  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] buff . append (   "--  " ) . append ( option . hasLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { [BUGGY] buff . append (   "--  " )  . append ( option . hasLongOpt ( ) )  ; }  	None^545^^^^^539^546^
[ADD]  buff  .  append  (    "--  "  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { [BUGGY] }  	None^545^^^^^539^546^
[REPLACE]  buff  .  append  (    "-  "  )    .  append  (  option  .  getOpt  (  )  )  ; 	[BUGGY] buff . StringBuffer (   "-  " ) . append ( option . getOpt ( ) ) ; [CE] cannot find symbol  [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { [BUGGY] buff . StringBuffer (   "-  " )  . append ( option . getOpt ( ) )  ; } else { buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ; }  	None^541^^^^^539^546^
[REPLACE]  buff  .  append  (    "-  "  )    .  append  (  option  .  getOpt  (  )  )  ; 	[BUGGY] buff . toString ( )[CE] ' ; ' expected  [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { [BUGGY] buff . toString ( ) } else { buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ; }  	None^541^^^^^539^546^
[REPLACE]  buff  .  append  (    "-  "  )    .  append  (  option  .  getOpt  (  )  )  ; 	[BUGGY] buff . append (   "-  " ) . append ( option . getKey ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { [BUGGY] buff . append (   "-  " )  . append ( option . getKey ( ) )  ; } else { buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ; }  	None^541^^^^^539^546^
[REPLACE]  if  (  option  .  hasArg  (  )  &&  (  option  .  getArgName  (  )  !=  null  )  )  { 	[BUGGY] if ( option . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  { if ( !required ) { buff . append (   "[  " ) ; } if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ; }  [BUGGY] if ( option . hasArg ( ) ) { buff . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; }  if ( !required ) { buff . append (   "]  " ) ; } }  	None^549^550^^^^533^559^
[REPLACE]  buff  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] buff . append (   " <  " ) . append ( option . hasArgName ( ) ) . append (   ">  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . hasArg ( ) && ( option . getArgName ( ) ! = null ) ) { [BUGGY] buff . append (   " <  " )  . append ( option . hasArgName ( ) )  . append (   ">  " )  ; }  	None^551^^^^^549^552^
[REPLACE]  buff  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] buff . StringBuffer (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; [CE] cannot find symbol  [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( option . hasArg ( ) && ( option . getArgName ( ) ! = null ) ) { [BUGGY] buff . StringBuffer (   " <  " )  . append ( option . getArgName ( ) )  . append (   ">  " )  ; }  	None^551^^^^^549^552^
[REPLACE]  if  (  !required  )  { 	[BUGGY] if ( required ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  { if ( !required ) { buff . append (   "[  " ) ; } if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ; }  if ( option . hasArg ( ) && ( option . getArgName ( ) ! = null ) ) { buff . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; }  [BUGGY] if ( required ) { buff . append (   "]  " ) ; } }  	None^555^556^^^^533^559^
[ADD]  if  (  !required  )  {  buff  .  append  (    "]  "  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  { if ( !required ) { buff . append (   "[  " ) ; } if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) . append ( option . getLongOpt ( ) ) ; }  if ( option . hasArg ( ) && ( option . getArgName ( ) ! = null ) ) { buff . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; }  [BUGGY]   }  	None^555^556^557^558^^533^559^
[REPLACE]  buff  .  append  (    "]  "  )  ; 	[BUGGY] buff . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  appendOption [TYPE] void [PARAMETER] StringBuffer buff Option option final boolean required [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer buff [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false required true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width  [CONTEXT]  if ( !required ) { [BUGGY] buff . toString ( ) ; }  	None^557^^^^^555^558^
[REPLACE]  int  argPos  =  cmdLineSyntax  .  indexOf  (  '  '  )  +  1; 	[BUGGY] int argPos = cmdLineSyntax . indexOf ( ' ' ) +defaultLeftPad ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax [CLASS] HelpFormatter OptionComparator  [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printUsage ( PrintWriter pw , int width , String cmdLineSyntax ) { [BUGGY] int argPos = cmdLineSyntax . indexOf ( ' ' ) +defaultLeftPad ;  printWrapped ( pw , width , defaultSyntaxPrefix . length ( ) + argPos , defaultSyntaxPrefix + cmdLineSyntax ) ; }  	None^571^^^^^569^575^
[ADD]  int  argPos  =  cmdLineSyntax  .  indexOf  (  '  '  )  +  1; 	[BUGGY] [CE] cannot find symbol argPos  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax [CLASS] HelpFormatter OptionComparator  [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printUsage ( PrintWriter pw , int width , String cmdLineSyntax ) { [BUGGY]  printWrapped ( pw , width , defaultSyntaxPrefix . length ( ) + argPos , defaultSyntaxPrefix + cmdLineSyntax ) ; }  	None^571^^^^^569^575^
[REPLACE]  printWrapped  (  pw,  width,  defaultSyntaxPrefix  .  length  (  )  +  argPos,  defaultSyntaxPrefix  +  cmdLineSyntax  )  ; 	[BUGGY] printWrapped ( pw , width , defaultSyntaxPrefix . length ( ) * 0 . 5 + argPos , defaultSyntaxPrefix + cmdLineSyntax ) ; [CE] no suitable method found for printWrapped(PrintWriter , int , double , String)  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax [CLASS] HelpFormatter OptionComparator  [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printUsage ( PrintWriter pw , int width , String cmdLineSyntax ) { int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ;  [BUGGY] printWrapped ( pw , width , defaultSyntaxPrefix . length ( ) *0 . 5+ argPos , defaultSyntaxPrefix + cmdLineSyntax )  ;  }  	None^573^574^^^^569^575^
[REPLACE]  printWrapped  (  pw,  width,  defaultSyntaxPrefix  .  length  (  )  +  argPos,  defaultSyntaxPrefix  +  cmdLineSyntax  )  ; 	[BUGGY] printWrapped ( pw , width , defaultSyntaxPrefix . charAt ( ) + argPos , defaultSyntaxPrefix + cmdLineSyntax ) ; [CE] method charAt in class String cannot be applied to given types ;  [METHOD]  printUsage [TYPE] void [PARAMETER] PrintWriter pw int width String cmdLineSyntax [CLASS] HelpFormatter OptionComparator  [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printUsage ( PrintWriter pw , int width , String cmdLineSyntax ) { int argPos = cmdLineSyntax . indexOf ( ' ' ) + 1 ;  [BUGGY] printWrapped ( pw , width , defaultSyntaxPrefix . charAt ( ) + argPos , defaultSyntaxPrefix + cmdLineSyntax )  ;  }  	None^573^574^^^^569^575^
[REPLACE]  StringBuffer  sb  =  new  StringBuffer  (  )  ; 	[BUGGY] StringBuffer sb = new StringBuffer ( len ) ; [CE] cannot find symbol len  [METHOD]  printOptions [TYPE] void [PARAMETER] PrintWriter pw int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printOptions ( PrintWriter pw , int width , Options options , int leftPad , int descPad ) { [BUGGY] StringBuffer sb = new StringBuffer ( len )  ;  renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString ( ) ) ; }  	None^592^^^^^589^596^
[ADD]  StringBuffer  sb  =  new  StringBuffer  (  )  ; 	[BUGGY] [CE] cannot find symbol sb  [METHOD]  printOptions [TYPE] void [PARAMETER] PrintWriter pw int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printOptions ( PrintWriter pw , int width , Options options , int leftPad , int descPad ) { [BUGGY]  renderOptions ( sb , width , options , leftPad , descPad ) ; pw . println ( sb . toString ( ) ) ; }  	None^592^^^^^589^596^
[REPLACE]  renderOptions  (  sb,  width,  options,  leftPad,  descPad  )  ; 	[BUGGY] printOptions ( pw , width , options , leftPad , descPad ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printOptions [TYPE] void [PARAMETER] PrintWriter pw int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printOptions ( PrintWriter pw , int width , Options options , int leftPad , int descPad ) { StringBuffer sb = new StringBuffer ( ) ;  [BUGGY] printOptions ( pw , width , options , leftPad , descPad )  ; pw . println ( sb . toString ( ) ) ; }  	None^594^^^^^589^596^
[ADD]  renderOptions  (  sb,  width,  options,  leftPad,  descPad  )  ;  pw  .  println  (  sb  .  toString  (  )  )  ; 	[BUGGY] pw . println ( sb . toString ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printOptions [TYPE] void [PARAMETER] PrintWriter pw int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printOptions ( PrintWriter pw , int width , Options options , int leftPad , int descPad ) { StringBuffer sb = new StringBuffer ( ) ;  [BUGGY] pw . println ( sb . toString ( ) )  ;  }  	None^594^595^^^^589^596^
[REPLACE]  pw  .  println  (  sb  .  toString  (  )  )  ; 	[BUGGY] pw . PrintWriter ( sb . toString ( ) ) ; [CE] cannot find symbol  [METHOD]  printOptions [TYPE] void [PARAMETER] PrintWriter pw int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printOptions ( PrintWriter pw , int width , Options options , int leftPad , int descPad ) { StringBuffer sb = new StringBuffer ( ) ;  renderOptions ( sb , width , options , leftPad , descPad ) ; [BUGGY] pw . PrintWriter ( sb . toString ( ) )  ; }  	None^595^^^^^589^596^
[REPLACE]  pw  .  println  (  sb  .  toString  (  )  )  ; 	[BUGGY] pw . println ( sb . StringBuffer ( defaultNewLine )  ) ; [CE] cannot find symbol  [METHOD]  printOptions [TYPE] void [PARAMETER] PrintWriter pw int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printOptions ( PrintWriter pw , int width , Options options , int leftPad , int descPad ) { StringBuffer sb = new StringBuffer ( ) ;  renderOptions ( sb , width , options , leftPad , descPad ) ; [BUGGY] pw . println ( sb . StringBuffer ( defaultNewLine )  )  ; }  	None^595^^^^^589^596^
[REPLACE]  printWrapped  (  pw,  width,  0,  text  )  ; 	[BUGGY] printWrapped ( pw , width , 1 , defaultOptPrefix ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printWrapped [TYPE] void [PARAMETER] PrintWriter pw int width String text [CLASS] HelpFormatter OptionComparator  [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printWrapped ( PrintWriter pw , int width , String text ) { [BUGGY] printWrapped ( pw , width , 1 , defaultOptPrefix )  ; }  	None^607^^^^^605^608^
[REPLACE]  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ; 	[BUGGY] StringBuffer sb = new StringBuffer ( footer . trim ( ) ) ; [CE] cannot find symbol footer  [METHOD]  printWrapped [TYPE] void [PARAMETER] PrintWriter pw int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad nextLineTabStop padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printWrapped ( PrintWriter pw , int width , int nextLineTabStop , String text ) { [BUGGY] StringBuffer sb = new StringBuffer ( footer . trim ( ) )  ;  renderWrappedText ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString ( ) ) ; }  	None^621^^^^^618^625^
[ADD]  StringBuffer  sb  =  new  StringBuffer  (  text  .  length  (  )  )  ; 	[BUGGY] [CE] cannot find symbol sb  [METHOD]  printWrapped [TYPE] void [PARAMETER] PrintWriter pw int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad nextLineTabStop padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printWrapped ( PrintWriter pw , int width , int nextLineTabStop , String text ) { [BUGGY]  renderWrappedText ( sb , width , nextLineTabStop , text ) ; pw . println ( sb . toString ( ) ) ; }  	None^621^^^^^618^625^
[REPLACE]  renderWrappedText  (  sb,  width,  nextLineTabStop,  text  )  ; 	[BUGGY] renderWrappedText ( sb , width , nextLineTabStop , defaultSyntaxPrefix ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  printWrapped [TYPE] void [PARAMETER] PrintWriter pw int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad nextLineTabStop padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printWrapped ( PrintWriter pw , int width , int nextLineTabStop , String text ) { StringBuffer sb = new StringBuffer ( text . length ( ) ) ;  [BUGGY] renderWrappedText ( sb , width , nextLineTabStop , defaultSyntaxPrefix )  ; pw . println ( sb . toString ( ) ) ; }  	None^623^^^^^618^625^
[REMOVE]   	[BUGGY] printUsage ( pw , width , cmdLineSyntax ) ; [CE] cannot find symbol cmdLineSyntax  [METHOD]  printWrapped [TYPE] void [PARAMETER] PrintWriter pw int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad nextLineTabStop padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printWrapped ( PrintWriter pw , int width , int nextLineTabStop , String text ) { StringBuffer sb = new StringBuffer ( text . length ( ) ) ;  [BUGGY] renderWrappedText ( sb , width , nextLineTabStop , text ) ;  printUsage ( pw , width , cmdLineSyntax )  ; pw . println ( sb . toString ( ) ) ;   	None^623^^^^^618^625^
[REPLACE]  pw  .  println  (  sb  .  toString  (  )  )  ; 	[BUGGY] pw . PrintWriter ( false )  ; [CE] cannot find symbol  [METHOD]  printWrapped [TYPE] void [PARAMETER] PrintWriter pw int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad nextLineTabStop padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printWrapped ( PrintWriter pw , int width , int nextLineTabStop , String text ) { StringBuffer sb = new StringBuffer ( text . length ( ) ) ;  renderWrappedText ( sb , width , nextLineTabStop , text ) ; [BUGGY] pw . PrintWriter ( false ) ; }  	None^624^^^^^618^625^
[REPLACE]  pw  .  println  (  sb  .  toString  (  )  )  ; 	[BUGGY] pw . println ( sb . StringBuffer ( prefix )  ) ; [CE] cannot find symbol prefix  [METHOD]  printWrapped [TYPE] void [PARAMETER] PrintWriter pw int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix footer header name newline prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad nextLineTabStop padding width [TYPE] PrintWriter pw  [CONTEXT]  public void printWrapped ( PrintWriter pw , int width , int nextLineTabStop , String text ) { StringBuffer sb = new StringBuffer ( text . length ( ) ) ;  renderWrappedText ( sb , width , nextLineTabStop , text ) ; [BUGGY] pw . println ( sb . StringBuffer ( prefix )  )  ; }  	None^624^^^^^618^625^
[REPLACE]  final  String  lpad  =  createPadding  (  leftPad  )  ; 	[BUGGY] final String lpad = createPadding ( max ) ; [CE] cannot find symbol max  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { [BUGGY] final String lpad = createPadding ( max )  ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^647^^^^^646^730^
[REPLACE]  final  String  dpad  =  createPadding  (  descPad  )  ; 	[BUGGY] final String dpad = createPadding ( nextLineTabStop ) ; [CE] cannot find symbol nextLineTabStop  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; [BUGGY] final String dpad = createPadding ( nextLineTabStop )  ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^648^^^^^646^730^
[REPLACE]  int  max  =  0; 	[BUGGY] int max = 4 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      [BUGGY] int max = 4 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^654^^^^^646^730^
[REPLACE]  StringBuffer  optBuf; 	[BUGGY] StringBuffer sb = new StringBuffer ( len ) ; [CE] variable sb is already defined in method renderOptions(StringBuffer , int , Options , int , int)  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; [BUGGY] StringBuffer sb = new StringBuffer ( len )  ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^655^^^^^646^730^
[ADD]  StringBuffer  optBuf; 	[BUGGY] [CE] cannot find symbol optBuf  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; [BUGGY] List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^655^^^^^646^730^
[REPLACE]  List  prefixList  =  new  ArrayList  (  )  ; 	[BUGGY] int pos = s . length ( ) ; [CE] cannot find symbol s  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; [BUGGY] int pos = s . length ( )  ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^656^^^^^646^730^
[REPLACE]  Option  option; 	[BUGGY] Option opt1 =  ( Option ) o1 ; [CE] cannot find symbol o1  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; [BUGGY] Option opt1 = ( Option ) o1 ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^657^^^^^646^730^
[REPLACE]  List  optList  =  options  .  helpOptions  (  )  ; 	[BUGGY] List optList = options . getOptions ( ) ; [CE] incompatible types  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; [BUGGY] List optList = options . getOptions ( )  ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^658^^^^^646^730^
[REPLACE]  Collections  .  sort  (  optList,  new  OptionComparator  (  )  )  ; 	[BUGGY] Collections . sort ( prefixList , new OptionComparator ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  [BUGGY] Collections . sort ( prefixList , new OptionComparator ( ) )  ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^660^^^^^646^730^
[REPLACE]  if  (  option  .  getOpt  (  )  ==  null  )  { 	[BUGGY] if ( option . getOpt ( ) ! = dpad ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  [BUGGY] if ( option . getOpt ( ) ! = dpad ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^667^668^^^^646^730^
[REPLACE]  if  (  option  .  hasLongOpt  (  )  )  { 	[BUGGY] if ( option . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  [BUGGY] if ( option . hasArg ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^677^678^^^^667^682^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix ) . append ( option . hasLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( ' , ' )  . append ( defaultLongOptPrefix )  . append ( option . hasLongOpt ( ) )  ;  } }  	None^679^680^^^^667^682^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( newline )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( newline )  } }  	None^679^680^^^^667^682^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( dpad )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( dpad )  } }  	None^679^680^^^^667^682^
[ADD]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { [BUGGY]  } }  	None^679^680^^^^667^682^
[REPLACE]    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] . append ( option . hasLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix ) [BUGGY] . append ( option . hasLongOpt ( ) )  ; } }  	None^680^^^^^667^682^
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (    "      "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( lpad ) . append (   "    " < defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [CE] bad operand types for binary operator  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { [BUGGY] optBuf . append ( lpad )  . append (   "   "<defaultLongOptPrefix )  . append ( option . getLongOpt ( ) )  ;  } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^669^670^^^^667^682^
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (    "      "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . StringBuffer ( newline ) . append (   "    "  = =  defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [CE] cannot find symbol newline  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { [BUGGY] optBuf . StringBuffer ( newline )  . append (   "   " = = defaultLongOptPrefix )  . append ( option . getLongOpt ( ) )  ;  } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^669^670^^^^667^682^
[ADD]  optBuf  .  append  (  lpad  )    .  append  (    "      "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { [BUGGY]  } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^669^670^^^^667^682^
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (    "      "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . StringBuffer ( lpad ) . append (   "    " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { [BUGGY] optBuf . StringBuffer ( lpad )  . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) )  ;  } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^669^670^^^^667^682^
[REPLACE]    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] . append ( option . hasLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix ) [BUGGY] . append ( option . hasLongOpt ( ) )  ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^670^^^^^667^682^
[REPLACE]  if  (  option  .  hasLongOpt  (  )  )  { 	[BUGGY] if ( option . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  [BUGGY] if ( option . hasArg ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^677^678^^^^646^730^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( newline )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( newline )  }  	None^679^680^^^^677^681^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( dpad )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( dpad )  }  	None^679^680^^^^677^681^
[ADD]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { [BUGGY]  }  	None^679^680^^^^677^681^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( defaultLongOptPrefix )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( defaultLongOptPrefix )  }  	None^679^680^^^^677^681^
[REPLACE]    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] . append ( option . hasLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix ) [BUGGY] . append ( option . hasLongOpt ( ) )  ; }  	None^680^^^^^677^681^
[REMOVE]   	[BUGGY] optBuf . append ( lpad ) . append (   "    " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix ) [BUGGY] . append ( option . getLongOpt ( ) ) ;   	None^680^^^^^677^681^
[REPLACE]  if  (  option  .  hasArg  (  )  )  { 	[BUGGY] if ( option . hasArgName ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } [BUGGY] if ( option . hasArgName ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^684^685^^^^646^730^
[REPLACE]  if  (  option  .  hasArgName  (  )  )  { 	[BUGGY] if ( option . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { [BUGGY] if ( option . hasArg ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } }  	None^686^687^^^^684^694^
[REPLACE]  optBuf  .  append  (  '  '  )  ; 	[BUGGY] optBuf . append ( dpad ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { [BUGGY] optBuf . append ( dpad )  ; } }  	None^692^^^^^684^694^
[REPLACE]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] optBuf . append (   " <  " ) . append ( option . hasArgName ( ) ) . append (   ">  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { [BUGGY] optBuf . append (   " <  " )  . append ( option . hasArgName ( ) )  . append (   ">  " )  ; } else { optBuf . append ( ' ' ) ; } }  	None^688^^^^^684^694^
[REPLACE]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] optBuf . StringBuffer (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { [BUGGY] optBuf . StringBuffer (   " <  " )  . append ( option . getArgName ( ) )  . append (   ">  " )  ; } else { optBuf . append ( ' ' ) ; } }  	None^688^^^^^684^694^
[REPLACE]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] optBuf . toString ( )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { [BUGGY] optBuf . toString ( ) } else { optBuf . append ( ' ' ) ; } }  	None^688^^^^^684^694^
[REPLACE]  if  (  option  .  hasArgName  (  )  )  { 	[BUGGY] if ( option . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { [BUGGY] if ( option . hasArg ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^686^687^^^^646^730^
[REPLACE]  optBuf  .  append  (  '  '  )  ; 	[BUGGY] optBuf . append ( dpad ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { [BUGGY] optBuf . append ( dpad )  ; }  	None^692^^^^^686^693^
[REPLACE]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] optBuf . toString ( )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArgName ( ) ) { [BUGGY] optBuf . toString ( ) } else { optBuf . append ( ' ' ) ; }  	None^688^^^^^686^693^
[ADD]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArgName ( ) ) { [BUGGY] } else { optBuf . append ( ' ' ) ; }  	None^688^^^^^686^693^
[REPLACE]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] optBuf . StringBuffer (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArgName ( ) ) { [BUGGY] optBuf . StringBuffer (   " <  " )  . append ( option . getArgName ( ) )  . append (   ">  " )  ; } else { optBuf . append ( ' ' ) ; }  	None^688^^^^^686^693^
[REPLACE]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] optBuf . append (   " <  " ) . append ( option . hasArgName ( ) ) . append (   ">  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArgName ( ) ) { [BUGGY] optBuf . append (   " <  " )  . append ( option . hasArgName ( ) )  . append (   ">  " )  ; } else { optBuf . append ( ' ' ) ; }  	None^688^^^^^686^693^
[REPLACE]  if  (  option  .  getOpt  (  )  ==  null  )  { 	[BUGGY] if (dpad ( ) ! = false ) {[CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  [BUGGY] if ( dpad ( ) ! = false ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; }  	None^667^668^^^^662^698^
[ADD]  if  (  option  .  getOpt  (  )  ==  null  )  {  optBuf  .  append  (  lpad  )    .  append  (    "      "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  [BUGGY]   else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; }  	None^667^668^669^670^671^662^698^
[REPLACE]  if  (  option  .  hasLongOpt  (  )  )  { 	[BUGGY] if ( option . getLongOpt ( ) ) {[CE] incompatible types  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  [BUGGY] if ( option . getLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^677^678^^^^667^682^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( text )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( text )  } }  	None^679^680^^^^667^682^
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (    "      "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( lpad ) . append (   "    " || defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [CE] bad operand types for binary operator  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { [BUGGY] optBuf . append ( lpad )  . append (   "   "||defaultLongOptPrefix )  . append ( option . getLongOpt ( ) )  ;  } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^669^670^^^^667^682^
[REPLACE]  optBuf  .  append  (  lpad  )    .  append  (    "      "  +  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( lpad ) . append (   "    " & defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [CE] bad operand types for binary operator  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getOpt ( )  = = null ) { [BUGGY] optBuf . append ( lpad )  . append (   "   "&defaultLongOptPrefix )  . append ( option . getLongOpt ( ) )  ;  } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } }  	None^669^670^^^^667^682^
[REPLACE]  if  (  option  .  hasLongOpt  (  )  )  { 	[BUGGY] if ( option . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  [BUGGY] if ( option . hasArg ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; }  	None^677^678^^^^662^698^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix ) . append ( option . hasLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( ' , ' )  . append ( defaultLongOptPrefix )  . append ( option . hasLongOpt ( ) )  ;  }  	None^679^680^^^^677^681^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( text )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( text )  }  	None^679^680^^^^677^681^
[REPLACE]  optBuf  .  append  (  ','  )    .  append  (  defaultLongOptPrefix  )    .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] optBuf . append ( defaultOptPrefix )[CE] ' ; ' expected  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasLongOpt ( ) ) { [BUGGY] optBuf . append ( defaultOptPrefix )  }  	None^679^680^^^^677^681^
[REPLACE]  if  (  option  .  hasArg  (  )  )  { 	[BUGGY] if ( option . hasArgName ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } [BUGGY] if ( option . hasArgName ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; }  	None^684^685^^^^662^698^
[ADD]  if  (  option  .  hasArg  (  )  )  {  if  (  option  .  hasArgName  (  )  )  {  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } [BUGGY]   } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; }  	None^684^685^686^687^688^662^698^
[REPLACE]  if  (  option  .  hasArgName  (  )  )  { 	[BUGGY] if ( option . getArgName ( ) ) {[CE] incompatible types  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { [BUGGY] if ( option . getArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } }  	None^686^687^^^^684^694^
[REPLACE]  optBuf  .  append  (  '  '  )  ; 	[BUGGY] optBuf . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { [BUGGY] optBuf . toString ( ) ; } }  	None^692^^^^^684^694^
[ADD]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { [BUGGY] } else { optBuf . append ( ' ' ) ; } }  	None^688^^^^^684^694^
[REPLACE]  optBuf  .  append  (    "  <  "  )    .  append  (  option  .  getArgName  (  )  )    .  append  (    ">  "  )  ; 	[BUGGY] optBuf . append (   " <  " ) . append ( option . hasArgName ( )  ) . append (   ">  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { [BUGGY] optBuf . append (   " <  " )  . append ( option . hasArgName ( )  )  . append (   ">  " )  ; } else { optBuf . append ( ' ' ) ; } }  	None^688^^^^^684^694^
[REPLACE]  if  (  option  .  hasArgName  (  )  )  { 	[BUGGY] if ( option . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { [BUGGY] if ( option . hasArg ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; }  	None^686^687^^^^662^698^
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ; 	[BUGGY] option =  ( Optnullon ) null . next ( ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { [BUGGY] option =  ( Optnullon ) null . next ( )  ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; }  	None^664^^^^^662^698^
[REPLACE]  optBuf  =  new  StringBuffer  (  8  )  ; 	[BUGGY] optBuf = new StringBuffer ( 8 >> 1 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; [BUGGY] optBuf = new StringBuffer ( 8 >> 1 )  ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; }  	None^665^^^^^662^698^
[REPLACE]  max  =  (  optBuf  .  length  (  )  >  max  )        ?  optBuf  .  length  (  )  :  max; 	[BUGGY] max =  ( optBuf . length ( ) - 2 > max )    ? optBuf . length ( ) - 2 : max ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; [BUGGY] max = ( optBuf . length ( ) - 2 > max ) ? optBuf . length ( ) - 2 : max ; }  	None^697^^^^^662^698^
[ADD]  max  =  (  optBuf  .  length  (  )  >  max  )        ?  optBuf  .  length  (  )  :  max; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; [BUGGY] }  	None^697^^^^^662^698^
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ; 	[BUGGY] option =  ( Optnullon ) null . next ( ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { [BUGGY] option =  ( Optnullon ) null . next ( )  ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^664^^^^^646^730^
[REPLACE]  optBuf  =  new  StringBuffer  (  8  )  ; 	[BUGGY] optBuf = new StringBuffer ( 5 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; [BUGGY] optBuf = new StringBuffer ( 5 )  ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^665^^^^^646^730^
[ADD]  optBuf  =  new  StringBuffer  (  8  )  ; 	[BUGGY] [CE] variable optBuf might not have been initialized  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; [BUGGY]  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^665^^^^^646^730^
[REPLACE]  max  =  (  optBuf  .  length  (  )  >  max  )        ?  optBuf  .  length  (  )  :  max; 	[BUGGY] max =  ( optBuf . length ( ) - 4 > max )    ? optBuf . length ( ) - 4 : max ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; [BUGGY] max = ( optBuf . length ( ) - 4 > max ) ? optBuf . length ( ) - 4 : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^697^^^^^646^730^
[REPLACE]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = prefixList . iterator ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  [BUGGY] for ( Iterator i = prefixList . iterator ( )  ; i . hasNext ( )  ;  ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^662^663^^^^646^730^
[REPLACE]  int  x  =  0; 	[BUGGY] int x = 1 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } [BUGGY] int x = 1 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^700^^^^^646^730^
[REPLACE]  if  (  optBuf  .  length  (  )  <  max  )  { 	[BUGGY] if ( optBuf . length ( ) / 2 < max ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  [BUGGY] if ( optBuf . length ( ) /2 < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^707^708^^^^646^730^
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ; 	[BUGGY] optBuf . append ( createPadding ( x - optBuf . length ( ) - 3 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( optBuf . length ( ) < max ) { [BUGGY] optBuf . append ( createPadding ( x - optBuf . length ( ) - 3 ) )  ; }  	None^709^^^^^707^710^
[REMOVE]   	[BUGGY] optBuf . append ( lpad ) . append (   "    " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( optBuf . length ( ) < max ) { [BUGGY] optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ;   	None^709^^^^^707^710^
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ; 	[BUGGY] optBuf . append ( createPadding ( max - optBuf . size ( ) ) ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( optBuf . length ( ) < max ) { [BUGGY] optBuf . append ( createPadding ( max - optBuf . size ( ) ) )  ; }  	None^709^^^^^707^710^
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ; 	[BUGGY] optBuf . append ( createPadding ( max - optBuf . append ( ) ) ) ; [CE] no suitable method found for append()  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( optBuf . length ( ) < max ) { [BUGGY] optBuf . append ( createPadding ( max - optBuf . append ( ) ) )  ; }  	None^709^^^^^707^710^
[REPLACE]  if  (  option  .  getDescription  (  )  !=  null  )  { 	[BUGGY] if (defaultSyntaxPrefix ( )  = = null ) {[CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  [BUGGY] if ( defaultSyntaxPrefix ( ) = = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^716^717^^^^646^730^
[REPLACE]  optBuf  .  append  (  option  .  getDescription  (  )  )  ; 	[BUGGY] optBuf . append ( option . getOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getDescription ( ) ! = null ) { [BUGGY] optBuf . append ( option . getOpt ( ) )  ; }  	None^718^^^^^716^719^
[REMOVE]   	[BUGGY] optBuf . append ( lpad ) . append (   "    " + defaultLongOptPrefix ) . append ( option . getLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( option . getDescription ( ) ! = null ) { [BUGGY] optBuf . append ( option . getDescription ( ) ) ;   	None^718^^^^^716^719^
[REPLACE]  if  (  i  .  hasNext  (  )  )  { 	[BUGGY] if ( i . next ( ) ) {[CE] incompatible types  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  [BUGGY] if ( i . next ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^723^724^^^^646^730^
[ADD]  if  (  i  .  hasNext  (  )  )  {  sb  .  append  (  defaultNewLine  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  [BUGGY]   } return sb ; }  	None^723^724^725^726^^646^730^
[REPLACE]  sb  .  append  (  defaultNewLine  )  ; 	[BUGGY] sb . StringBuffer ( defaultNewLine ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  if ( i . hasNext ( ) ) { [BUGGY] sb . StringBuffer ( defaultNewLine )  ; }  	None^725^^^^^723^726^
[REPLACE]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = optList . iterator ( ) ; i . next ( ) ; ) {[CE] incompatible types  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  [BUGGY] for ( Iterator i = optList . iterator ( )  ; i . next ( )  ;  ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^702^703^^^^646^730^
[REPLACE]  if  (  optBuf  .  length  (  )  <  max  )  { 	[BUGGY] if ( optBuf . size ( ) < max ) {[CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  [BUGGY] if ( optBuf . size ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^707^708^^^^702^727^
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ; 	[BUGGY] optBuf . append ( createPadding ( max - optBuf . size ( ) ) ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { [BUGGY] optBuf . append ( createPadding ( max - optBuf . size ( ) ) )  ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^709^^^^^702^727^
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ; 	[BUGGY] optBuf . append ( createPadding ( max - optBuf . length ( ) + 5 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { [BUGGY] optBuf . append ( createPadding ( max - optBuf . length ( ) + 5 ) )  ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^709^^^^^702^727^
[REPLACE]  optBuf  .  append  (  createPadding  (  max  -  optBuf  .  length  (  )  )  )  ; 	[BUGGY] optBuf . append ( createPadding ( max - sb . append ( ) ) ) ; [CE] no suitable method found for append()  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { [BUGGY] optBuf . append ( createPadding ( max - sb . append ( ) ) )  ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^709^^^^^702^727^
[REPLACE]  if  (  option  .  getDescription  (  )  !=  null  )  { 	[BUGGY] if ( option . getDescription ( )  = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  [BUGGY] if ( option . getDescription ( ) = = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^716^717^^^^702^727^
[ADD]  if  (  option  .  getDescription  (  )  !=  null  )  {  optBuf  .  append  (  option  .  getDescription  (  )  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  [BUGGY]   renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^716^717^718^719^^702^727^
[REPLACE]  optBuf  .  append  (  option  .  getDescription  (  )  )  ; 	[BUGGY] optBuf . append ( option . getOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { [BUGGY] optBuf . append ( option . getOpt ( ) )  ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^718^^^^^702^727^
[REPLACE]  optBuf  .  append  (  option  .  getDescription  (  )  )  ; 	[BUGGY] optBuf . append ( option . getOpt ( )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { [BUGGY] optBuf . append ( option . getOpt ( )  )  ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^718^^^^^702^727^
[REPLACE]  if  (  i  .  hasNext  (  )  )  { 	[BUGGY] if ( i . next ( ) ) {[CE] incompatible types  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  [BUGGY] if ( i . next ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^723^724^^^^702^727^
[REPLACE]  sb  .  append  (  defaultNewLine  )  ; 	[BUGGY] sb . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { [BUGGY] sb . toString ( ) ; } }  	None^725^^^^^702^727^
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ; 	[BUGGY] option =  ( Optnullon ) null . next ( ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { [BUGGY] option =  ( Optnullon ) null . next ( )  ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^704^^^^^702^727^
[REPLACE]  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )    .  toString  (  )  )  ; 	[BUGGY] optBuf =  new StringBuffer ( null . get ( x++ ) . toString ( ) ) ; [CE] <null> cannot be dereferenced  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; [BUGGY] optBuf = new StringBuffer ( null . get ( x++ )  . toString ( ) )  ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^705^^^^^702^727^
[REPLACE]  int  nextLineTabStop  =  max  +  descPad; 	[BUGGY] int nextLineTabStop = max +x ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  [BUGGY] int nextLineTabStop = max +x ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^714^^^^^702^727^
[ADD]  int  nextLineTabStop  =  max  +  descPad; 	[BUGGY] [CE] cannot find symbol nextLineTabStop  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  [BUGGY]  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } }  	None^714^^^^^702^727^
[REPLACE]  option  =  (  Option  )  i  .  next  (  )  ; 	[BUGGY] option =  ( Optnullon ) null . next ( ) ; [CE] cannot find symbol  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { [BUGGY] option =  ( Optnullon ) null . next ( )  ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^704^^^^^646^730^
[REPLACE]  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )    .  toString  (  )  )  ; 	[BUGGY] optBuf =  new StringBuffer ( optList . get ( x++ ) . toString ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; [BUGGY] optBuf = new StringBuffer ( optList . get ( x++ )  . toString ( ) )  ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^705^^^^^646^730^
[REPLACE]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = prefixList . iterator ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  [BUGGY] for ( Iterator i = prefixList . iterator ( )  ; i . hasNext ( )  ;  ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^702^703^^^^646^730^
[ADD]  for  (  Iterator  i  =  optList  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  option  =  (  Option  )  i  .  next  (  )  ;  optBuf  =  new  StringBuffer  (  prefixList  .  get  (  x++  )    .  toString  (  )  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  [BUGGY]   if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^702^703^704^705^^646^730^
[REPLACE]  int  nextLineTabStop  =  max  +  descPad; 	[BUGGY] int nextLineTabStop = x + descPad ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  [BUGGY] int nextLineTabStop = x + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } return sb ; }  	None^714^^^^^646^730^
[REPLACE]  return  sb; 	[BUGGY] return optBuf ; [CE] variable optBuf might not have been initialized  [METHOD]  renderOptions [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width Options options int leftPad int descPad [CLASS] HelpFormatter OptionComparator  [TYPE] Options options [TYPE] StringBuffer optBuf sb [TYPE] boolean false true [TYPE] Iterator i [TYPE] List optList prefixList [TYPE] Option option [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline prefix text [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding width x  [CONTEXT]  { final String lpad = createPadding ( leftPad ) ; final String dpad = createPadding ( descPad ) ;      int max = 0 ; StringBuffer optBuf ; List prefixList = new ArrayList ( ) ; Option option ; List optList = options . helpOptions ( ) ;  Collections . sort ( optList , new OptionComparator ( ) ) ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( 8 ) ;  if ( option . getOpt ( )  = = null ) { optBuf . append ( lpad ) . append (   "   " + defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } else { optBuf . append ( lpad ) . append ( defaultOptPrefix )  . append ( option . getOpt ( ) ) ;  if ( option . hasLongOpt ( ) ) { optBuf . append ( ' , ' ) . append ( defaultLongOptPrefix )  . append ( option . getLongOpt ( ) ) ; } } if ( option . hasArg ( ) ) { if ( option . hasArgName ( ) ) { optBuf . append (   " <  " ) . append ( option . getArgName ( ) ) . append (   ">  " ) ; } else { optBuf . append ( ' ' ) ; } } prefixList . add ( optBuf ) ; max =  ( optBuf . length ( ) > max ) ? optBuf . length ( ) : max ; } int x = 0 ;  for ( Iterator i = optList . iterator ( ) ; i . hasNext ( ) ; ) { option =  ( Option ) i . next ( ) ; optBuf = new StringBuffer ( prefixList . get ( x++ ) . toString ( ) ) ;  if ( optBuf . length ( ) < max ) { optBuf . append ( createPadding ( max - optBuf . length ( ) ) ) ; } optBuf . append ( dpad ) ;  int nextLineTabStop = max + descPad ;  if ( option . getDescription ( ) ! = null ) { optBuf . append ( option . getDescription ( ) ) ; } renderWrappedText ( sb , width , nextLineTabStop , optBuf . toString ( ) ) ;  if ( i . hasNext ( ) ) { sb . append ( defaultNewLine ) ; } } [BUGGY] return optBuf ; }  	None^729^^^^^646^730^
[REPLACE]  int  pos  =  findWrapPos  (  text,  width,  0  )  ; 	[BUGGY] int pos = findWrapPos ( text , width , 1 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { [BUGGY] int pos = findWrapPos ( text , width , 1 )  ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^746^^^^^745^774^
[ADD]  int  pos  =  findWrapPos  (  text,  width,  0  )  ; 	[BUGGY] [CE] cannot find symbol pos  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { [BUGGY]  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^746^^^^^745^774^
[REPLACE]  if  (  pos  ==  -1  )  { 	[BUGGY] if ( pos ! =  -3 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  [BUGGY] if ( pos! = -3 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^748^749^^^^745^774^
[REPLACE]  return  sb; 	[BUGGY] return s ; [CE] cannot find symbol s  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  [BUGGY] return s ; }  	None^752^^^^^748^753^
[REPLACE]  return  sb; 	[BUGGY] return s ; [CE] cannot find symbol s  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  [BUGGY] return s ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^752^^^^^745^774^
[REPLACE]  sb  .  append  (  rtrim  (  text  .  substring  (  0,  pos  )  )  )    .  append  (  defaultNewLine  )  ; 	[BUGGY] sb . StringBuffer ( rtrim ( text . substring ( 2 , pos ) ) ) . append ( defaultNewLine ) ; [CE] cannot find symbol  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } [BUGGY] sb . StringBuffer ( rtrim ( text . substring ( 2 , pos ) ) )  . append ( defaultNewLine )  ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^754^^^^^745^774^
[REPLACE]  sb  .  append  (  rtrim  (  text  .  substring  (  0,  pos  )  )  )    .  append  (  defaultNewLine  )  ; 	[BUGGY] sb . StringBuffer ( rtrim ( text . substring ( 0 / 4 , pos ) ) ) . append ( defaultNewLine ) ; [CE] cannot find symbol  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } [BUGGY] sb . StringBuffer ( rtrim ( text . substring ( 0 / 4 , pos ) ) )  . append ( defaultNewLine )  ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^754^^^^^745^774^
[REPLACE]  sb  .  append  (  rtrim  (  text  .  substring  (  0,  pos  )  )  )    .  append  (  defaultNewLine  )  ; 	[BUGGY] sb . append ( rtrim ( text . substring ( 0L , pos ) ) ) . append ( defaultNewLine ) ; [CE] no suitable method found for substring(long , int)  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } [BUGGY] sb . append ( rtrim ( text . substring ( 0L , pos ) ) )  . append ( defaultNewLine )  ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^754^^^^^745^774^
[REPLACE]  sb  .  append  (  rtrim  (  text  .  substring  (  0,  pos  )  )  )    .  append  (  defaultNewLine  )  ; 	[BUGGY] sb . append ( rtrim ( text . indexOf ( 1 , pos ) ) ) . append ( defaultNewLine ) ; [CE] method rtrim in class HelpFormatter cannot be applied to given types ;  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } [BUGGY] sb . append ( rtrim ( text . indexOf ( 1 , pos ) ) )  . append ( defaultNewLine )  ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^754^^^^^745^774^
[REPLACE]  final  String  padding  =  createPadding  (  nextLineTabStop  )  ; 	[BUGGY] final String padding = createPadding ( x ) ; [CE] cannot find symbol x  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    [BUGGY] final String padding = createPadding ( x )  ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^758^^^^^745^774^
[REPLACE]  while  (  true  )  { 	[BUGGY] while ( false ) {[CE] unreachable statement  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  [BUGGY] while ( false ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^760^761^^^^745^774^
[REPLACE]  if  (  pos  ==  -1  )  { 	[BUGGY] if ( padding && padding ) {[CE] bad operand types for binary operator '&&'  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  [BUGGY] if ( padding&& padding ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; }  	None^765^766^^^^760^773^
[ADD]  if  (  pos  ==  -1  )  {  sb  .  append  (  text  )  ;  return  sb; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  [BUGGY]   } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; }  	None^765^766^767^^769^760^773^
[REPLACE]  return  sb; 	[BUGGY] return s ; [CE] cannot find symbol s  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  [BUGGY] return s ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; }  	None^769^^^^^760^773^
[REPLACE]  text  =  padding  +  text  .  substring  (  pos  )    .  trim  (  )  ; 	[BUGGY] text = prefix + text . substring ( pos ) . trim ( ) ; [CE] cannot find symbol prefix  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  while ( true ) { [BUGGY] text = prefix + text . substring ( pos )  . trim ( )  ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; }  	None^762^^^^^760^773^
[REPLACE]  pos  =  findWrapPos  (  text,  width,  nextLineTabStop  )  ; 	[BUGGY] pos =  findWrapPos ( footer , width , nextLineTabStop ) ; [CE] cannot find symbol footer  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; [BUGGY] pos = findWrapPos ( footer , width , nextLineTabStop )  ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; }  	None^763^^^^^760^773^
[ADD]  pos  =  findWrapPos  (  text,  width,  nextLineTabStop  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; [BUGGY]  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; }  	None^763^^^^^760^773^
[REPLACE]  if  (  pos  ==  -1  )  { 	[BUGGY] if (padding ! =  -1 ) {[CE] incomparable types: String and int  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  [BUGGY] if ( padding! = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^765^766^^^^745^774^
[REPLACE]  return  sb; 	[BUGGY] return s ; [CE] cannot find symbol s  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  if ( pos = = -1 ) { sb . append ( text ) ;  [BUGGY] return s ; }  	None^769^^^^^765^770^
[REPLACE]  text  =  padding  +  text  .  substring  (  pos  )    .  trim  (  )  ; 	[BUGGY] text = prefix + text . substring ( pos ) . trim ( ) ; [CE] cannot find symbol prefix  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { [BUGGY] text = prefix + text . substring ( pos )  . trim ( )  ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^762^^^^^745^774^
[REPLACE]  pos  =  findWrapPos  (  text,  width,  nextLineTabStop  )  ; 	[BUGGY] pos =  findWrapPos ( newline , width , nextLineTabStop ) ; [CE] cannot find symbol newline  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; [BUGGY] pos = findWrapPos ( newline , width , nextLineTabStop )  ;  if ( pos = = -1 ) { sb . append ( text ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^763^^^^^745^774^
[REPLACE]  return  sb; 	[BUGGY] return s ; [CE] cannot find symbol s  [METHOD]  renderWrappedText [TYPE] StringBuffer [PARAMETER] StringBuffer sb int width int nextLineTabStop String text [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos width x  [CONTEXT]  { int pos = findWrapPos ( text , width , 0 ) ;  if ( pos = = -1 ) { sb . append ( rtrim ( text ) ) ;  return sb ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ;    final String padding = createPadding ( nextLineTabStop ) ;  while ( true ) { text = padding + text . substring ( pos ) . trim ( ) ; pos = findWrapPos ( text , width , nextLineTabStop ) ;  if ( pos = = -1 ) { sb . append ( text ) ;  [BUGGY] return s ; } sb . append ( rtrim ( text . substring ( 0 , pos ) ) ) . append ( defaultNewLine ) ; } }  	None^769^^^^^745^774^
[REPLACE]  int  pos  =  -1; 	[BUGGY] int pos = -1 / 3 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { [BUGGY] int pos = -1 / 3 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^791^^^^^790^833^
[REPLACE]  if  (  (  (  pos  =  text  .  indexOf  (  '\n',  startPos  )  )  !=  -1  &&  pos  <=  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t',  startPos  )  )  !=  -1  &&  pos  <=  width  )  )  { 	[BUGGY] if ( ( ( pos = text . substring ( '\n' , startPos ) ) ! = -1 && pos < = width ) && ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) {[CE] incompatible types  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   [BUGGY] if ( ( ( pos = text . substring ( '\n' , startPos ) ) ! = -1 && pos < = width ) && ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) {  return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^794^795^796^^^790^833^
[REPLACE]  else  if  (  (  startPos  +  width  )  >=  text  .  length  (  )  )  { 	[BUGGY] if ( ( startPos + width ) > = text . length ( ) * 2 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } [BUGGY] if ( ( startPos + width ) > = text . length ( ) *2 ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^799^800^^^^790^833^
[REPLACE]  return  -1; 	[BUGGY] return -1 << 0 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  else if ( ( startPos + width ) > = text . length ( ) ) { [BUGGY] return -1 << 0 ; }  	None^801^^^^^799^802^
[REPLACE]  return  -1; 	[BUGGY] return -1 + 2 ; [FE] AssertionFailedError [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { [BUGGY] return -1 + 2 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^801^^^^^790^833^
[REPLACE]  return  pos+1; 	[BUGGY] return startPos+1 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { [BUGGY] return startPos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }  	None^797^^^^^794^802^
[REPLACE]  else  if  (  (  startPos  +  width  )  >=  text  .  length  (  )  )  { 	[BUGGY] else {[CE] unreachable statement  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } [BUGGY] else { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^799^800^^^^790^833^
[REPLACE]  return  -1; 	[BUGGY] return -3 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  else if ( ( startPos + width ) > = text . length ( ) ) { [BUGGY] return -3 ; }  	None^801^^^^^799^802^
[REPLACE]  if  (  (  (  pos  =  text  .  indexOf  (  '\n',  startPos  )  )  !=  -1  &&  pos  <=  width  )  ||  (  (  pos  =  text  .  indexOf  (  '\t',  startPos  )  )  !=  -1  &&  pos  <=  width  )  )  { 	[BUGGY] if ( ( ( pos =  null . indexOf ( '\n' , startPos ) ) ![CE] ')' expected  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   [BUGGY] if ( ( ( pos = null . indexOf ( '\n' , startPos ) ) !  return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^794^795^796^^^790^833^
[REPLACE]  ||  (  (  pos  =  text  .  indexOf  (  '\t',  startPos  )  )  !=  -1  &&  pos  <=  width  )  )  { 	[BUGGY] || ( ( pos =  prefix . indexOf ( '\t' , startPos ) ) ![CE] ')' expected  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) [BUGGY] || ( ( pos = prefix . indexOf ( '\t' , startPos ) ) ! return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^795^796^^^^790^833^
[REPLACE]  return  pos+1; 	[BUGGY] returnpadding+1 ; [CE] not a statement  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { [BUGGY] returnpadding+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^797^^^^^790^833^
[REPLACE]  return  -1; 	[BUGGY] return -4 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { [BUGGY] return -4 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^801^^^^^790^833^
[REPLACE]  pos  =  startPos  +  width; 	[BUGGY] pos = max + width ; [CE] cannot find symbol max  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   [BUGGY] pos = max + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^806^^^^^790^833^
[REPLACE]  char  c; 	[BUGGY] final String padding = createPadding ( nextLineTabStop ) ; [CE] cannot find symbol nextLineTabStop  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  [BUGGY] final String padding = createPadding ( nextLineTabStop )  ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^808^^^^^790^833^
[REPLACE]  while  (  (  pos  >=  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !=  '  '  )  &&  (  c  !=  '\n'  )  &&  (  c  !=  '\r'  )  )  { 	[BUGGY] while ( ( pos > = startPos ) || ( ( c = text . charAt ( pos ) ) ! = ' ' ) || ( c ! = '\n' ) || ( c ! = '\r' ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  [BUGGY] while ( ( pos > = startPos ) || ( ( c = text . charAt ( pos ) ) ! = ' ' ) || ( c ! = '\n' ) || ( c ! = '\r' ) ) {  --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^810^811^812^^^790^833^
[REPLACE]  while  (  (  pos  >=  startPos  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !=  '  '  )  &&  (  c  !=  '\n'  )  &&  (  c  !=  '\r'  )  )  { 	[BUGGY] while ( ( pos > =  startPos ) && ( ( c[CE] ')' expected  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  [BUGGY] while ( ( pos > = startPos ) && ( ( c  --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^810^811^812^^^790^833^
[REPLACE]  if  (  pos  >  startPos  )  { 	[BUGGY] if ( pos > =  width ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  [BUGGY] if ( pos> = width ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^817^818^^^^790^833^
[ADD]  if  (  pos  >  startPos  )  {  return  pos;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  [BUGGY]     pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^817^818^819^820^^790^833^
[REPLACE]  return  pos; 	[BUGGY] return startPos ; [FE] AssertionFailedError [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  if ( pos > startPos ) { [BUGGY] return startPos ; }  	None^819^^^^^817^820^
[REPLACE]  return  pos; 	[BUGGY] return padding ; [CE] cannot find symbol padding  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { [BUGGY] return padding ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^819^^^^^790^833^
[REPLACE]  pos  =  startPos  +  width; 	[BUGGY] pos = startPos +pos ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   [BUGGY] pos = startPos +pos ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^824^^^^^790^833^
[REPLACE]  while  (  (  pos  <=  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !=  '  '  )  &&  (  c  !=  '\n'  )  &&  (  c  !=  '\r'  )  )  { 	[BUGGY] while ( ( pos < = text . length ( ) / 0 . 5 ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  [BUGGY] while ( ( pos < = text . length ( ) /0 . 5 ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) {  ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^826^827^828^^^790^833^
[REPLACE]  while  (  (  pos  <=  text  .  length  (  )  )  &&  (  (  c  =  text  .  charAt  (  pos  )  )  !=  '  '  )  &&  (  c  !=  '\n'  )  &&  (  c  !=  '\r'  )  )  { 	[BUGGY] while ( ( pos < =  prefix . length ( ) ) && ( ( c[CE] ')' expected  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  [BUGGY] while ( ( pos < = prefix . length ( ) ) && ( ( c  ++pos ; } return ( pos = = text . length ( ) ) ? ( -1 ) : pos ; }  	None^826^827^828^^^790^833^
[REPLACE]  return  (  pos  ==  text  .  length  (  )  )          ?  (  -1  )  :  pos; 	[BUGGY] returnstartPos ; [CE] not a statement  [METHOD]  findWrapPos [TYPE] int [PARAMETER] String text int width int startPos [CLASS] HelpFormatter OptionComparator  [TYPE] char c [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad leftPad max nextLineTabStop padding pos startPos width x  [CONTEXT]  { int pos = -1 ;   if ( ( ( pos = text . indexOf ( '\n' , startPos ) ) ! = -1 && pos < = width ) || ( ( pos = text . indexOf ( '\t' , startPos ) ) ! = -1 && pos < = width ) ) { return pos+1 ; } else if ( ( startPos + width ) > = text . length ( ) ) { return -1 ; }   pos = startPos + width ;  char c ;  while ( ( pos > = startPos ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { --pos ; }  if ( pos > startPos ) { return pos ; }   pos = startPos + width ;  while ( ( pos < = text . length ( ) ) && ( ( c = text . charAt ( pos ) ) ! = ' ' ) && ( c ! = '\n' ) && ( c ! = '\r' ) ) { ++pos ; } [BUGGY] returnstartPos ; }  	None^832^^^^^790^833^
[REPLACE]  StringBuffer  sb  =  new  StringBuffer  (  len  )  ; 	[BUGGY] StringBuffer sb = new StringBuffer ( padding ) ; [CE] cannot find symbol padding  [METHOD]  createPadding [TYPE] String [PARAMETER] int len [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  protected String createPadding ( int len ) { [BUGGY] StringBuffer sb = new StringBuffer ( padding )  ;  for ( int i = 0 ; i < len ; ++i ) { sb . append ( ' ' ) ; } return sb . toString ( ) ; }  	None^844^^^^^842^852^
[ADD]  StringBuffer  sb  =  new  StringBuffer  (  len  )  ; 	[BUGGY] [CE] cannot find symbol sb  [METHOD]  createPadding [TYPE] String [PARAMETER] int len [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  protected String createPadding ( int len ) { [BUGGY]  for ( int i = 0 ; i < len ; ++i ) { sb . append ( ' ' ) ; } return sb . toString ( ) ; }  	None^844^^^^^842^852^
[REPLACE]  for  (  int  i  =  0;  i  <  len;  ++i  )  { 	[BUGGY] for ( int i = 0 ; i ! =  len ; ++i ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createPadding [TYPE] String [PARAMETER] int len [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  protected String createPadding ( int len ) { StringBuffer sb = new StringBuffer ( len ) ;  [BUGGY] for ( int i = 0 ; i! = len ; ++i ) { sb . append ( ' ' ) ; } return sb . toString ( ) ; }  	None^846^847^^^^842^852^
[REPLACE]  sb  .  append  (  '  '  )  ; 	[BUGGY] sb . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createPadding [TYPE] String [PARAMETER] int len [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  protected String createPadding ( int len ) { StringBuffer sb = new StringBuffer ( len ) ;  for ( int i = 0 ; i < len ; ++i ) { [BUGGY] sb . toString ( ) ; } return sb . toString ( ) ; }  	None^848^^^^^842^852^
[REPLACE]  for  (  int  i  =  0;  i  <  len;  ++i  )  { 	[BUGGY] for ( int i = 4 ; i < len ; ++i ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createPadding [TYPE] String [PARAMETER] int len [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  protected String createPadding ( int len ) { StringBuffer sb = new StringBuffer ( len ) ;  [BUGGY] for ( int i = 4 ; i < len ; ++i ) { sb . append ( ' ' ) ; } return sb . toString ( ) ; }  	None^846^847^^^^842^852^
[REPLACE]  return  sb  .  toString  (  )  ; 	[BUGGY] return sb . StringBuffer ( ) ; [CE] cannot find symbol  [METHOD]  createPadding [TYPE] String [PARAMETER] int len [CLASS] HelpFormatter OptionComparator  [TYPE] StringBuffer sb [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  protected String createPadding ( int len ) { StringBuffer sb = new StringBuffer ( len ) ;  for ( int i = 0 ; i < len ; ++i ) { sb . append ( ' ' ) ; } [BUGGY] return sb . StringBuffer ( )  ; }  	None^851^^^^^842^852^
[REPLACE]  if  (  (  s  ==  null  )  ||  (  s  .  length  (  )  ==  0  )  )  { 	[BUGGY] if ( ( defaultSyntaxPrefix = = false ) || ( s . length ( ) / 2 = = 0 ) ) {[CE] incomparable types: String and boolean  [METHOD]  rtrim [TYPE] String [PARAMETER] String s [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true  [CONTEXT]  protected String rtrim ( String s ) { [BUGGY] if ( ( defaultSyntaxPrefix = = false ) || ( s . length ( ) /2 = = 0 ) ) { return s ; } int pos = s . length ( ) ;  while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { --pos ; } return s . substring ( 0 , pos ) ; }  	None^863^864^^^^861^876^
[REMOVE]   	[BUGGY] if ( pos > startPos ) {   return pos ; }[CE] cannot find symbol pos  [METHOD]  rtrim [TYPE] String [PARAMETER] String s [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true  [CONTEXT]  protected String rtrim ( String s ) { [BUGGY] if ( ( s = = null ) || ( s . length ( )  = = 0 ) )  if ( pos > startPos ) { return pos ; }{ return s ; } int pos = s . length ( ) ;  while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { --pos ; } return s . substring ( 0 , pos ) ;   	None^863^^^^^861^876^
[REPLACE]  return  s; 	[BUGGY] return defaultSyntaxPrefix ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  rtrim [TYPE] String [PARAMETER] String s [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true  [CONTEXT]  protected String rtrim ( String s ) { if ( ( s = = null ) || ( s . length ( )  = = 0 ) ) { [BUGGY] return defaultSyntaxPrefix ; } int pos = s . length ( ) ;  while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { --pos ; } return s . substring ( 0 , pos ) ; }  	None^865^^^^^861^876^
[REPLACE]  return  s; 	[BUGGY] return sb ; [CE] cannot find symbol sb  [METHOD]  rtrim [TYPE] String [PARAMETER] String s [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true  [CONTEXT]  protected String rtrim ( String s ) { if ( ( s = = null ) || ( s . length ( )  = = 0 ) ) { [BUGGY] return sb ; } int pos = s . length ( ) ;  while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { --pos ; } return s . substring ( 0 , pos ) ; }  	None^865^^^^^861^876^
[REPLACE]  int  pos  =  s  .  length  (  )  ; 	[BUGGY] int pos = defaultSyntaxPrefix . length ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  rtrim [TYPE] String [PARAMETER] String s [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true  [CONTEXT]  protected String rtrim ( String s ) { if ( ( s = = null ) || ( s . length ( )  = = 0 ) ) { return s ; } [BUGGY] int pos = defaultSyntaxPrefix . length ( )  ;  while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { --pos ; } return s . substring ( 0 , pos ) ; }  	None^868^^^^^861^876^
[ADD]  int  pos  =  s  .  length  (  )  ; 	[BUGGY] [CE] cannot find symbol pos  [METHOD]  rtrim [TYPE] String [PARAMETER] String s [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true  [CONTEXT]  protected String rtrim ( String s ) { if ( ( s = = null ) || ( s . length ( )  = = 0 ) ) { return s ; } [BUGGY]  while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { --pos ; } return s . substring ( 0 , pos ) ; }  	None^868^^^^^861^876^
[REPLACE]  return  s  .  substring  (  0,  pos  )  ; 	[BUGGY] return s . indexOf ( 3 , pos ) ; [CE] incompatible types  [METHOD]  rtrim [TYPE] String [PARAMETER] String s [CLASS] HelpFormatter OptionComparator  [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true  [CONTEXT]  protected String rtrim ( String s ) { if ( ( s = = null ) || ( s . length ( )  = = 0 ) ) { return s ; } int pos = s . length ( ) ;  while ( ( pos > 0 ) && Character . isWhitespace ( s . charAt ( pos - 1 ) ) ) { --pos ; } [BUGGY] return s . indexOf ( 3 , pos )  ; }  	None^875^^^^^861^876^
[REPLACE]  Option  opt1  =  (  Option  )  o1; 	[BUGGY] Option opt2 =  ( Option ) o2 ; [CE] variable opt2 is already defined in method compare(Object , Object)  [METHOD]  compare [TYPE] int [PARAMETER] Object o1 Object o2 [CLASS] HelpFormatter OptionComparator  [TYPE] Object o1 o2 [TYPE] Option opt1 opt2 [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  public int compare ( Object o1 , Object o2 ) { [BUGGY] Option opt2 = ( Option ) o2 ; Option opt2 =  ( Option ) o2 ;  return opt1 . getKey ( ) . compareToIgnoreCase ( opt2 . getKey ( ) ) ; }  	None^902^^^^^900^906^
[ADD]  Option  opt1  =  (  Option  )  o1; 	[BUGGY] [CE] cannot find symbol opt1  [METHOD]  compare [TYPE] int [PARAMETER] Object o1 Object o2 [CLASS] HelpFormatter OptionComparator  [TYPE] Object o1 o2 [TYPE] Option opt1 opt2 [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  public int compare ( Object o1 , Object o2 ) { [BUGGY] Option opt2 =  ( Option ) o2 ;  return opt1 . getKey ( ) . compareToIgnoreCase ( opt2 . getKey ( ) ) ; }  	None^902^^^^^900^906^
[REPLACE]  Option  opt2  =  (  Option  )  o2; 	[BUGGY] Option opt1 =  ( Option ) o1 ; [CE] variable opt1 is already defined in method compare(Object , Object)  [METHOD]  compare [TYPE] int [PARAMETER] Object o1 Object o2 [CLASS] HelpFormatter OptionComparator  [TYPE] Object o1 o2 [TYPE] Option opt1 opt2 [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  public int compare ( Object o1 , Object o2 ) { Option opt1 =  ( Option ) o1 ; [BUGGY] Option opt1 = ( Option ) o1 ;  return opt1 . getKey ( ) . compareToIgnoreCase ( opt2 . getKey ( ) ) ; }  	None^903^^^^^900^906^
[REPLACE]  return  opt1  .  getKey  (  )    .  compareToIgnoreCase  (  opt2  .  getKey  (  )  )  ; 	[BUGGY] return opt1 . getOpt ( )  . compareToIgnoreCase ( opt2[CE] ')' expected  [METHOD]  compare [TYPE] int [PARAMETER] Object o1 Object o2 [CLASS] HelpFormatter OptionComparator  [TYPE] Object o1 o2 [TYPE] Option opt1 opt2 [TYPE] String DEFAULT_ARG_NAME DEFAULT_LONG_OPT_PREFIX DEFAULT_OPT_PREFIX DEFAULT_SYNTAX_PREFIX app cmdLineSyntax defaultArgName defaultLongOptPrefix defaultNewLine defaultOptPrefix defaultSyntaxPrefix dpad footer header lpad name newline padding prefix s text [TYPE] boolean false true [TYPE] int DEFAULT_DESC_PAD DEFAULT_LEFT_PAD DEFAULT_WIDTH argPos defaultDescPad defaultLeftPad defaultWidth descPad i leftPad len max nextLineTabStop padding pos startPos width x  [CONTEXT]  public int compare ( Object o1 , Object o2 ) { Option opt1 =  ( Option ) o1 ; Option opt2 =  ( Option ) o2 ;  [BUGGY] return opt1 . getOpt ( ) . compareToIgnoreCase ( opt2 }  	None^905^^^^^900^906^
[REPLACE]  Option  opt1  =  (  Option  )  o1; 	[BUGGY] Option opt2 =  ( Option ) o2 ; [CE] variable opt2 is already defined in method compare(Object , Object)  [METHOD]  compare [TYPE] int [PARAMETER] Object o1 Object o2 [CLASS] OptionComparator  [TYPE] boolean false true [TYPE] Object o1 o2 [TYPE] Option opt1 opt2  [CONTEXT]  public int compare ( Object o1 , Object o2 ) { [BUGGY] Option opt2 = ( Option ) o2 ; Option opt2 =  ( Option ) o2 ;  return opt1 . getKey ( ) . compareToIgnoreCase ( opt2 . getKey ( ) ) ; }  	None^902^^^^^900^906^
[REPLACE]  Option  opt2  =  (  Option  )  o2; 	[BUGGY] Option opt1 =  ( Option ) o1 ; [CE] variable opt1 is already defined in method compare(Object , Object)  [METHOD]  compare [TYPE] int [PARAMETER] Object o1 Object o2 [CLASS] OptionComparator  [TYPE] boolean false true [TYPE] Object o1 o2 [TYPE] Option opt1 opt2  [CONTEXT]  public int compare ( Object o1 , Object o2 ) { Option opt1 =  ( Option ) o1 ; [BUGGY] Option opt1 = ( Option ) o1 ;  return opt1 . getKey ( ) . compareToIgnoreCase ( opt2 . getKey ( ) ) ; }  	None^903^^^^^900^906^
[ADD]  Option  opt2  =  (  Option  )  o2; 	[BUGGY] [CE] cannot find symbol opt2  [METHOD]  compare [TYPE] int [PARAMETER] Object o1 Object o2 [CLASS] OptionComparator  [TYPE] boolean false true [TYPE] Object o1 o2 [TYPE] Option opt1 opt2  [CONTEXT]  public int compare ( Object o1 , Object o2 ) { Option opt1 =  ( Option ) o1 ; [BUGGY]  return opt1 . getKey ( ) . compareToIgnoreCase ( opt2 . getKey ( ) ) ; }  	None^903^^^^^900^906^
[REPLACE]  public  static  final  int  UNINITIALIZED  =  -1; 	[BUGGY] public final int UNINITIALIZED = -1 / 4 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] Option  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^39^^^^^^^
[REPLACE]  public  static  final  int  UNLIMITED_VALUES  =  -2; 	[BUGGY] public static final int UNLIMITED_VALUES = -1 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] Option  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^42^^^^^^^
[REPLACE]  private  String  argName  =    "arg  "; 	[BUGGY] private String argName ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] Option  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^54^^^^^^^
[REPLACE]  private  int  numberOfArgs  =  UNINITIALIZED; 	[BUGGY] private int numberOfArgs  = null ; [CE] incompatible types  [CONTEXT]    [CLASS] Option  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^69^^^^^^^
[REPLACE]  private  ArrayList  values  =  new  ArrayList  (  )  ; 	[BUGGY] private ArrayList values ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] Option  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^75^^^^^^^
[REPLACE]  this  (  opt,  null,  false,  description  )  ; 	[BUGGY] this ( opt , false , false , longOpt ) ; [CE] cannot reference longOpt before supertype constructor has been called  [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String description ) throws IllegalArgumentException { [BUGGY] this ( opt , false , false , longOpt )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^92^^^^^89^93^
[REPLACE]  this  (  opt,  null,  hasArg,  description  )  ; 	[BUGGY] this ( opt , true , hasArg , description ) ; [CE] no suitable constructor found for Option(String , boolean , boolean , String)  [METHOD]  <init> [TYPE] String) [PARAMETER] String opt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , boolean hasArg , String description ) throws IllegalArgumentException { [BUGGY] this ( opt , true , hasArg , description )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^108^^^^^105^109^
[ADD]  this  (  opt,  null,  hasArg,  description  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , boolean hasArg , String description ) throws IllegalArgumentException { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^108^^^^^105^109^
[REPLACE]  OptionValidator  .  validateOption  (  opt  )  ; 	[BUGGY] OptionValidator . validateOption ( longOpt ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  [BUGGY] OptionValidator . validateOption ( longOpt )  ;  this . opt = opt ; this . longOpt = longOpt ;   if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^127^^^^^122^140^
[REPLACE]  this  .  opt  =  opt; 	[BUGGY] this . opt =  longOpt ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  [BUGGY] this . opt = longOpt ; this . longOpt = longOpt ;   if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^129^^^^^122^140^
[REPLACE]  this  .  longOpt  =  longOpt; 	[BUGGY] this . longOpt =  opt ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  this . opt = opt ; [BUGGY] this . longOpt = opt ;   if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^130^^^^^122^140^
[ADD]  this  .  longOpt  =  longOpt; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  this . opt = opt ; [BUGGY]   if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^130^^^^^122^140^
[REPLACE]  if  (  hasArg  )  { 	[BUGGY] if ( required ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  this . opt = opt ; this . longOpt = longOpt ;   [BUGGY] if ( required ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^133^134^^^^122^140^
[REPLACE]  this  .  numberOfArgs  =  1; 	[BUGGY] this . numberOfArgs = num ;  ; [CE] cannot find symbol num  [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  this . opt = opt ; this . longOpt = longOpt ;   if ( hasArg ) { [BUGGY] this . numberOfArgs = num ;  ; } this . hasArg = hasArg ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^135^^^^^122^140^
[REPLACE]  this  .  numberOfArgs  =  1; 	[BUGGY] this . numberOfArgs = 1 >>> 0 ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  this . opt = opt ; this . longOpt = longOpt ;   if ( hasArg ) { [BUGGY] this . numberOfArgs = 1 >>> 0 ; } this . hasArg = hasArg ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^135^^^^^122^140^
[ADD]  this  .  numberOfArgs  =  1; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  this . opt = opt ; this . longOpt = longOpt ;   if ( hasArg ) { [BUGGY] } this . hasArg = hasArg ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^135^^^^^122^140^
[REPLACE]  this  .  hasArg  =  hasArg; 	[BUGGY] this . hasArg =  required ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  this . opt = opt ; this . longOpt = longOpt ;   if ( hasArg ) { this . numberOfArgs = 1 ; } [BUGGY] this . hasArg = required ; this . description = description ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^138^^^^^122^140^
[REPLACE]  this  .  description  =  description; 	[BUGGY] this . description =  null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] String) [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Option ( String opt , String longOpt , boolean hasArg , String description ) throws IllegalArgumentException {  OptionValidator . validateOption ( opt ) ;  this . opt = opt ; this . longOpt = longOpt ;   if ( hasArg ) { this . numberOfArgs = 1 ; } this . hasArg = hasArg ; [BUGGY] this . description = null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^139^^^^^122^140^
[REPLACE]  return  getKey  (  )    .  charAt  (  0  )  ; 	[BUGGY] return getKey ( ) . indexOf ( 0 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getId [TYPE] int [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public int getId ( ) { [BUGGY] return getKey ( )  . indexOf ( 0 )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^151^^^^^149^152^
[REPLACE]  if  (  opt  ==  null  )  { 	[BUGGY] if ( opt ! = false ) {[CE] incomparable types: String and boolean  [METHOD]  getKey [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  String getKey ( ) {  [BUGGY] if ( opt ! = false ) { return this . longOpt ; } return this . opt ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^162^163^^^^159^168^
[REPLACE]  return  this  .  longOpt; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  getKey [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  String getKey ( ) {  if ( opt = = null ) { [BUGGY] return buf . toString ( )  ; } return this . opt ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^164^^^^^159^168^
[REPLACE]  return  this  .  opt; 	[BUGGY] return this . type ; [CE] incompatible types  [METHOD]  getKey [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  String getKey ( ) {  if ( opt = = null ) { return this . longOpt ; } [BUGGY] return this . type ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^167^^^^^159^168^
[REPLACE]  return  this  .  opt; 	[BUGGY] return this . type ; [CE] incompatible types  [METHOD]  getOpt [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public String getOpt ( ) { [BUGGY] return this . type ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^182^^^^^180^183^
[REPLACE]  return  this  .  type; 	[BUGGY] return this . opt ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getType [TYPE] Object [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public Object getType ( ) { [BUGGY] return this . opt ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^192^^^^^190^193^
[REPLACE]  this  .  type  =  type; 	[BUGGY] this . type =  null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setType [TYPE] void [PARAMETER] Object type [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public void setType ( Object type ) { [BUGGY] this . type = null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^202^^^^^200^203^
[REPLACE]  return  this  .  longOpt; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  getLongOpt [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public String getLongOpt ( ) { [BUGGY] return buf . toString ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^212^^^^^210^213^
[REPLACE]  this  .  longOpt  =  longOpt; 	[BUGGY] this . longOpt =  opt ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setLongOpt [TYPE] void [PARAMETER] String longOpt [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public void setLongOpt ( String longOpt ) { [BUGGY] this . longOpt = opt ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^222^^^^^220^223^
[REPLACE]  this  .  optionalArg  =  optionalArg; 	[BUGGY] this . optionalArg =  true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setOptionalArg [TYPE] void [PARAMETER] boolean optionalArg [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public void setOptionalArg ( boolean optionalArg ) { [BUGGY] this . optionalArg = true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^233^^^^^231^234^
[REPLACE]  return  this  .  optionalArg; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  hasOptionalArg [TYPE] boolean [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public boolean hasOptionalArg ( ) { [BUGGY] return buf . toString ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^241^^^^^239^242^
[REPLACE]  return  (  this  .  longOpt  !=  null  )  ; 	[BUGGY] return ( this . longOpt ; [CE] ')' expected  [METHOD]  hasLongOpt [TYPE] boolean [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public boolean hasLongOpt ( ) { [BUGGY] return ( this . longOpt ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^251^^^^^249^252^
[REPLACE]  return  (  this  .  numberOfArgs  >  0  )  ||  (  numberOfArgs  ==  UNLIMITED_VALUES  )  ; 	[BUGGY] return ( this . numberOfArgs ; [CE] ')' expected  [METHOD]  hasArg [TYPE] boolean [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public boolean hasArg ( ) { [BUGGY] return ( this . numberOfArgs ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^261^^^^^259^262^
[REPLACE]  return  this  .  description; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  getDescription [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public String getDescription ( ) { [BUGGY] return buf . toString ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^271^^^^^269^272^
[REPLACE]  this  .  description  =  description; 	[BUGGY] this . description =  opt ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setDescription [TYPE] void [PARAMETER] String description [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public void setDescription ( String description ) { [BUGGY] this . description = opt ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^281^^^^^279^282^
[REPLACE]  return  this  .  required; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  isRequired [TYPE] boolean [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public boolean isRequired ( ) { [BUGGY] return buf . toString ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^291^^^^^289^292^
[REPLACE]  this  .  required  =  required; 	[BUGGY] this . required =  true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setRequired [TYPE] void [PARAMETER] boolean required [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public void setRequired ( boolean required ) { [BUGGY] this . required = true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^301^^^^^299^302^
[ADD]  this  .  required  =  required; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setRequired [TYPE] void [PARAMETER] boolean required [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public void setRequired ( boolean required ) { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^301^^^^^299^302^
[REPLACE]  this  .  argName  =  argName; 	[BUGGY] this . argName =  null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setArgName [TYPE] void [PARAMETER] String argName [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public void setArgName ( String argName ) { [BUGGY] this . argName = null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^311^^^^^309^312^
[REPLACE]  return  this  .  argName; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  getArgName [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public String getArgName ( ) { [BUGGY] return buf . toString ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^321^^^^^319^322^
[REPLACE]  return  (  this  .  argName  !=  null  &&  this  .  argName  .  length  (  )  >  0  )  ; 	[BUGGY] return ( this . argName ! = null && this . argName . charAt ( ) > 0 ) ; [CE] method charAt in class String cannot be applied to given types ;  [METHOD]  hasArgName [TYPE] boolean [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public boolean hasArgName ( ) { [BUGGY] return ( this . argName ! = null && this . argName . charAt ( ) > 0 )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^333^^^^^331^334^
[REPLACE]  return  (  this  .  numberOfArgs  >  1  )  ||  (  this  .  numberOfArgs  ==  UNLIMITED_VALUES  )  ; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  hasArgs [TYPE] boolean [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES numberOfArgs  [CONTEXT]  public boolean hasArgs ( ) { [BUGGY] return false ;  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^343^344^^^^341^345^
[REPLACE]  this  .  numberOfArgs  =  num; 	[BUGGY] this . numberOfArgs = 1 ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setArgs [TYPE] void [PARAMETER] int num [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  public void setArgs ( int num ) { [BUGGY] this . numberOfArgs = 1 ;  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^354^^^^^352^355^
[REPLACE]  this  .  valuesep  =  sep; 	[BUGGY] this . valuesep =  valuesep ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setValueSeparator [TYPE] void [PARAMETER] char sep [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  public void setValueSeparator ( char sep ) { [BUGGY] this . valuesep = valuesep ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^365^^^^^363^366^
[REPLACE]  return  this  .  valuesep; 	[BUGGY] return this . values ; [CE] incompatible types  [METHOD]  getValueSeparator [TYPE] char [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  public char getValueSeparator ( ) { [BUGGY] return this . values ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^375^^^^^373^376^
[REPLACE]  return  (  this  .  valuesep  >  0  )  ; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  hasValueSeparator [TYPE] boolean [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  public boolean hasValueSeparator ( ) { [BUGGY] return false ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^385^^^^^383^386^
[REPLACE]  return  this  .  numberOfArgs; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  getArgs [TYPE] int [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  public int getArgs ( ) { [BUGGY] return buf . toString ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^395^^^^^393^396^
[REPLACE]  throw  new  RuntimeException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  void addValue ( String value ) { switch ( numberOfArgs ) { case UNINITIALIZED: [BUGGY] return ;  default: processValue ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^408^^^^^403^413^
[ADD]  throw  new  RuntimeException  (  "    ")  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  void addValue ( String value ) { switch ( numberOfArgs ) { case UNINITIALIZED: [BUGGY]  default: processValue ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^408^^^^^403^413^
[REPLACE]  processValue  (  value  )  ; 	[BUGGY] processValue ( argName ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  void addValue ( String value ) { switch ( numberOfArgs ) { case UNINITIALIZED: throw new RuntimeException (   "NO_ARGS_ALLOWED  " ) ;  default: [BUGGY] processValue ( argName )  ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^411^^^^^403^413^
[ADD]  processValue  (  value  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES num numberOfArgs  [CONTEXT]  void addValue ( String value ) { switch ( numberOfArgs ) { case UNINITIALIZED: throw new RuntimeException (   "NO_ARGS_ALLOWED  " ) ;  default: [BUGGY] } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^411^^^^^403^413^
[REPLACE]  while  (  index  !=  -1  )  { 	[BUGGY] while ( index  = =  -1 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   [BUGGY] while ( index = = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^438^439^^^^427^463^
[ADD]  while  (  index  !=  -1  )  { 	[BUGGY] [CE] invalid method declaration ; return type required  [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   [BUGGY]  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^438^439^440^^^427^463^
[REPLACE]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  { 	[BUGGY] if ( values . size ( ) + 3 = =  ( numberOfArgs - 1 ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  while ( index ! = -1 ) {  [BUGGY] if ( values . size ( ) + 3 = = ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^441^442^^^^438^457^
[REPLACE]  value  =  value  .  substring  (  index  +  1  )  ; 	[BUGGY] value = value . substring ( numberOfArgs + 1 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   [BUGGY] value = value . substring ( numberOfArgs + 1 )  ;   index = value . indexOf ( sep ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^452^^^^^438^457^
[REPLACE]  index  =  value  .  indexOf  (  sep  )  ; 	[BUGGY] index =  argName . indexOf ( sep ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   [BUGGY] index = argName . indexOf ( sep )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^456^^^^^438^457^
[REPLACE]  if  (  hasValueSeparator  (  )  )  { 	[BUGGY] if ( hasArg ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  [BUGGY] if ( hasArg ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^429^430^^^^427^463^
[ADD]  if  (  hasValueSeparator  (  )  )  {  char  sep  =  getValueSeparator  (  )  ; 	[BUGGY] [CE] invalid method declaration ; return type required  [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  [BUGGY]     int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^429^430^^432^^427^463^
[REPLACE]  while  (  index  !=  -1  )  { 	[BUGGY] while ( numberOfArgs  = =  -3 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   [BUGGY] while ( numberOfArgs = = -3 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^438^439^^^^429^458^
[REPLACE]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  { 	[BUGGY] if ( values . ArrayList ( )  + 3 = =  ( numberOfArgs - 0 ) ) {[CE] cannot find symbol  [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  while ( index ! = -1 ) {  [BUGGY] if ( values . ArrayList ( ) + 3 = = ( numberOfArgs - 0 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^441^442^^^^438^457^
[ADD]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  {  break;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  while ( index ! = -1 ) {  [BUGGY]     add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^441^442^443^444^^438^457^
[REPLACE]  value  =  value  .  substring  (  index  +  1  )  ; 	[BUGGY] value = value . substring ( index +numberOfArgs ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   [BUGGY] value = value . substring ( index +numberOfArgs )  ;   index = value . indexOf ( sep ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^452^^^^^438^457^
[REPLACE]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  { 	[BUGGY] if ( values . length ( )  = =  ( numberOfArgs - 0 ) ) {[CE] cannot find symbol  [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  [BUGGY] if ( values . length ( ) = = ( numberOfArgs - 0 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^441^442^^^^429^458^
[ADD]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  {  break;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  [BUGGY]     add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^441^442^443^444^^429^458^
[REPLACE]  value  =  value  .  substring  (  index  +  1  )  ; 	[BUGGY] value = value . substring (numberOfArgs + 1 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   [BUGGY] value = value . substring ( numberOfArgs + 1 )  ;   index = value . indexOf ( sep ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^452^^^^^429^458^
[REPLACE]  index  =  value  .  indexOf  (  sep  )  ; 	[BUGGY] index =  argName . indexOf ( sep ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   [BUGGY] index = argName . indexOf ( sep )  ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^456^^^^^429^458^
[ADD]  index  =  value  .  indexOf  (  sep  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   [BUGGY] } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^456^^^^^429^458^
[REPLACE]  char  sep  =  getValueSeparator  (  )  ; 	[BUGGY] int index = value . indexOf ( sep ) ; [CE] cannot find symbol sep  [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasValueSeparator ( ) ) {  [BUGGY] int index = value . indexOf ( sep )  ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^432^^^^^429^458^
[REPLACE]  int  index  =  value  .  indexOf  (  sep  )  ; 	[BUGGY] int index = value . indexOf ( valuesep ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   [BUGGY] int index = value . indexOf ( valuesep )  ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^435^^^^^429^458^
[REPLACE]  if  (  values  .  size  (  )  ==  (  numberOfArgs  -  1  )  )  { 	[BUGGY] if ( values . add ( ) + 4 = =  ( numberOfArgs - 1 ) ) {[CE] no suitable method found for add()  [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  [BUGGY] if ( values . add ( ) + 4 = = ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^441^442^^^^427^463^
[REPLACE]  value  =  value  .  substring  (  index  +  1  )  ; 	[BUGGY] value = value . substring ( index  = =  1 ) ; [CE] no suitable method found for substring(boolean)  [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   [BUGGY] value = value . substring ( index = = 1 )  ;   index = value . indexOf ( sep ) ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^452^^^^^427^463^
[REPLACE]  index  =  value  .  indexOf  (  sep  )  ; 	[BUGGY] index =  argName . indexOf ( sep ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   [BUGGY] index = argName . indexOf ( sep )  ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^456^^^^^427^463^
[ADD]  index  =  value  .  indexOf  (  sep  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   [BUGGY] } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^456^^^^^427^463^
[REPLACE]  char  sep  =  getValueSeparator  (  )  ; 	[BUGGY] int index = value . indexOf ( sep ) ; [CE] cannot find symbol sep  [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  [BUGGY] int index = value . indexOf ( sep )  ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^432^^^^^427^463^
[REPLACE]  int  index  =  value  .  indexOf  (  sep  )  ; 	[BUGGY] int index = value . hashCode ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   [BUGGY] int index = value . hashCode ( ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }   add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^435^^^^^427^463^
[REPLACE]  add  (  value  )  ; 	[BUGGY] add ( argName ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processValue [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  {  if ( hasValueSeparator ( ) ) {  char sep = getValueSeparator ( ) ;   int index = value . indexOf ( sep ) ;   while ( index ! = -1 ) {  if ( values . size ( )  = =  ( numberOfArgs - 1 ) ) { break ; }   add ( value . substring ( 0 , index ) ) ;   value = value . substring ( index + 1 ) ;   index = value . indexOf ( sep ) ; } }   [BUGGY] add ( argName )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^462^^^^^427^463^
[REPLACE]  if  (  (  numberOfArgs  >  0  )  &&  (  values  .  size  (  )  >  (  numberOfArgs  -  1  )  )  )  { 	[BUGGY] if (  ( values . ArrayList ( )  % 2 > ( numberOfArgs - 1 ) ) ) {[CE] cannot find symbol  [METHOD]  add [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  private void add ( String value ) { [BUGGY] if (  ( values . ArrayList ( ) %2 > ( numberOfArgs - 1 ) ) ) { throw new RuntimeException (   "Cannot add value , list full .   " ) ; }   this . values . add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^476^477^^^^474^484^
[REPLACE]  throw  new  RuntimeException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  add [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  private void add ( String value ) { if ( ( numberOfArgs > 0 ) && ( values . size ( ) > ( numberOfArgs - 1 ) ) ) { [BUGGY] return ; }   this . values . add ( value ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^478^^^^^474^484^
[REPLACE]  this  .  values  .  add  (  value  )  ; 	[BUGGY] this . values . add ( argName ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  add [TYPE] void [PARAMETER] String value [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  private void add ( String value ) { if ( ( numberOfArgs > 0 ) && ( values . size ( ) > ( numberOfArgs - 1 ) ) ) { throw new RuntimeException (   "Cannot add value , list full .   " ) ; }   [BUGGY] this . values . add ( argName )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^483^^^^^474^484^
[REPLACE]  return  hasNoValues  (  )  ?  null  :  (  String  )  this  .  values  .  get  (  0  )  ; 	[BUGGY] return hasNoValues ( ) ? null : ( String ) this . values . ArrayList ( )  ; [CE] cannot find symbol  [METHOD]  getValue [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public String getValue ( ) { [BUGGY] return hasNoValues ( ) ? null : ( String ) this . values . ArrayList ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^495^^^^^493^496^
[REPLACE]  return  hasNoValues  (  )  ?  null  :  (  String  )  this  .  values  .  get  (  index  )  ; 	[BUGGY] return hasNoValues ( ) ? this : ( String ) this . values . get ( index ) ; [CE] incompatible types  [METHOD]  getValue [TYPE] String [PARAMETER] int index [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public String getValue ( int index ) throws IndexOutOfBoundsException { [BUGGY] return hasNoValues ( ) ? this : ( String ) this . values . get ( index )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^513^^^^^510^514^
[REPLACE]  String  value  =  getValue  (  )  ; 	[BUGGY] int index = value . indexOf ( sep ) ; [CE] cannot find symbol sep  [METHOD]  getValue [TYPE] String [PARAMETER] String defaultValue [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public String getValue ( String defaultValue ) { [BUGGY] int index = value . indexOf ( sep )  ;  return ( value ! = null ) ? value : defaultValue ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^528^^^^^526^531^
[ADD]  String  value  =  getValue  (  )  ; 	[BUGGY] [CE] cannot find symbol value  [METHOD]  getValue [TYPE] String [PARAMETER] String defaultValue [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public String getValue ( String defaultValue ) { [BUGGY]  return ( value ! = null ) ? value : defaultValue ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^528^^^^^526^531^
[REPLACE]  return  (  value  !=  null  )  ?  value  :  defaultValue; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  getValue [TYPE] String [PARAMETER] String defaultValue [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public String getValue ( String defaultValue ) { String value = getValue ( ) ;  [BUGGY] return false ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^530^^^^^526^531^
[REPLACE]  return  hasNoValues  (  )  ?  null  :  (  String[]  )  this  .  values  .  toArray  (  new  String[]  {  }  )  ; 	[BUGGY] return hasNoValues ( ) ? this : ( String[] ) this . values . toArray ( new String[] { } ) ; [CE] incompatible types  [METHOD]  getValues [TYPE] String[] [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public String[] getValues ( ) { [BUGGY] return hasNoValues ( ) ? this : ( String[] ) this . values . toArray ( new String[] {} )  ;  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^542^543^^^^540^544^
[REPLACE]  return  this  .  values; 	[BUGGY] return this . valuesep ; [CE] incompatible types  [METHOD]  getValuesList [TYPE] List [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public java . util . List getValuesList ( ) { [BUGGY] return this . valuesep ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^552^^^^^550^553^
[REPLACE]  StringBuffer  buf  =  new  StringBuffer  (  )    .  append  (    "[  option:    "  )  ; 	[BUGGY] int index = value . indexOf ( sep ) ; [CE] cannot find symbol sep  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { [BUGGY] int index = value . indexOf ( sep )  ;  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^562^^^^^561^588^
[ADD]  StringBuffer  buf  =  new  StringBuffer  (  )    .  append  (    "[  option:    "  )  ; 	[BUGGY] [CE] cannot find symbol buf  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { [BUGGY]  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^562^^^^^561^588^
[REPLACE]  buf  .  append  (  this  .  opt  )  ; 	[BUGGY] buf . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  [BUGGY] buf . toString ( ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^564^^^^^561^588^
[REPLACE]  if  (  this  .  longOpt  !=  null  )  { 	[BUGGY] if ( this . longOpt = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  [BUGGY] if ( this . longOpt = = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^566^567^^^^561^588^
[ADD]  if  (  this  .  longOpt  !=  null  )  {  buf  .  append  (    "    "  )    .  append  (  this  .  longOpt  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  [BUGGY]   buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^566^567^568^569^^561^588^
[REPLACE]  buf  .  append  (    "    "  )    .  append  (  this  .  longOpt  )  ; 	[BUGGY] buf . append (   "+ARG  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( this . longOpt ! = null ) { [BUGGY] buf . append (   "+ARG  " )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^568^^^^^566^569^
[ADD]  buf  .  append  (    "    "  )    .  append  (  this  .  longOpt  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( this . longOpt ! = null ) { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^568^^^^^566^569^
[REPLACE]  buf  .  append  (    "    "  )    .  append  (  this  .  longOpt  )  ; 	[BUGGY] buf . toString ( )[CE] ' ; ' expected  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( this . longOpt ! = null ) { [BUGGY] buf . toString ( ) }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^568^^^^^566^569^
[REPLACE]  buf  .  append  (    "    "  )  ; 	[BUGGY] buf . append (   " ]  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } [BUGGY] buf . append (   " ]  " )  ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^571^^^^^561^588^
[REPLACE]  if  (  hasArg  )  { 	[BUGGY] if ( opt = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  [BUGGY] if ( opt = = null ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^573^574^^^^561^588^
[REPLACE]  buf  .  append  (    "+ARG  "  )  ; 	[BUGGY] add ( value ) ; [CE] cannot find symbol value  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( hasArg ) { [BUGGY] add ( value )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^575^^^^^573^576^
[REPLACE]  buf  .  append  (    "  ::    "  )    .  append  (  this  .  description  )  ; 	[BUGGY] this ( opt , null , false , description ) ; [CE] call to this must be first statement in constructor  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } [BUGGY] this ( opt , null , false , description )  ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^578^^^^^561^588^
[REPLACE]  buf  .  append  (    "  ::    "  )    .  append  (  this  .  description  )  ; 	[BUGGY] buf . toString ( )[CE] ' ; ' expected  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } [BUGGY] buf . toString ( )  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^578^^^^^561^588^
[REPLACE]  if  (  this  .  type  !=  null  )  { 	[BUGGY] if ( this . type = = this ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  [BUGGY] if ( this . type = = this ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^580^581^^^^561^588^
[REPLACE]  buf  .  append  (    "  ::    "  )    .  append  (  this  .  type  )  ; 	[BUGGY] buf . toString ( )[CE] ' ; ' expected  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( this . type ! = null ) { [BUGGY] buf . toString ( ) }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^582^^^^^580^583^
[ADD]  buf  .  append  (    "  ::    "  )    .  append  (  this  .  type  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( this . type ! = null ) { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^582^^^^^580^583^
[REPLACE]  buf  .  append  (    "  ::    "  )    .  append  (  this  .  type  )  ; 	[BUGGY] buf . append (   "+ARG  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  if ( this . type ! = null ) { [BUGGY] buf . append (   "+ARG  " )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^582^^^^^580^583^
[REPLACE]  buf  .  append  (    "  ]  "  )  ; 	[BUGGY] buf . append (   "   " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } [BUGGY] buf . append (   "   " )  ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^585^^^^^561^588^
[REPLACE]  return  buf  .  toString  (  )  ; 	[BUGGY] return buf . StringBuffer ( )  ; [CE] cannot find symbol  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Option  [TYPE] StringBuffer buf [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  { StringBuffer buf = new StringBuffer ( ) . append (   "[ option:   " ) ;  buf . append ( this . opt ) ;  if ( this . longOpt ! = null ) { buf . append (   "   " ) . append ( this . longOpt ) ; } buf . append (   "   " ) ;  if ( hasArg ) { buf . append (   "+ARG  " ) ; } buf . append (   " ::   " ) . append ( this . description ) ;  if ( this . type ! = null ) { buf . append (   " ::   " ) . append ( this . type ) ; } buf . append (   " ]  " ) ;  [BUGGY] return buf . StringBuffer ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^587^^^^^561^588^
[REPLACE]  return  this  .  values  .  size  (  )  ==  0; 	[BUGGY] return this . values . ArrayList ( )  = = 0L ; [CE] cannot find symbol  [METHOD]  hasNoValues [TYPE] boolean [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  private boolean hasNoValues ( ) { [BUGGY] return this . values . ArrayList ( )  = = 0L ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^597^^^^^595^598^
[REPLACE]  if  (  this  ==  o  )  { 	[BUGGY] if ( option || o ) {[CE] cannot find symbol option  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { [BUGGY] if ( option||o ) { return true ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^602^603^^^^600^624^
[ADD]  if  (  this  ==  o  )  {  return  true;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { [BUGGY]   if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^602^603^604^605^^600^624^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { [BUGGY] return false ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^604^^^^^600^624^
[REPLACE]  if  (  o  ==  null  ||  getClass  (  )  !=  o  .  getClass  (  )    )  { 	[BUGGY] if ( o ! = true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { return true ; } [BUGGY] if ( o ! = true ) { return false ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^606^607^^^^600^624^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { [BUGGY] return true ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^608^^^^^600^624^
[REPLACE]  Option  option  =  (  Option  )  o; 	[BUGGY] int index = value . indexOf ( sep ) ; [CE] cannot find symbol sep  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } [BUGGY] int index = value . indexOf ( sep )  ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^611^^^^^600^624^
[REPLACE]  if  (  opt  !=  null  ?  !opt  .  equals  (  option  .  opt  )  :  option  .  opt  !=  null  )  { 	[BUGGY] if ( opt = = this ? !opt . substring ( option . opt ) : option . opt ! = this ) {[CE] incomparable types: String and Option  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } Option option =  ( Option ) o ;  [BUGGY] if ( opt = = this ? !opt . substring ( option . opt ) : option . opt ! = this ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^614^615^^^^600^624^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { [BUGGY] return true ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^616^^^^^600^624^
[REPLACE]  if  (  longOpt  !=  null  ?  !longOpt  .  equals  (  option  .  longOpt  )  :  option  .  longOpt  !=  null  )  { 	[BUGGY] if ( longOpt ! =  option . longOpt = = false ) {[CE] ')' expected  [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } [BUGGY] if ( longOpt ! = option . longOpt = = false ) { return false ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^618^619^^^^600^624^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { [BUGGY] return true ; } return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^620^^^^^600^624^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  equals [TYPE] boolean [PARAMETER] Object o [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] Option option [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs  [CONTEXT]  public boolean equals ( Object o ) { if ( this = = o ) { return true ; } if ( o = = null || getClass ( ) ! = o . getClass ( )  ) { return false ; } Option option =  ( Option ) o ;  if ( opt ! = null ? !opt . equals ( option . opt ) : option . opt ! = null ) { return false ; } if ( longOpt ! = null ? !longOpt . equals ( option . longOpt ) : option . longOpt ! = null ) { return false ; } [BUGGY] return false ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^623^^^^^600^624^
[REPLACE]  int  result; 	[BUGGY] int index = value . indexOf ( sep ) ; [CE] cannot find symbol sep  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs result  [CONTEXT]  public int hashCode ( ) { [BUGGY] int index = value . indexOf ( sep )  ; result =  ( opt ! = null ? opt . hashCode ( ) : 0 ) ; result = 31 * result + ( longOpt ! = null ? longOpt . hashCode ( ) : 0 ) ; return result ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^628^^^^^626^632^
[REPLACE]  result  =  (  opt  !=  null  ?  opt  .  hashCode  (  )  :  0  )  ; 	[BUGGY] result  =  0 ) ; [CE] ' ; ' expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs result  [CONTEXT]  public int hashCode ( ) { int result ; [BUGGY] result = 0 )  ; result = 31 * result + ( longOpt ! = null ? longOpt . hashCode ( ) : 0 ) ; return result ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^629^^^^^626^632^
[ADD]  result  =  (  opt  !=  null  ?  opt  .  hashCode  (  )  :  0  )  ; 	[BUGGY] [CE] variable result might not have been initialized  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs result  [CONTEXT]  public int hashCode ( ) { int result ; [BUGGY] result = 31 * result + ( longOpt ! = null ? longOpt . hashCode ( ) : 0 ) ; return result ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^629^^^^^626^632^
[REPLACE]  result  =  31  *  result  +  (  longOpt  !=  null  ?  longOpt  .  hashCode  (  )  :  0  )  ; 	[BUGGY] result  =  0 ) ; [CE] ' ; ' expected  [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs result  [CONTEXT]  public int hashCode ( ) { int result ; result =  ( opt ! = null ? opt . hashCode ( ) : 0 ) ; [BUGGY] result = 0 )  ; return result ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^630^^^^^626^632^
[REPLACE]  return  result; 	[BUGGY] return numberOfArgs ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  hashCode [TYPE] int [PARAMETER] [CLASS] Option  [TYPE] boolean false hasArg optionalArg required true [TYPE] ArrayList values [TYPE] char sep valuesep [TYPE] Object o type [TYPE] String argName defaultValue description longOpt opt value [TYPE] int UNINITIALIZED UNLIMITED_VALUES index num numberOfArgs result  [CONTEXT]  public int hashCode ( ) { int result ; result =  ( opt ! = null ? opt . hashCode ( ) : 0 ) ; result = 31 * result + ( longOpt ! = null ? longOpt . hashCode ( ) : 0 ) ; [BUGGY] return numberOfArgs ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Option.java^631^^^^^626^632^
[REPLACE]  return  createValue  (  str,  (  Class  )  obj  )  ; 	[BUGGY] return Class . forName ( str ) ; [CE] unreported exception ClassNotFoundException ; must be caught or declared to be thrown  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Object obj [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Object obj [TYPE] String str  [CONTEXT]  public static Object createValue ( String str , Object obj ) { [BUGGY] return Class . forName ( str )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^49^^^^^47^50^
[REPLACE]  if  (  PatternOptionBuilder  .  STRING_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . STRING_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { [BUGGY] if ( PatternOptionBuilder . STRING_VALUE&&clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^63^64^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  ==  clazz  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } [BUGGY] else { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^67^68^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . NUMBER_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } [BUGGY] if ( PatternOptionBuilder . NUMBER_VALUE! = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^71^72^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . DATE_VALUE ! = true ) {[CE] incomparable types: Class and boolean  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } [BUGGY] if ( PatternOptionBuilder . DATE_VALUE! = true ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^75^76^^^^62^103^
[ADD]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  {  return  createDate  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } [BUGGY]   else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^75^76^77^78^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } [BUGGY] else { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^79^80^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] else { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[ADD]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  {  return  createFile  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY]   else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^85^86^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE! = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . FILES_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . FILES_VALUE! = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE||clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[ADD]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  {  return  createURL  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY]   else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^97^98^^62^103^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { [BUGGY] return false ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^101^^^^^95^102^
[REPLACE]  return  createURL  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { [BUGGY] return createFile ( str )  ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^97^^^^^95^102^
[REPLACE]  return  createURL  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { [BUGGY] return createFile ( str )  ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^97^^^^^62^103^
[REPLACE]  return  null; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { [BUGGY] return true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^101^^^^^62^103^
[REPLACE]  return  createFiles  (  str  )  ; 	[BUGGY] return createObject ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { [BUGGY] return createObject ( str )  ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^93^^^^^91^102^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { [BUGGY] return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^101^^^^^95^102^
[REPLACE]  return  createFiles  (  str  )  ; 	[BUGGY] return createObject ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { [BUGGY] return createObject ( str )  ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^93^^^^^62^103^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { [BUGGY] return false ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^101^^^^^62^103^
[REPLACE]  return  createFile  (  str  )  ; 	[BUGGY] return createObject ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { [BUGGY] return createObject ( str )  ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^89^^^^^87^102^
[ADD]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  {  return  createFiles  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY]   else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^93^94^^62^103^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { [BUGGY] return this ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^101^^^^^62^103^
[REPLACE]  return  createFile  (  str  )  ; 	[BUGGY] return createObject ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { [BUGGY] return createObject ( str )  ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^89^^^^^62^103^
[REPLACE]  return  createFile  (  str  )  ; 	[BUGGY] return createObject ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { [BUGGY] return createObject ( str )  ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^85^^^^^83^102^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE||clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REMOVE]   	[BUGGY] if ( ( FILE_VALUE )  = = clazz ) {   return createFile ( str ) ; }else   if ( ( EXISTING_FILE_VALUE )  = = clazz ) {     return createFile ( str ) ;   }else     if ( ( FILES_VALUE )  = = clazz ) {       return createFiles ( str ) ;     }else       if ( ( URL_VALUE )  = = clazz ) {         return createURL ( str ) ;       }else {         return null ;       }[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz )  if ( ( FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( EXISTING_FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( FILES_VALUE ) = = clazz ) { return createFiles ( str )  ; }else if ( ( URL_VALUE ) = = clazz ) { return createURL ( str )  ; }else { return null ; }{ return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REMOVE]   	[BUGGY] if ( ( FILE_VALUE )  = = clazz ) {   return createFile ( str ) ; }else   if ( ( EXISTING_FILE_VALUE )  = = clazz ) {     return createFile ( str ) ;   }else     if ( ( FILES_VALUE )  = = clazz ) {       return createFiles ( str ) ;     }else       if ( ( URL_VALUE )  = = clazz ) {         return createURL ( str ) ;       }else {         return null ;       }[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . FILES_VALUE = = clazz )  if ( ( FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( EXISTING_FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( FILES_VALUE ) = = clazz ) { return createFiles ( str )  ; }else if ( ( URL_VALUE ) = = clazz ) { return createURL ( str )  ; }else { return null ; }{ return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE||clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE&&clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE! = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  return  null; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { [BUGGY] return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^101^^^^^95^102^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE ! = this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE! = this ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  return  createFile  (  str  )  ; 	[BUGGY] return createObject ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { [BUGGY] return createObject ( str )  ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^85^^^^^62^103^
[REPLACE]  return  createClass  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { [BUGGY] return createFile ( str )  ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^81^^^^^79^102^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILE_VALUE && null ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILE_VALUE&& null ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[ADD]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  {  return  createFile  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY]   else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^89^90^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILES_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILES_VALUE||clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE && 1 ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE&& 1 ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILES_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILES_VALUE! = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILES_VALUE || true ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILES_VALUE|| true ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  return  createClass  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { [BUGGY] return createFile ( str )  ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^81^^^^^62^103^
[REPLACE]  return  createDate  (  str  )  ; 	[BUGGY] return createObject ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { [BUGGY] return createObject ( str )  ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^77^^^^^75^102^
[ADD]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  {  return  createClass  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } [BUGGY]   else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^79^80^81^82^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE! = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE! = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE ! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE! = null ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE&&clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE || null ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE|| null ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  return  createDate  (  str  )  ; 	[BUGGY] return createObject ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { [BUGGY] return createObject ( str )  ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^77^^^^^62^103^
[REPLACE]  return  createNumber  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { [BUGGY] return createFile ( str )  ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^73^^^^^71^102^
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . DATE_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . DATE_VALUE||clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^75^76^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . CLASS_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } [BUGGY] if ( PatternOptionBuilder . CLASS_VALUE! = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^79^80^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILE_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILE_VALUE&&clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE||clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . FILES_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . FILES_VALUE||clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE ! = this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE! = this ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . FILE_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . FILE_VALUE||clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE && null ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE&& null ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . FILES_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . FILES_VALUE&&clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE&&clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE && false ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE&& false ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE || this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE|| this ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE ! = false ) {[CE] incomparable types: Class and boolean  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE! = false ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  return  createNumber  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { [BUGGY] return createFile ( str )  ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^73^^^^^62^103^
[REPLACE]  return  createObject  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { [BUGGY] return createFile ( str )  ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^69^^^^^67^102^
[REPLACE]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ==  clazz  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } [BUGGY] else { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^71^72^^^^62^103^
[ADD]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ==  clazz  )  {  return  createNumber  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } [BUGGY]   else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^71^72^73^74^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . DATE_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } [BUGGY] if ( PatternOptionBuilder . DATE_VALUE||clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^75^76^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILES_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILES_VALUE&&clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE && false ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE&& false ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . FILE_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . FILE_VALUE&&clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE || true ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE|| true ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE ! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE! = null ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . DATE_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . DATE_VALUE! = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^75^76^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILES_VALUE && this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILES_VALUE&& this ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . FILE_VALUE ! = 0 ) {[CE] incomparable types: Class and int  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . FILE_VALUE! = 0 ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE && true ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE&& true ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REMOVE]   	[BUGGY] if ( ( FILE_VALUE )  = = clazz ) {   return createFile ( str ) ; }else   if ( ( EXISTING_FILE_VALUE )  = = clazz ) {     return createFile ( str ) ;   }else     if ( ( FILES_VALUE )  = = clazz ) {       return createFiles ( str ) ;     }else       if ( ( URL_VALUE )  = = clazz ) {         return createURL ( str ) ;       }else {         return null ;       }[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . CLASS_VALUE = = clazz )  if ( ( FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( EXISTING_FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( FILES_VALUE ) = = clazz ) { return createFiles ( str )  ; }else if ( ( URL_VALUE ) = = clazz ) { return createURL ( str )  ; }else { return null ; }{ return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^79^^^^^62^103^
[REPLACE]  return  createObject  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { [BUGGY] return createFile ( str )  ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^69^^^^^62^103^
[REPLACE]  return  str; 	[BUGGY] return Class . forName ( str ) ; [CE] unreported exception ClassNotFoundException ; must be caught or declared to be thrown  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { [BUGGY] return Class . forName ( str )  ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^65^^^^^63^102^
[ADD]  else  if  (  PatternOptionBuilder  .  OBJECT_VALUE  ==  clazz  )  {  return  createObject  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } [BUGGY]   else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^67^68^69^70^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  DATE_VALUE  ==  clazz  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } [BUGGY] else { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^75^76^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILE_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILE_VALUE||clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . FILE_VALUE || null ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . FILE_VALUE|| null ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . CLASS_VALUE || null ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } [BUGGY] if ( PatternOptionBuilder . CLASS_VALUE|| null ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^79^80^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . EXISTING_FILE_VALUE&&clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE || null ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE|| null ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILES_VALUE || this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILES_VALUE|| this ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REMOVE]   	[BUGGY] if ( ( FILE_VALUE )  = = clazz ) {   return createFile ( str ) ; }else   if ( ( EXISTING_FILE_VALUE )  = = clazz ) {     return createFile ( str ) ;   }else     if ( ( FILES_VALUE )  = = clazz ) {       return createFiles ( str ) ;     }else       if ( ( URL_VALUE )  = = clazz ) {         return createURL ( str ) ;       }else {         return null ;       }[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . DATE_VALUE = = clazz )  if ( ( FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( EXISTING_FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( FILES_VALUE ) = = clazz ) { return createFiles ( str )  ; }else if ( ( URL_VALUE ) = = clazz ) { return createURL ( str )  ; }else { return null ; }{ return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^75^^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE && null ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE&& null ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE ! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE! = null ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . CLASS_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . CLASS_VALUE&&clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^79^80^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILES_VALUE && null ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILES_VALUE&& null ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE || this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE|| this ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE && this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE&& this ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  NUMBER_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . NUMBER_VALUE || clazz ) {[CE] bad operand types for binary operator '||'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } [BUGGY] if ( PatternOptionBuilder . NUMBER_VALUE||clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^71^72^^^^62^103^
[REMOVE]   	[BUGGY] if ( ( FILE_VALUE )  = = clazz ) {   return createFile ( str ) ; }else   if ( ( EXISTING_FILE_VALUE )  = = clazz ) {     return createFile ( str ) ;   }else     if ( ( FILES_VALUE )  = = clazz ) {       return createFiles ( str ) ;     }else       if ( ( URL_VALUE )  = = clazz ) {         return createURL ( str ) ;       }else {         return null ;       }[CE] 'else' without 'if'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz )  if ( ( FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( EXISTING_FILE_VALUE ) = = clazz ) { return createFile ( str )  ; }else if ( ( FILES_VALUE ) = = clazz ) { return createFiles ( str )  ; }else if ( ( URL_VALUE ) = = clazz ) { return createURL ( str )  ; }else { return null ; }{ return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^71^^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  CLASS_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . CLASS_VALUE && clazz ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } [BUGGY] if ( PatternOptionBuilder . CLASS_VALUE&&clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^79^80^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  EXISTING_FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE && this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . EXISTING_FILE_VALUE&& this ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^87^88^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILE_VALUE ! = this ) {[CE] non-static variable this cannot be referenced from a static context  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILE_VALUE! = this ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILE_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILE_VALUE ! =  clazz ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILE_VALUE! = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^83^84^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  FILES_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . FILES_VALUE && 0 ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } [BUGGY] if ( PatternOptionBuilder . FILES_VALUE&& 0 ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^91^92^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] else if ( PatternOptionBuilder . URL_VALUE ! = false ) {[CE] incomparable types: Class and boolean  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] else if ( PatternOptionBuilder . URL_VALUE! = false ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  else  if  (  PatternOptionBuilder  .  URL_VALUE  ==  clazz  )  { 	[BUGGY] if ( PatternOptionBuilder . URL_VALUE && null ) {[CE] bad operand types for binary operator '&&'  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { return str ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } [BUGGY] if ( PatternOptionBuilder . URL_VALUE&& null ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^95^96^^^^62^103^
[REPLACE]  return  str; 	[BUGGY] return Class . forName ( str ) ; [CE] unreported exception ClassNotFoundException ; must be caught or declared to be thrown  [METHOD]  createValue [TYPE] Object [PARAMETER] String str Class clazz [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class clazz [TYPE] String str  [CONTEXT]  { if ( PatternOptionBuilder . STRING_VALUE = = clazz ) { [BUGGY] return Class . forName ( str )  ; } else if ( PatternOptionBuilder . OBJECT_VALUE = = clazz ) { return createObject ( str ) ; } else if ( PatternOptionBuilder . NUMBER_VALUE = = clazz ) { return createNumber ( str ) ; } else if ( PatternOptionBuilder . DATE_VALUE = = clazz ) { return createDate ( str ) ; } else if ( PatternOptionBuilder . CLASS_VALUE = = clazz ) { return createClass ( str ) ; } else if ( PatternOptionBuilder . FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . EXISTING_FILE_VALUE = = clazz ) { return createFile ( str ) ; } else if ( PatternOptionBuilder . FILES_VALUE = = clazz ) { return createFiles ( str ) ; } else if ( PatternOptionBuilder . URL_VALUE = = clazz ) { return createURL ( str ) ; } else { return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^65^^^^^62^103^
[REPLACE]  Class  cl  =  null; 	[BUGGY] Class cl = this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { [BUGGY] Class cl = this ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^114^^^^^113^149^
[ADD]  Class  cl  =  null; 	[BUGGY] [CE] cannot find symbol cl  [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { [BUGGY]  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^114^^^^^113^149^
[ADD]  try  {  cl  =  Class  .  forName  (  str  )  ;  } 	[BUGGY] cl = Class . forName ( str ) ; [CE] 'catch' without 'try'  [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  [BUGGY] cl = Class . forName ( str )  ;   catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^116^117^118^119^^113^149^
[REPLACE]  cl  =  Class  .  forName  (  str  )  ; 	[BUGGY] cl =  Class . forName ( null ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  try { [BUGGY] cl = Class . forName ( null )  ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^118^^^^^116^125^
[REPLACE]  cl  =  Class  .  forName  (  str  )  ; 	[BUGGY] cl =  Class . forName ( null ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { [BUGGY] cl = Class . forName ( null )  ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^118^^^^^113^149^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  [BUGGY] return false ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^124^^^^^113^149^
[REPLACE]  Object  instance  =  null; 	[BUGGY] Object instance = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } [BUGGY] Object instance = false ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^127^^^^^113^149^
[ADD]  try  {  instance  =  cl  .  newInstance  (  )  ;  } 	[BUGGY] instance = cl . newInstance ( ) ; [CE] 'catch' without 'try'  [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  [BUGGY] instance = cl . newInstance ( )  ;   catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^129^130^131^132^^113^149^
[REPLACE]  instance  =  cl  .  newInstance  (  )  ; 	[BUGGY] instance =  null . newInstance ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  try { [BUGGY] instance = null . newInstance ( )  ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^131^^^^^129^146^
[REPLACE]  instance  =  cl  .  newInstance  (  )  ; 	[BUGGY] instance =  null . newInstance ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { [BUGGY] instance = null . newInstance ( )  ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^131^^^^^113^149^
[REPLACE]  return  null; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  [BUGGY] return true ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^138^^^^^113^149^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  [BUGGY] return false ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^145^^^^^113^149^
[ADD]  catch  (  InstantiationException  cnfe  )  {  System  .  err  .  println  (    "InstantiationException;  Unable  to  create:    " 	[BUGGY] [CE] 'try' without 'catch' , 'finally' or resource declarations  [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } [BUGGY]  + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } return instance ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^133^134^135^^^113^149^
[REPLACE]  return  instance; 	[BUGGY] return Class . forName ( str ) ; [CE] unreported exception ClassNotFoundException ; must be caught or declared to be thrown  [METHOD]  createObject [TYPE] Object [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] Class cl [TYPE] Object instance [TYPE] String str [TYPE] ClassNotFoundException cnfe [TYPE] InstantiationException cnfe [TYPE] IllegalAccessException cnfe  [CONTEXT]  { Class cl = null ;  try { cl = Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } Object instance = null ;  try { instance = cl . newInstance ( ) ; } catch ( InstantiationException cnfe ) { System . err . println (   "InstantiationException ; Unable to create:   " + str ) ;  return null ; } catch ( IllegalAccessException cnfe ) { System . err . println (   "IllegalAccessException ; Unable to create:   " + str ) ;  return null ; } [BUGGY] return Class . forName ( str )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^148^^^^^113^149^
[ADD]  try  {  return  NumberUtils  .  createNumber  (  str  )  ;  } 	[BUGGY] return NumberUtils . createNumber ( str ) ; [CE] 'catch' without 'try'  [METHOD]  createNumber [TYPE] Number [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] NumberFormatException nfe [TYPE] String str  [CONTEXT]  public static Number createNumber ( String str ) {  [BUGGY] return NumberUtils . createNumber ( str )  ;    catch ( NumberFormatException nfe ) { System . err . println ( nfe . getMessage ( ) ) ;  return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^161^162^^164^165^158^172^
[REPLACE]  return  NumberUtils  .  createNumber  (  str  )  ; 	[BUGGY] return  str  ; [CE] incompatible types  [METHOD]  createNumber [TYPE] Number [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] NumberFormatException nfe [TYPE] String str  [CONTEXT]  public static Number createNumber ( String str ) {  try {  [BUGGY] return str ; } catch ( NumberFormatException nfe ) { System . err . println ( nfe . getMessage ( ) ) ;  return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^164^^^^^158^172^
[REPLACE]  return  NumberUtils  .  createNumber  (  str  )  ; 	[BUGGY] return NumberUtils . createValue ( str , this )  ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  createNumber [TYPE] Number [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] NumberFormatException nfe [TYPE] String str  [CONTEXT]  public static Number createNumber ( String str ) {  try {  [BUGGY] return NumberUtils . createValue ( str , this ) ; } catch ( NumberFormatException nfe ) { System . err . println ( nfe . getMessage ( ) ) ;  return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^164^^^^^158^172^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  createNumber [TYPE] Number [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] NumberFormatException nfe [TYPE] String str  [CONTEXT]  public static Number createNumber ( String str ) {  try {  return NumberUtils . createNumber ( str ) ; } catch ( NumberFormatException nfe ) { System . err . println ( nfe . getMessage ( ) ) ;  [BUGGY] return false ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^170^^^^^158^172^
[ADD]  try  {  return  Class  .  forName  (  str  )  ;  } 	[BUGGY] return Class . forName ( str ) ; [CE] 'catch' without 'try'  [METHOD]  createClass [TYPE] Class [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str [TYPE] ClassNotFoundException cnfe  [CONTEXT]  public static Class createClass ( String str ) { [BUGGY] return Class . forName ( str )  ;   catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^182^183^184^185^^180^192^
[REPLACE]  return  Class  .  forName  (  str  )  ; 	[BUGGY] return  str  ; [CE] incompatible types  [METHOD]  createClass [TYPE] Class [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str [TYPE] ClassNotFoundException cnfe  [CONTEXT]  public static Class createClass ( String str ) { try { [BUGGY] return str ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^184^^^^^180^192^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  createClass [TYPE] Class [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str [TYPE] ClassNotFoundException cnfe  [CONTEXT]  public static Class createClass ( String str ) { try { return Class . forName ( str ) ; } catch ( ClassNotFoundException cnfe ) { System . err . println (   "Unable to find:   " + str ) ;  [BUGGY] return this ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^190^^^^^180^192^
[REPLACE]  Date  date  =  null; 	[BUGGY] Date date = false ; [CE] incompatible types  [METHOD]  createDate [TYPE] Date [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str [TYPE] Date date  [CONTEXT]  public static Date createDate ( String str ) { [BUGGY] Date date = false ;  if ( date = = null ) { System . err . println (   "Unable to parse:   " + str ) ; } return date ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^203^^^^^201^211^
[REPLACE]  if  (  date  ==  null  )  { 	[BUGGY] if ( date ! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createDate [TYPE] Date [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str [TYPE] Date date  [CONTEXT]  public static Date createDate ( String str ) { Date date = null ;  [BUGGY] if ( date ! = null ) { System . err . println (   "Unable to parse:   " + str ) ; } return date ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^205^206^^^^201^211^
[REPLACE]  System  .  err  .  println  (    "Unable  to  parse:    "  +  str  )  ; 	[BUGGY] System . err . println (   "Unable to parse:   " || str ) ; [CE] bad operand types for binary operator  [METHOD]  createDate [TYPE] Date [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str [TYPE] Date date  [CONTEXT]  public static Date createDate ( String str ) { Date date = null ;  if ( date = = null ) { [BUGGY] System . err . println (   "Unable to parse:   "||str )  ; } return date ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^207^^^^^201^211^
[REPLACE]  return  date; 	[BUGGY] return Class . forName ( str ) ; [CE] incompatible types  [METHOD]  createDate [TYPE] Date [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str [TYPE] Date date  [CONTEXT]  public static Date createDate ( String str ) { Date date = null ;  if ( date = = null ) { System . err . println (   "Unable to parse:   " + str ) ; } [BUGGY] return Class . forName ( str )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^210^^^^^201^211^
[ADD]  try  {  return  new  URL  (  str  )  ;  } 	[BUGGY] return new URL ( str ) ; [CE] 'catch' without 'try'  [METHOD]  createURL [TYPE] URL [PARAMETER] String str [CLASS] TypeHandler  [TYPE] MalformedURLException mue [TYPE] boolean false true [TYPE] String str  [CONTEXT]  public static URL createURL ( String str ) { [BUGGY] return new URL ( str )  ;   catch ( MalformedURLException mue ) { System . err . println (   "Unable to parse:   " + str ) ;  return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^222^223^224^225^^220^232^
[REPLACE]  return  new  URL  (  str  )  ; 	[BUGGY] return new File ( str )  ; [CE] incompatible types  [METHOD]  createURL [TYPE] URL [PARAMETER] String str [CLASS] TypeHandler  [TYPE] MalformedURLException mue [TYPE] boolean false true [TYPE] String str  [CONTEXT]  public static URL createURL ( String str ) { try { [BUGGY] returnnew File ( str ) ; } catch ( MalformedURLException mue ) { System . err . println (   "Unable to parse:   " + str ) ;  return null ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^224^^^^^220^232^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  createURL [TYPE] URL [PARAMETER] String str [CLASS] TypeHandler  [TYPE] MalformedURLException mue [TYPE] boolean false true [TYPE] String str  [CONTEXT]  public static URL createURL ( String str ) { try { return new URL ( str ) ; } catch ( MalformedURLException mue ) { System . err . println (   "Unable to parse:   " + str ) ;  [BUGGY] return this ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^230^^^^^220^232^
[REPLACE]  return  new  File  (  str  )  ; 	[BUGGY] return createFile ( str ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  createFile [TYPE] File [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  public static File createFile ( String str ) { [BUGGY] return createFile ( str )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^242^^^^^240^243^
[REPLACE]  return  null; 	[BUGGY] return this ; [CE] non-static variable this cannot be referenced from a static context  [METHOD]  createFiles [TYPE] File[] [PARAMETER] String str [CLASS] TypeHandler  [TYPE] boolean false true [TYPE] String str  [CONTEXT]  public static File[] createFiles ( String str ) {   [BUGGY] return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/TypeHandler.java^255^^^^^251^256^
[REPLACE]  private  HashMap  optionMap  =  new  HashMap  (  )  ; 	[BUGGY] private HashMap optionMap  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] OptionGroup  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^30^^^^^^^
[REPLACE]  private  String  selected; 	[BUGGY] private char selected ; [CE] incomparable types: char and <null>  [CONTEXT]    [CLASS] OptionGroup  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^33^^^^^^^
[REPLACE]  optionMap  .  put  (  opt  .  getKey  (  )  ,  opt  )  ; 	[BUGGY] optionMap . put ( opt . getOpt ( ) , opt ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] OptionGroup [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public OptionGroup addOption ( Option opt ) {   [BUGGY] optionMap . put ( opt . getOpt ( )  , opt )  ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^48^^^^^44^51^
[REPLACE]  optionMap  .  put  (  opt  .  getKey  (  )  ,  opt  )  ; 	[BUGGY] optionMap . put ( opt . getOpt ( )  , opt ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] OptionGroup [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public OptionGroup addOption ( Option opt ) {   [BUGGY] optionMap . put ( opt . getOpt ( ) , opt )  ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^48^^^^^44^51^
[ADD]  optionMap  .  put  (  opt  .  getKey  (  )  ,  opt  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] OptionGroup [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public OptionGroup addOption ( Option opt ) {   [BUGGY]  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^48^^^^^44^51^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] OptionGroup [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public OptionGroup addOption ( Option opt ) {   optionMap . put ( opt . getKey ( ) , opt ) ;  [BUGGY] return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^50^^^^^44^51^
[REPLACE]  return  optionMap  .  keySet  (  )  ; 	[BUGGY] return optionMap . values ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getNames [TYPE] Collection [PARAMETER] [CLASS] OptionGroup  [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public Collection getNames ( ) {  [BUGGY] return optionMap . values ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^60^^^^^57^61^
[REPLACE]  return  optionMap  .  values  (  )  ; 	[BUGGY] return optionMap . keySet ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptions [TYPE] Collection [PARAMETER] [CLASS] OptionGroup  [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public Collection getOptions ( ) {  [BUGGY] return optionMap . keySet ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^69^^^^^66^70^
[REPLACE]  if  (  (  this  .  selected  ==  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  { 	[BUGGY] if ( ( this . selected ! = null ) || this . selected . equals ( opt . getOpt ( ) ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setSelected [TYPE] void [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public void setSelected ( Option opt ) throws AlreadySelectedException {    [BUGGY] if ( ( this . selected ! = null ) || this . selected . equals ( opt . getOpt ( ) ) ) { this . selected = opt . getOpt ( ) ; } else { throw new AlreadySelectedException (   "an option from this group has   " +   "already been selected: '  " + selected +   "'  " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^84^85^^^^78^94^
[ADD]  if  (  (  this  .  selected  ==  null  )  ||  this  .  selected  .  equals  (  opt  .  getOpt  (  )  )  )  {  this  .  selected  =  opt  .  getOpt  (  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  setSelected [TYPE] void [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public void setSelected ( Option opt ) throws AlreadySelectedException {    [BUGGY]   else { throw new AlreadySelectedException (   "an option from this group has   " +   "already been selected: '  " + selected +   "'  " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^84^85^86^87^^78^94^
[REPLACE]  throw  new  AlreadySelectedException  (    "an  option  from  this  group  has    "  +    "already  been  selected:  '  "  +  selected  +    "'  "  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setSelected [TYPE] void [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public void setSelected ( Option opt ) throws AlreadySelectedException {    if ( ( this . selected = = null ) || this . selected . equals ( opt . getOpt ( ) ) ) { this . selected = opt . getOpt ( ) ; } else { [BUGGY] return ;  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^90^91^92^^^78^94^
[REPLACE]  this  .  selected  =  opt  .  getOpt  (  )  ; 	[BUGGY] this . selected =  null . getOpt ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  setSelected [TYPE] void [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public void setSelected ( Option opt ) throws AlreadySelectedException {    if ( ( this . selected = = null ) || this . selected . equals ( opt . getOpt ( ) ) ) { [BUGGY] this . selected = null . getOpt ( )  ; } else { throw new AlreadySelectedException (   "an option from this group has   " +   "already been selected: '  " + selected +   "'  " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^86^^^^^78^94^
[ADD]  this  .  selected  =  opt  .  getOpt  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setSelected [TYPE] void [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public void setSelected ( Option opt ) throws AlreadySelectedException {    if ( ( this . selected = = null ) || this . selected . equals ( opt . getOpt ( ) ) ) { [BUGGY] } else { throw new AlreadySelectedException (   "an option from this group has   " +   "already been selected: '  " + selected +   "'  " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^86^^^^^78^94^
[REPLACE]  throw  new  AlreadySelectedException  (    "an  option  from  this  group  has    "  +    "already  been  selected:  '  "  +  selected  +    "'  "  )  ; 	[BUGGY] throw new AlreadySelectedException (   "an option from this group has   " +   "already been selected: '  " ; [CE]  [METHOD]  setSelected [TYPE] void [PARAMETER] Option opt [CLASS] OptionGroup  [TYPE] Option opt [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public void setSelected ( Option opt ) throws AlreadySelectedException {    if ( ( this . selected = = null ) || this . selected . equals ( opt . getOpt ( ) ) ) { this . selected = opt . getOpt ( ) ; } else { [BUGGY] throw new AlreadySelectedException (   "an option from this group has   " +   "already been selected: '  " ;  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^90^91^92^^^78^94^
[REPLACE]  return  selected; 	[BUGGY] return optionMap . values ( ) ; [CE] incompatible types  [METHOD]  getSelected [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public String getSelected ( ) { [BUGGY] return optionMap . values ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^101^^^^^99^102^
[REPLACE]  this  .  required  =  required; 	[BUGGY] this . required =  true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setRequired [TYPE] void [PARAMETER] boolean required [CLASS] OptionGroup  [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public void setRequired ( boolean required ) { [BUGGY] this . required = true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^109^^^^^107^110^
[ADD]  this  .  required  =  required; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  setRequired [TYPE] void [PARAMETER] boolean required [CLASS] OptionGroup  [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public void setRequired ( boolean required ) { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^109^^^^^107^110^
[REPLACE]  return  this  .  required; 	[BUGGY] return optionMap . values ( ) ; [CE] incompatible types  [METHOD]  isRequired [TYPE] boolean [PARAMETER] [CLASS] OptionGroup  [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  public boolean isRequired ( ) { [BUGGY] return optionMap . values ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^119^^^^^117^120^
[REPLACE]  StringBuffer  buff  =  new  StringBuffer  (  )  ; 	[BUGGY] Option option =  ( Option ) iter . next ( ) ; [CE] cannot find symbol iter  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { [BUGGY] Option option = ( Option ) iter . next ( )  ;  Iterator iter = getOptions ( ) . iterator ( ) ;  buff . append (   "[  " ) ;  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } } buff . append (   "]  " ) ;  return buff . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^128^^^^^127^161^
[ADD]  StringBuffer  buff  =  new  StringBuffer  (  )  ; 	[BUGGY] [CE] cannot find symbol buff  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { [BUGGY]  Iterator iter = getOptions ( ) . iterator ( ) ;  buff . append (   "[  " ) ;  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } } buff . append (   "]  " ) ;  return buff . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^128^^^^^127^161^
[REPLACE]  Iterator  iter  =  getOptions  (  )    .  iterator  (  )  ; 	[BUGGY] Option option =  ( Option ) iter . next ( ) ; [CE] cannot find symbol iter  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { StringBuffer buff = new StringBuffer ( ) ;  [BUGGY] Option option = ( Option ) iter . next ( )  ;  buff . append (   "[  " ) ;  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } } buff . append (   "]  " ) ;  return buff . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^130^^^^^127^161^
[REPLACE]  buff  .  append  (    "[  "  )  ; 	[BUGGY] buff . append (   "--  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { StringBuffer buff = new StringBuffer ( ) ;  Iterator iter = getOptions ( ) . iterator ( ) ;  [BUGGY] buff . append (   "--  " )  ;  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } } buff . append (   "]  " ) ;  return buff . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^132^^^^^127^161^
[REPLACE]  if  (  option  .  getOpt  (  )  !=  null  )  { 	[BUGGY] if ( option . getOpt ( )  = = false ) {[CE] incomparable types: String and boolean  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  [BUGGY] if ( option . getOpt ( ) = = false ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^138^139^^^^134^156^
[REPLACE]  buff  .  append  (    "--  "  )  ; 	[BUGGY] buff . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { [BUGGY] buff . toString ( ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^145^^^^^134^156^
[ADD]  buff  .  append  (    "--  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { [BUGGY] buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^145^^^^^134^156^
[REPLACE]  buff  .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] buff . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; [BUGGY] buff . toString ( ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^146^^^^^134^156^
[REPLACE]  buff  .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] buff . append ( option . getOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; [BUGGY] buff . append ( option . getOpt ( ) )  ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^146^^^^^134^156^
[REMOVE]   	[BUGGY] return optionMap . values ( ) ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; [BUGGY] buff . append ( option . getLongOpt ( ) ) ;  return optionMap . values ( )  ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^146^^^^^134^156^
[REPLACE]  buff  .  append  (    "-  "  )  ; 	[BUGGY] buff . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { [BUGGY] buff . toString ( ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^140^^^^^134^156^
[REPLACE]  buff  .  append  (  option  .  getOpt  (  )  )  ; 	[BUGGY] buff . append ( option . getKey ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; [BUGGY] buff . append ( option . getKey ( ) )  ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^141^^^^^134^156^
[REPLACE]  buff  .  append  (  option  .  getOpt  (  )  )  ; 	[BUGGY] buff . append ( option . getLongOpt ( )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; [BUGGY] buff . append ( option . getLongOpt ( )  )  ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^141^^^^^134^156^
[REMOVE]   	[BUGGY] return optionMap . values ( ) ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; [BUGGY] buff . append ( option . getOpt ( ) ) ;  return optionMap . values ( )  ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^141^^^^^134^156^
[REPLACE]  if  (  iter  .  hasNext  (  )  )  { 	[BUGGY] if ( iter . next ( )  ) {[CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  [BUGGY] if ( iter . next ( )  ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^152^153^^^^134^156^
[REPLACE]  buff  .  append  (    ",    "  )  ; 	[BUGGY] buff . append (   "--  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { [BUGGY] buff . append (   "--  " )  ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^154^^^^^134^156^
[REPLACE]  Option  option  =  (  Option  )  iter  .  next  (  )  ; 	[BUGGY] Option option =  ( Option ) iter . hasNext ( )  ; [CE] inconvertible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { [BUGGY] Option option = ( Option ) iter . hasNext ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^136^^^^^134^156^
[ADD]  Option  option  =  (  Option  )  iter  .  next  (  )  ; 	[BUGGY] [CE] cannot find symbol option  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  while ( iter . hasNext ( ) ) { [BUGGY]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^136^^^^^134^156^
[REPLACE]  if  (  option  .  getOpt  (  )  !=  null  )  { 	[BUGGY] if ( option . getOpt ( )  = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { StringBuffer buff = new StringBuffer ( ) ;  Iterator iter = getOptions ( ) . iterator ( ) ;  buff . append (   "[  " ) ;  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  [BUGGY] if ( option . getOpt ( ) = = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } } buff . append (   "]  " ) ;  return buff . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^138^139^^^^127^161^
[REPLACE]  buff  .  append  (    "--  "  )  ; 	[BUGGY] buff . append (   "[  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { [BUGGY] buff . append (   "[  " )  ; buff . append ( option . getLongOpt ( ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^145^^^^^138^147^
[ADD]  buff  .  append  (    "--  "  )  ;  buff  .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] buff . append ( option . getLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { [BUGGY] buff . append ( option . getLongOpt ( ) )  ;  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^145^146^^^^138^147^
[REPLACE]  buff  .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] buff . append ( option . getOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; [BUGGY] buff . append ( option . getOpt ( ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^146^^^^^138^147^
[ADD]  buff  .  append  (  option  .  getLongOpt  (  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^146^^^^^138^147^
[REPLACE]  buff  .  append  (    "-  "  )  ; 	[BUGGY] buff . append (   "--  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { [BUGGY] buff . append (   "--  " )  ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^140^^^^^138^147^
[REPLACE]  buff  .  append  (  option  .  getOpt  (  )  )  ; 	[BUGGY] buff . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; [BUGGY] buff . toString ( ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^141^^^^^138^147^
[REPLACE]  buff  .  append  (  option  .  getOpt  (  )  )  ; 	[BUGGY] buff . append ( option . getLongOpt ( )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; [BUGGY] buff . append ( option . getLongOpt ( )  )  ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^141^^^^^138^147^
[REMOVE]   	[BUGGY] return optionMap . values ( ) ; [CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; [BUGGY] buff . append ( option . getOpt ( ) ) ;  return optionMap . values ( )  ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^141^^^^^138^147^
[REPLACE]  if  (  iter  .  hasNext  (  )  )  { 	[BUGGY] if ( iter . next ( )  ) {[CE] incompatible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { StringBuffer buff = new StringBuffer ( ) ;  Iterator iter = getOptions ( ) . iterator ( ) ;  buff . append (   "[  " ) ;  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  [BUGGY] if ( iter . next ( )  ) { buff . append (   " ,   " ) ; } } buff . append (   "]  " ) ;  return buff . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^152^153^^^^127^161^
[REPLACE]  buff  .  append  (    ",    "  )  ; 	[BUGGY] buff . append (   "--  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  if ( iter . hasNext ( ) ) { [BUGGY] buff . append (   "--  " )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^154^^^^^152^155^
[REPLACE]  Option  option  =  (  Option  )  iter  .  next  (  )  ; 	[BUGGY] Option option =  ( Option ) iter . hasNext ( ) ; [CE] inconvertible types  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { StringBuffer buff = new StringBuffer ( ) ;  Iterator iter = getOptions ( ) . iterator ( ) ;  buff . append (   "[  " ) ;  while ( iter . hasNext ( ) ) { [BUGGY] Option option = ( Option ) iter . hasNext ( )  ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } } buff . append (   "]  " ) ;  return buff . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^136^^^^^127^161^
[REPLACE]  buff  .  append  (    "]  "  )  ; 	[BUGGY] buff . append (   "--  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { StringBuffer buff = new StringBuffer ( ) ;  Iterator iter = getOptions ( ) . iterator ( ) ;  buff . append (   "[  " ) ;  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } } [BUGGY] buff . append (   "--  " )  ;  return buff . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^158^^^^^127^161^
[REPLACE]  return  buff  .  toString  (  )  ; 	[BUGGY] return buff . StringBuffer ( ) ; [CE] cannot find symbol  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] OptionGroup  [TYPE] Iterator iter [TYPE] StringBuffer buff [TYPE] Option option [TYPE] boolean false required true [TYPE] String selected [TYPE] HashMap optionMap  [CONTEXT]  { StringBuffer buff = new StringBuffer ( ) ;  Iterator iter = getOptions ( ) . iterator ( ) ;  buff . append (   "[  " ) ;  while ( iter . hasNext ( ) ) { Option option =  ( Option ) iter . next ( ) ;  if ( option . getOpt ( ) ! = null ) { buff . append (   "-  " ) ; buff . append ( option . getOpt ( ) ) ; } else { buff . append (   "--  " ) ; buff . append ( option . getLongOpt ( ) ) ; } buff . append (   "   " ) ; buff . append ( option . getDescription ( ) ) ;  if ( iter . hasNext ( ) ) { buff . append (   " ,   " ) ; } } buff . append (   "]  " ) ;  [BUGGY] return buff . StringBuffer ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionGroup.java^160^^^^^127^161^
[REPLACE]  if  (  opt  ==  null  )  { 	[BUGGY] if ( opt ! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  [BUGGY] if ( opt ! = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^44^45^^^^42^76^
[REMOVE]   	[BUGGY] if ( ( opt . length ( ) )  = = 1 ) {   char ch = opt . charAt ( 0 ) ;   if ( ! ( isValidOpt ( ch ) ) ) {     throw new IllegalArgumentException ( ( (   "illegal option value '  " + ch ) +   "'  " ) ) ;   } }else {   char[] chars = opt . toCharArray ( ) ;   for ( int i = 0 ; i < ( chars . length ) ; i++ ) {     if ( ! ( isValidChar ( chars[i] ) ) ) {       throw new IllegalArgumentException ( ( (   "opt contains illegal character value '  " + ( chars[i] ) ) +   "'  " ) ) ;     }   } }[CE] 'else' without 'if'  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  [BUGGY] if ( opt = = null )  if ( ( opt . length ( ) ) = = 1 ) { char ch = opt . charAt ( 0 )  ; if ( ! ( isValidOpt ( ch ) ) ) { throw new IllegalArgumentException ( ( (   "illegal option value '  " + ch ) +   "'  " ) )  ; } }else { char[] chars = opt . toCharArray ( )  ; for ( int i = 0 ; i < ( chars . length )  ; i++ ) { if ( ! ( isValidChar ( chars[i] ) ) ) { throw new IllegalArgumentException ( ( (   "opt contains illegal character value '  " + ( chars[i] ) ) +   "'  " ) )  ; } } }{ return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^44^^^^^42^76^
[REPLACE]  else  if  (  opt  .  length  (  )  ==  1  )  { 	[BUGGY] else if ( opt . charAt ( ) / 0 . 5  = = 1 ) {[CE] method charAt in class String cannot be applied to given types ;  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  [BUGGY] else if ( opt . charAt ( ) /0 . 5 = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^50^51^^^^42^76^
[ADD]  else  if  (  opt  .  length  (  )  ==  1  )  {  char  ch  =  opt  .  charAt  (  0  )  ;  if  (  !isValidOpt  (  ch  )  ) 	[BUGGY] [CE] illegal start of type  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  [BUGGY]   { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^50^51^52^^54^42^76^
[REPLACE]  if  (  !isValidChar  (  chars[i]  )  )  { 	[BUGGY] if ( isValidChar ( chars[i] ) ) {[FE]  opt contains illegal character value 'h' assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { [BUGGY] if ( isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^68^69^^^^50^75^
[REPLACE]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ;  ; [CE] cannot find symbol ch  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { [BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " )  ;  ;  } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^50^75^
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < chars . length ( ) ; i++ ) {[CE] cannot find symbol  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  [BUGGY] for ( int i = 0 ; i < chars . length ( )  ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^66^67^^^^50^75^
[ADD]  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { [BUGGY]   } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^68^69^70^71^72^50^75^
[REPLACE]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { [BUGGY] return ;  } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^50^75^
[REPLACE]  char[]  chars  =  opt  .  toCharArray  (  )  ; 	[BUGGY] char[] chars = opt . length ( ) ; [CE] incompatible types  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { [BUGGY] char[] chars = opt . length ( )  ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^64^^^^^50^75^
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < chars . length ; i++ ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  [BUGGY] for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^66^67^^^^50^75^
[ADD]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  ( 	[BUGGY] [CE] not a statement  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  [BUGGY]     "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^66^67^68^69^70^50^75^
[ADD]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { [BUGGY]  } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^50^75^
[REPLACE]  if  (  !isValidOpt  (  ch  )  )  { 	[BUGGY] if ( isValidOpt ( ch ) ) {[FE]  illegal option value 'D' assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  [BUGGY] if ( isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^54^55^^^^50^75^
[REMOVE]   	[BUGGY] if ( ! ( isValidChar ( chars[i] ) ) ) {   throw new IllegalArgumentException ( ( (   "opt contains illegal character value '  " + ( chars[i] ) ) +   "'  " ) ) ; }[CE] cannot find symbol chars  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  [BUGGY] if ( !isValidOpt ( ch ) )  if ( ! ( isValidChar ( chars[i] ) ) ) { throw new IllegalArgumentException ( ( (   "opt contains illegal character value '  " + ( chars[i] ) ) +   "'  " ) )  ; }{ throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^54^^^^^50^75^
[REPLACE]  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { [BUGGY] return ;  } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^56^57^^^^50^75^
[REPLACE]  char  ch  =  opt  .  charAt  (  0  )  ; 	[BUGGY] char ch = opt . charAt ( 3 ) ; [FE]  String index out of range: 3 assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { [BUGGY] char ch = opt . charAt ( 3 )  ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^52^^^^^50^75^
[REPLACE]  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ; 	[BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch ; [CE]  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { [BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch ;  } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^56^57^^^^50^75^
[ADD]  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { [BUGGY]  } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^56^57^^^^50^75^
[REPLACE]  if  (  !isValidOpt  (  ch  )  )  { 	[BUGGY] if ( isValidOpt ( ch ) ) {[FE]  illegal option value 'D' assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  [BUGGY] if ( isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^54^55^^^^42^76^
[REPLACE]  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  if ( !isValidOpt ( ch ) ) { [BUGGY] return ;  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^56^57^^^^54^58^
[ADD]  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  if ( !isValidOpt ( ch ) ) { [BUGGY]  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^56^57^^^^54^58^
[REPLACE]  if  (  !isValidChar  (  chars[i]  )  )  { 	[BUGGY] if ( isValidChar ( chars[i] ) ) {[FE]  opt contains illegal character value 'h' assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { [BUGGY] if ( isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^68^69^^^^42^76^
[REPLACE]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ;  ; [CE] cannot find symbol ch  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  if ( !isValidChar ( chars[i] ) ) { [BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " )  ;  ;  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^68^73^
[ADD]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  if ( !isValidChar ( chars[i] ) ) { [BUGGY]  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^68^73^
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < chars . length * 2 ; i++ ) {[FE]  4 assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  [BUGGY] for ( int i = 0 ; i < chars . length *2 ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^66^67^^^^42^76^
[REPLACE]  if  (  !isValidChar  (  chars[i]  )  )  { 	[BUGGY] if ( isValidChar ( chars[i] ) ) {[FE]  opt contains illegal character value 'h' assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  for ( int i = 0 ; i < chars . length ; i++ ) { [BUGGY] if ( isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^68^69^^^^66^74^
[REPLACE]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ;  ; [CE] cannot find symbol ch  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { [BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " )  ;  ;  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^66^74^
[ADD]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { [BUGGY]  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^66^74^
[REPLACE]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { [BUGGY] return ;  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^66^74^
[REPLACE]  char  ch  =  opt  .  charAt  (  0  )  ; 	[BUGGY] char ch = opt . charAt ( 0 - 0 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { [BUGGY] char ch = opt . charAt ( 0 - 0 )  ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^52^^^^^42^76^
[REPLACE]  char[]  chars  =  opt  .  toCharArray  (  )  ; 	[BUGGY] char[] chars = opt . length ( ) ; [CE] incompatible types  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { [BUGGY] char[] chars = opt . length ( )  ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^64^^^^^42^76^
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < chars . length ; i++ ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  [BUGGY] for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^66^67^^^^42^76^
[REPLACE]  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ; 	[BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch ; [CE]  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { [BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch ;  } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^56^57^^^^42^76^
[ADD]  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { [BUGGY]  } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^56^57^^^^42^76^
[REPLACE]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ;  ; [CE] cannot find symbol ch  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { [BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " )  ;  ;  } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^42^76^
[ADD]  throw  new  IllegalArgumentException  (    "opt  contains  illegal  character  value  '  "  +  chars[i]  +    "'  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { [BUGGY]  } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^70^71^72^^^42^76^
[REPLACE]  return; 	[BUGGY] return ( isValidChar ( c ) || ( c = = ' ' ) || ( c = = '?' ) || c = = '@' ) ; [CE] cannot return a value from method whose result type is void  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  if ( opt = = null ) { [BUGGY] return ( isValidChar ( c ) || ( c = = ' ' ) || ( c = = '?' ) || c = = '@' )  ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^46^^^^^44^75^
[REPLACE]  else  if  (  opt  .  length  (  )  ==  1  )  { 	[BUGGY] else if ( opt . length ( ) * 0 . 5  = = 1 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  [BUGGY] else if ( opt . length ( ) *0 . 5 = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^50^51^^^^42^76^
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < chars . length ( ) ; i++ ) {[CE] cannot find symbol  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  [BUGGY] for ( int i = 0 ; i < chars . length ( )  ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^66^67^^^^50^75^
[REPLACE]  char[]  chars  =  opt  .  toCharArray  (  )  ; 	[BUGGY] char[] chars = opt . charAt ( i )  ; [CE] cannot find symbol i  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { [BUGGY] char[] chars = opt . charAt ( i ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^64^^^^^50^75^
[ADD]  if  (  !isValidOpt  (  ch  )  )  {  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  [BUGGY]   }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^54^55^56^57^58^42^76^
[REPLACE]  throw  new  IllegalArgumentException  (    "illegal  option  value  '  "  +  ch  +    "'  "  )  ; 	[BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch ; [CE]  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  if ( !isValidOpt ( ch ) ) { [BUGGY] throw new IllegalArgumentException (   "illegal option value '  " + ch ;  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^56^57^^^^54^58^
[REPLACE]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  { 	[BUGGY] for ( int i = 0 ; i < chars . length + 4 ; i++ ) {[FE]  4 assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  [BUGGY] for ( int i = 0 ; i < chars . length + 4 ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^66^67^^^^42^76^
[ADD]  for  (  int  i  =  0;  i  <  chars  .  length;  i++  )  {  if  (  !isValidChar  (  chars[i]  )  )  {  throw  new  IllegalArgumentException  ( 	[BUGGY] [CE] not a statement  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  [BUGGY]     "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^66^67^68^69^70^42^76^
[REPLACE]  char  ch  =  opt  .  charAt  (  0  )  ; 	[BUGGY] char ch = opt . charAt ( 1 ) ; [FE]  String index out of range: 1 assertEquals(   "property  " , opts[0] )   [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { [BUGGY] char ch = opt . charAt ( 1 )  ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { char[] chars = opt . toCharArray ( ) ;  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^52^^^^^42^76^
[ADD]  char[]  chars  =  opt  .  toCharArray  (  )  ; 	[BUGGY] [CE] cannot find symbol chars  [METHOD]  validateOption [TYPE] void [PARAMETER] String opt [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char ch [TYPE] String opt [TYPE] int i [TYPE] char[] chars  [CONTEXT]  {  if ( opt = = null ) { return ; }  else if ( opt . length ( )  = = 1 ) { char ch = opt . charAt ( 0 ) ;  if ( !isValidOpt ( ch ) ) { throw new IllegalArgumentException (   "illegal option value '  " + ch +   "'  " ) ; } }  else { [BUGGY]  for ( int i = 0 ; i < chars . length ; i++ ) { if ( !isValidChar ( chars[i] ) ) { throw new IllegalArgumentException (   "opt contains illegal character value '  " + chars[i] +   "'  " ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^64^^^^^42^76^
[REPLACE]  return  (  isValidChar  (  c  )  ||  (  c  ==  '  '  )  ||  (  c  ==  '?'  )  ||  c  ==  '@'  )  ; 	[BUGGY] return  ( c ; [CE] ')' expected  [METHOD]  isValidOpt [TYPE] boolean [PARAMETER] char c [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char c  [CONTEXT]  private static boolean isValidOpt ( char c ) { [BUGGY] return ( c ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^87^^^^^85^88^
[REPLACE]  return  Character  .  isJavaIdentifierPart  (  c  )  ; 	[BUGGY] return  c  ; [CE] incompatible types  [METHOD]  isValidChar [TYPE] boolean [PARAMETER] char c [CLASS] OptionValidator  [TYPE] boolean false true [TYPE] char c  [CONTEXT]  private static boolean isValidChar ( char c ) { [BUGGY] return c ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/OptionValidator.java^98^^^^^96^99^
[REPLACE]  private  ArrayList  tokens  =  new  ArrayList  (  )  ; 	[BUGGY] private ArrayList tokens ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] PosixParser  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^33^^^^^^^
[REPLACE]  eatTheRest  =  false; 	[BUGGY] eatTheRest = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  init [TYPE] void [PARAMETER] [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false true  [CONTEXT]  private void init ( ) { [BUGGY] eatTheRest = true ; tokens . clear ( ) ; currentOption = null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^51^^^^^49^54^
[REPLACE]  tokens  .  clear  (  )  ; 	[BUGGY] tokens . ArrayList ( ) ; [CE] cannot find symbol  [METHOD]  init [TYPE] void [PARAMETER] [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false true  [CONTEXT]  private void init ( ) { eatTheRest = false ; [BUGGY] tokens . ArrayList ( )  ; currentOption = null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^52^^^^^49^54^
[ADD]  tokens  .  clear  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  init [TYPE] void [PARAMETER] [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false true  [CONTEXT]  private void init ( ) { eatTheRest = false ; [BUGGY] currentOption = null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^52^^^^^49^54^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = false ; [CE] incompatible types  [METHOD]  init [TYPE] void [PARAMETER] [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false true  [CONTEXT]  private void init ( ) { eatTheRest = false ; tokens . clear ( ) ; [BUGGY] currentOption = false ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^53^^^^^49^54^
[REPLACE]  init  (  )  ; 	[BUGGY] gobble ( iter ) ; [CE] cannot find symbol iter  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { [BUGGY] gobble ( iter )  ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^97^^^^^96^163^
[REPLACE]  this  .  options  =  options; 	[BUGGY] this . options =  null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; [BUGGY] this . options = null ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^98^^^^^96^163^
[ADD]  this  .  options  =  options; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; [BUGGY]   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^98^^^^^96^163^
[REPLACE]  Iterator  iter  =  Arrays  .  asList  (  arguments  )    .  iterator  (  )  ; 	[BUGGY] Iterator iter =  arguments  . iterator ( ) ; [CE] cannot find symbol  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   [BUGGY] Iterator iter = arguments . iterator ( )  ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^101^^^^^96^163^
[REPLACE]  String  token  =  null; 	[BUGGY] String token = false ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; [BUGGY] String token = false ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^102^^^^^96^163^
[ADD]  while  (  iter  .  hasNext  (  )  )  { 	[BUGGY] [CE] illegal start of type  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   [BUGGY]  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^105^106^107^^^96^163^
[REPLACE]  if  (  token  .  startsWith  (    "--  "  )  )  { 	[BUGGY] else if ( token . startsWith (   "-  " ) ) {[CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   [BUGGY] else if ( token . startsWith (   "-  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^111^112^^^^105^160^
[REPLACE]  else  if  (    "-  "  .  equals  (  token  )  )  { 	[BUGGY] else {[CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  [BUGGY] else { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^126^127^^^^105^160^
[REPLACE]  else  if  (  token  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( token . startsWith (   "-  " ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } [BUGGY] if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^130^131^^^^105^160^
[ADD]  else  if  (  token  .  startsWith  (    "-  "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;  if  (  tokenLength  ==  2  ) 	[BUGGY] [CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } [BUGGY]   { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^130^131^132^^134^105^160^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { [BUGGY] if ( true ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^149^150^^^^130^157^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( token ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( stopAtNonOption ) { process ( token ) ; } else { [BUGGY] tokens . toArray ( token )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^155^^^^^149^156^
[REPLACE]  process  (  token  )  ; 	[BUGGY] tokens . add (   "-  " + ch ) ; [CE] cannot find symbol ch  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( stopAtNonOption ) { [BUGGY] tokens . add (   "-  " + ch )  ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^151^^^^^149^156^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength ! =  2 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength! = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^130^157^
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] else { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^^^^^130^157^
[REPLACE]  burstToken  (  token,  stopAtNonOption  )  ; 	[BUGGY] burstToken ( token , true ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { [BUGGY] burstToken ( token , true )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^144^^^^^138^145^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( token ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( token )  ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^130^157^
[REPLACE]  processOptionToken  (  token,  stopAtNonOption  )  ; 	[BUGGY] burstToken ( token , stopAtNonOption ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( tokenLength = = 2 ) { [BUGGY] burstToken ( token , stopAtNonOption )  ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^136^^^^^134^145^
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  { 	[BUGGY] if ( options . hasOption ( token ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^^^^^130^157^
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  } 	[BUGGY] tokens . add ( token ) ; [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] tokens . add ( token )  ;   else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^139^140^^^130^157^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . add ( token ) ;  tokens . add ( iter . next ( ) )  ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^130^157^
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] int tokenLength = token . startsWith ( token )  ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { [BUGGY] int tokenLength = token . startsWith ( token ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^132^^^^^130^157^
[ADD]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] [CE] cannot find symbol tokenLength  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { [BUGGY]  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^132^^^^^130^157^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength ! =  0 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength! = 0 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^105^160^
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  { 	[BUGGY] if ( options . hasOption ( token ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^^^^^105^160^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( token ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( token )  ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^105^160^
[ADD]  processOptionToken  (  token,  stopAtNonOption  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( tokenLength = = 2 ) { [BUGGY] } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^136^^^^^134^145^
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] else { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^^^^^105^160^
[REPLACE]  burstToken  (  token,  stopAtNonOption  )  ; 	[BUGGY] boolean hasOption = options . hasOption ( ch ) ; [CE] cannot find symbol ch  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { [BUGGY] boolean hasOption = options . hasOption ( ch )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^144^^^^^138^145^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( false )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( false ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^105^160^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { [BUGGY] if ( true ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^149^150^^^^105^160^
[ADD]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { [BUGGY]   else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^149^150^151^152^^105^160^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( stopAtNonOption ) { process ( token ) ; } else { [BUGGY] tokens . toArray ( null ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^155^^^^^149^156^
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] String ch = String . valueOf ( token . charAt ( i ) ) ; [CE] cannot find symbol i  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { [BUGGY] String ch = String . valueOf ( token . charAt ( i ) )  ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^132^^^^^105^160^
[REPLACE]  processSingleHyphen  (  token  )  ; 	[BUGGY] gobble ( iter ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if (   "-  " . equals ( token ) ) { [BUGGY] gobble ( iter )  ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^128^^^^^126^157^
[REPLACE]  else  if  (  token  .  startsWith  (    "-  "  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } [BUGGY] else { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^130^131^^^^105^160^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption ) {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { [BUGGY] else if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^149^150^^^^130^157^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength || 2 ) {[CE] bad operand types for binary operator '||'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength||2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^130^157^
[REPLACE]  processOptionToken  (  token,  stopAtNonOption  )  ; 	[BUGGY] processOptionToken ( token , true ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( tokenLength = = 2 ) { [BUGGY] processOptionToken ( token , true )  ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^136^^^^^134^145^
[ADD]  burstToken  (  token,  stopAtNonOption  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^144^^^^^138^145^
[ADD]  tokens  .  add  (  token  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^130^157^
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] String ch = String . valueOf ( token . charAt ( i ) ) ; [CE] cannot find symbol i  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { [BUGGY] String ch = String . valueOf ( token . charAt ( i ) )  ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^132^^^^^130^157^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength && 2 ) {[CE] bad operand types for binary operator '&&'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength&&2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^105^160^
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  } 	[BUGGY] tokens . add ( token ) ; [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] tokens . add ( token )  ;   else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^139^140^^^105^160^
[REMOVE]   	[BUGGY] tokens . add ( token . substring ( i + 1 ) ) ; [CE] cannot find symbol i  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { [BUGGY] burstToken ( token , stopAtNonOption ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^144^^^^^138^145^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( null ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^105^160^
[ADD]  tokens  .  add  (  token  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^105^160^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( stopAtNonOption ) { process ( token ) ; } else { [BUGGY] tokens . add ( token ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^155^^^^^149^156^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( stopAtNonOption ) { [BUGGY] process ( token ) ;  tokens . add ( iter . next ( ) )  ; } else { tokens . add ( token ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^151^^^^^149^156^
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] int tokenLength = token . startsWith ( token )  ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { [BUGGY] int tokenLength = token . startsWith ( token ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^132^^^^^105^160^
[REPLACE]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  { 	[BUGGY] if ( token . indexOf ( ' = ' )  = =  -1 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . startsWith (   "--  " ) ) { [BUGGY] if ( token . indexOf ( ' = ' )  = = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^113^114^^^^111^157^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( token ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { [BUGGY] tokens . toArray ( token )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^121^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( 0L , token . indexOf ( ' = ' ) ) ) ; [CE] no suitable method found for substring(long , int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 0L , token . indexOf ( ' = ' ) ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ;  tokens . add ( iter . next ( ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( 4 , token . indexOf ( ' = ' ) ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 4 , token . indexOf ( ' = ' ) ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( 0 , token . valueOf ( null )  ) ) ; [CE] no suitable method found for substring(int , String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 0 , token . valueOf ( null )  ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) * 2 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) *2 ) )  ;  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) - 5 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) - 5 ) )  ;  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( token . charAt ( ' = ' ) + 1 , token . length ( ) ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY] tokens . add ( token . substring ( token . charAt ( ' = ' ) + 1 , token . length ( ) ) )  ;  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[ADD]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY]  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[REPLACE]  token  .  length  (  )  )  )  ; 	[BUGGY] token . startsWith ( token )  ) ) ; [CE] no suitable method found for substring(int , boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , [BUGGY] token . startsWith ( token )  ) )  ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^117^^^^^113^122^
[REPLACE]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  { 	[BUGGY] if ( token . indexOf ( ' = ' )  = =  -1 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { [BUGGY] if ( token . indexOf ( ' = ' )  = = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^113^114^^^^105^160^
[ADD]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] [CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { [BUGGY]   } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^113^114^115^116^117^105^160^
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( 0 % 1 , token . indexOf ( ' = ' ) ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 0 % 1 , token . indexOf ( ' = ' ) ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( 0 , token . valueOf ( this )  ) ) ; [CE] no suitable method found for substring(int , String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 0 , token . valueOf ( this )  ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . size ( ) ) ) ; [CE] cannot find symbol  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . size ( ) ) )  ;  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) + 3 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) + 3 ) )  ;  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[REPLACE]  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( iter . next ( ) ) ; [CE] ')' expected  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , [BUGGY] tokens . add ( iter . next ( ) )  ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^117^^^^^113^122^
[ADD]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { [BUGGY]   else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^149^150^151^152^^130^157^
[ADD]  process  (  token  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( stopAtNonOption ) { [BUGGY] } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^151^^^^^149^156^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength ! =  2 + 0 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength! = 2 + 0 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^130^157^
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY]   else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^139^140^^^130^157^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength || 2 ) {[CE] bad operand types for binary operator '||'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength||2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^105^160^
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY]   else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^139^140^^^105^160^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . add ( token ) ;  tokens . add ( iter . next ( ) )  ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^105^160^
[REMOVE]   	[BUGGY] String ch = String . valueOf ( token . charAt ( i ) ) ; [CE] cannot find symbol i  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( tokenLength = = 2 ) { [BUGGY] processOptionToken ( token , stopAtNonOption ) ;  String ch = String . valueOf ( token . charAt ( i ) )  ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^136^^^^^134^145^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( 1 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( 1 ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^130^157^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength || 4 ) {[CE] bad operand types for binary operator '||'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength||4 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^105^160^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( true )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( true ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^105^160^
[ADD]  tokens  .  add  (  token  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( stopAtNonOption ) { process ( token ) ; } else { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^155^^^^^149^156^
[REPLACE]  token  =  (  String  )  iter  .  next  (  )  ; 	[BUGGY] token =  ( String ) null . next ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  while ( iter . hasNext ( ) ) {  [BUGGY] token =  ( String ) null . next ( )  ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^108^^^^^105^160^
[REPLACE]  if  (  token  .  startsWith  (    "--  "  )  )  { 	[BUGGY] else if ( token . startsWith (   "-  " ) ) {[CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   [BUGGY] else if ( token . startsWith (   "-  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^111^112^^^^96^163^
[ADD]  if  (  token  .  startsWith  (    "--  "  )  )  {  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] [CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   [BUGGY]   tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^111^112^113^114^115^96^163^
[REPLACE]  else  if  (    "-  "  .  equals  (  token  )  )  { 	[BUGGY] if (   "-  " . equals ( token ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  [BUGGY] if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^126^127^^^^96^163^
[ADD]  else  if  (    "-  "  .  equals  (  token  )  )  {  processSingleHyphen  (  token  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  [BUGGY]   else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^126^127^128^129^^96^163^
[REPLACE]  else  if  (  token  .  startsWith  (    "-  "  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } [BUGGY] else { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^130^131^^^^96^163^
[ADD]  else  if  (  token  .  startsWith  (    "-  "  )  )  {  int  tokenLength  =  token  .  length  (  )  ;  if  (  tokenLength  ==  2  ) 	[BUGGY] [CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } [BUGGY]   { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^130^131^132^^134^96^163^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength && 2 ) {[CE] bad operand types for binary operator '&&'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength&&2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^130^157^
[ADD]  if  (  tokenLength  ==  2  )  {  processOptionToken  (  token,  stopAtNonOption  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY]   else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^136^137^^130^157^
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^^^^^130^157^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength ! =  2 << 0 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength! = 2 << 0 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^96^163^
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] else { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^^^^^96^163^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( token ) ; [CE] no suitable method found for toArray(String)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( token )  ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^96^163^
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  { 	[BUGGY] if ( options . hasOption ( token ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^^^^^96^163^
[ADD]  else  if  (  options  .  hasOption  (  token  )  )  {  tokens  .  add  (  token  )  ;  } 	[BUGGY] tokens . add ( token ) ; [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] tokens . add ( token )  ;   else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^139^140^^^96^163^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { [BUGGY] if ( true ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^149^150^^^^96^163^
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] int tokenLength = token . startsWith ( token )  ; [CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { [BUGGY] int tokenLength = token . startsWith ( token ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^132^^^^^96^163^
[REPLACE]  else  if  (  token  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( token . startsWith (   "-  " ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } [BUGGY] if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^130^131^^^^96^163^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( 0 )  ; [CE] no suitable method found for toArray(int)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( stopAtNonOption ) { process ( token ) ; } else { [BUGGY] tokens . toArray ( 0 ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^155^^^^^149^156^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( false )  ; [CE] no suitable method found for toArray(boolean)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( false ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^130^157^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength ! =  2 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength! = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^96^163^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . add ( token ) ;  tokens . add ( iter . next ( ) )  ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^96^163^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(PosixParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { [BUGGY] tokens . toArray ( this ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^121^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( 2 , token . indexOf ( ' = ' ) ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 2 , token . indexOf ( ' = ' ) ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[ADD]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( 0 , token . charAt ( ' = ' ) ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 0 , token . charAt ( ' = ' ) ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) + 4 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) + 4 ) )  ;  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[ADD]  token  .  length  (  )  )  )  ; 	[BUGGY] [CE] illegal start of expression  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , [BUGGY] } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^117^^^^^113^122^
[REPLACE]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  { 	[BUGGY] if ( token . indexOf ( ' = ' )  = =  -1 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { [BUGGY] if ( token . indexOf ( ' = ' )  = = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^113^114^^^^96^163^
[ADD]  if  (  token  .  indexOf  (  '='  )  !=  -1  )  {  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ;  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] [CE]  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { [BUGGY]   } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^113^114^115^116^117^96^163^
[REPLACE]  tokens  .  add  (  token  .  substring  (  0,  token  .  indexOf  (  '='  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( 0 * 4 , token . indexOf ( ' = ' ) ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { [BUGGY] tokens . add ( token . substring ( 0 * 4 , token . indexOf ( ' = ' ) ) )  ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^115^^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( token . length ( token . indexOf ( ' = ' ) + 1 , token . length ( ) * 0 . 5 ) ) ; [CE] method length in class String cannot be applied to given types ;  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY] tokens . add ( token . length ( token . indexOf ( ' = ' ) + 1 , token . length ( ) *0 . 5 ) )  ;  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[REPLACE]  tokens  .  add  (  token  .  substring  (  token  .  indexOf  (  '='  )  +  1,  token  .  length  (  )  )  )  ; 	[BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) % 0 . 5 ) ) ; [CE] no suitable method found for substring(int , double)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; [BUGGY] tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) %0 . 5 ) )  ;  } else { tokens . add ( token ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^116^117^^^^113^122^
[REPLACE]  if  (  tokenLength  ==  2  )  { 	[BUGGY] if ( tokenLength || 0 ) {[CE] bad operand types for binary operator '||'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  [BUGGY] if ( tokenLength||0 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^134^135^^^^96^163^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( null ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^96^163^
[ADD]  tokens  .  add  (  token  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^96^163^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( stopAtNonOption ) {[CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { [BUGGY] else if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^149^150^^^^96^163^
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] String ch = String . valueOf ( token . charAt ( i ) ) ; [CE] cannot find symbol i  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { [BUGGY] String ch = String . valueOf ( token . charAt ( i ) )  ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^132^^^^^96^163^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( null ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^130^157^
[REPLACE]  else  if  (  options  .  hasOption  (  token  )  )  { 	[BUGGY] if ( options . getOption ( token ) ) {[CE] incompatible types  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } [BUGGY] if ( options . getOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^138^^^^^96^163^
[REPLACE]  tokens  .  add  (  token  )  ; 	[BUGGY] tokens . toArray ( this )  ; [CE] no suitable method found for toArray(PosixParser)  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { [BUGGY] tokens . toArray ( this ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^139^^^^^96^163^
[ADD]  if  (  stopAtNonOption  )  {  process  (  token  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { [BUGGY]   else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^149^150^151^152^^96^163^
[REPLACE]  token  =  (  String  )  iter  .  next  (  )  ; 	[BUGGY] token =  ( String ) null . next ( ) ; [CE] <null> cannot be dereferenced  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  [BUGGY] token =  ( String ) null . next ( )  ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^108^^^^^96^163^
[ADD]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] [CE] cannot find symbol tokenLength  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { [BUGGY]  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } return ( String[] ) tokens . toArray ( new String[] {} ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^132^^^^^96^163^
[REPLACE]  return  (  String[]  )  tokens  .  toArray  (  new  String[]  {  }  )  ; 	[BUGGY] return ( String[] ) tokens . ArrayList ( new String[] { } ) ; [CE] cannot find symbol  [METHOD]  flatten [TYPE] String[] [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] PosixParser  [TYPE] Options options [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Option currentOption [TYPE] String[] arguments [TYPE] String token [TYPE] int tokenLength  [CONTEXT]  { init ( ) ; this . options = options ;   Iterator iter = Arrays . asList ( arguments ) . iterator ( ) ; String token = null ;   while ( iter . hasNext ( ) ) {  token =  ( String ) iter . next ( ) ;   if ( token . startsWith (   "--  " ) ) { if ( token . indexOf ( ' = ' ) ! = -1 ) { tokens . add ( token . substring ( 0 , token . indexOf ( ' = ' ) ) ) ; tokens . add ( token . substring ( token . indexOf ( ' = ' ) + 1 , token . length ( ) ) ) ; } else { tokens . add ( token ) ; } }  else if (   "-  " . equals ( token ) ) { processSingleHyphen ( token ) ; } else if ( token . startsWith (   "-  " ) ) { int tokenLength = token . length ( ) ;  if ( tokenLength = = 2 ) { processOptionToken ( token , stopAtNonOption ) ; } else if ( options . hasOption ( token ) ) { tokens . add ( token ) ; }  else { burstToken ( token , stopAtNonOption ) ; } } else { if ( stopAtNonOption ) { process ( token ) ; } else { tokens . add ( token ) ; } } gobble ( iter ) ; } [BUGGY] return ( String[] ) tokens . ArrayList ( new String[] {} )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^162^^^^^96^163^
[REPLACE]  while  (  iter  .  hasNext  (  )  )  { 	[BUGGY] while ( iter . next ( ) ) {[CE] incompatible types  [METHOD]  gobble [TYPE] void [PARAMETER] Iterator iter [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true  [CONTEXT]  private void gobble ( Iterator iter ) { if ( eatTheRest ) { [BUGGY] while ( iter . next ( ) ) { tokens . add ( iter . next ( ) ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^174^175^^^^170^179^
[REPLACE]  tokens  .  add  (  iter  .  next  (  )  )  ; 	[BUGGY] tokens . toArray ( null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  gobble [TYPE] void [PARAMETER] Iterator iter [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true  [CONTEXT]  private void gobble ( Iterator iter ) { if ( eatTheRest ) { while ( iter . hasNext ( ) ) { [BUGGY] tokens . toArray ( null ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^176^^^^^170^179^
[REPLACE]  tokens  .  add  (  iter  .  next  (  )  )  ; 	[BUGGY] tokens . add ( iter . hasNext ( )  ) ; [FE] AssertionFailedError [METHOD]  gobble [TYPE] void [PARAMETER] Iterator iter [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true  [CONTEXT]  private void gobble ( Iterator iter ) { if ( eatTheRest ) { while ( iter . hasNext ( ) ) { [BUGGY] tokens . add ( iter . hasNext ( )  )  ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^176^^^^^170^179^
[REPLACE]  if  (  eatTheRest  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[CE] 'else' without 'if'  [METHOD]  gobble [TYPE] void [PARAMETER] Iterator iter [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true  [CONTEXT]  private void gobble ( Iterator iter ) { [BUGGY] else if ( currentOption . hasArgs ( ) ) { while ( iter . hasNext ( ) ) { tokens . add ( iter . next ( ) ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^172^173^^^^170^179^
[REPLACE]  tokens  .  add  (  iter  .  next  (  )  )  ; 	[BUGGY] tokens . toArray ( iter . next ( ) ) ; [CE] no suitable method found for toArray(Object)  [METHOD]  gobble [TYPE] void [PARAMETER] Iterator iter [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true  [CONTEXT]  private void gobble ( Iterator iter ) { if ( eatTheRest ) { while ( iter . hasNext ( ) ) { [BUGGY] tokens . toArray ( iter . next ( ) )  ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^176^^^^^170^179^
[REPLACE]  tokens  .  add  (  iter  .  next  (  )  )  ; 	[BUGGY] tokens . add ( iter . hasNext ( ) ) ; [FE] AssertionFailedError [METHOD]  gobble [TYPE] void [PARAMETER] Iterator iter [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Iterator iter [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true  [CONTEXT]  private void gobble ( Iterator iter ) { if ( eatTheRest ) { while ( iter . hasNext ( ) ) { [BUGGY] tokens . add ( iter . hasNext ( ) )  ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^176^^^^^170^179^
[REPLACE]  if  (  (  currentOption  !=  null  )  &&  currentOption  .  hasArg  (  )  )  { 	[BUGGY] if ( ( currentOption = = this ) ) {[CE] incomparable types: Option and PosixParser  [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { [BUGGY] if ( ( currentOption = = this ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^196^197^^^^194^214^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { [BUGGY] eatTheRest = false ;  ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^210^^^^^194^214^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[CE] 'else' without 'if'  [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^198^199^^^^194^214^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } [BUGGY] else { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^203^204^^^^194^214^
[ADD]  else  if  (  currentOption  .  hasArgs  (  )  )  {  tokens  .  add  (  value  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } [BUGGY]   } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^203^204^205^206^^194^214^
[REPLACE]  tokens  .  add  (  value  )  ; 	[BUGGY] tokens . toArray ( value ) ; [CE] no suitable method found for toArray(String)  [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { [BUGGY] tokens . toArray ( value )  ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^205^^^^^194^214^
[ADD]  tokens  .  add  (  value  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { [BUGGY] } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^205^^^^^194^214^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = this ; [CE] incompatible types  [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; [BUGGY] currentOption = this ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^201^^^^^194^214^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = true ; [CE] incompatible types  [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; [BUGGY] currentOption = true ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^201^^^^^194^214^
[ADD]  if  (  currentOption  .  hasArg  (  )  )  {  tokens  .  add  (  value  )  ;  currentOption  =  null;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { [BUGGY]   else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^198^199^200^201^202^194^214^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) )[CE] illegal start of type  [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArgs ( ) )  tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^203^204^^^^194^214^
[REPLACE]  else  if  (  currentOption  .  hasArgs  (  )  )  { 	[BUGGY] else if ( currentOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } [BUGGY] else if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^203^204^^^^194^214^
[REPLACE]  currentOption  =  null; 	[BUGGY] currentOption = false ; [CE] incompatible types  [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; [BUGGY] currentOption = false ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { eatTheRest = true ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^201^^^^^194^214^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  process [TYPE] void [PARAMETER] String value [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String value  [CONTEXT]  private void process ( String value ) { if ( ( currentOption ! = null ) && currentOption . hasArg ( ) ) { if ( currentOption . hasArg ( ) ) { tokens . add ( value ) ; currentOption = null ; } else if ( currentOption . hasArgs ( ) ) { tokens . add ( value ) ; } } else { [BUGGY] eatTheRest = false ; tokens . add (   "--  " ) ; tokens . add ( value ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^210^^^^^194^214^
[REPLACE]  tokens  .  add  (  hyphen  )  ; 	[BUGGY] tokens . toArray ( hyphen ) ; [CE] no suitable method found for toArray(String)  [METHOD]  processSingleHyphen [TYPE] void [PARAMETER] String hyphen [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String hyphen  [CONTEXT]  private void processSingleHyphen ( String hyphen ) { [BUGGY] tokens . toArray ( hyphen )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^224^^^^^222^225^
[REPLACE]  if  (  this  .  options  .  hasOption  (  token  )  )  { 	[BUGGY] if ( this . options . getOption ( token ) ) {[CE] incompatible types  [METHOD]  processOptionToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String token  [CONTEXT]  private void processOptionToken ( String token , boolean stopAtNonOption ) { [BUGGY] if ( this . options . getOption ( token ) ) { currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^241^242^^^^239^250^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOptionToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String token  [CONTEXT]  private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } [BUGGY] else { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^246^247^^^^239^250^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOptionToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String token  [CONTEXT]  private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^248^^^^^239^250^
[REPLACE]  currentOption  =  this  .  options  .  getOption  (  token  )  ; 	[BUGGY] currentOption = options . getOption ( ch ) ;  ; [CE] cannot find symbol ch  [METHOD]  processOptionToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String token  [CONTEXT]  private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { [BUGGY] currentOption = options . getOption ( ch )  ;  ; tokens . add ( token ) ; } else if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^243^^^^^239^250^
[ADD]  currentOption  =  this  .  options  .  getOption  (  token  )  ;  tokens  .  add  (  token  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOptionToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String token  [CONTEXT]  private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { [BUGGY]  } else if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^243^244^^^^239^250^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOptionToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] String token  [CONTEXT]  private void processOptionToken ( String token , boolean stopAtNonOption ) { if ( this . options . hasOption ( token ) ) { currentOption = this . options . getOption ( token ) ; tokens . add ( token ) ; } [BUGGY] if ( true ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^246^247^^^^239^250^
[REPLACE]  int  tokenLength  =  token  .  length  (  )  ; 	[BUGGY] int tokenLength = token . startsWith ( token )  ; [CE] incompatible types  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { [BUGGY] int tokenLength = token . startsWith ( token ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^280^^^^^279^308^
[REPLACE]  if  (  hasOption  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[CE] 'else' without 'if'  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^287^288^^^^279^308^
[ADD]  if  (  hasOption  )  {  tokens  .  add  (    "-  "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  [BUGGY]   if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^287^288^289^290^^279^308^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] else if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } [BUGGY] else if ( true ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^299^300^^^^279^308^
[ADD]  else  if  (  stopAtNonOption  )  {  process  (  token  .  substring  (  i  )  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } [BUGGY]   else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^299^300^301^302^^279^308^
[REPLACE]  tokens  .  add  (    "-  "  +  ch  )  ; 	[BUGGY] tokens . add (   "-  " ! =  ch ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { [BUGGY] tokens . add (   "-  "! = ch )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^305^^^^^299^306^
[REPLACE]  process  (  token  .  substring  (  i  )  )  ; 	[BUGGY] process ( token . charAt ( i ) ) ; [CE] method process in class PosixParser cannot be applied to given types ;  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] process ( token . charAt ( i ) )  ; } else { tokens . add (   "-  " + ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^301^^^^^299^306^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [CE] cannot find symbol iter  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] process ( token . substring ( i ) ) ;  tokens . add ( iter . next ( ) )  ; } else { tokens . add (   "-  " + ch ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^301^^^^^299^306^
[REPLACE]  process  (  token  .  substring  (  i  )  )  ; 	[BUGGY] process ( token . substring ( tokenLength , tokenLength )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] process ( token . substring ( tokenLength , tokenLength )  )  ; } else { tokens . add (   "-  " + ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^301^^^^^299^306^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) && ( token . length ( ) - 3 ! =  ( i + 1 ) ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  [BUGGY] if ( currentOption . hasArg ( ) && ( token . length ( ) - 3 ! = ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^292^293^^^^287^306^
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ; 	[BUGGY] tokens . toArray ( token . substring ( i || 3 ) ) ; [CE] bad operand types for binary operator '||'  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . toArray ( token . substring ( i||3 ) )  ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^287^306^
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ; 	[BUGGY] tokens . add ( token . substring ( i  = =  1 ) ) ; [CE] no suitable method found for substring(boolean)  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . add ( token . substring ( i = = 1 ) )  ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^287^306^
[REPLACE]  currentOption  =  options  .  getOption  (  ch  )  ; 	[BUGGY] currentOption = this . options . getOption ( token ) ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  if ( hasOption ) { tokens . add (   "-  " + ch ) ; [BUGGY] currentOption = this . options . getOption ( token )  ;  ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^290^^^^^287^306^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  [BUGGY] if ( currentOption . hasArg ( ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^292^293^^^^279^308^
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ; 	[BUGGY] tokens . add ( token . substring ( i & 1 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . add ( token . substring ( i&1 ) )  ;  break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^292^297^
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ; 	[BUGGY] tokens . add ( token . substring ( i | 4 ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . add ( token . substring ( i|4 ) )  ;  break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^292^297^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } [BUGGY] if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^299^300^^^^279^308^
[REPLACE]  tokens  .  add  (    "-  "  +  ch  )  ; 	[BUGGY] tokens . add (   "-  " < =  ch ) ; [CE] bad operand types for binary operator  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { [BUGGY] tokens . add (   "-  "< = ch )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^305^^^^^299^306^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [CE] cannot find symbol iter  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { [BUGGY] tokens . add (   "-  " + ch ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^305^^^^^299^306^
[REPLACE]  process  (  token  .  substring  (  i  )  )  ; 	[BUGGY] tokens . add ( iter . next ( ) ) ; [CE] cannot find symbol iter  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  else if ( stopAtNonOption ) { [BUGGY] tokens . add ( iter . next ( ) )  ; } else { tokens . add (   "-  " + ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^301^^^^^299^306^
[REPLACE]  for  (  int  i  =  1;  i  <  tokenLength;  i++  )  { 	[BUGGY] for ( int i = 1 ; i > tokenLength ; i++ ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  [BUGGY] for ( int i = 1 ; i>tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^282^283^^^^279^308^
[ADD]  for  (  int  i  =  1;  i  <  tokenLength;  i++  )  {  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ;  boolean  hasOption  =  options  .  hasOption  (  ch  )  ; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  [BUGGY]   if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^282^283^284^285^^279^308^
[REPLACE]  if  (  hasOption  )  { 	[BUGGY] else if ( currentOption . hasArgs ( ) ) {[CE] 'else' without 'if'  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  [BUGGY] else if ( currentOption . hasArgs ( ) ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^287^288^^^^282^307^
[ADD]  if  (  hasOption  )  {  tokens  .  add  (    "-  "  +  ch  )  ;  currentOption  =  options  .  getOption  (  ch  )  ; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  [BUGGY]   if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^287^288^289^290^^282^307^
[REPLACE]  else  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } [BUGGY] if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^299^300^^^^282^307^
[REPLACE]  tokens  .  add  (    "-  "  +  ch  )  ; 	[BUGGY] tokens . add (   "-  " & ch ) ; [CE] bad operand types for binary operator  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { [BUGGY] tokens . add (   "-  "&ch )  ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^305^^^^^282^307^
[REPLACE]  process  (  token  .  substring  (  i  )  )  ; 	[BUGGY] process ( token . charAt ( i ) ) ; [CE] method process in class PosixParser cannot be applied to given types ;  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { [BUGGY] process ( token . charAt ( i ) )  ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^301^^^^^282^307^
[REPLACE]  process  (  token  .  substring  (  i  )  )  ; 	[BUGGY] process ( token . substring ( i , i )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { [BUGGY] process ( token . substring ( i , i )  )  ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^301^^^^^282^307^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  [BUGGY] if ( currentOption . hasArg ( ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^292^293^^^^282^307^
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ; 	[BUGGY] tokens . add ( token . substring ( i  = =  1 - 1 ) ) ; [CE] no suitable method found for substring(boolean)  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . add ( token . substring ( i = = 1 - 1 ) )  ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^282^307^
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ; 	[BUGGY] tokens . add ( token . length ( i < 1 ) ) ; [CE] method length in class String cannot be applied to given types ;  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . add ( token . length ( i<1 ) )  ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^282^307^
[REPLACE]  currentOption  =  options  .  getOption  (  ch  )  ; 	[BUGGY] currentOption = this . options . getOption ( token ) ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; [BUGGY] currentOption = this . options . getOption ( token )  ;  ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^290^^^^^282^307^
[REPLACE]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  { 	[BUGGY] if ( currentOption . hasArg ( ) && ( token . length ( ) * 2 ! =  ( i + 1 ) ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  [BUGGY] if ( currentOption . hasArg ( ) && ( token . length ( ) *2 ! = ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^292^293^^^^282^307^
[ADD]  if  (  currentOption  .  hasArg  (  )  &&  (  token  .  length  (  )  !=  (  i  +  1  )  )  )  {  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ;  break; 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  [BUGGY]   } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^292^293^294^^296^282^307^
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ; 	[BUGGY] tokens . add ( token . length ( i && 1 ) ) ; [CE] bad operand types for binary operator '&&'  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . add ( token . length ( i&&1 ) )  ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^282^307^
[REPLACE]  tokens  .  add  (  token  .  substring  (  i  +  1  )  )  ; 	[BUGGY] tokens . add ( token . substring ( i > =  2 ) ) ; [CE] no suitable method found for substring(boolean)  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . add ( token . substring ( i> = 2 ) )  ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^282^307^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [CE] cannot find symbol iter  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { [BUGGY] tokens . add ( token . substring ( i + 1 ) ) ;  tokens . add ( iter . next ( ) )  ; break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^294^^^^^282^307^
[REPLACE]  tokens  .  add  (    "-  "  +  ch  )  ; 	[BUGGY] tokens . clear (   "-  " > =  ch ) ; [CE] bad operand types for binary operator  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { [BUGGY] tokens . clear (   "-  "> = ch )  ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^305^^^^^282^307^
[REMOVE]   	[BUGGY] tokens . add ( iter . next ( ) ) ; [CE] cannot find symbol iter  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { [BUGGY] tokens . add (   "-  " + ch ) ;  tokens . add ( iter . next ( ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^305^^^^^282^307^
[REPLACE]  process  (  token  .  substring  (  i  )  )  ; 	[BUGGY] tokens . add ( iter . next ( ) ) ; [CE] cannot find symbol iter  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { [BUGGY] tokens . add ( iter . next ( ) )  ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^301^^^^^282^307^
[REPLACE]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ; 	[BUGGY] String ch = String . indexOf ( tokenLength )  ; [CE] non-static method indexOf(int) cannot be referenced from a static context  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { [BUGGY] String ch = String . indexOf ( tokenLength ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^284^^^^^282^307^
[REPLACE]  boolean  hasOption  =  options  .  hasOption  (  ch  )  ; 	[BUGGY] boolean . getOption = options . hasOption ( ch ) ; [CE] class expected  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; [BUGGY] boolean . getOption = options . hasOption ( ch )  ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^285^^^^^282^307^
[REPLACE]  currentOption  =  options  .  getOption  (  ch  )  ; 	[BUGGY] currentOption = this . options . getOption ( token ) ;  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; [BUGGY] currentOption = this . options . getOption ( token )  ;  ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^290^^^^^279^308^
[REPLACE]  for  (  int  i  =  1;  i  <  tokenLength;  i++  )  { 	[BUGGY] for ( int i = 1L ; i < tokenLength ; i++ ) {[CE] possible loss of precision  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  [BUGGY] for ( int i = 1L ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^282^283^^^^279^308^
[REPLACE]  String  ch  =  String  .  valueOf  (  token  .  charAt  (  i  )  )  ; 	[BUGGY] String ch = String . valueOf ( token . startsWith ( token )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { [BUGGY] String ch = String . valueOf ( token . startsWith ( token )  )  ; boolean hasOption = options . hasOption ( ch ) ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^284^^^^^279^308^
[REPLACE]  boolean  hasOption  =  options  .  hasOption  (  ch  )  ; 	[BUGGY] boolean . getOption = options . hasOption ( ch ) ; [CE] class expected  [METHOD]  burstToken [TYPE] void [PARAMETER] String token boolean stopAtNonOption [CLASS] PosixParser  [TYPE] ArrayList tokens [TYPE] Options options [TYPE] Option currentOption [TYPE] boolean eatTheRest false hasOption stopAtNonOption true [TYPE] String ch token [TYPE] int i tokenLength  [CONTEXT]  { int tokenLength = token . length ( ) ;  for ( int i = 1 ; i < tokenLength ; i++ ) { String ch = String . valueOf ( token . charAt ( i ) ) ; [BUGGY] boolean . getOption = options . hasOption ( ch )  ;  if ( hasOption ) { tokens . add (   "-  " + ch ) ; currentOption = options . getOption ( ch ) ;  if ( currentOption . hasArg ( ) && ( token . length ( ) ! =  ( i + 1 ) ) ) { tokens . add ( token . substring ( i + 1 ) ) ;  break ; } } else if ( stopAtNonOption ) { process ( token . substring ( i ) ) ; } else { tokens . add (   "-  " + ch ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/PosixParser.java^285^^^^^279^308^
[REPLACE]  private  Map  shortOpts  =  new  HashMap  (  )  ; 	[BUGGY] private Map shortOpts  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] Options  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^45^^^^^^^
[REPLACE]  private  Map  longOpts  =  new  HashMap  (  )  ; 	[BUGGY] private Map longOpts  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] Options  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^48^^^^^^^
[REPLACE]  private  List  requiredOpts  =  new  ArrayList  (  )  ; 	[BUGGY] private List requiredOpts ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] Options  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^51^^^^^^^
[REPLACE]  private  Map  optionGroups  =  new  HashMap  (  )  ; 	[BUGGY] private Map optionGroups  = null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] Options  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^54^^^^^^^
[REPLACE]  Iterator  options  =  group  .  getOptions  (  )    .  iterator  (  )  ; 	[BUGGY] Iterator options = group . isRequired ( )  . iterator ( ) ; [CE] boolean cannot be dereferenced  [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { [BUGGY] Iterator options = group . isRequired ( ) . iterator ( )  ;  if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option =  ( Option ) options . next ( ) ;     option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^71^^^^^69^93^
[ADD]  Iterator  options  =  group  .  getOptions  (  )    .  iterator  (  )  ; 	[BUGGY] [CE] cannot find symbol options  [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { [BUGGY]  if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option =  ( Option ) options . next ( ) ;     option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^71^^^^^69^93^
[REPLACE]  if  (  group  .  isRequired  (  )  )  { 	[BUGGY] if ( group . getOptions ( ) ) {[CE] incompatible types  [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ;  [BUGGY] if ( group . getOptions ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option =  ( Option ) options . next ( ) ;     option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^73^74^^^^69^93^
[REPLACE]  requiredOpts  .  add  (  group  )  ; 	[BUGGY] requiredOpts . remove ( group ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ;  if ( group . isRequired ( ) ) { [BUGGY] requiredOpts . remove ( group )  ; } while ( options . hasNext ( ) ) { Option option =  ( Option ) options . next ( ) ;     option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^75^^^^^69^93^
[ADD]  requiredOpts  .  add  (  group  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ;  if ( group . isRequired ( ) ) { [BUGGY] } while ( options . hasNext ( ) ) { Option option =  ( Option ) options . next ( ) ;     option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^75^^^^^69^93^
[REPLACE]  while  (  options  .  hasNext  (  )  )  { 	[BUGGY] while ( options . next ( ) ) {[CE] incompatible types  [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ;  if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } [BUGGY] while ( options . next ( ) ) { Option option =  ( Option ) options . next ( ) ;     option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^78^79^^^^69^93^
[ADD]  while  (  options  .  hasNext  (  )  )  {  Option  option  =  (  Option  )  options  .  next  (  )  ; 	[BUGGY] [CE] illegal start of type  [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ;  if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } [BUGGY]      option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^78^79^80^^^69^93^
[REPLACE]  Option  option  =  (  Option  )  options  .  next  (  )  ; 	[BUGGY] Option option =  ( Option ) options . hasNext ( ) ; [CE] inconvertible types  [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ;  if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { [BUGGY] Option option = ( Option ) options . hasNext ( )  ;     option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^80^^^^^69^93^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOptionGroup [TYPE] Options [PARAMETER] OptionGroup group [CLASS] Options  [TYPE] Iterator options [TYPE] List requiredOpts [TYPE] Option option [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOptionGroup ( OptionGroup group ) { Iterator options = group . getOptions ( ) . iterator ( ) ;  if ( group . isRequired ( ) ) { requiredOpts . add ( group ) ; } while ( options . hasNext ( ) ) { Option option =  ( Option ) options . next ( ) ;     option . setRequired ( false ) ; addOption ( option ) ;  optionGroups . put ( option . getKey ( ) , group ) ; } [BUGGY] return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^92^^^^^69^93^
[REPLACE]  return  new  HashSet  (  optionGroups  .  values  (  )  )  ; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  getOptionGroups [TYPE] Collection [PARAMETER] [CLASS] Options  [TYPE] Map longOpts optionGroups shortOpts [TYPE] List requiredOpts [TYPE] boolean false true  [CONTEXT]  Collection getOptionGroups ( ) { [BUGGY] return buf . toString ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^100^^^^^99^101^
[REPLACE]  addOption  (  opt,  null,  hasArg,  description  )  ; 	[BUGGY] addOption ( opt , false , hasArg , description ) ; [CE] no suitable method found for addOption(String , boolean , boolean , String)  [METHOD]  addOption [TYPE] Options [PARAMETER] String opt boolean hasArg String description [CLASS] Options  [TYPE] List requiredOpts [TYPE] String description opt [TYPE] boolean false hasArg true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( String opt , boolean hasArg , String description ) { [BUGGY] addOption ( opt , false , hasArg , description )  ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^114^^^^^112^117^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] String opt boolean hasArg String description [CLASS] Options  [TYPE] List requiredOpts [TYPE] String description opt [TYPE] boolean false hasArg true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( String opt , boolean hasArg , String description ) { addOption ( opt , null , hasArg , description ) ;  [BUGGY] return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^116^^^^^112^117^
[REPLACE]  addOption  (  new  Option  (  opt,  longOpt,  hasArg,  description  )  )  ; 	[BUGGY] addOption ( new Option ( opt , longOpt , hasArg , longOpt ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Options  [TYPE] List requiredOpts [TYPE] String description longOpt opt [TYPE] boolean false hasArg true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( String opt , String longOpt , boolean hasArg , String description ) { [BUGGY] addOption ( new Option ( opt , longOpt , hasArg , longOpt ) )  ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^132^^^^^129^135^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] String opt String longOpt boolean hasArg String description [CLASS] Options  [TYPE] List requiredOpts [TYPE] String description longOpt opt [TYPE] boolean false hasArg true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( String opt , String longOpt , boolean hasArg , String description ) { addOption ( new Option ( opt , longOpt , hasArg , description ) ) ;  [BUGGY] return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^134^^^^^129^135^
[REPLACE]  String  key  =  opt  .  getKey  (  )  ; 	[BUGGY] String key = opt . getLongOpt ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { [BUGGY] String key = opt . getLongOpt ( )  ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^145^^^^^143^165^
[REPLACE]  if  (  opt  .  hasLongOpt  (  )  )  { 	[BUGGY] if ( opt . getLongOpt ( ) ) {[CE] incompatible types  [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   [BUGGY] if ( opt . getLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^148^149^^^^143^165^
[ADD]  if  (  opt  .  hasLongOpt  (  )  )  {  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   [BUGGY]    if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^148^149^150^151^^143^165^
[REPLACE]  longOpts  .  put  (  opt  .  getLongOpt  (  )  ,  opt  )  ; 	[BUGGY] longOpts . put ( opt . hasLongOpt ( ) , opt ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { [BUGGY] longOpts . put ( opt . hasLongOpt ( )  , opt )  ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^150^^^^^143^165^
[REPLACE]  if  (  opt  .  isRequired  (  )    )  { 	[BUGGY] if ( group . isRequired ( ) ) {[CE] cannot find symbol group  [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  [BUGGY] if ( group . isRequired ( ) ) { if ( requiredOpts . contains ( key )  ) { requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^154^155^^^^143^165^
[ADD]  if  (  opt  .  isRequired  (  )    )  {  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  } 	[BUGGY] [CE] <identifier> expected  [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  [BUGGY]   requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^154^155^156^157^158^143^165^
[REPLACE]  if  (  requiredOpts  .  contains  (  key  )    )  { 	[BUGGY] if ( ! requiredOpts . contains ( key )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { [BUGGY] if ( !requiredOpts . contains ( key )  ) { requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^156^^^^^143^165^
[ADD]  if  (  requiredOpts  .  contains  (  key  )    )  {  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ;  } 	[BUGGY] requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { [BUGGY] requiredOpts . remove ( requiredOpts . indexOf ( key )  )  ;  requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^156^157^158^^^143^165^
[REPLACE]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ; 	[BUGGY] requiredOpts . add ( requiredOpts . indexOf ( key )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { [BUGGY] requiredOpts . add ( requiredOpts . indexOf ( key )  )  ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^157^^^^^143^165^
[ADD]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { [BUGGY] } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^157^^^^^143^165^
[REPLACE]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ; 	[BUGGY] requiredOpts . remove ( requiredOpts . contains ( key )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { [BUGGY] requiredOpts . remove ( requiredOpts . contains ( key )  )  ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^157^^^^^143^165^
[REPLACE]  requiredOpts  .  remove  (  requiredOpts  .  indexOf  (  key  )    )  ; 	[BUGGY] requiredOpts . indexOf ( false )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { [BUGGY] requiredOpts . indexOf ( false ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^157^^^^^143^165^
[REPLACE]  shortOpts  .  put  (  key,  opt  )  ; 	[BUGGY] if ( shortOpts . containsKey ( opt ) ) {[CE] illegal start of expression  [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; } requiredOpts . add ( key ) ; } [BUGGY] if ( shortOpts . containsKey ( opt ) ) { return this ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^162^^^^^143^165^
[REPLACE]  return  this; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] Options [PARAMETER] Option opt [CLASS] Options  [TYPE] List requiredOpts [TYPE] Option opt [TYPE] String key [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Options addOption ( Option opt ) { String key = opt . getKey ( ) ;   if ( opt . hasLongOpt ( ) ) { longOpts . put ( opt . getLongOpt ( ) , opt ) ; }  if ( opt . isRequired ( )  ) { if ( requiredOpts . contains ( key )  ) { requiredOpts . remove ( requiredOpts . indexOf ( key )  ) ; } requiredOpts . add ( key ) ; } shortOpts . put ( key , opt ) ;  [BUGGY] return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^164^^^^^143^165^
[REPLACE]  return  Collections  .  unmodifiableCollection  (  helpOptions  (  )  )  ; 	[BUGGY] return  helpOptions ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptions [TYPE] Collection [PARAMETER] [CLASS] Options  [TYPE] Map longOpts optionGroups shortOpts [TYPE] List requiredOpts [TYPE] boolean false true  [CONTEXT]  public Collection getOptions ( ) { [BUGGY] return helpOptions ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^174^^^^^172^175^
[REPLACE]  List  opts  =  new  ArrayList  (  shortOpts  .  values  (  )  )  ; 	[BUGGY] Option option =  ( Option ) options . next ( ) ; [CE] cannot find symbol options  [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { [BUGGY] Option option = ( Option ) options . next ( )  ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  if ( !opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^184^^^^^182^201^
[REPLACE]  Iterator  iter  =  longOpts  .  values  (  )    .  iterator  (  )  ; 	[BUGGY] Iterator options = group . getOptions ( ) . iterator ( ) ; [CE] cannot find symbol group  [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    [BUGGY] Iterator options = group . getOptions ( )  . iterator ( )  ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  if ( !opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^188^^^^^182^201^
[ADD]  Iterator  iter  =  longOpts  .  values  (  )    .  iterator  (  )  ; 	[BUGGY] [CE] cannot find symbol iter  [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    [BUGGY]  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  if ( !opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^188^^^^^182^201^
[REPLACE]  if  (  !opts  .  contains  (  item  )  )  { 	[BUGGY] if ( !opts . indexOf ( item ) ) {[CE] bad operand type int for unary operator '!'  [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  [BUGGY] if ( !opts . indexOf ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^194^195^^^^182^201^
[ADD]  if  (  !opts  .  contains  (  item  )  )  {  opts  .  add  (  item  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  [BUGGY]   } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^194^195^196^197^^182^201^
[REPLACE]  opts  .  add  (  item  )  ; 	[BUGGY] opts . remove ( item ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  if ( !opts . contains ( item ) ) { [BUGGY] opts . remove ( item )  ; } } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^196^^^^^182^201^
[REMOVE]   	[BUGGY] shortOpts . put ( key , opt ) ; [CE] cannot find symbol key  [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  if ( !opts . contains ( item ) ) { [BUGGY] opts . add ( item ) ;  shortOpts . put ( key , opt )  ; } } return new ArrayList ( opts ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^196^^^^^182^201^
[REPLACE]  Object  item  =  iter  .  next  (  )  ; 	[BUGGY] Object item = iter . hasNext ( ) ; [FE] AssertionFailedError [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { [BUGGY] Object item = iter . hasNext ( )  ;  if ( !opts . contains ( item ) ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^192^^^^^182^201^
[REPLACE]  if  (  !opts  .  contains  (  item  )  )  { 	[BUGGY] if ( !opts . add ( null )  ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  [BUGGY] if ( !opts . add ( null )  ) { opts . add ( item ) ; } } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^194^195^^^^182^201^
[REPLACE]  opts  .  add  (  item  )  ; 	[BUGGY] opts . indexOf ( item )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  if ( !opts . contains ( item ) ) { [BUGGY] opts . indexOf ( item ) ; } } return new ArrayList ( opts ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^196^^^^^182^201^
[REPLACE]  return  new  ArrayList  (  opts  )  ; 	[BUGGY] return new ArrayList ( shortOpts . values ( ) )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  helpOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Iterator iter [TYPE] List opts requiredOpts [TYPE] Object item [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  List helpOptions ( ) { List opts = new ArrayList ( shortOpts . values ( ) ) ;    Iterator iter = longOpts . values ( ) . iterator ( ) ;  while ( iter . hasNext ( ) ) { Object item = iter . next ( ) ;  if ( !opts . contains ( item ) ) { opts . add ( item ) ; } } [BUGGY] returnnew ArrayList ( shortOpts . values ( ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^200^^^^^182^201^
[REPLACE]  return  requiredOpts; 	[BUGGY] return buf . toString ( ) ; [CE] cannot find symbol buf  [METHOD]  getRequiredOptions [TYPE] List [PARAMETER] [CLASS] Options  [TYPE] Map longOpts optionGroups shortOpts [TYPE] List opts requiredOpts [TYPE] boolean false true  [CONTEXT]  public List getRequiredOptions ( ) { [BUGGY] return buf . toString ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^211^^^^^209^212^
[REPLACE]  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ; 	[BUGGY] opt =  Util . stripLeadingHyphens ( null ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOption [TYPE] Option [PARAMETER] String opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] String opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Option getOption ( String opt ) { [BUGGY] opt = Util . stripLeadingHyphens ( null )  ;  if ( shortOpts . containsKey ( opt ) ) { return ( Option ) shortOpts . get ( opt ) ; } return ( Option ) longOpts . get ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^222^^^^^220^230^
[REPLACE]  if  (  shortOpts  .  containsKey  (  opt  )  )  { 	[BUGGY] if ( shortOpts . get ( opt ) ) {[CE] incompatible types  [METHOD]  getOption [TYPE] Option [PARAMETER] String opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] String opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;  [BUGGY] if ( shortOpts . get ( opt ) ) { return ( Option ) shortOpts . get ( opt ) ; } return ( Option ) longOpts . get ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^224^225^^^^220^230^
[REMOVE]   	[BUGGY] if ( requiredOpts . contains ( key ) ) {   requiredOpts . remove ( requiredOpts . indexOf ( key ) ) ; }[CE] cannot find symbol key  [METHOD]  getOption [TYPE] Option [PARAMETER] String opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] String opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;  [BUGGY] if ( shortOpts . containsKey ( opt ) )  if ( requiredOpts . contains ( key ) ) { requiredOpts . remove ( requiredOpts . indexOf ( key ) )  ; }{ return ( Option ) shortOpts . get ( opt ) ; } return ( Option ) longOpts . get ( opt ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^224^^^^^220^230^
[REPLACE]  return  (  Option  )  shortOpts  .  get  (  opt  )  ; 	[BUGGY] return ( Option ) shortOpts . put ( this , null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOption [TYPE] Option [PARAMETER] String opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] String opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;  if ( shortOpts . containsKey ( opt ) ) { [BUGGY] return ( Option ) shortOpts . put ( this , null ) ; } return ( Option ) longOpts . get ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^226^^^^^220^230^
[REPLACE]  return  (  Option  )  shortOpts  .  get  (  opt  )  ; 	[BUGGY] return ( Option ) shortOpts . values ( opt ) ; [CE] method values in interface Map<K , V> cannot be applied to given types ;  [METHOD]  getOption [TYPE] Option [PARAMETER] String opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] String opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;  if ( shortOpts . containsKey ( opt ) ) { [BUGGY] return ( Option ) shortOpts . values ( opt )  ; } return ( Option ) longOpts . get ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^226^^^^^220^230^
[REPLACE]  return  (  Option  )  longOpts  .  get  (  opt  )  ; 	[BUGGY] return ( Option ) longOpts . put ( null , true )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOption [TYPE] Option [PARAMETER] String opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] String opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public Option getOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;  if ( shortOpts . containsKey ( opt ) ) { return ( Option ) shortOpts . get ( opt ) ; } [BUGGY] return ( Option ) longOpts . put ( null , true ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^229^^^^^220^230^
[REPLACE]  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ; 	[BUGGY] opt =  Util . stripLeadingHyphens ( null ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  hasOption [TYPE] boolean [PARAMETER] String opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] String opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public boolean hasOption ( String opt ) { [BUGGY] opt = Util . stripLeadingHyphens ( null )  ;  return shortOpts . containsKey ( opt ) || longOpts . containsKey ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^242^^^^^240^245^
[REPLACE]  return  shortOpts  .  containsKey  (  opt  )  ||  longOpts  .  containsKey  (  opt  )  ; 	[BUGGY] return shortOpts . get ( opt ) || longOpts . containsKey ( opt ) ; [CE] bad operand types for binary operator '||'  [METHOD]  hasOption [TYPE] boolean [PARAMETER] String opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] String opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public boolean hasOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ;  [BUGGY] return shortOpts . get ( opt ) || longOpts . containsKey ( opt )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^244^^^^^240^245^
[REPLACE]  return  (  OptionGroup  )  optionGroups  .  get  (  opt  .  getKey  (  )  )  ; 	[BUGGY] return ( OptionGroup ) optionGroups . get ( opt . getLongOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptionGroup [TYPE] OptionGroup [PARAMETER] Option opt [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] Option opt [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public OptionGroup getOptionGroup ( Option opt ) { [BUGGY] return ( OptionGroup ) optionGroups . get ( opt . getLongOpt ( ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^257^^^^^255^258^
[REPLACE]  StringBuffer  buf  =  new  StringBuffer  (  )  ; 	[BUGGY] String key = opt . getKey ( ) ; [CE] cannot find symbol opt  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] StringBuffer buf [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public String toString ( ) { [BUGGY] String key = opt . getKey ( )  ;  buf . append (   "[ Options: [ short   " ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append (   " ] [ long   " ) ; buf . append ( longOpts ) ; buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^267^^^^^265^276^
[REPLACE]  buf  .  append  (    "[  Options:  [  short    "  )  ; 	[BUGGY] Iterator options = group . getOptions ( ) . iterator ( ) ; [CE] cannot find symbol group  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] StringBuffer buf [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ;  [BUGGY] Iterator options = group . getOptions ( )  . iterator ( )  ; buf . append ( shortOpts . toString ( ) ) ; buf . append (   " ] [ long   " ) ; buf . append ( longOpts ) ; buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^269^^^^^265^276^
[REPLACE]  buf  .  append  (  shortOpts  .  toString  (  )  )  ; 	[BUGGY] buf . append ( shortOpts . Object ( ) ) ; [CE] cannot find symbol  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] StringBuffer buf [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ;  buf . append (   "[ Options: [ short   " ) ; [BUGGY] buf . append ( shortOpts . Object ( ) )  ; buf . append (   " ] [ long   " ) ; buf . append ( longOpts ) ; buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^270^^^^^265^276^
[REPLACE]  buf  .  append  (    "  ]  [  long    "  )  ; 	[BUGGY] buf . append (   " ]  " ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] StringBuffer buf [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ;  buf . append (   "[ Options: [ short   " ) ; buf . append ( shortOpts . toString ( ) ) ; [BUGGY] buf . append (   " ]  " )  ; buf . append ( longOpts ) ; buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^271^^^^^265^276^
[REPLACE]  buf  .  append  (  longOpts  )  ; 	[BUGGY] shortOpts . put ( key , opt ) ; [CE] cannot find symbol key  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] StringBuffer buf [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ;  buf . append (   "[ Options: [ short   " ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append (   " ] [ long   " ) ; [BUGGY] shortOpts . put ( key , opt )  ; buf . append (   " ]  " ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^272^^^^^265^276^
[REPLACE]  buf  .  append  (    "  ]  "  )  ; 	[BUGGY] buf . toString ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] StringBuffer buf [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ;  buf . append (   "[ Options: [ short   " ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append (   " ] [ long   " ) ; buf . append ( longOpts ) ; [BUGGY] buf . toString ( ) ;  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^273^^^^^265^276^
[ADD]  buf  .  append  (    "  ]  "  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] StringBuffer buf [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ;  buf . append (   "[ Options: [ short   " ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append (   " ] [ long   " ) ; buf . append ( longOpts ) ; [BUGGY]  return buf . toString ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^273^^^^^265^276^
[REPLACE]  return  buf  .  toString  (  )  ; 	[BUGGY] return buf . StringBuffer ( ) ; [CE] cannot find symbol  [METHOD]  toString [TYPE] String [PARAMETER] [CLASS] Options  [TYPE] List opts requiredOpts [TYPE] StringBuffer buf [TYPE] boolean false true [TYPE] Map longOpts optionGroups shortOpts  [CONTEXT]  public String toString ( ) { StringBuffer buf = new StringBuffer ( ) ;  buf . append (   "[ Options: [ short   " ) ; buf . append ( shortOpts . toString ( ) ) ; buf . append (   " ] [ long   " ) ; buf . append ( longOpts ) ; buf . append (   " ]  " ) ;  [BUGGY] return buf . StringBuffer ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Options.java^275^^^^^265^276^
[REPLACE]  return  parse  (  options,  arguments,  null,  false  )  ; 	[BUGGY] return parse ( options , arguments , false , false ) ; [CE] no suitable method found for parse(Options , String[] , boolean , boolean)  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions [TYPE] String[] arguments [TYPE] boolean false true  [CONTEXT]  public CommandLine parse ( Options options , String[] arguments ) throws ParseException { [BUGGY] return parse ( options , arguments , false , false )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^70^^^^^67^71^
[REPLACE]  return  parse  (  options,  arguments,  properties,  false  )  ; 	[BUGGY] return parse ( options , arguments , properties , true ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions [TYPE] String[] arguments [TYPE] boolean false true [TYPE] Properties properties  [CONTEXT]  public CommandLine parse ( Options options , String[] arguments , Properties properties ) throws ParseException { [BUGGY] return parse ( options , arguments , properties , true )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^89^^^^^85^90^
[REPLACE]  return  parse  (  options,  arguments,  null,  stopAtNonOption  )  ; 	[BUGGY] return parse ( options , arguments , false , stopAtNonOption ) ; [CE] no suitable method found for parse(Options , String[] , boolean , boolean)  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions [TYPE] String[] arguments [TYPE] boolean false stopAtNonOption true  [CONTEXT]  public CommandLine parse ( Options options , String[] arguments , boolean stopAtNonOption ) throws ParseException { [BUGGY] return parse ( options , arguments , false , stopAtNonOption )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^111^^^^^107^112^
[REPLACE]  this  .  options  =  options; 	[BUGGY] this . options =  null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  [BUGGY] this . options = null ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^134^^^^^132^220^
[REPLACE]  requiredOptions  =  options  .  getRequiredOptions  (  )  ; 	[BUGGY] requiredOptions =  opts . getRequiredOptions ( ) ; [CE] cannot find symbol opts  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; [BUGGY] requiredOptions = opts . getRequiredOptions ( )  ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^135^^^^^132^220^
[ADD]  requiredOptions  =  options  .  getRequiredOptions  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; [BUGGY] cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^135^^^^^132^220^
[REPLACE]  cmd  =  new  CommandLine  (  )  ; 	[BUGGY] cmd ; [CE] not a statement  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; [BUGGY] cmd ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^136^^^^^132^220^
[REPLACE]  boolean  eatTheRest  =  false; 	[BUGGY] boolean eatTheRest = true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  [BUGGY] boolean eatTheRest = true ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^138^^^^^132^220^
[REPLACE]  if  (  arguments  ==  null  )  { 	[BUGGY] if ( arguments ! = true ) {[CE] incomparable types: String[] and boolean  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  [BUGGY] if ( arguments ! = true ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^140^141^^^^132^220^
[REPLACE]  arguments  =  new  String[0]; 	[BUGGY] arguments = new String[4] ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( arguments = = null ) { [BUGGY] arguments = new String[4] ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^142^^^^^140^143^
[REPLACE]  arguments  =  new  String[0]; 	[BUGGY] arguments = new String[1] ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { [BUGGY] arguments = new String[1] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^142^^^^^132^220^
[REPLACE]  List  tokenList  =  Arrays  .  asList  (  flatten  (  this  .  options,  arguments,  stopAtNonOption  )  )  ; 	[BUGGY] List tokenList = Arrays . asList ( flatten ( this . options , arguments , true ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } [BUGGY] List tokenList = Arrays . asList ( flatten ( this . options , arguments , true ) )  ;   ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^145^146^147^^^132^220^
[REPLACE]  ListIterator  iterator  =  tokenList  .  listIterator  (  )  ; 	[BUGGY] ListIterator iterator = requiredOptions . listIterator ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  [BUGGY] ListIterator iterator = requiredOptions . listIterator ( )  ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^149^^^^^132^220^
[REPLACE]  while  (  iterator  .  hasNext  (  )  )  { 	[BUGGY] while ( iterator . next ( ) ) {[CE] incompatible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { [BUGGY] while ( iterator . next ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^203^204^^^^152^214^
[REPLACE]  if  (  !  "--  "  .  equals  (  str  )  )  { 	[BUGGY] if ( !  "--  " . equals ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   [BUGGY] if ( !  "--  " . equals ( t ) ) { cmd . addArg ( str ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^208^209^^^^203^212^
[REPLACE]  cmd  .  addArg  (  str  )  ; 	[BUGGY] cmd . addArg ( t ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { [BUGGY] cmd . addArg ( t )  ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^210^^^^^203^212^
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] String str =  ( String ) iterator . hasNext ( )  ; [CE] inconvertible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { [BUGGY] String str = ( String ) iterator . hasNext ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^205^^^^^203^212^
[REPLACE]  if  (    "--  "  .  equals  (  t  )  )  { 	[BUGGY] else if (   "-  " . equals ( t ) ) {[CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   [BUGGY] else if (   "-  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^157^158^^^^152^214^
[REPLACE]  else  if  (    "-  "  .  equals  (  t  )  )  { 	[BUGGY] else {[CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  [BUGGY] else { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^163^164^^^^152^214^
[REPLACE]  else  if  (  t  .  startsWith  (    "-  "  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  [BUGGY] else { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^176^177^^^^152^214^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  [BUGGY] if ( true ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^194^195^^^^176^198^
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  [BUGGY]   }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^194^195^196^197^^176^198^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^196^^^^^176^198^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { [BUGGY] } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^196^^^^^176^198^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( stopAtNonOption ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( stopAtNonOption ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^176^198^
[REPLACE]  processOption  (  t,  iterator  )  ; 	[BUGGY] processOption ( str , iterator ) ; [CE] cannot find symbol str  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { [BUGGY] processOption ( str , iterator )  ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^185^^^^^176^198^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] eatTheRest = false ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^^^^^176^198^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( stopAtNonOption && options . hasOption ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( stopAtNonOption && options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^152^214^
[ADD]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY]   else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^180^181^182^152^214^
[REPLACE]  processOption  (  t,  iterator  )  ; 	[BUGGY] String t =  ( String ) iterator . next ( ) ; [CE] variable t is already defined in method parse(Options , String[] , Properties , boolean)  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { [BUGGY] String t = ( String ) iterator . next ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^185^^^^^178^186^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] eatTheRest = false ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^^^^^178^186^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  [BUGGY] if ( true ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^194^195^^^^152^214^
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  [BUGGY]   }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^194^195^196^197^^152^214^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^196^^^^^194^197^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] eatTheRest = false ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^^^^^152^214^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^196^^^^^152^214^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { [BUGGY] } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^196^^^^^152^214^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption )[CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if (   "-  " . equals ( t ) ) { [BUGGY] if ( stopAtNonOption )  eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^165^166^^^^163^198^
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if (   "-  " . equals ( t ) ) { [BUGGY]   else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^165^166^167^168^^163^198^
[REPLACE]  cmd  .  addArg  (  t  )  ; 	[BUGGY] cmd . hasOption ( str ) ; [CE] cannot find symbol str  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption ) { eatTheRest = true ; } else { [BUGGY] cmd . hasOption ( str )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^171^^^^^165^172^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; } else { cmd . addArg ( t ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^167^^^^^165^172^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^167^^^^^163^198^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { [BUGGY] } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^167^^^^^163^198^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption )[CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { [BUGGY] if ( stopAtNonOption )  eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^165^166^^^^152^214^
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { [BUGGY]   else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^165^166^167^168^^152^214^
[REPLACE]  cmd  .  addArg  (  t  )  ; 	[BUGGY] cmd . addArg ( str ) ; [CE] cannot find symbol str  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption ) { eatTheRest = true ; } else { [BUGGY] cmd . addArg ( str )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^171^^^^^165^172^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption ) { [BUGGY] } else { cmd . addArg ( t ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^167^^^^^165^172^
[REPLACE]  else  if  (  t  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( t . startsWith (   "-  " ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  [BUGGY] if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^176^177^^^^152^214^
[ADD]  else  if  (  t  .  startsWith  (    "-  "  )  )  {  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true; 	[BUGGY] [CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  [BUGGY]   cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^176^177^178^179^180^152^214^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^^^^^176^198^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( true ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^152^214^
[REMOVE]   	[BUGGY] String t =  ( String ) iterator . next ( ) ; [CE] variable t is already defined in method parse(Options , String[] , Properties , boolean)  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { [BUGGY] processOption ( t , iterator ) ;   	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^185^^^^^178^186^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^^^^^178^186^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^167^^^^^152^214^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^^^^^152^214^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if (   "--  " . equals ( t ) ) { [BUGGY] eatTheRest = false ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^159^^^^^157^198^
[REPLACE]  else  if  (    "-  "  .  equals  (  t  )  )  { 	[BUGGY] if (   "-  " . equals ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  [BUGGY] if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^163^164^^^^152^214^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( stopAtNonOption && options . hasOption ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( stopAtNonOption && options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^176^198^
[REPLACE]  processOption  (  t,  iterator  )  ; 	[BUGGY] String t =  ( String ) iterator . next ( ) ; [CE] variable t is already defined in method parse(Options , String[] , Properties , boolean)  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { [BUGGY] String t = ( String ) iterator . next ( )  ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^185^^^^^176^198^
[ADD]  processOption  (  t,  iterator  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { [BUGGY] } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^185^^^^^176^198^
[ADD]  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ; 	[BUGGY] cmd . addArg ( t ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] cmd . addArg ( t )  ;  } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^181^^^^176^198^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if (false ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( false ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^152^214^
[REPLACE]  processOption  (  t,  iterator  )  ; 	[BUGGY] processOption ( str , iterator ) ; [CE] cannot find symbol str  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { [BUGGY] processOption ( str , iterator )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^185^^^^^178^186^
[ADD]  processOption  (  t,  iterator  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^185^^^^^178^186^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if (   "-  " . equals ( t ) ) { [BUGGY] if ( true ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^165^166^^^^163^198^
[ADD]  cmd  .  addArg  (  t  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption ) { eatTheRest = true ; } else { [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^171^^^^^165^172^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption )[CE] invalid method declaration ; return type required  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  [BUGGY] if ( stopAtNonOption )  eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^194^195^^^^176^198^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( options . hasOption ( str ) ) {[CE] cannot find symbol str  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( options . hasOption ( str ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^176^198^
[ADD]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { [BUGGY]   else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^180^181^182^176^198^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( options . hasOption ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^152^214^
[REPLACE]  if  (  eatTheRest  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  [BUGGY] if ( true ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^201^202^^^^152^214^
[REPLACE]  while  (  iterator  .  hasNext  (  )  )  { 	[BUGGY] while ( iterator . next ( ) ) {[CE] incompatible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( eatTheRest ) { [BUGGY] while ( iterator . next ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^203^204^^^^201^213^
[REPLACE]  if  (  !  "--  "  .  equals  (  str  )  )  { 	[BUGGY] if ( !  "--  " . equals ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   [BUGGY] if ( !  "--  " . equals ( t ) ) { cmd . addArg ( str ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^208^209^^^^201^213^
[REPLACE]  cmd  .  addArg  (  str  )  ; 	[BUGGY] cmd . addArg ( t ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { [BUGGY] cmd . addArg ( t )  ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^210^^^^^201^213^
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] String str =  ( String ) iterator . hasNext ( ) ; [CE] inconvertible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { [BUGGY] String str = ( String ) iterator . hasNext ( )  ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^205^^^^^201^213^
[ADD]  String  str  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] [CE] cannot find symbol str  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { [BUGGY]   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^205^^^^^201^213^
[ADD]  if  (  !  "--  "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   [BUGGY]   } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^208^209^210^211^^201^213^
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] String str =  ( String ) iterator . hasNext ( )  ; [CE] inconvertible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { [BUGGY] String str = ( String ) iterator . hasNext ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^205^^^^^201^213^
[REPLACE]  if  (  !  "--  "  .  equals  (  str  )  )  { 	[BUGGY] if (   "--  " . equals ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   [BUGGY] if (   "--  " . equals ( t ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^208^209^^^^152^214^
[REPLACE]  cmd  .  addArg  (  str  )  ; 	[BUGGY] cmd . addArg ( t ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( !  "--  " . equals ( str ) ) { [BUGGY] cmd . addArg ( t )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^210^^^^^208^211^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { [BUGGY] eatTheRest = false ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^159^^^^^152^214^
[REPLACE]  String  t  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] String t =  ( String ) iterator . hasNext ( )  ; [CE] inconvertible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { [BUGGY] String t = ( String ) iterator . hasNext ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^154^^^^^152^214^
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] String str =  ( String ) iterator . hasNext ( ) ; [CE] inconvertible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { [BUGGY] String str = ( String ) iterator . hasNext ( )  ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^205^^^^^152^214^
[ADD]  String  str  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] [CE] cannot find symbol str  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { [BUGGY]   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^205^^^^^152^214^
[REPLACE]  while  (  iterator  .  hasNext  (  )  )  { 	[BUGGY] while ( iterator . next ( )  ) {[CE] incompatible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { [BUGGY] while ( iterator . next ( )  ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^203^204^^^^132^220^
[REPLACE]  if  (  !  "--  "  .  equals  (  str  )  )  { 	[BUGGY] if ( !  "--  " . equalsIgnoreCase ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   [BUGGY] if ( !  "--  " . equalsIgnoreCase ( t ) ) { cmd . addArg ( str ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^208^209^^^^203^212^
[REPLACE]  cmd  .  addArg  (  str  )  ; 	[BUGGY] cmd . addOption ( null )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { [BUGGY] cmd . addOption ( null ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^210^^^^^203^212^
[ADD]  cmd  .  addArg  (  str  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { [BUGGY] } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^210^^^^^203^212^
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] String str =  ( String ) iterator . hasNext ( ) ; [CE] inconvertible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  while ( iterator . hasNext ( ) ) { [BUGGY] String str = ( String ) iterator . hasNext ( )  ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^205^^^^^203^212^
[REPLACE]  if  (    "--  "  .  equals  (  t  )  )  { 	[BUGGY] else if (   "-  " . equals ( t ) ) {[CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   [BUGGY] else if (   "-  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^157^158^^^^132^220^
[ADD]  if  (    "--  "  .  equals  (  t  )  )  {  eatTheRest  =  true;  } 	[BUGGY] [CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   [BUGGY]    else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^157^158^159^160^^132^220^
[REPLACE]  else  if  (    "-  "  .  equals  (  t  )  )  { 	[BUGGY] else {[CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  [BUGGY] else { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^163^164^^^^132^220^
[REPLACE]  else  if  (  t  .  startsWith  (    "-  "  )  )  { 	[BUGGY] else {[CE] 'else' without 'if'  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  [BUGGY] else { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^176^177^^^^132^220^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( options . hasOption ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^176^198^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( true ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^132^220^
[ADD]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  {  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ;  } 	[BUGGY] [CE] 'else' without 'if'  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY]   else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^180^181^182^132^220^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  [BUGGY] if ( true ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^194^195^^^^132^220^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] eatTheRest = false ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^^^^^132^220^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^196^^^^^132^220^
[REPLACE]  cmd  .  addArg  (  t  )  ; 	[BUGGY] cmd . addOption ( false )  ; [CE] method addOption in class CommandLine cannot be applied to given types ;  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption ) { eatTheRest = true ; } else { [BUGGY] cmd . addOption ( false ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^171^^^^^165^172^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( stopAtNonOption )[CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { [BUGGY] if ( stopAtNonOption )  eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^165^166^^^^132^220^
[REPLACE]  cmd  .  addArg  (  t  )  ; 	[BUGGY] cmd . hasOption ( t ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption ) { eatTheRest = true ; } else { [BUGGY] cmd . hasOption ( t )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^171^^^^^165^172^
[REPLACE]  else  if  (  t  .  startsWith  (    "-  "  )  )  { 	[BUGGY] else if ( t . startsWith (   "-  " ) )[CE]  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  [BUGGY] else if ( t . startsWith (   "-  " ) )  if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^176^177^^^^132^220^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( stopAtNonOption && options . hasOption ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( stopAtNonOption && options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^132^220^
[ADD]  if  (  stopAtNonOption  )  {  eatTheRest  =  true;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  [BUGGY]   }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^194^195^196^197^^132^220^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { [BUGGY] eatTheRest = false ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^167^^^^^132^220^
[ADD]  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY]  } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^181^^^^132^220^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if (   "--  " . equals ( t ) ) { [BUGGY] }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^159^^^^^157^198^
[REPLACE]  else  if  (    "-  "  .  equals  (  t  )  )  { 	[BUGGY] if (   "--  " . equals ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  [BUGGY] if (   "--  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^163^164^^^^132^220^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( options . getOption ( t ) ) {[CE] incompatible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( options . getOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^176^198^
[ADD]  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY]  } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^181^^^^176^198^
[REPLACE]  if  (  stopAtNonOption  &&  !options  .  hasOption  (  t  )  )  { 	[BUGGY] if ( options . hasOption ( t ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { [BUGGY] if ( options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^178^179^^^^132^220^
[ADD]  eatTheRest  =  true;  cmd  .  addArg  (  t  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY]  } else { processOption ( t , iterator ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^181^^^^178^186^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { [BUGGY] cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^180^^^^^132^220^
[REPLACE]  if  (  stopAtNonOption  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { [BUGGY] if ( true ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^165^166^^^^132^220^
[REPLACE]  else  if  (  t  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( t . startsWith (   "-  " ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  [BUGGY] if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^176^177^^^^132^220^
[REPLACE]  if  (  eatTheRest  )  { 	[BUGGY] if ( true ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  [BUGGY] if ( true ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^201^202^^^^132^220^
[ADD]  cmd  .  addArg  (  str  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { [BUGGY] } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^210^^^^^201^213^
[REPLACE]  if  (  !  "--  "  .  equals  (  str  )  )  { 	[BUGGY] if ( !  "--  " . equalsIgnoreCase ( str ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   [BUGGY] if ( !  "--  " . equalsIgnoreCase ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^208^209^^^^132^220^
[ADD]  if  (  !  "--  "  .  equals  (  str  )  )  {  cmd  .  addArg  (  str  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   [BUGGY]   } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^208^209^210^211^^132^220^
[REPLACE]  eatTheRest  =  true; 	[BUGGY] eatTheRest = false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { [BUGGY] eatTheRest = false ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^159^^^^^132^220^
[ADD]  eatTheRest  =  true; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { [BUGGY] } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^167^^^^^132^220^
[REPLACE]  String  t  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] String t =  ( String ) iterator . hasNext ( ) ; [CE] inconvertible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { [BUGGY] String t = ( String ) iterator . hasNext ( )  ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^154^^^^^132^220^
[ADD]  String  t  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] [CE] cannot find symbol t  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { [BUGGY]   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^154^^^^^132^220^
[REPLACE]  String  str  =  (  String  )  iterator  .  next  (  )  ; 	[BUGGY] String str =  ( String ) iterator . hasNext ( ) ; [CE] inconvertible types  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { [BUGGY] String str = ( String ) iterator . hasNext ( )  ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^205^^^^^132^220^
[REPLACE]  processProperties  (  properties  )  ; 	[BUGGY] cmd . addOption ( opt ) ; [CE] cannot find symbol opt  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } [BUGGY] cmd . addOption ( opt )  ; checkRequiredOptions ( ) ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^216^^^^^132^220^
[REPLACE]  checkRequiredOptions  (  )  ; 	[BUGGY] cmd . addOption ( opt ) ; [CE] cannot find symbol opt  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; [BUGGY] cmd . addOption ( opt )  ;  return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^217^^^^^132^220^
[REPLACE]  return  cmd; 	[BUGGY] return ; [CE] missing return value  [METHOD]  parse [TYPE] CommandLine [PARAMETER] Options options String[] arguments Properties properties boolean stopAtNonOption [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean eatTheRest false stopAtNonOption true [TYPE] List requiredOptions tokenList [TYPE] String[] arguments [TYPE] String str t [TYPE] Properties properties [TYPE] ListIterator iterator  [CONTEXT]  {  this . options = options ; requiredOptions = options . getRequiredOptions ( ) ; cmd = new CommandLine ( ) ;  boolean eatTheRest = false ;  if ( arguments = = null ) { arguments = new String[0] ; } List tokenList = Arrays . asList ( flatten ( this . options , arguments , stopAtNonOption ) ) ;  ListIterator iterator = tokenList . listIterator ( ) ;   while ( iterator . hasNext ( ) ) { String t =  ( String ) iterator . next ( ) ;   if (   "--  " . equals ( t ) ) { eatTheRest = true ; }  else if (   "-  " . equals ( t ) ) { if ( stopAtNonOption ) { eatTheRest = true ; } else { cmd . addArg ( t ) ; } }  else if ( t . startsWith (   "-  " ) ) { if ( stopAtNonOption && !options . hasOption ( t ) ) { eatTheRest = true ; cmd . addArg ( t ) ; } else { processOption ( t , iterator ) ; } }  else { cmd . addArg ( t ) ;  if ( stopAtNonOption ) { eatTheRest = true ; } }  if ( eatTheRest ) { while ( iterator . hasNext ( ) ) { String str =  ( String ) iterator . next ( ) ;   if ( !  "--  " . equals ( str ) ) { cmd . addArg ( str ) ; } } } } processProperties ( properties ) ; checkRequiredOptions ( ) ;  [BUGGY] return ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^219^^^^^132^220^
[REPLACE]  if  (  properties  ==  null  )  { 	[BUGGY] if ( properties ! = true ) {[CE] incomparable types: Properties and boolean  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { [BUGGY] if ( properties ! = true ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^230^231^^^^229^273^
[REPLACE]  return; 	[BUGGY] return cmd ; [CE] cannot return a value from method whose result type is void  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( properties = = null ) { [BUGGY] return cmd ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^232^^^^^230^233^
[REPLACE]  return; 	[BUGGY] return cmd ; [CE] cannot return a value from method whose result type is void  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { [BUGGY] return cmd ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^232^^^^^229^273^
[REPLACE]  if  (  !cmd  .  hasOption  (  option  )  )  { 	[BUGGY] if ( cmd . hasOption ( option ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  [BUGGY] if ( cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^239^240^^^^229^273^
[REPLACE]  if  (  opt  .  hasArg  (  )  )  { 	[BUGGY] if (   "--  " . equals ( t ) ) {[CE] cannot find symbol t  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  [BUGGY] if (   "--  " . equals ( t ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^246^247^^^^239^271^
[REPLACE]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] else {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY] else {    break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^239^271^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  { 	[BUGGY] if (  ( opt . getValues ( ) . length - 4 = = 0 ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { [BUGGY] if (  ( opt . getValues ( )  . length - 4 = = 0 ) ) {  try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^^^246^268^
[ADD]  try  {  opt  .  addValue  (  value  )  ;  } 	[BUGGY] opt . addValue ( value ) ; [CE] 'catch' without 'try'  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { [BUGGY] opt . addValue ( value )  ;   catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^251^252^253^254^^246^268^
[REPLACE]  opt  .  addValue  (  value  )  ; 	[BUGGY] opt . getValues ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { [BUGGY] opt . getValues ( ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^246^268^
[REPLACE]  opt  .  addValue  (  value  )  ; 	[BUGGY] || ( opt . getValues ( ) . length = = 0 ) ) {[CE] illegal start of expression  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { [BUGGY] || ( opt . getValues ( )  . length = = 0 ) ) { } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^246^268^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  { 	[BUGGY] if ( ( opt . getValues ( )  = = false ) || ( opt . getValues ( ) . length - 5 = = 0 ) ) {[CE] incomparable types: String[] and boolean  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { [BUGGY] if ( ( opt . getValues ( ) = = false ) || ( opt . getValues ( )  . length - 5 = = 0 ) ) {  try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^^^239^271^
[ADD]  try  {  opt  .  addValue  (  value  )  ;  } 	[BUGGY] opt . addValue ( value ) ; [CE] 'catch' without 'try'  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { [BUGGY] opt . addValue ( value )  ;   catch ( RuntimeException exp ) {  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^251^252^253^254^^248^259^
[REPLACE]  opt  .  addValue  (  value  )  ; 	[BUGGY] || ( opt . getValues ( ) . length = = 0 ) ) {[CE] illegal start of expression  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { [BUGGY] || ( opt . getValues ( )  . length = = 0 ) ) { } catch ( RuntimeException exp ) {  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^248^259^
[ADD]  opt  .  addValue  (  value  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { [BUGGY] } catch ( RuntimeException exp ) {  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^248^259^
[ADD]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY]     break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^239^271^
[ADD]  try  {  opt  .  addValue  (  value  )  ;  } 	[BUGGY] opt . addValue ( value ) ; [CE] 'catch' without 'try'  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { [BUGGY] opt . addValue ( value )  ;   catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^251^252^253^254^^239^271^
[REPLACE]  opt  .  addValue  (  value  )  ; 	[BUGGY] opt . getValues ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  try { [BUGGY] opt . getValues ( ) ; } catch ( RuntimeException exp ) {  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^251^258^
[REPLACE]  Option  opt  =  options  .  getOption  (  option  )  ; 	[BUGGY] Option opt = options . hasOption ( option ) ; [CE] incompatible types  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { [BUGGY] Option opt = options . hasOption ( option )  ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^241^^^^^239^271^
[REPLACE]  String  value  =  properties  .  getProperty  (  option  )  ; 	[BUGGY] String t =  ( String ) iterator . next ( ) ; [CE] cannot find symbol iterator  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   [BUGGY] String t = ( String ) iterator . next ( )  ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^244^^^^^239^271^
[ADD]  catch  (  RuntimeException  exp  )  { 	[BUGGY] [CE]  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } [BUGGY]  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^255^256^257^^^239^271^
[REPLACE]  if  (  opt  .  hasArg  (  )  )  { 	[BUGGY] if (   "--  " . equals ( t ) ) {[CE] cannot find symbol t  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  [BUGGY] if (   "--  " . equals ( t ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^246^247^^^^229^273^
[REPLACE]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] else if (   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {[CE] illegal start of expression  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY] else if (   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {    break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^229^273^
[ADD]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY]     break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^229^273^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  { 	[BUGGY] if ( ( opt . getValues ( )  = = null ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { [BUGGY] if ( ( opt . getValues ( ) = = null )  ) {  try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^^^246^268^
[ADD]  catch  (  RuntimeException  exp  )  { 	[BUGGY] [CE]  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } [BUGGY]  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^255^256^257^^^246^268^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  { 	[BUGGY] if ( ( opt . getValues ( )  = = this ) || ( opt . getValues ( ) . length * 0 . 5  = = 0 ) ) {[CE] incomparable types: String[] and Parser  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { [BUGGY] if ( ( opt . getValues ( ) = = this ) || ( opt . getValues ( )  . length *0 . 5 = = 0 ) ) {  try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^^^229^273^
[REPLACE]  opt  .  addValue  (  value  )  ; 	[BUGGY] opt . getValues ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { [BUGGY] opt . getValues ( ) ; } catch ( RuntimeException exp ) {  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^248^259^
[REMOVE]   	[BUGGY] || ( opt . getValues ( ) . length = = 0 ) ) {[CE] illegal start of expression  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { [BUGGY] opt . addValue ( value ) ;  || ( opt . getValues ( )  . length = = 0 ) ) {} catch ( RuntimeException exp ) {  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^248^259^
[ADD]  catch  (  RuntimeException  exp  )  { 	[BUGGY] [CE]  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } [BUGGY]  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^255^256^257^^^248^259^
[REPLACE]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] if ( (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY] if ( (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {    break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^229^273^
[ADD]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  {  String  option  =  e  .  nextElement  (  )    .  toString  (  )  ;  if  (  !cmd  .  hasOption  (  option  )  ) 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } [BUGGY]   { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^235^236^237^^239^229^273^
[REPLACE]  if  (  !cmd  .  hasOption  (  option  )  )  { 	[BUGGY] if ( cmd . hasOption ( option ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  [BUGGY] if ( cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^239^240^^^^235^272^
[REPLACE]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] if ( (   "yes  " . equals ( null ) ||   "true  "[CE]  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY] if ( (   "yes  " . equals ( null ) ||   "true  "    break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^239^271^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  { 	[BUGGY] if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length ( )  = = 0 ) ) {[CE] cannot find symbol  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { [BUGGY] if ( ( opt . getValues ( ) = = null ) || ( opt . getValues ( )  . length ( ) = = 0 ) ) {  try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^^^246^268^
[ADD]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  {  try 	[BUGGY] [CE]  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { [BUGGY]   { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^251^^246^268^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  { 	[BUGGY] if (  ( opt . getValues ( ) . length - 5 = = 0 ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { [BUGGY] if (  ( opt . getValues ( )  . length - 5 = = 0 ) ) {  try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^^^239^271^
[REPLACE]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] if ( (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY] if ( (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {    break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^239^271^
[ADD]  opt  .  addValue  (  value  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  try { [BUGGY] } catch ( RuntimeException exp ) {  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^251^258^
[REPLACE]  String  value  =  properties  .  getProperty  (  option  )  ; 	[BUGGY] String value = properties . propertyNames ( )  ; [CE] incompatible types  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   [BUGGY] String value = properties . propertyNames ( ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^244^^^^^239^271^
[ADD]  String  value  =  properties  .  getProperty  (  option  )  ; 	[BUGGY] [CE] cannot find symbol value  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   [BUGGY]  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^244^^^^^239^271^
[REPLACE]  if  (  opt  .  hasArg  (  )  )  { 	[BUGGY] if (   "--  " . equals ( t ) ) {[CE] cannot find symbol t  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  [BUGGY] if (   "--  " . equals ( t ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^246^247^^^^235^272^
[REPLACE]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] if ( (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY] if ( (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {    break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^235^272^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  { 	[BUGGY] if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length / 0 . 5  = = 0 ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  if ( opt . hasArg ( ) ) { [BUGGY] if ( ( opt . getValues ( ) = = null ) || ( opt . getValues ( )  . length /0 . 5 = = 0 ) ) {  try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^^^246^268^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  ||  (  opt  .  getValues  (  )    .  length  ==  0  )  )  { 	[BUGGY] if ( ( opt . getValues ( )  = = this ) || ( opt . getValues ( ) . length * 0 . 5  = = 0 ) ) {[CE] incomparable types: String[] and Parser  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { [BUGGY] if ( ( opt . getValues ( ) = = this ) || ( opt . getValues ( )  . length *0 . 5 = = 0 ) ) {  try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^248^249^250^^^235^272^
[REPLACE]  else  if  (  !  (    "yes  "  .  equalsIgnoreCase  (  value  )  ||    "true  "  .  equalsIgnoreCase  (  value  )  ||    "1  "  .  equalsIgnoreCase  (  value  )  )  )  { 	[BUGGY] if ( (   "yes  " . equalsIgnoreCase ( value ) ) {[CE]  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } [BUGGY] if ( (   "yes  " . equalsIgnoreCase ( value )  ) {    break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^261^262^263^264^^235^272^
[ADD]  try  {  opt  .  addValue  (  value  )  ;  } 	[BUGGY] opt . addValue ( value ) ; [CE] 'catch' without 'try'  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { [BUGGY] opt . addValue ( value )  ;   catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^251^252^253^254^^235^272^
[REPLACE]  opt  .  addValue  (  value  )  ; 	[BUGGY] || ( opt . getValues ( ) . length = = 0 ) ) {[CE] illegal start of expression  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  try { [BUGGY] || ( opt . getValues ( )  . length = = 0 ) ) { } catch ( RuntimeException exp ) {  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^253^^^^^251^258^
[REPLACE]  String  option  =  e  .  nextElement  (  )    .  toString  (  )  ; 	[BUGGY] String option = e . nextElement ( )  . Object ( )  ; [CE] cannot find symbol  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { [BUGGY] String option = e . nextElement ( ) . Object ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^237^^^^^235^272^
[REPLACE]  Option  opt  =  options  .  getOption  (  option  )  ; 	[BUGGY] Option opt = options . hasOption ( option ) ; [CE] incompatible types  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { [BUGGY] Option opt = options . hasOption ( option )  ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^241^^^^^235^272^
[REPLACE]  String  value  =  properties  .  getProperty  (  option  )  ; 	[BUGGY] String t =  ( String ) iterator . next ( ) ; [CE] cannot find symbol iterator  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   [BUGGY] String t = ( String ) iterator . next ( )  ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^244^^^^^235^272^
[ADD]  String  value  =  properties  .  getProperty  (  option  )  ; 	[BUGGY] [CE] cannot find symbol value  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   [BUGGY]  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^244^^^^^235^272^
[ADD]  catch  (  RuntimeException  exp  )  { 	[BUGGY] [CE]  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } [BUGGY]  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^255^256^257^^^235^272^
[ADD]  try  {  opt  .  addValue  (  value  )  ;  } 	[BUGGY] opt . addValue ( value ) ; [CE] 'catch' without 'try'  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { [BUGGY] opt . addValue ( value )  ;   catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^251^252^253^254^^229^273^
[REPLACE]  for  (  Enumeration  e  =  properties  .  propertyNames  (  )  ;  e  .  hasMoreElements  (  )  ;  )  { 	[BUGGY] for ( Enumeration e = properties . getProperty ( value )  ; e . hasMoreElements ( ) ; ) {[CE] cannot find symbol value  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } [BUGGY] for ( Enumeration e = properties . getProperty ( value ) ; e . hasMoreElements ( )  ;  ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^235^236^^^^229^273^
[REPLACE]  String  option  =  e  .  nextElement  (  )    .  toString  (  )  ; 	[BUGGY] String option = e . nextElement ( )  . Object ( )  ; [CE] cannot find symbol  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { [BUGGY] String option = e . nextElement ( ) . Object ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^237^^^^^229^273^
[REPLACE]  Option  opt  =  options  .  getOption  (  option  )  ; 	[BUGGY] Option opt = options . hasOption ( option ) ; [CE] incompatible types  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { [BUGGY] Option opt = options . hasOption ( option )  ;   String value = properties . getProperty ( option ) ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^241^^^^^229^273^
[REPLACE]  String  value  =  properties  .  getProperty  (  option  )  ; 	[BUGGY] String t =  ( String ) iterator . next ( ) ; [CE] cannot find symbol iterator  [METHOD]  processProperties [TYPE] void [PARAMETER] Properties properties [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] Enumeration e [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String option value [TYPE] Properties properties  [CONTEXT]  { if ( properties = = null ) { return ; } for ( Enumeration e = properties . propertyNames ( ) ; e . hasMoreElements ( ) ; ) { String option = e . nextElement ( ) . toString ( ) ;  if ( !cmd . hasOption ( option ) ) { Option opt = options . getOption ( option ) ;   [BUGGY] String t = ( String ) iterator . next ( )  ;  if ( opt . hasArg ( ) ) { if ( ( opt . getValues ( )  = = null ) || ( opt . getValues ( ) . length = = 0 ) ) { try { opt . addValue ( value ) ; } catch ( RuntimeException exp ) {  } } } else if ( ! (   "yes  " . equalsIgnoreCase ( value ) ||   "true  " . equalsIgnoreCase ( value ) ||   "1  " . equalsIgnoreCase ( value ) ) ) {   break ; } cmd . addOption ( opt ) ; } } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^244^^^^^229^273^
[REPLACE]  while  (  iter  .  hasNext  (  )  )  { 	[BUGGY] while ( iter . next ( )  ) {[CE] incompatible types  [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   [BUGGY] while ( iter . next ( )  ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^293^294^^^^282^300^
[REPLACE]  buff  .  append  (  iter  .  next  (  )  )  ; 	[BUGGY] buff . toString ( )  ; [FE] AssertionFailedError [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { [BUGGY] buff . toString ( ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^295^^^^^282^300^
[REPLACE]  buff  .  append  (  iter  .  next  (  )  )  ; 	[BUGGY] buff . append ( iter . hasNext ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { [BUGGY] buff . append ( iter . hasNext ( ) )  ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^295^^^^^282^300^
[ADD]  buff  .  append  (  iter  .  next  (  )  )  ; 	[BUGGY] [FE] AssertionFailedError [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { [BUGGY] } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^295^^^^^282^300^
[REPLACE]  if  (  requiredOptions  .  size  (  )  >  0  )  { 	[BUGGY] if ( requiredOptions . size ( ) - 3 > 0 ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   [BUGGY] if ( requiredOptions . size ( ) - 3 > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^287^288^^^^282^300^
[ADD]  while  (  iter  .  hasNext  (  )  )  {  buff  .  append  (  iter  .  next  (  )  )  ; 	[BUGGY] [CE] class , interface , or enum expected  [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   [BUGGY]  } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^293^294^295^^^282^300^
[REPLACE]  buff  .  append  (  iter  .  next  (  )  )  ; 	[BUGGY] buff . append ( iter . hasNext ( )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { [BUGGY] buff . append ( iter . hasNext ( )  )  ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^295^^^^^282^300^
[REMOVE]   	[BUGGY] String t =  ( String ) iterator . next ( ) ; [CE] cannot find symbol iterator  [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { [BUGGY] buff . append ( iter . next ( ) ) ;  String t = ( String ) iterator . next ( )  ; } throw new MissingOptionException ( buff . toString ( ) ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^295^^^^^282^300^
[REPLACE]  Iterator  iter  =  requiredOptions  .  iterator  (  )  ; 	[BUGGY] Iterator iter = requiredOptions . listIterator ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { [BUGGY] Iterator iter = requiredOptions . listIterator ( )  ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^289^^^^^282^300^
[ADD]  Iterator  iter  =  requiredOptions  .  iterator  (  )  ;  StringBuffer  buff  =  new  StringBuffer  (  )  ; 	[BUGGY] [CE] cannot find symbol iter  [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { [BUGGY]   while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^289^290^^^^282^300^
[REPLACE]  StringBuffer  buff  =  new  StringBuffer  (  )  ; 	[BUGGY] String t =  ( String ) iterator . next ( ) ; [CE] cannot find symbol iterator  [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; [BUGGY] String t = ( String ) iterator . next ( )  ;   while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^290^^^^^282^300^
[ADD]  StringBuffer  buff  =  new  StringBuffer  (  )  ; 	[BUGGY] [CE] cannot find symbol buff  [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; [BUGGY]   while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } throw new MissingOptionException ( buff . toString ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^290^^^^^282^300^
[REPLACE]  throw  new  MissingOptionException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } [BUGGY] return ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^298^^^^^282^300^
[ADD]  throw  new  MissingOptionException  (  "    ")  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  checkRequiredOptions [TYPE] void [PARAMETER] [CLASS] Parser  [TYPE] Iterator iter [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] List requiredOptions tokenList [TYPE] StringBuffer buff [TYPE] boolean false true  [CONTEXT]  private void checkRequiredOptions ( ) throws MissingOptionException {   if ( requiredOptions . size ( ) > 0 ) { Iterator iter = requiredOptions . iterator ( ) ; StringBuffer buff = new StringBuffer ( ) ;   while ( iter . hasNext ( ) ) { buff . append ( iter . next ( ) ) ; } [BUGGY] } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^298^^^^^282^300^
[REPLACE]  if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( str . startsWith (   "-  " ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   [BUGGY] if ( str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^323^324^^^^318^339^
[ADD]  if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (    "-  "  )  )  {  iter  .  previous  (  )  ;  break;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   [BUGGY]     try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^323^324^325^326^327^318^339^
[REPLACE]  iter  .  previous  (  )  ; 	[BUGGY] iter . next ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { [BUGGY] iter . next ( )  ; break ; }  try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^325^^^^^318^339^
[ADD]  try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  } 	[BUGGY] opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; [CE] 'catch' without 'try'  [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  [BUGGY] opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  )  ;   catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^330^331^332^333^^318^339^
[REPLACE]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ; 	[BUGGY] opt . getValues ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  try { [BUGGY] opt . getValues ( ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^332^^^^^318^339^
[REPLACE]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ; 	[BUGGY] opt . addValue (  str   ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  try { [BUGGY] opt . addValue ( str )  ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^332^^^^^318^339^
[REPLACE]  String  str  =  (  String  )  iter  .  next  (  )  ; 	[BUGGY] String str =  ( String ) iter . hasNext ( ) ; [CE] inconvertible types  [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  while ( iter . hasNext ( ) ) { [BUGGY] String str = ( String ) iter . hasNext ( )  ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^320^^^^^318^339^
[REPLACE]  if  (  options  .  hasOption  (  str  )  &&  str  .  startsWith  (    "-  "  )  )  { 	[BUGGY] if ( options . hasOption ( str ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  {  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   [BUGGY] if ( options . hasOption ( str ) ) { iter . previous ( ) ; break ; }  try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( )  = = null ) && !opt . hasOptionalArg ( ) ) { throw new MissingArgumentException (   "Missing argument for option:  " + opt . getKey ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^323^324^^^^316^346^
[REPLACE]  iter  .  previous  (  )  ; 	[BUGGY] iter . next ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { [BUGGY] iter . next ( )  ; break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^325^^^^^323^327^
[ADD]  iter  .  previous  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { [BUGGY] break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^325^^^^^323^327^
[ADD]  try  {  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ;  } 	[BUGGY] opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; [CE] 'catch' without 'try'  [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  {  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  [BUGGY] opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  )  ;   catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( )  = = null ) && !opt . hasOptionalArg ( ) ) { throw new MissingArgumentException (   "Missing argument for option:  " + opt . getKey ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^330^331^332^333^^316^346^
[REPLACE]  opt  .  addValue  (  Util  .  stripLeadingAndTrailingQuotes  (  str  )    )  ; 	[BUGGY] opt . addValue (  str   ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  try { [BUGGY] opt . addValue ( str )  ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^332^^^^^330^338^
[REPLACE]  String  str  =  (  String  )  iter  .  next  (  )  ; 	[BUGGY] String str =  ( String ) iter . hasNext ( ) ; [CE] inconvertible types  [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  {  while ( iter . hasNext ( ) ) { [BUGGY] String str = ( String ) iter . hasNext ( )  ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( )  = = null ) && !opt . hasOptionalArg ( ) ) { throw new MissingArgumentException (   "Missing argument for option:  " + opt . getKey ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^320^^^^^316^346^
[REPLACE]  if  (  (  opt  .  getValues  (  )  ==  null  )  &&  !opt  .  hasOptionalArg  (  )  )  { 	[BUGGY] if ( ( opt . getValues ( ) ! = false ) ) {[CE] incomparable types: String[] and boolean  [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  {  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } [BUGGY] if ( ( opt . getValues ( ) ! = false ) ) { throw new MissingArgumentException (   "Missing argument for option:  " + opt . getKey ( ) ) ; } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^341^342^^^^316^346^
[REPLACE]  throw  new  MissingArgumentException  (    "Missing  argument  for  option:  "  +  opt  .  getKey  (  )  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) && !opt . hasOptionalArg ( ) ) { [BUGGY] return ;  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^343^344^^^^341^345^
[ADD]  throw  new  MissingArgumentException  (    "Missing  argument  for  option:  "  +  opt  .  getKey  (  )  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) && !opt . hasOptionalArg ( ) ) { [BUGGY]    	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^343^344^345^^^341^345^
[REPLACE]  +  opt  .  getKey  (  )  )  ; 	[BUGGY] + opt . addValue ( ) ) ; [CE] method addValue in class Option cannot be applied to given types ;  [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  if ( ( opt . getValues ( )  = = null ) && !opt . hasOptionalArg ( ) ) { throw new MissingArgumentException (   "Missing argument for option:  " [BUGGY] + opt . addValue ( ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^344^^^^^341^345^
[REPLACE]  throw  new  MissingArgumentException  (    "Missing  argument  for  option:  "  +  opt  .  getKey  (  )  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  {  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( )  = = null ) && !opt . hasOptionalArg ( ) ) { [BUGGY] return ;  } }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^343^344^^^^316^346^
[ADD]  throw  new  MissingArgumentException  (    "Missing  argument  for  option:  "  +  opt  .  getKey  (  )  )  ;  } 	[BUGGY] [CE] illegal start of expression  [METHOD]  processArgs [TYPE] void [PARAMETER] Option opt ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] RuntimeException exp [TYPE] boolean false true [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String str [TYPE] ListIterator iter  [CONTEXT]  {  while ( iter . hasNext ( ) ) { String str =  ( String ) iter . next ( ) ;   if ( options . hasOption ( str ) && str . startsWith (   "-  " ) ) { iter . previous ( ) ; break ; }  try { opt . addValue ( Util . stripLeadingAndTrailingQuotes ( str )  ) ; } catch ( RuntimeException exp ) { iter . previous ( ) ; break ; } } if ( ( opt . getValues ( )  = = null ) && !opt . hasOptionalArg ( ) ) { [BUGGY]  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^343^344^345^^^316^346^
[REPLACE]  boolean  hasOption  =  options  .  hasOption  (  arg  )  ; 	[BUGGY] boolean . getOption = options . hasOption ( arg ) ; [CE] class expected  [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { [BUGGY] boolean . getOption = options . hasOption ( arg )  ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^363^^^^^362^405^
[REPLACE]  if  (  !hasOption  )  { 	[BUGGY] if ( hasOption ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   [BUGGY] if ( hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^366^367^^^^362^405^
[REPLACE]  throw  new  UnrecognizedOptionException  (    "Unrecognized  option:    "  +  arg  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( !hasOption ) { [BUGGY] return ;  }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^368^369^^^^366^370^
[REPLACE]  throw  new  UnrecognizedOptionException  (    "Unrecognized  option:    "  +  arg  )  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { [BUGGY] return ;  }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^368^369^^^^362^405^
[REPLACE]  final  Option  opt  =  options  .  getOption  (  arg  )  ; 	[BUGGY] final Option opt = options . hasOption ( arg ) ; [CE] incompatible types  [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  [BUGGY] final Option opt = options . hasOption ( arg )  ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^373^^^^^362^405^
[ADD]  final  Option  opt  =  options  .  getOption  (  arg  )  ; 	[BUGGY] [CE] cannot find symbol opt  [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  [BUGGY]    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^373^^^^^362^405^
[REPLACE]  if  (  opt  .  isRequired  (  )  )  { 	[BUGGY] if ( group . isRequired ( ) ) {[CE] cannot find symbol group  [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    [BUGGY] if ( group . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^377^378^^^^362^405^
[REPLACE]  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ; 	[BUGGY] cmd . addOption ( opt ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( opt . isRequired ( ) ) { [BUGGY] cmd . addOption ( opt )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^379^^^^^377^380^
[REPLACE]  requiredOptions  .  remove  (  opt  .  getKey  (  )  )  ; 	[BUGGY] requiredOptions . remove ( opt . getValues ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( opt . isRequired ( ) ) { [BUGGY] requiredOptions . remove ( opt . getValues ( ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^379^^^^^377^380^
[REPLACE]  if  (  options  .  getOptionGroup  (  opt  )  !=  null  )  { 	[BUGGY] if ( options . getOptionGroup ( opt )  = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   [BUGGY] if ( options . getOptionGroup ( opt ) = = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^384^385^^^^362^405^
[REPLACE]  if  (  group  .  isRequired  (  )  )  { 	[BUGGY] if ( opt . isRequired ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  [BUGGY] if ( opt . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^388^389^^^^384^394^
[REPLACE]  requiredOptions  .  remove  (  group  )  ; 	[BUGGY] requiredOptions . size ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { [BUGGY] requiredOptions . size ( ) ; } group . setSelected ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^390^^^^^384^394^
[ADD]  requiredOptions  .  remove  (  group  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { [BUGGY] } group . setSelected ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^390^^^^^384^394^
[REPLACE]  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ; 	[BUGGY] OptionGroup group = options . getOption ( opt ) ; [CE] method getOption in class Options cannot be applied to given types ;  [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( options . getOptionGroup ( opt ) ! = null ) { [BUGGY] OptionGroup group = options . getOption ( opt )  ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^386^^^^^384^394^
[REPLACE]  if  (  group  .  isRequired  (  )  )  { 	[BUGGY] if ( opt . isRequired ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  [BUGGY] if ( opt . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^388^389^^^^362^405^
[REPLACE]  requiredOptions  .  remove  (  group  )  ; 	[BUGGY] requiredOptions . size ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( group . isRequired ( ) ) { [BUGGY] requiredOptions . size ( ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^390^^^^^388^391^
[REPLACE]  OptionGroup  group  =  options  .  getOptionGroup  (  opt  )  ; 	[BUGGY] OptionGroup group = options . getOption ( arg )  ; [CE] incompatible types  [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { [BUGGY] OptionGroup group = options . getOption ( arg ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^386^^^^^362^405^
[REPLACE]  if  (  opt  .  hasArg  (  )  )  { 	[BUGGY] if ( opt . getKey ( ) ) {[CE] incompatible types  [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  [BUGGY] if ( opt . getKey ( ) ) { processArgs ( opt , iter ) ; }   cmd . addOption ( opt ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^397^398^^^^362^405^
[REPLACE]  processArgs  (  opt,  iter  )  ; 	[BUGGY] String str =  ( String ) iter . next ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  if ( opt . hasArg ( ) ) { [BUGGY] String str = ( String ) iter . next ( )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^399^^^^^397^400^
[REPLACE]  cmd  .  addOption  (  opt  )  ; 	[BUGGY] cmd . hasOption ( opt ) ; [CE] no suitable method found for hasOption(Option)  [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   [BUGGY] cmd . hasOption ( opt )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^404^^^^^362^405^
[ADD]  cmd  .  addOption  (  opt  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  processOption [TYPE] void [PARAMETER] String arg ListIterator iter [CLASS] Parser  [TYPE] Options options opts [TYPE] CommandLine cmd [TYPE] boolean false hasOption true [TYPE] OptionGroup group [TYPE] List requiredOptions tokenList [TYPE] Option opt [TYPE] String arg [TYPE] ListIterator iter  [CONTEXT]  { boolean hasOption = options . hasOption ( arg ) ;   if ( !hasOption ) { throw new UnrecognizedOptionException (   "Unrecognized option:   " + arg ) ; }  final Option opt = options . getOption ( arg ) ;    if ( opt . isRequired ( ) ) { requiredOptions . remove ( opt . getKey ( ) ) ; }   if ( options . getOptionGroup ( opt ) ! = null ) { OptionGroup group = options . getOptionGroup ( opt ) ;  if ( group . isRequired ( ) ) { requiredOptions . remove ( group ) ; } group . setSelected ( opt ) ; }  if ( opt . hasArg ( ) ) { processArgs ( opt , iter ) ; }   [BUGGY] }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/Parser.java^404^^^^^362^405^
[REPLACE]  private  List  args  =  new  LinkedList  (  )  ; 	[BUGGY] private List args ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] CommandLine  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^43^^^^^^^
[REPLACE]  private  Set  options  =  new  HashSet  (  )  ; 	[BUGGY] private Set options ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [CONTEXT]    [CLASS] CommandLine  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^46^^^^^^^
[REPLACE]  return  options  .  contains  (  resolveOption  (  opt  )  )  ; 	[BUGGY] return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; [CE] cannot find symbol defaultValue  [METHOD]  hasOption [TYPE] boolean [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  public boolean hasOption ( String opt ) { [BUGGY] return getOptionValue ( String . valueOf ( opt )  , defaultValue )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^67^^^^^65^68^
[REPLACE]  return  hasOption  (  String  .  valueOf  (  opt  )  )  ; 	[BUGGY] return getOptionObject ( String . valueOf ( opt ) ) ; [CE] incompatible types  [METHOD]  hasOption [TYPE] boolean [PARAMETER] char opt [CLASS] CommandLine  [TYPE] char opt [TYPE] List args [TYPE] Set options [TYPE] boolean false true  [CONTEXT]  public boolean hasOption ( char opt ) { [BUGGY] return getOptionObject ( String . valueOf ( opt ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^78^^^^^76^79^
[REPLACE]  String  res  =  getOptionValue  (  opt  )  ; 	[BUGGY] String answer = getOptionValue ( opt ) ; [CE] cannot find symbol res  [METHOD]  getOptionObject [TYPE] Object [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option option [TYPE] Object type [TYPE] Set options [TYPE] String opt res [TYPE] boolean false true  [CONTEXT]  public Object getOptionObject ( String opt ) { [BUGGY] String answer = getOptionValue ( opt )  ;  Option option = resolveOption ( opt ) ; if ( option = = null ) { return null ; } Object type = option . getType ( ) ;  return ( res = = null ) ? null : TypeHandler . createValue ( res , type ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^89^^^^^87^100^
[ADD]  String  res  =  getOptionValue  (  opt  )  ; 	[BUGGY] [CE] cannot find symbol res  [METHOD]  getOptionObject [TYPE] Object [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option option [TYPE] Object type [TYPE] Set options [TYPE] String opt res [TYPE] boolean false true  [CONTEXT]  public Object getOptionObject ( String opt ) { [BUGGY]  Option option = resolveOption ( opt ) ; if ( option = = null ) { return null ; } Object type = option . getType ( ) ;  return ( res = = null ) ? null : TypeHandler . createValue ( res , type ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^89^^^^^87^100^
[REPLACE]  Option  option  =  resolveOption  (  opt  )  ; 	[BUGGY] Collection processed = options ; [CE] cannot find symbol option  [METHOD]  getOptionObject [TYPE] Object [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option option [TYPE] Object type [TYPE] Set options [TYPE] String opt res [TYPE] boolean false true  [CONTEXT]  public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ;  [BUGGY] Collection processed = options ; if ( option = = null ) { return null ; } Object type = option . getType ( ) ;  return ( res = = null ) ? null : TypeHandler . createValue ( res , type ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^91^^^^^87^100^
[REPLACE]  if  (  option  ==  null  )  { 	[BUGGY] if ( option ! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptionObject [TYPE] Object [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option option [TYPE] Object type [TYPE] Set options [TYPE] String opt res [TYPE] boolean false true  [CONTEXT]  public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ;  Option option = resolveOption ( opt ) ; [BUGGY] if ( option ! = null ) { return null ; } Object type = option . getType ( ) ;  return ( res = = null ) ? null : TypeHandler . createValue ( res , type ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^92^93^^^^87^100^
[REPLACE]  return  null; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptionObject [TYPE] Object [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option option [TYPE] Object type [TYPE] Set options [TYPE] String opt res [TYPE] boolean false true  [CONTEXT]  public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ;  Option option = resolveOption ( opt ) ; if ( option = = null ) { [BUGGY] return false ; } Object type = option . getType ( ) ;  return ( res = = null ) ? null : TypeHandler . createValue ( res , type ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^94^^^^^87^100^
[REPLACE]  Object  type  =  option  .  getType  (  )  ; 	[BUGGY] Object type = option . getOpt ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptionObject [TYPE] Object [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option option [TYPE] Object type [TYPE] Set options [TYPE] String opt res [TYPE] boolean false true  [CONTEXT]  public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ;  Option option = resolveOption ( opt ) ; if ( option = = null ) { return null ; } [BUGGY] Object type = option . getOpt ( )  ;  return ( res = = null ) ? null : TypeHandler . createValue ( res , type ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^97^^^^^87^100^
[REPLACE]  return  (  res  ==  null  )          ?  null  :  TypeHandler  .  createValue  (  res,  type  )  ; 	[BUGGY] return TypeHandler . createValue ( res , type ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptionObject [TYPE] Object [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option option [TYPE] Object type [TYPE] Set options [TYPE] String opt res [TYPE] boolean false true  [CONTEXT]  public Object getOptionObject ( String opt ) { String res = getOptionValue ( opt ) ;  Option option = resolveOption ( opt ) ; if ( option = = null ) { return null ; } Object type = option . getType ( ) ;  [BUGGY] return TypeHandler . createValue ( res , type )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^99^^^^^87^100^
[REPLACE]  return  getOptionObject  (  String  .  valueOf  (  opt  )  )  ; 	[BUGGY] return getOptionObject ( String . equals ( opt ) ) ; [CE] non-static method equals(Object) cannot be referenced from a static context  [METHOD]  getOptionObject [TYPE] Object [PARAMETER] char opt [CLASS] CommandLine  [TYPE] char opt [TYPE] List args [TYPE] Set options [TYPE] boolean false true  [CONTEXT]  public Object getOptionObject ( char opt ) { [BUGGY] return getOptionObject ( String . equals ( opt ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^110^^^^^108^111^
[REPLACE]  String[]  values  =  getOptionValues  (  opt  )  ; 	[BUGGY] String answer = getOptionValue ( opt ) ; [CE] cannot find symbol values  [METHOD]  getOptionValue [TYPE] String [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String opt [TYPE] String[] values [TYPE] boolean false true  [CONTEXT]  public String getOptionValue ( String opt ) { [BUGGY] String answer = getOptionValue ( opt )  ;  return ( values = = null ) ? null : values[0] ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^122^^^^^120^125^
[REPLACE]  return  (  values  ==  null  )  ?  null  :  values[0]; 	[BUGGY] return values[0] ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptionValue [TYPE] String [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String opt [TYPE] String[] values [TYPE] boolean false true  [CONTEXT]  public String getOptionValue ( String opt ) { String[] values = getOptionValues ( opt ) ;  [BUGGY] return values[0] ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^124^^^^^120^125^
[REPLACE]  return  getOptionValue  (  String  .  valueOf  (  opt  )  )  ; 	[BUGGY] return hasOption ( String . valueOf ( opt ) ) ; [CE] incompatible types  [METHOD]  getOptionValue [TYPE] String [PARAMETER] char opt [CLASS] CommandLine  [TYPE] char opt [TYPE] List args [TYPE] Set options [TYPE] boolean false true  [CONTEXT]  public String getOptionValue ( char opt ) { [BUGGY] return hasOption ( String . valueOf ( opt ) )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^136^^^^^134^137^
[REPLACE]  Option  key  =  resolveOption  (  opt  )  ; 	[BUGGY] String[] values = getOptionValues ( opt ) ; [CE] cannot find symbol key  [METHOD]  getOptionValues [TYPE] String[] [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option key [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  public String[] getOptionValues ( String opt ) { [BUGGY] String[] values = getOptionValues ( opt )  ;  if ( options . contains ( key ) ) { return key . getValues ( ) ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^148^^^^^146^156^
[REPLACE]  if  (  options  .  contains  (  key  )  )  { 	[BUGGY] if ( options . iterator ( )  ) {[CE] incompatible types  [METHOD]  getOptionValues [TYPE] String[] [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option key [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  public String[] getOptionValues ( String opt ) { Option key = resolveOption ( opt ) ;  [BUGGY] if ( options . iterator ( )  ) { return key . getValues ( ) ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^150^151^^^^146^156^
[ADD]  if  (  options  .  contains  (  key  )  )  {  return  key  .  getValues  (  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptionValues [TYPE] String[] [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option key [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  public String[] getOptionValues ( String opt ) { Option key = resolveOption ( opt ) ;  [BUGGY]   return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^150^151^152^153^^146^156^
[REPLACE]  return  key  .  getValues  (  )  ; 	[BUGGY] return key . getType ( ) ; [CE] incompatible types  [METHOD]  getOptionValues [TYPE] String[] [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option key [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  public String[] getOptionValues ( String opt ) { Option key = resolveOption ( opt ) ;  if ( options . contains ( key ) ) { [BUGGY] return key . getType ( )  ; } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^152^^^^^146^156^
[REPLACE]  return  null; 	[BUGGY] return true ; [CE] incompatible types  [METHOD]  getOptionValues [TYPE] String[] [PARAMETER] String opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option key [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  public String[] getOptionValues ( String opt ) { Option key = resolveOption ( opt ) ;  if ( options . contains ( key ) ) { return key . getValues ( ) ; } [BUGGY] return true ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^155^^^^^146^156^
[REPLACE]  opt  =  Util  .  stripLeadingHyphens  (  opt  )  ; 	[BUGGY] opt =  Util . stripLeadingHyphens ( null ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { [BUGGY] opt = Util . stripLeadingHyphens ( null )  ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^165^^^^^163^180^
[REPLACE]  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  { 	[BUGGY] if ( opt . valueOf ( null )  ) {[CE] incompatible types  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; [BUGGY] if ( opt . valueOf ( null )  ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^169^170^^^^163^180^
[REPLACE]  return  option; 	[BUGGY] return hasOption ( String . valueOf ( opt ) ) ; [CE] incompatible types  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { [BUGGY] return hasOption ( String . valueOf ( opt ) )  ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^171^^^^^163^180^
[REPLACE]  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  { 	[BUGGY] if ( opt . valueOf ( option . getLongOpt ( ) ) ) {[CE] incompatible types  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } [BUGGY] if ( opt . valueOf ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^173^174^^^^163^180^
[REPLACE]  return  option; 	[BUGGY] return hasOption ( String . valueOf ( opt ) ) ; [CE] incompatible types  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { [BUGGY] return hasOption ( String . valueOf ( opt ) )  ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^175^^^^^163^180^
[REPLACE]  for  (  Iterator  it  =  options  .  iterator  (  )  ;  it  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator it = options . iterator ( ) ; it . next ( ) ;  ) {[CE] incompatible types  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; [BUGGY] for ( Iterator it = options . iterator ( )  ; it . next ( )  ; ) { Option option =  ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^166^167^^^^163^180^
[REPLACE]  if  (  opt  .  equals  (  option  .  getOpt  (  )  )  )  { 	[BUGGY] if ( opt . equals ( option . getType ( ) ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; [BUGGY] if ( opt . equals ( option . getType ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^169^170^^^^163^180^
[REPLACE]  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  { 	[BUGGY] if ( opt . equals ( option . getOpt ( ) ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } [BUGGY] if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^173^174^^^^163^180^
[ADD]  if  (  opt  .  equals  (  option  .  getLongOpt  (  )  )  )  {  return  option;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } [BUGGY]   } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^173^174^175^176^^163^180^
[REPLACE]  Option  option  =  (  Option  )  it  .  next  (  )  ; 	[BUGGY] Option option =  ( Option ) it . hasNext ( ) ; [CE] inconvertible types  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { [BUGGY] Option option = ( Option ) it . hasNext ( )  ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^168^^^^^163^180^
[ADD]  Option  option  =  (  Option  )  it  .  next  (  )  ; 	[BUGGY] [CE] cannot find symbol option  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { [BUGGY] if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^168^^^^^163^180^
[REPLACE]  Option  option  =  (  Option  )  it  .  next  (  )  ; 	[BUGGY] Option option =  ( Option ) it . hasNext ( )  ; [CE] inconvertible types  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { [BUGGY] Option option = ( Option ) it . hasNext ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^168^^^^^163^180^
[REPLACE]  return  null; 	[BUGGY] return false ; [CE] incompatible types  [METHOD]  resolveOption [TYPE] Option [PARAMETER] String opt [CLASS] CommandLine  [TYPE] Iterator it [TYPE] List args [TYPE] Option option [TYPE] Set options [TYPE] String opt [TYPE] boolean false true  [CONTEXT]  private Option resolveOption ( String opt ) { opt = Util . stripLeadingHyphens ( opt ) ; for ( Iterator it = options . iterator ( ) ; it . hasNext ( ) ;  ) { Option option =  ( Option ) it . next ( ) ; if ( opt . equals ( option . getOpt ( ) ) ) { return option ; } if ( opt . equals ( option . getLongOpt ( ) ) ) { return option ; } } [BUGGY] return false ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^179^^^^^163^180^
[REPLACE]  return  getOptionValues  (  String  .  valueOf  (  opt  )  )  ; 	[BUGGY] return getOptionValues ( String . equals ( null )  ) ; [CE] non-static method equals(Object) cannot be referenced from a static context  [METHOD]  getOptionValues [TYPE] String[] [PARAMETER] char opt [CLASS] CommandLine  [TYPE] char opt [TYPE] List args [TYPE] Set options [TYPE] boolean false true  [CONTEXT]  public String[] getOptionValues ( char opt ) { [BUGGY] return getOptionValues ( String . equals ( null )  )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^191^^^^^189^192^
[REPLACE]  String  answer  =  getOptionValue  (  opt  )  ; 	[BUGGY] String answer = getOptionValue ( defaultValue ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getOptionValue [TYPE] String [PARAMETER] String opt String defaultValue [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String answer defaultValue opt [TYPE] boolean false true  [CONTEXT]  public String getOptionValue ( String opt , String defaultValue ) { [BUGGY] String answer = getOptionValue ( defaultValue )  ;  return ( answer ! = null ) ? answer : defaultValue ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^205^^^^^203^208^
[REPLACE]  return  (  answer  !=  null  )  ?  answer  :  defaultValue; 	[BUGGY] return ( answer  =  defaultValue ; [CE] ')' expected  [METHOD]  getOptionValue [TYPE] String [PARAMETER] String opt String defaultValue [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String answer defaultValue opt [TYPE] boolean false true  [CONTEXT]  public String getOptionValue ( String opt , String defaultValue ) { String answer = getOptionValue ( opt ) ;  [BUGGY] return ( answer = defaultValue ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^207^^^^^203^208^
[REPLACE]  return  getOptionValue  (  String  .  valueOf  (  opt  )  ,  defaultValue  )  ; 	[BUGGY] return ( answer ! = null ) ? answer : defaultValue ; [CE] cannot find symbol answer  [METHOD]  getOptionValue [TYPE] String [PARAMETER] char opt String defaultValue [CLASS] CommandLine  [TYPE] char opt [TYPE] List args [TYPE] Set options [TYPE] String defaultValue [TYPE] boolean false true  [CONTEXT]  public String getOptionValue ( char opt , String defaultValue ) { [BUGGY] return ( answer ! = null ) ? answer : defaultValue ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^221^^^^^219^222^
[REPLACE]  String[]  answer  =  new  String[args  .  size  (  )  ]; 	[BUGGY] String[] values = getOptionValues ( opt ) ; [CE] cannot find symbol opt  [METHOD]  getArgs [TYPE] String[] [PARAMETER] [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String[] answer [TYPE] boolean false true  [CONTEXT]  public String[] getArgs ( ) { [BUGGY] String[] values = getOptionValues ( opt )  ;  args . toArray ( answer ) ;  return answer ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^231^^^^^229^236^
[REPLACE]  args  .  toArray  (  answer  )  ; 	[BUGGY] args . add ( 0 )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getArgs [TYPE] String[] [PARAMETER] [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String[] answer [TYPE] boolean false true  [CONTEXT]  public String[] getArgs ( ) { String[] answer = new String[args . size ( ) ] ;  [BUGGY] args . add ( 0 ) ;  return answer ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^233^^^^^229^236^
[REPLACE]  return  answer; 	[BUGGY] return args ; [CE] incompatible types  [METHOD]  getArgs [TYPE] String[] [PARAMETER] [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String[] answer [TYPE] boolean false true  [CONTEXT]  public String[] getArgs ( ) { String[] answer = new String[args . size ( ) ] ;  args . toArray ( answer ) ;  [BUGGY] return args ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^235^^^^^229^236^
[REPLACE]  return  args; 	[BUGGY] return null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  getArgList [TYPE] List [PARAMETER] [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] boolean false true  [CONTEXT]  public List getArgList ( ) { [BUGGY] return null ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^245^^^^^243^246^
[REPLACE]  args  .  add  (  arg  )  ; 	[BUGGY] args . toArray ( arg ) ; [CE] no suitable method found for toArray(String)  [METHOD]  addArg [TYPE] void [PARAMETER] String arg [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] String arg [TYPE] boolean false true  [CONTEXT]  void addArg ( String arg ) { [BUGGY] args . toArray ( arg )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^277^^^^^275^278^
[REPLACE]  options  .  add  (  opt  )  ; 	[BUGGY] options . contains ( opt ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  addOption [TYPE] void [PARAMETER] Option opt [CLASS] CommandLine  [TYPE] List args [TYPE] Option opt [TYPE] Set options [TYPE] boolean false true  [CONTEXT]  void addOption ( Option opt ) { [BUGGY] options . contains ( opt )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^288^^^^^286^289^
[REPLACE]  return  options  .  iterator  (  )  ; 	[BUGGY] return getOptionValue ( String . valueOf ( opt ) , defaultValue ) ; [CE] cannot find symbol opt  [METHOD]  iterator [TYPE] Iterator [PARAMETER] [CLASS] CommandLine  [TYPE] List args [TYPE] Set options [TYPE] boolean false true  [CONTEXT]  public Iterator iterator ( ) { [BUGGY] return getOptionValue ( String . valueOf ( opt )  , defaultValue )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^299^^^^^297^300^
[REPLACE]  Collection  processed  =  options; 	[BUGGY] Option option = resolveOption ( opt ) ; [CE] cannot find symbol opt  [METHOD]  getOptions [TYPE] Option[] [PARAMETER] [CLASS] CommandLine  [TYPE] Collection processed [TYPE] List args [TYPE] Set options [TYPE] Option[] optionsArray [TYPE] boolean false true  [CONTEXT]  public Option[] getOptions ( ) { [BUGGY] Option option = resolveOption ( opt )  ;   Option[] optionsArray = new Option[processed . size ( ) ] ;   return ( Option[] ) processed . toArray ( optionsArray ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^309^^^^^307^316^
[REPLACE]  Option[]  optionsArray  =  new  Option[processed  .  size  (  )  ]; 	[BUGGY] String[] values = getOptionValues ( opt ) ; [CE] cannot find symbol opt  [METHOD]  getOptions [TYPE] Option[] [PARAMETER] [CLASS] CommandLine  [TYPE] Collection processed [TYPE] List args [TYPE] Set options [TYPE] Option[] optionsArray [TYPE] boolean false true  [CONTEXT]  public Option[] getOptions ( ) { Collection processed = options ;   [BUGGY] String[] values = getOptionValues ( opt )  ;   return ( Option[] ) processed . toArray ( optionsArray ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^312^^^^^307^316^
[ADD]  Option[]  optionsArray  =  new  Option[processed  .  size  (  )  ]; 	[BUGGY] [CE] cannot find symbol optionsArray  [METHOD]  getOptions [TYPE] Option[] [PARAMETER] [CLASS] CommandLine  [TYPE] Collection processed [TYPE] List args [TYPE] Set options [TYPE] Option[] optionsArray [TYPE] boolean false true  [CONTEXT]  public Option[] getOptions ( ) { Collection processed = options ;   [BUGGY]   return ( Option[] ) processed . toArray ( optionsArray ) ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^312^^^^^307^316^
[REPLACE]  return  (  Option[]  )  processed  .  toArray  (  optionsArray  )  ; 	[BUGGY] return ( Option[] ) processed . size ( optionsArray ) ; [CE] method size in interface Collection<E> cannot be applied to given types ;  [METHOD]  getOptions [TYPE] Option[] [PARAMETER] [CLASS] CommandLine  [TYPE] Collection processed [TYPE] List args [TYPE] Set options [TYPE] Option[] optionsArray [TYPE] boolean false true  [CONTEXT]  public Option[] getOptions ( ) { Collection processed = options ;   Option[] optionsArray = new Option[processed . size ( ) ] ;   [BUGGY] return ( Option[] ) processed . size ( optionsArray )  ; }  	./Perturbation-Cli-1/src/java/org/apache/commons/cli/CommandLine.java^315^^^^^307^316^
[REPLACE]  final  DefaultOptionBuilder  obuilder  =  new  DefaultOptionBuilder  (  )  ; 	[BUGGY] final GroupBuilder gbuilder = new GroupBuilder ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { [BUGGY] final GroupBuilder gbuilder = new GroupBuilder ( )  ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^50^^^^^48^94^
[REPLACE]  obuilder  .  withRequired  (  option1  .  isRequired  (  )  )  ; 	[BUGGY] obuilder . withRequired ( option1 . getId ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; [BUGGY] obuilder . withRequired ( option1 . getId ( ) )  ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^51^^^^^48^94^
[REPLACE]  final  String  shortName  =  option1  .  getOpt  (  )  ; 	[BUGGY] final String shortName = option1 . getType ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  [BUGGY] final String shortName = option1 . getType ( )  ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^53^^^^^48^94^
[ADD]  final  String  shortName  =  option1  .  getOpt  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  [BUGGY] if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^53^^^^^48^94^
[REPLACE]  if  (  shortName!=null  &&  !  "    "  .  equals  (  shortName  )  )  { 	[BUGGY] if ( shortName = = null && !  "   " . equals ( shortName ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; [BUGGY] if ( shortName = = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^54^^^^^48^94^
[REPLACE]  obuilder  .  withShortName  (  shortName  )  ; 	[BUGGY] obuilder . withShortName ( longName ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { [BUGGY] obuilder . withShortName ( longName )  ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^55^^^^^48^94^
[REPLACE]  final  String  longName  =  option1  .  getLongOpt  (  )  ; 	[BUGGY] final String longName = option1 . getOpt ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } [BUGGY] final String longName = option1 . getOpt ( )  ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^58^^^^^48^94^
[REPLACE]  if  (  longName!=null  )  { 	[BUGGY] if ( shortName = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; [BUGGY] if ( shortName = = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^59^^^^^48^94^
[ADD]  if  (  longName!=null  )  {  obuilder  .  withLongName  (  longName  )  ;  } 	[BUGGY] obuilder . withLongName ( longName ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; [BUGGY] obuilder . withLongName ( longName )  ;  obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^59^60^61^^^48^94^
[REPLACE]  obuilder  .  withLongName  (  longName  )  ; 	[BUGGY] obuilder . withLongName ( shortName ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { [BUGGY] obuilder . withLongName ( shortName )  ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^60^^^^^48^94^
[REPLACE]  obuilder  .  withId  (  option1  .  getId  (  )  )  ; 	[BUGGY] obuilder . withId ( option1 . getOpt ( )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } [BUGGY] obuilder . withId ( option1 . getOpt ( )  )  ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^62^^^^^48^94^
[REPLACE]  obuilder  .  withId  (  option1  .  getId  (  )  )  ; 	[BUGGY] obuilder . withId ( option1 . getOpt ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } [BUGGY] obuilder . withId ( option1 . getOpt ( ) )  ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^62^^^^^48^94^
[REPLACE]  final  String  description  =  option1  .  getDescription  (  )  ; 	[BUGGY] final String description = option1 . getOpt ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  [BUGGY] final String description = option1 . getOpt ( )  ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^64^^^^^48^94^
[REPLACE]  if  (  description!=null  )  { 	[BUGGY] if ( description = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; [BUGGY] if ( description = = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^65^^^^^48^94^
[REPLACE]  obuilder  .  withDescription  (  description  )  ; 	[BUGGY] obuilder . withShortName ( description ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { [BUGGY] obuilder . withShortName ( description )  ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^66^^^^^48^94^
[ADD]  obuilder  .  withDescription  (  description  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { [BUGGY] } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^66^^^^^48^94^
[REPLACE]  if  (  option1  .  hasArg  (  )  )  { 	[BUGGY] if ( ! option1 . hasArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } [BUGGY] if ( ! option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^69^^^^^48^94^
[REPLACE]  if  (  option1  .  hasValueSeparator  (  )  )  { 	[BUGGY] if ( ! option1 . hasValueSeparator ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; [BUGGY] if ( ! option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^74^^^^^48^94^
[ADD]  if  (  option1  .  hasValueSeparator  (  )  )  {  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; [BUGGY]  if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^74^75^76^^^48^94^
[REPLACE]  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ; 	[BUGGY] abuilder . withValidator ( this )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { [BUGGY] abuilder . withValidator ( this ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^75^^^^^48^94^
[REPLACE]  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ; 	[BUGGY] abuilder . withSubsequentSeparator ( option1 . hasValueSeparator ( )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { [BUGGY] abuilder . withSubsequentSeparator ( option1 . hasValueSeparator ( )  )  ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^75^^^^^48^94^
[REPLACE]  if  (  option1  .  hasOptionalArg  (  )  )  { 	[BUGGY] if ( ! option1 . hasOptionalArg ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } [BUGGY] if ( ! option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^77^^^^^48^94^
[REPLACE]  abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ; 	[BUGGY] abuilder . withMaximum ( option1 . getArgs ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  [BUGGY] abuilder . withMaximum ( option1 . getArgs ( ) )  ; }  	./Perturbation-Cli-1/CLI2Converter.java^82^^^^^77^83^
[REPLACE]  abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ; 	[BUGGY] abuilder . withMinimum ( option1 . getArgName ( )  ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  [BUGGY] abuilder . withMinimum ( option1 . getArgName ( )  )  ; }  	./Perturbation-Cli-1/CLI2Converter.java^82^^^^^77^83^
[REPLACE]  abuilder  .  withMinimum  (  0  )  ; 	[BUGGY] abuilder . withMaximum ( 0 - 3 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { [BUGGY] abuilder . withMaximum ( 0 - 3 )  ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^78^^^^^48^94^
[REPLACE]  if  (  type!=null  )  { 	[BUGGY] if ( type = = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; [BUGGY] if ( type = = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^86^^^^^48^94^
[REPLACE]  abuilder  .  withValidator  (  new  TypeHandlerValidator  (  type  )  )  ; 	[BUGGY] abuilder . withName ( new TypeHandlerValidator ( type ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { [BUGGY] abuilder . withName ( new TypeHandlerValidator ( type ) )  ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^87^^^^^48^94^
[REPLACE]  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ; 	[BUGGY] final GroupBuilder gbuilder = new GroupBuilder ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { [BUGGY] final GroupBuilder gbuilder = new GroupBuilder ( )  ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^70^^^^^48^94^
[ADD]  final  ArgumentBuilder  abuilder  =  new  ArgumentBuilder  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { [BUGGY] final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^70^^^^^48^94^
[REPLACE]  final  String  argName  =  option1  .  getArgName  (  )  ; 	[BUGGY] final String argName = option1 . getArgs ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; [BUGGY] final String argName = option1 . getArgs ( )  ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^71^^^^^48^94^
[ADD]  final  String  argName  =  option1  .  getArgName  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; [BUGGY] abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^71^^^^^48^94^
[REPLACE]  final  Object  type  =  option1  .  getType  (  )  ; 	[BUGGY] final Object type = option1 . getOpt ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } [BUGGY] final Object type = option1 . getOpt ( )  ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^85^^^^^48^94^
[REPLACE]  abuilder  .  withSubsequentSeparator  (  option1  .  getValueSeparator  (  )  )  ; 	[BUGGY] abuilder . withSubsequentSeparator ( option1 . hasValueSeparator ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { [BUGGY] abuilder . withSubsequentSeparator ( option1 . hasValueSeparator ( ) )  ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^75^^^^^48^94^
[ADD]  if  (  option1  .  hasOptionalArg  (  )  )  {  abuilder  .  withMinimum  (  0  )  ;  } 	[BUGGY] abuilder . withMinimum ( 0 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } [BUGGY] abuilder . withMinimum ( 0 )  ;  else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^77^78^79^^^48^94^
[REPLACE]  abuilder  .  withMinimum  (  option1  .  getArgs  (  )  )  ; 	[BUGGY] abuilder . withMinimum ( option1 . getArgName ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  [BUGGY] abuilder . withMinimum ( option1 . getArgName ( ) )  ; }  	./Perturbation-Cli-1/CLI2Converter.java^82^^^^^77^83^
[REMOVE]   	[BUGGY] obuilder . withRequired ( option1 . isRequired ( ) ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  [BUGGY] abuilder . withMinimum ( option1 . getArgs ( ) ) ;   	./Perturbation-Cli-1/CLI2Converter.java^82^^^^^77^83^
[REPLACE]  abuilder  .  withMinimum  (  0  )  ; 	[BUGGY] abuilder . withMinimum ( 3 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { [BUGGY] abuilder . withMinimum ( 3 )  ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^78^^^^^48^94^
[REPLACE]  if  (  type!=null  )  { 	[BUGGY] if ( type = = false ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; [BUGGY] if ( type = = false ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } return obuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^86^^^^^48^94^
[REPLACE]  return  obuilder  .  create  (  )  ; 	[BUGGY] return obuilder . withArgument ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  option [TYPE] Option [PARAMETER] Option option1 [CLASS] CLI2Converter  [TYPE] boolean false true [TYPE] ArgumentBuilder abuilder [TYPE] Option option1 [TYPE] DefaultOptionBuilder obuilder [TYPE] Object type [TYPE] String argName description longName shortName  [CONTEXT]  public static Option option ( final org . apache . commons . cli . Option option1 ) { final DefaultOptionBuilder obuilder = new DefaultOptionBuilder ( ) ; obuilder . withRequired ( option1 . isRequired ( ) ) ;  final String shortName = option1 . getOpt ( ) ; if ( shortName! = null && !  "   " . equals ( shortName ) ) { obuilder . withShortName ( shortName ) ; } final String longName = option1 . getLongOpt ( ) ; if ( longName! = null ) { obuilder . withLongName ( longName ) ; } obuilder . withId ( option1 . getId ( ) ) ;  final String description = option1 . getDescription ( ) ; if ( description! = null ) { obuilder . withDescription ( description ) ; } if ( option1 . hasArg ( ) ) { final ArgumentBuilder abuilder = new ArgumentBuilder ( ) ; final String argName = option1 . getArgName ( ) ; abuilder . withName ( argName ) ; abuilder . withMaximum ( option1 . getArgs ( ) ) ; if ( option1 . hasValueSeparator ( ) ) { abuilder . withSubsequentSeparator ( option1 . getValueSeparator ( ) ) ; } if ( option1 . hasOptionalArg ( ) ) { abuilder . withMinimum ( 0 ) ; } else{  abuilder . withMinimum ( option1 . getArgs ( ) ) ; } final Object type = option1 . getType ( ) ; if ( type! = null ) { abuilder . withValidator ( new TypeHandlerValidator ( type ) ) ; } obuilder . withArgument ( abuilder . create ( ) ) ; } [BUGGY] return obuilder . withArgument ( )  ; }  	./Perturbation-Cli-1/CLI2Converter.java^93^^^^^48^94^
[REPLACE]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ; 	[BUGGY] final Set optionGroups = new HashSet ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { [BUGGY] final Set optionGroups = new HashSet ( )  ;  for ( final Iterator i = optionGroup1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^104^^^^^102^119^
[REPLACE]  for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  [BUGGY] for ( final Iterator i = options1 . getOptions ( )  . iterator ( )  ; i . hasNext ( )  ;  ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^106^^^^^102^119^
[ADD]  for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  {  final  org  .  apache  .  commons  .  cli  .  Option  option1  =  (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ;  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  [BUGGY]    gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^106^107^108^109^110^102^119^
[REPLACE]  final  org  .  apache  .  commons  .  cli  .  Option  option1  =  (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ; 	[BUGGY] final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . hasNext ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  for ( final Iterator i = optionGroup1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { [BUGGY] final org . apache . commons . cli . Option option1 = ( org . apache . commons . cli . Option ) i . hasNext ( )  ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^107^^^^^102^119^
[REPLACE]  final  Option  option2  =  option  (  option1  )  ; 	[BUGGY] final Option option2 = option ( option2 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  for ( final Iterator i = optionGroup1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; [BUGGY] final Option option2 = option ( option2 )  ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^108^^^^^102^119^
[REPLACE]  for  (  final  Iterator  i  =  optionGroup1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( final Iterator i = optionGroup1 . isRequired ( )  . iterator ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  [BUGGY] for ( final Iterator i = optionGroup1 . isRequired ( ) . iterator ( )  ; i . hasNext ( )  ;  ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^106^^^^^102^119^
[REPLACE]  gbuilder  .  withMaximum  (  1  )  ; 	[BUGGY] gbuilder . withMaximum ( 2 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  for ( final Iterator i = optionGroup1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } [BUGGY] gbuilder . withMaximum ( 2 )  ;  if ( optionGroup1 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^112^^^^^102^119^
[REPLACE]  if  (  optionGroup1  .  isRequired  (  )  )  { 	[BUGGY] if ( optionGroup1 % 4 . isRequired ( ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  for ( final Iterator i = optionGroup1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  [BUGGY] if ( optionGroup1 % 4 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^114^^^^^102^119^
[REPLACE]  gbuilder  .  withMinimum  (  1  )  ; 	[BUGGY] gbuilder . withMinimum ( 2 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  for ( final Iterator i = optionGroup1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { [BUGGY] gbuilder . withMinimum ( 2 )  ; } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^115^^^^^102^119^
[ADD]  gbuilder  .  withMinimum  (  1  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  for ( final Iterator i = optionGroup1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { [BUGGY] } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^115^^^^^102^119^
[REPLACE]  return  gbuilder  .  create  (  )  ; 	[BUGGY] return gbuilder . GroupBuilder ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] OptionGroup optionGroup1 [CLASS] CLI2Converter  [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final OptionGroup optionGroup1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  for ( final Iterator i = optionGroup1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } gbuilder . withMaximum ( 1 ) ;  if ( optionGroup1 . isRequired ( ) ) { gbuilder . withMinimum ( 1 ) ; } [BUGGY] return gbuilder . GroupBuilder ( )  ; }  	./Perturbation-Cli-1/CLI2Converter.java^118^^^^^102^119^
[REPLACE]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ; 	[BUGGY] final Set optionGroups = new HashSet ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { [BUGGY] final Set optionGroups = new HashSet ( )  ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^129^^^^^127^149^
[ADD]  final  GroupBuilder  gbuilder  =  new  GroupBuilder  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { [BUGGY]  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^129^^^^^127^149^
[REPLACE]  final  Set  optionGroups  =  new  HashSet  (  )  ; 	[BUGGY] final GroupBuilder gbuilder = new GroupBuilder ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  [BUGGY] final GroupBuilder gbuilder = new GroupBuilder ( )  ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^131^^^^^127^149^
[REPLACE]  for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  [BUGGY] for ( final Iterator i = options1 . getOptions ( )  . iterator ( )  ; i . hasNext ( )  ;  ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^133^^^^^127^149^
[REPLACE]  final  OptionGroup  optionGroup1  =  (  OptionGroup  )  i  .  next  (  )  ; 	[BUGGY] final OptionGroup optionGroup1 =  ( OptionGroup ) i . hasNext ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { [BUGGY] final OptionGroup optionGroup1 = ( OptionGroup ) i . hasNext ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^134^^^^^127^149^
[REPLACE]  Group  group  =  group  (  optionGroup1  )  ; 	[BUGGY] final String shortName = option1 . getOpt ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; [BUGGY] final String shortName = option1 . getOpt ( )  ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^135^^^^^127^149^
[REPLACE]  for  (  final  Iterator  i  =  options1  .  getOptionGroups  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( final Iterator i = options1 . getOptions ( )  . iterator ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  [BUGGY] for ( final Iterator i = options1 . getOptions ( ) . iterator ( )  ; i . hasNext ( )  ;  ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^133^^^^^127^149^
[REPLACE]  if  (  !optionInAGroup  (  option1,optionGroups  )  )  { 	[BUGGY] if ( optionInAGroup ( option1 , optionGroups ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; [BUGGY] if ( optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^142^^^^^127^149^
[REPLACE]  final  Option  option2  =  option  (  option1  )  ; 	[BUGGY] final Option option2 = option ( option2 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { [BUGGY] final Option option2 = option ( option2 )  ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^143^^^^^127^149^
[ADD]  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { [BUGGY]  } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^143^144^^^^127^149^
[REPLACE]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( final Iterator i = options1 . getOptions ( ) . contains ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } [BUGGY] for ( final Iterator i = options1 . getOptions ( )  . contains ( )  ; i . hasNext ( )  ;  ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^140^^^^^127^149^
[ADD]  if  (  !optionInAGroup  (  option1,optionGroups  )  )  {  final  Option  option2  =  option  (  option1  )  ;  gbuilder  .  withOption  (  option2  )  ;  } 	[BUGGY] final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; [BUGGY] final Option option2 = option ( option1 )  ; gbuilder . withOption ( option2 )  ;   } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^142^143^144^145^^127^149^
[REPLACE]  final  org  .  apache  .  commons  .  cli  .  Option  option1  =  (  org  .  apache  .  commons  .  cli  .  Option  )  i  .  next  (  )  ; 	[BUGGY] final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . hasNext ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { [BUGGY] final org . apache . commons . cli . Option option1 = ( org . apache . commons . cli . Option ) i . hasNext ( )  ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^141^^^^^127^149^
[REPLACE]  for  (  final  Iterator  i  =  options1  .  getOptions  (  )    .  iterator  (  )  ;i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } [BUGGY] for ( final Iterator i = options1 . getOptionGroups ( )  . iterator ( )  ; i . hasNext ( )  ;  ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } return gbuilder . create ( ) ; }  	./Perturbation-Cli-1/CLI2Converter.java^140^^^^^127^149^
[REPLACE]  return  gbuilder  .  create  (  )  ; 	[BUGGY] return gbuilder . GroupBuilder ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  group [TYPE] Group [PARAMETER] Options options1 [CLASS] CLI2Converter  [TYPE] Options options1 [TYPE] Group group [TYPE] Set optionGroups [TYPE] OptionGroup optionGroup1 [TYPE] boolean false true [TYPE] GroupBuilder gbuilder [TYPE] Iterator i [TYPE] Option option1 option2  [CONTEXT]  public static Group group ( final Options options1 ) { final GroupBuilder gbuilder = new GroupBuilder ( ) ;  final Set optionGroups = new HashSet ( ) ;  for ( final Iterator i = options1 . getOptionGroups ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final OptionGroup optionGroup1 =  ( OptionGroup ) i . next ( ) ; Group group = group ( optionGroup1 ) ; gbuilder . withOption ( group ) ; optionGroups . add ( optionGroup1 ) ; } for ( final Iterator i = options1 . getOptions ( ) . iterator ( ) ; i . hasNext ( ) ; ) { final org . apache . commons . cli . Option option1 =  ( org . apache . commons . cli . Option ) i . next ( ) ; if ( !optionInAGroup ( option1 , optionGroups ) ) { final Option option2 = option ( option1 ) ; gbuilder . withOption ( option2 ) ; } } [BUGGY] return gbuilder . GroupBuilder ( )  ; }  	./Perturbation-Cli-1/CLI2Converter.java^148^^^^^127^149^
[REPLACE]  if  (  group  .  getOptions  (  )    .  contains  (  option1  )  )  { 	[BUGGY] if ( group . isRequired ( )  . contains ( option1 ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] CLI2Converter  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]  private static boolean optionInAGroup ( final org . apache . commons . cli . Option option1 , final Set optionGroups ) { for ( Iterator i = optionGroups . iterator ( ) ; i . hasNext ( ) ; ) { OptionGroup group =  ( OptionGroup ) i . next ( ) ; [BUGGY] if ( group . isRequired ( ) . contains ( option1 ) ) { return true ; } } return false ; }  	./Perturbation-Cli-1/CLI2Converter.java^154^^^^^151^159^
[REPLACE]  return  true; 	[BUGGY] return false ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] CLI2Converter  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]  private static boolean optionInAGroup ( final org . apache . commons . cli . Option option1 , final Set optionGroups ) { for ( Iterator i = optionGroups . iterator ( ) ; i . hasNext ( ) ; ) { OptionGroup group =  ( OptionGroup ) i . next ( ) ; if ( group . getOptions ( ) . contains ( option1 ) ) { [BUGGY] return false ; } } return false ; }  	./Perturbation-Cli-1/CLI2Converter.java^155^^^^^151^159^
[REPLACE]  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = optionGroups . contains ( null )  ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] CLI2Converter  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]  private static boolean optionInAGroup ( final org . apache . commons . cli . Option option1 , final Set optionGroups ) { [BUGGY] for ( Iterator i = optionGroups . contains ( null ) ; i . hasNext ( )  ;  ) { OptionGroup group =  ( OptionGroup ) i . next ( ) ; if ( group . getOptions ( ) . contains ( option1 ) ) { return true ; } } return false ; }  	./Perturbation-Cli-1/CLI2Converter.java^152^^^^^151^159^
[ADD]  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  {  OptionGroup  group  =  (  OptionGroup  )  i  .  next  (  )  ;  if  (  group  .  getOptions  (  )    .  contains  (  option1  )  )  {  return  true;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] CLI2Converter  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]  private static boolean optionInAGroup ( final org . apache . commons . cli . Option option1 , final Set optionGroups ) { [BUGGY]   } return false ; }  	./Perturbation-Cli-1/CLI2Converter.java^152^153^154^155^156^151^159^
[REPLACE]  if  (  group  .  getOptions  (  )    .  contains  (  option1  )  )  { 	[BUGGY] if ( ! group . getOptions ( ) . contains ( option1 ) ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] CLI2Converter  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]  private static boolean optionInAGroup ( final org . apache . commons . cli . Option option1 , final Set optionGroups ) { for ( Iterator i = optionGroups . iterator ( ) ; i . hasNext ( ) ; ) { OptionGroup group =  ( OptionGroup ) i . next ( ) ; [BUGGY] if ( ! group . getOptions ( )  . contains ( option1 ) ) { return true ; } } return false ; }  	./Perturbation-Cli-1/CLI2Converter.java^154^^^^^151^159^
[REPLACE]  OptionGroup  group  =  (  OptionGroup  )  i  .  next  (  )  ; 	[BUGGY] OptionGroup group =  ( OptionGroup ) i . hasNext ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] CLI2Converter  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]  private static boolean optionInAGroup ( final org . apache . commons . cli . Option option1 , final Set optionGroups ) { for ( Iterator i = optionGroups . iterator ( ) ; i . hasNext ( ) ; ) { [BUGGY] OptionGroup group = ( OptionGroup ) i . hasNext ( )  ; if ( group . getOptions ( ) . contains ( option1 ) ) { return true ; } } return false ; }  	./Perturbation-Cli-1/CLI2Converter.java^153^^^^^151^159^
[REPLACE]  for  (  Iterator  i  =  optionGroups  .  iterator  (  )  ;  i  .  hasNext  (  )  ;  )  { 	[BUGGY] for ( Iterator i = optionGroups . contains ( true )  ; i . hasNext ( ) ; ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] CLI2Converter  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]  private static boolean optionInAGroup ( final org . apache . commons . cli . Option option1 , final Set optionGroups ) { [BUGGY] for ( Iterator i = optionGroups . contains ( true ) ; i . hasNext ( )  ;  ) { OptionGroup group =  ( OptionGroup ) i . next ( ) ; if ( group . getOptions ( ) . contains ( option1 ) ) { return true ; } } return false ; }  	./Perturbation-Cli-1/CLI2Converter.java^152^^^^^151^159^
[REPLACE]  return  false; 	[BUGGY] return true ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] CLI2Converter  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]  private static boolean optionInAGroup ( final org . apache . commons . cli . Option option1 , final Set optionGroups ) { for ( Iterator i = optionGroups . iterator ( ) ; i . hasNext ( ) ; ) { OptionGroup group =  ( OptionGroup ) i . next ( ) ; if ( group . getOptions ( ) . contains ( option1 ) ) { return true ; } } [BUGGY] return true ; }  	./Perturbation-Cli-1/CLI2Converter.java^158^^^^^151^159^
[REPLACE]  private  final  Object  type; 	[BUGGY] private Object type ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  optionInAGroup [TYPE] boolean [PARAMETER] Option option1 Set optionGroups [CLASS] TypeHandlerValidator  [TYPE] Set optionGroups [TYPE] OptionGroup group [TYPE] boolean false true [TYPE] Iterator i [TYPE] Option option1  [CONTEXT]   	None^164^^^^^^^
[REPLACE]  this  .  type  =  type; 	[BUGGY] this . type =  null ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  <init> [TYPE] Object) [PARAMETER] Object type [CLASS] TypeHandlerValidator  [TYPE] Object type [TYPE] boolean false true  [CONTEXT]  public TypeHandlerValidator ( final Object type ) { [BUGGY] this . type = null ; }  	None^173^^^^^172^174^
[REPLACE]  final  ListIterator  i  =  values  .  listIterator  (  )  ; 	[BUGGY] final Object converted = TypeHandler . createValue ( value , type ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { [BUGGY] final Object converted = TypeHandler . createValue ( value , type )  ; while ( i . hasNext ( ) ) { final String value =  ( String ) i . next ( ) ; final Object converted = TypeHandler . createValue ( value , type ) ; if ( converted = = null ) { throw new InvalidArgumentException (   "Unable to understand value:   " + value ) ; } i . set ( converted ) ; } }  	None^180^^^^^179^189^
[ADD]  final  ListIterator  i  =  values  .  listIterator  (  )  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { [BUGGY] while ( i . hasNext ( ) ) { final String value =  ( String ) i . next ( ) ; final Object converted = TypeHandler . createValue ( value , type ) ; if ( converted = = null ) { throw new InvalidArgumentException (   "Unable to understand value:   " + value ) ; } i . set ( converted ) ; } }  	None^180^^^^^179^189^
[REPLACE]  if  (  converted==null  )  { 	[BUGGY] if ( converted! = null ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { final ListIterator i = values . listIterator ( ) ; while ( i . hasNext ( ) ) { final String value =  ( String ) i . next ( ) ; final Object converted = TypeHandler . createValue ( value , type ) ; [BUGGY] if ( converted! = null ) { throw new InvalidArgumentException (   "Unable to understand value:   " + value ) ; } i . set ( converted ) ; } }  	None^184^^^^^179^189^
[ADD]  if  (  converted==null  )  {  throw  new  InvalidArgumentException  (  "    ")  ;  } 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { final ListIterator i = values . listIterator ( ) ; while ( i . hasNext ( ) ) { final String value =  ( String ) i . next ( ) ; final Object converted = TypeHandler . createValue ( value , type ) ; [BUGGY]  i . set ( converted ) ; } }  	None^184^185^186^^^179^189^
[REPLACE]  throw  new  InvalidArgumentException  (  "    ")  ; 	[BUGGY] return ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { final ListIterator i = values . listIterator ( ) ; while ( i . hasNext ( ) ) { final String value =  ( String ) i . next ( ) ; final Object converted = TypeHandler . createValue ( value , type ) ; if ( converted = = null ) { [BUGGY] return ; } i . set ( converted ) ; } }  	None^185^^^^^179^189^
[REPLACE]  final  String  value  =  (  String  )  i  .  next  (  )  ; 	[BUGGY] final String value =  ( String ) i . hasNext ( )  ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { final ListIterator i = values . listIterator ( ) ; while ( i . hasNext ( ) ) { [BUGGY] final String value = ( String ) i . hasNext ( ) ; final Object converted = TypeHandler . createValue ( value , type ) ; if ( converted = = null ) { throw new InvalidArgumentException (   "Unable to understand value:   " + value ) ; } i . set ( converted ) ; } }  	None^182^^^^^179^189^
[REPLACE]  final  Object  converted  =  TypeHandler  .  createValue  (  value,type  )  ; 	[BUGGY] final ListIterator i = values . listIterator ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { final ListIterator i = values . listIterator ( ) ; while ( i . hasNext ( ) ) { final String value =  ( String ) i . next ( ) ; [BUGGY] final ListIterator i = values . listIterator ( )  ; if ( converted = = null ) { throw new InvalidArgumentException (   "Unable to understand value:   " + value ) ; } i . set ( converted ) ; } }  	None^183^^^^^179^189^
[REPLACE]  if  (  converted==null  )  { 	[BUGGY] if ( converted! = this ) {[FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { final ListIterator i = values . listIterator ( ) ; while ( i . hasNext ( ) ) { final String value =  ( String ) i . next ( ) ; final Object converted = TypeHandler . createValue ( value , type ) ; [BUGGY] if ( converted! = this ) { throw new InvalidArgumentException (   "Unable to understand value:   " + value ) ; } i . set ( converted ) ; } }  	None^184^^^^^179^189^
[REPLACE]  final  String  value  =  (  String  )  i  .  next  (  )  ; 	[BUGGY] final String value =  ( String ) i . hasNext ( ) ; [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { final ListIterator i = values . listIterator ( ) ; while ( i . hasNext ( ) ) { [BUGGY] final String value = ( String ) i . hasNext ( )  ; final Object converted = TypeHandler . createValue ( value , type ) ; if ( converted = = null ) { throw new InvalidArgumentException (   "Unable to understand value:   " + value ) ; } i . set ( converted ) ; } }  	None^182^^^^^179^189^
[ADD]  throw  new  InvalidArgumentException  (  "    ")  ; 	[BUGGY] [FE] NullPointerException assertEquals(   "property  " , opts[0] )   [METHOD]  validate [TYPE] void [PARAMETER] List values [CLASS] TypeHandlerValidator  [TYPE] Object converted type [TYPE] List values [TYPE] String value [TYPE] boolean false true [TYPE] ListIterator i  [CONTEXT]  public void validate ( final List values ) throws InvalidArgumentException { final ListIterator i = values . listIterator ( ) ; while ( i . hasNext ( ) ) { final String value =  ( String ) i . next ( ) ; final Object converted = TypeHandler . createValue ( value , type ) ; if ( converted = = null ) { [BUGGY] } i . set ( converted ) ; } }  	None^185^^^^^179^189^
